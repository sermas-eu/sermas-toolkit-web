"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn4, res) => function __init() {
    return fn4 && (res = (0, fn4[__getOwnPropNames(fn4)[0]])(fn4 = 0)), res;
  };
  var __commonJS = (cb2, mod2) => function __require() {
    return mod2 || (0, cb2[__getOwnPropNames(cb2)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all3) => {
    for (var name2 in all3)
      __defProp(target, name2, { get: all3[name2], enumerable: true });
  };
  var __copyProps = (to4, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to4, key) && key !== except)
          __defProp(to4, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to4;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  var byteToHex;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      byteToHex = [];
      for (let i5 = 0; i5 < 256; ++i5) {
        byteToHex.push((i5 + 256).toString(16).slice(1));
      }
    }
  });

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID, native_default;
  var init_native = __esm({
    "node_modules/uuid/dist/esm-browser/native.js"() {
      randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      native_default = {
        randomUUID
      };
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i5 = 0; i5 < 16; ++i5) {
        buf[offset + i5] = rnds[i5];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_native();
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_v4();
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  function bind(fn4, thisArg) {
    return function wrap() {
      return fn4.apply(thisArg, arguments);
    };
  }
  var init_bind = __esm({
    "node_modules/axios/lib/helpers/bind.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/utils.js
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function forEach(obj, fn4, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i5;
    let l4;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i5 = 0, l4 = obj.length; i5 < l4; i5++) {
        fn4.call(null, obj[i5], i5, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len2 = keys.length;
      let key;
      for (i5 = 0; i5 < len2; i5++) {
        key = keys[i5];
        fn4.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i5 = keys.length;
    let _key;
    while (i5-- > 0) {
      _key = keys[i5];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i5 = 0, l4 = arguments.length; i5 < l4; i5++) {
      arguments[i5] && forEach(arguments[i5], assignValue);
    }
    return result;
  }
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  var toString, getPrototypeOf, kindOf, kindOfTest, typeOfTest, isArray, isUndefined, isArrayBuffer, isString, isFunction, isNumber, isObject, isBoolean, isPlainObject, isDate, isFile, isBlob, isFileList, isStream, isFormData, isURLSearchParams, trim, _global, isContextDefined, extend, stripBOM, inherits, toFlatObject, endsWith, toArray, isTypedArray, forEachEntry, matchAll, isHTMLForm, toCamelCase, hasOwnProperty, isRegExp, reduceDescriptors, freezeMethods, toObjectSet, noop, toFiniteNumber, ALPHA, DIGIT, ALPHABET, generateString, toJSONObject, isAsyncFn, isThenable, utils_default;
  var init_utils = __esm({
    "node_modules/axios/lib/utils.js"() {
      "use strict";
      init_bind();
      ({ toString } = Object.prototype);
      ({ getPrototypeOf } = Object);
      kindOf = /* @__PURE__ */ ((cache) => (thing) => {
        const str2 = toString.call(thing);
        return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null));
      kindOfTest = (type) => {
        type = type.toLowerCase();
        return (thing) => kindOf(thing) === type;
      };
      typeOfTest = (type) => (thing) => typeof thing === type;
      ({ isArray } = Array);
      isUndefined = typeOfTest("undefined");
      isArrayBuffer = kindOfTest("ArrayBuffer");
      isString = typeOfTest("string");
      isFunction = typeOfTest("function");
      isNumber = typeOfTest("number");
      isObject = (thing) => thing !== null && typeof thing === "object";
      isBoolean = (thing) => thing === true || thing === false;
      isPlainObject = (val) => {
        if (kindOf(val) !== "object") {
          return false;
        }
        const prototype3 = getPrototypeOf(val);
        return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
      };
      isDate = kindOfTest("Date");
      isFile = kindOfTest("File");
      isBlob = kindOfTest("Blob");
      isFileList = kindOfTest("FileList");
      isStream = (val) => isObject(val) && isFunction(val.pipe);
      isFormData = (thing) => {
        let kind;
        return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
        kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
      };
      isURLSearchParams = kindOfTest("URLSearchParams");
      trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      _global = (() => {
        if (typeof globalThis !== "undefined")
          return globalThis;
        return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      })();
      isContextDefined = (context) => !isUndefined(context) && context !== _global;
      extend = (a4, b3, thisArg, { allOwnKeys } = {}) => {
        forEach(b3, (val, key) => {
          if (thisArg && isFunction(val)) {
            a4[key] = bind(val, thisArg);
          } else {
            a4[key] = val;
          }
        }, { allOwnKeys });
        return a4;
      };
      stripBOM = (content) => {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      };
      inherits = (constructor, superConstructor, props, descriptors2) => {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
        constructor.prototype.constructor = constructor;
        Object.defineProperty(constructor, "super", {
          value: superConstructor.prototype
        });
        props && Object.assign(constructor.prototype, props);
      };
      toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
        let props;
        let i5;
        let prop;
        const merged = {};
        destObj = destObj || {};
        if (sourceObj == null)
          return destObj;
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i5 = props.length;
          while (i5-- > 0) {
            prop = props[i5];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      };
      endsWith = (str2, searchString, position) => {
        str2 = String(str2);
        if (position === void 0 || position > str2.length) {
          position = str2.length;
        }
        position -= searchString.length;
        const lastIndex = str2.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
      toArray = (thing) => {
        if (!thing)
          return null;
        if (isArray(thing))
          return thing;
        let i5 = thing.length;
        if (!isNumber(i5))
          return null;
        const arr = new Array(i5);
        while (i5-- > 0) {
          arr[i5] = thing[i5];
        }
        return arr;
      };
      isTypedArray = /* @__PURE__ */ ((TypedArray) => {
        return (thing) => {
          return TypedArray && thing instanceof TypedArray;
        };
      })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
      forEachEntry = (obj, fn4) => {
        const generator = obj && obj[Symbol.iterator];
        const iterator = generator.call(obj);
        let result;
        while ((result = iterator.next()) && !result.done) {
          const pair = result.value;
          fn4.call(obj, pair[0], pair[1]);
        }
      };
      matchAll = (regExp, str2) => {
        let matches;
        const arr = [];
        while ((matches = regExp.exec(str2)) !== null) {
          arr.push(matches);
        }
        return arr;
      };
      isHTMLForm = kindOfTest("HTMLFormElement");
      toCamelCase = (str2) => {
        return str2.toLowerCase().replace(
          /[-_\s]([a-z\d])(\w*)/g,
          function replacer(m4, p1, p22) {
            return p1.toUpperCase() + p22;
          }
        );
      };
      hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
      isRegExp = kindOfTest("RegExp");
      reduceDescriptors = (obj, reducer) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(obj);
        const reducedDescriptors = {};
        forEach(descriptors2, (descriptor, name2) => {
          let ret;
          if ((ret = reducer(descriptor, name2, obj)) !== false) {
            reducedDescriptors[name2] = ret || descriptor;
          }
        });
        Object.defineProperties(obj, reducedDescriptors);
      };
      freezeMethods = (obj) => {
        reduceDescriptors(obj, (descriptor, name2) => {
          if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
            return false;
          }
          const value = obj[name2];
          if (!isFunction(value))
            return;
          descriptor.enumerable = false;
          if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
          }
          if (!descriptor.set) {
            descriptor.set = () => {
              throw Error("Can not rewrite read-only method '" + name2 + "'");
            };
          }
        });
      };
      toObjectSet = (arrayOrString, delimiter) => {
        const obj = {};
        const define2 = (arr) => {
          arr.forEach((value) => {
            obj[value] = true;
          });
        };
        isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
        return obj;
      };
      noop = () => {
      };
      toFiniteNumber = (value, defaultValue) => {
        value = +value;
        return Number.isFinite(value) ? value : defaultValue;
      };
      ALPHA = "abcdefghijklmnopqrstuvwxyz";
      DIGIT = "0123456789";
      ALPHABET = {
        DIGIT,
        ALPHA,
        ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
      };
      generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
        let str2 = "";
        const { length: length3 } = alphabet;
        while (size--) {
          str2 += alphabet[Math.random() * length3 | 0];
        }
        return str2;
      };
      toJSONObject = (obj) => {
        const stack = new Array(10);
        const visit = (source, i5) => {
          if (isObject(source)) {
            if (stack.indexOf(source) >= 0) {
              return;
            }
            if (!("toJSON" in source)) {
              stack[i5] = source;
              const target = isArray(source) ? [] : {};
              forEach(source, (value, key) => {
                const reducedValue = visit(value, i5 + 1);
                !isUndefined(reducedValue) && (target[key] = reducedValue);
              });
              stack[i5] = void 0;
              return target;
            }
          }
          return source;
        };
        return visit(obj, 0);
      };
      isAsyncFn = kindOfTest("AsyncFunction");
      isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
      utils_default = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isBoolean,
        isObject,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isRegExp,
        isFunction,
        isStream,
        isURLSearchParams,
        isTypedArray,
        isFileList,
        forEach,
        merge,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty,
        hasOwnProp: hasOwnProperty,
        // an alias to avoid ESLint no-prototype-builtins detection
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase,
        noop,
        toFiniteNumber,
        findKey,
        global: _global,
        isContextDefined,
        ALPHABET,
        generateString,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable
      };
    }
  });

  // node_modules/axios/lib/core/AxiosError.js
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }
  var prototype, descriptors, AxiosError_default;
  var init_AxiosError = __esm({
    "node_modules/axios/lib/core/AxiosError.js"() {
      "use strict";
      init_utils();
      utils_default.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils_default.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        }
      });
      prototype = AxiosError.prototype;
      descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
        // eslint-disable-next-line func-names
      ].forEach((code) => {
        descriptors[code] = { value: code };
      });
      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype, "isAxiosError", { value: true });
      AxiosError.from = (error, code, config, request, response, customProps) => {
        const axiosError = Object.create(prototype);
        utils_default.toFlatObject(error, axiosError, function filter2(obj) {
          return obj !== Error.prototype;
        }, (prop) => {
          return prop !== "isAxiosError";
        });
        AxiosError.call(axiosError, error.message, code, config, request, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      AxiosError_default = AxiosError;
    }
  });

  // node_modules/axios/lib/helpers/null.js
  var null_default;
  var init_null = __esm({
    "node_modules/axios/lib/helpers/null.js"() {
      null_default = null;
    }
  });

  // node_modules/axios/lib/helpers/toFormData.js
  function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
  }
  function removeBrackets(key) {
    return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path)
      return key;
    return path.concat(key).map(function each(token, i5) {
      token = removeBrackets(token);
      return !dots && i5 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
  }
  function toFormData(obj, formData, options) {
    if (!utils_default.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (null_default || FormData)();
    options = utils_default.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils_default.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils_default.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils_default.isBlob(value)) {
        throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
      }
      if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils_default.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el3, index) {
            !(utils_default.isUndefined(el3) || el3 === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el3)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils_default.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils_default.forEach(value, function each(el3, key) {
        const result = !(utils_default.isUndefined(el3) || el3 === null) && visitor.call(
          formData,
          el3,
          utils_default.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el3, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils_default.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  var predicates, toFormData_default;
  var init_toFormData = __esm({
    "node_modules/axios/lib/helpers/toFormData.js"() {
      "use strict";
      init_utils();
      init_AxiosError();
      init_null();
      predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
        return /^is[A-Z]/.test(prop);
      });
      toFormData_default = toFormData;
    }
  });

  // node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  function encode(str2) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData_default(params, this, options);
  }
  var prototype2, AxiosURLSearchParams_default;
  var init_AxiosURLSearchParams = __esm({
    "node_modules/axios/lib/helpers/AxiosURLSearchParams.js"() {
      "use strict";
      init_toFormData();
      prototype2 = AxiosURLSearchParams.prototype;
      prototype2.append = function append(name2, value) {
        this._pairs.push([name2, value]);
      };
      prototype2.toString = function toString2(encoder) {
        const _encode = encoder ? function(value) {
          return encoder.call(this, value, encode);
        } : encode;
        return this._pairs.map(function each(pair) {
          return _encode(pair[0]) + "=" + _encode(pair[1]);
        }, "").join("&");
      };
      AxiosURLSearchParams_default = AxiosURLSearchParams;
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode2;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  var init_buildURL = __esm({
    "node_modules/axios/lib/helpers/buildURL.js"() {
      "use strict";
      init_utils();
      init_AxiosURLSearchParams();
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var InterceptorManager, InterceptorManager_default;
  var init_InterceptorManager = __esm({
    "node_modules/axios/lib/core/InterceptorManager.js"() {
      "use strict";
      init_utils();
      InterceptorManager = class {
        constructor() {
          this.handlers = [];
        }
        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        }
        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         *
         * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
         */
        eject(id2) {
          if (this.handlers[id2]) {
            this.handlers[id2] = null;
          }
        }
        /**
         * Clear all interceptors from the stack
         *
         * @returns {void}
         */
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         *
         * @returns {void}
         */
        forEach(fn4) {
          utils_default.forEach(this.handlers, function forEachHandler(h4) {
            if (h4 !== null) {
              fn4(h4);
            }
          });
        }
      };
      InterceptorManager_default = InterceptorManager;
    }
  });

  // node_modules/axios/lib/defaults/transitional.js
  var transitional_default;
  var init_transitional = __esm({
    "node_modules/axios/lib/defaults/transitional.js"() {
      "use strict";
      transitional_default = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
    }
  });

  // node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
  var URLSearchParams_default;
  var init_URLSearchParams = __esm({
    "node_modules/axios/lib/platform/browser/classes/URLSearchParams.js"() {
      "use strict";
      init_AxiosURLSearchParams();
      URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;
    }
  });

  // node_modules/axios/lib/platform/browser/classes/FormData.js
  var FormData_default;
  var init_FormData = __esm({
    "node_modules/axios/lib/platform/browser/classes/FormData.js"() {
      "use strict";
      FormData_default = typeof FormData !== "undefined" ? FormData : null;
    }
  });

  // node_modules/axios/lib/platform/browser/classes/Blob.js
  var Blob_default;
  var init_Blob = __esm({
    "node_modules/axios/lib/platform/browser/classes/Blob.js"() {
      "use strict";
      Blob_default = typeof Blob !== "undefined" ? Blob : null;
    }
  });

  // node_modules/axios/lib/platform/browser/index.js
  var browser_default;
  var init_browser = __esm({
    "node_modules/axios/lib/platform/browser/index.js"() {
      init_URLSearchParams();
      init_FormData();
      init_Blob();
      browser_default = {
        isBrowser: true,
        classes: {
          URLSearchParams: URLSearchParams_default,
          FormData: FormData_default,
          Blob: Blob_default
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
    }
  });

  // node_modules/axios/lib/platform/common/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    hasBrowserEnv: () => hasBrowserEnv,
    hasStandardBrowserEnv: () => hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
  });
  var hasBrowserEnv, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv;
  var init_utils2 = __esm({
    "node_modules/axios/lib/platform/common/utils.js"() {
      hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
      hasStandardBrowserEnv = ((product) => {
        return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
      })(typeof navigator !== "undefined" && navigator.product);
      hasStandardBrowserWebWorkerEnv = (() => {
        return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
      })();
    }
  });

  // node_modules/axios/lib/platform/index.js
  var platform_default;
  var init_platform = __esm({
    "node_modules/axios/lib/platform/index.js"() {
      init_browser();
      init_utils2();
      platform_default = {
        ...utils_exports,
        ...browser_default
      };
    }
  });

  // node_modules/axios/lib/helpers/toURLEncodedForm.js
  function toURLEncodedForm(data, options) {
    return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform_default.isNode && utils_default.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  var init_toURLEncodedForm = __esm({
    "node_modules/axios/lib/helpers/toURLEncodedForm.js"() {
      "use strict";
      init_utils();
      init_toFormData();
      init_platform();
    }
  });

  // node_modules/axios/lib/helpers/formDataToJSON.js
  function parsePropPath(name2) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i5;
    const len2 = keys.length;
    let key;
    for (i5 = 0; i5 < len2; i5++) {
      key = keys[i5];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name2 = path[index++];
      if (name2 === "__proto__")
        return true;
      const isNumericKey = Number.isFinite(+name2);
      const isLast = index >= path.length;
      name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
      if (isLast) {
        if (utils_default.hasOwnProp(target, name2)) {
          target[name2] = [target[name2], value];
        } else {
          target[name2] = value;
        }
        return !isNumericKey;
      }
      if (!target[name2] || !utils_default.isObject(target[name2])) {
        target[name2] = [];
      }
      const result = buildPath(path, value, target[name2], index);
      if (result && utils_default.isArray(target[name2])) {
        target[name2] = arrayToObject(target[name2]);
      }
      return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
      const obj = {};
      utils_default.forEachEntry(formData, (name2, value) => {
        buildPath(parsePropPath(name2), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  var formDataToJSON_default;
  var init_formDataToJSON = __esm({
    "node_modules/axios/lib/helpers/formDataToJSON.js"() {
      "use strict";
      init_utils();
      formDataToJSON_default = formDataToJSON;
    }
  });

  // node_modules/axios/lib/defaults/index.js
  function stringifySafely(rawValue, parser, encoder) {
    if (utils_default.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils_default.trim(rawValue);
      } catch (e4) {
        if (e4.name !== "SyntaxError") {
          throw e4;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults, defaults_default;
  var init_defaults = __esm({
    "node_modules/axios/lib/defaults/index.js"() {
      "use strict";
      init_utils();
      init_AxiosError();
      init_transitional();
      init_toFormData();
      init_toURLEncodedForm();
      init_platform();
      init_formDataToJSON();
      defaults = {
        transitional: transitional_default,
        adapter: ["xhr", "http"],
        transformRequest: [function transformRequest(data, headers) {
          const contentType = headers.getContentType() || "";
          const hasJSONContentType = contentType.indexOf("application/json") > -1;
          const isObjectPayload = utils_default.isObject(data);
          if (isObjectPayload && utils_default.isHTMLForm(data)) {
            data = new FormData(data);
          }
          const isFormData2 = utils_default.isFormData(data);
          if (isFormData2) {
            return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
          }
          if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
            return data;
          }
          if (utils_default.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils_default.isURLSearchParams(data)) {
            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return data.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
              return toURLEncodedForm(data, this.formSerializer).toString();
            }
            if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
              const _FormData = this.env && this.env.FormData;
              return toFormData_default(
                isFileList2 ? { "files[]": data } : data,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType("application/json", false);
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          const transitional2 = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          const JSONRequested = this.responseType === "json";
          if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
            const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data);
            } catch (e4) {
              if (strictJSONParsing) {
                if (e4.name === "SyntaxError") {
                  throw AxiosError_default.from(e4, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e4;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: platform_default.classes.FormData,
          Blob: platform_default.classes.Blob
        },
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method2) => {
        defaults.headers[method2] = {};
      });
      defaults_default = defaults;
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var ignoreDuplicateOf, parseHeaders_default;
  var init_parseHeaders = __esm({
    "node_modules/axios/lib/helpers/parseHeaders.js"() {
      "use strict";
      init_utils();
      ignoreDuplicateOf = utils_default.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]);
      parseHeaders_default = (rawHeaders) => {
        const parsed = {};
        let key;
        let val;
        let i5;
        rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
          i5 = line.indexOf(":");
          key = line.substring(0, i5).trim().toLowerCase();
          val = line.substring(i5 + 1).trim();
          if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
          }
          if (key === "set-cookie") {
            if (parsed[key]) {
              parsed[key].push(val);
            } else {
              parsed[key] = [val];
            }
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/core/AxiosHeaders.js
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str2) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str2)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils_default.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils_default.isString(value))
      return;
    if (utils_default.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils_default.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str2) => {
      return char.toUpperCase() + str2;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils_default.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var $internals, isValidHeaderName, AxiosHeaders, AxiosHeaders_default;
  var init_AxiosHeaders = __esm({
    "node_modules/axios/lib/core/AxiosHeaders.js"() {
      "use strict";
      init_utils();
      init_parseHeaders();
      $internals = Symbol("internals");
      isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
      AxiosHeaders = class {
        constructor(headers) {
          headers && this.set(headers);
        }
        set(header, valueOrRewrite, rewrite) {
          const self2 = this;
          function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
              throw new Error("header name must be a non-empty string");
            }
            const key = utils_default.findKey(self2, lHeader);
            if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
              self2[key || _header] = normalizeValue(_value);
            }
          }
          const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
          if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
            setHeaders(header, valueOrRewrite);
          } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders(parseHeaders_default(header), valueOrRewrite);
          } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
          }
          return this;
        }
        get(header, parser) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils_default.findKey(this, header);
            if (key) {
              const value = this[key];
              if (!parser) {
                return value;
              }
              if (parser === true) {
                return parseTokens(value);
              }
              if (utils_default.isFunction(parser)) {
                return parser.call(this, value, key);
              }
              if (utils_default.isRegExp(parser)) {
                return parser.exec(value);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(header, matcher) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils_default.findKey(this, header);
            return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
          }
          return false;
        }
        delete(header, matcher) {
          const self2 = this;
          let deleted = false;
          function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
              const key = utils_default.findKey(self2, _header);
              if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                delete self2[key];
                deleted = true;
              }
            }
          }
          if (utils_default.isArray(header)) {
            header.forEach(deleteHeader);
          } else {
            deleteHeader(header);
          }
          return deleted;
        }
        clear(matcher) {
          const keys = Object.keys(this);
          let i5 = keys.length;
          let deleted = false;
          while (i5--) {
            const key = keys[i5];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
              delete this[key];
              deleted = true;
            }
          }
          return deleted;
        }
        normalize(format) {
          const self2 = this;
          const headers = {};
          utils_default.forEach(this, (value, header) => {
            const key = utils_default.findKey(headers, header);
            if (key) {
              self2[key] = normalizeValue(value);
              delete self2[header];
              return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
              delete self2[header];
            }
            self2[normalized] = normalizeValue(value);
            headers[normalized] = true;
          });
          return this;
        }
        concat(...targets) {
          return this.constructor.concat(this, ...targets);
        }
        toJSON(asStrings) {
          const obj = /* @__PURE__ */ Object.create(null);
          utils_default.forEach(this, (value, header) => {
            value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
          });
          return obj;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(thing) {
          return thing instanceof this ? thing : new this(thing);
        }
        static concat(first, ...targets) {
          const computed = new this(first);
          targets.forEach((target) => computed.set(target));
          return computed;
        }
        static accessor(header) {
          const internals = this[$internals] = this[$internals] = {
            accessors: {}
          };
          const accessors = internals.accessors;
          const prototype3 = this.prototype;
          function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
              buildAccessors(prototype3, _header);
              accessors[lHeader] = true;
            }
          }
          utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
          return this;
        }
      };
      AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
        let mapped = key[0].toUpperCase() + key.slice(1);
        return {
          get: () => value,
          set(headerValue) {
            this[mapped] = headerValue;
          }
        };
      });
      utils_default.freezeMethods(AxiosHeaders);
      AxiosHeaders_default = AxiosHeaders;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  function transformData(fns, response) {
    const config = this || defaults_default;
    const context = response || config;
    const headers = AxiosHeaders_default.from(context.headers);
    let data = context.data;
    utils_default.forEach(fns, function transform(fn4) {
      data = fn4.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  var init_transformData = __esm({
    "node_modules/axios/lib/core/transformData.js"() {
      "use strict";
      init_utils();
      init_defaults();
      init_AxiosHeaders();
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  var init_isCancel = __esm({
    "node_modules/axios/lib/cancel/isCancel.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/cancel/CanceledError.js
  function CanceledError(message, config, request) {
    AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  var CanceledError_default;
  var init_CanceledError = __esm({
    "node_modules/axios/lib/cancel/CanceledError.js"() {
      "use strict";
      init_AxiosError();
      init_utils();
      utils_default.inherits(CanceledError, AxiosError_default, {
        __CANCEL__: true
      });
      CanceledError_default = CanceledError;
    }
  });

  // node_modules/axios/lib/core/settle.js
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError_default(
        "Request failed with status code " + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  var init_settle = __esm({
    "node_modules/axios/lib/core/settle.js"() {
      "use strict";
      init_AxiosError();
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var cookies_default;
  var init_cookies = __esm({
    "node_modules/axios/lib/helpers/cookies.js"() {
      init_utils();
      init_platform();
      cookies_default = platform_default.hasStandardBrowserEnv ? (
        // Standard browser envs support document.cookie
        {
          write(name2, value, expires, path, domain, secure) {
            const cookie = [name2 + "=" + encodeURIComponent(value)];
            utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
            utils_default.isString(path) && cookie.push("path=" + path);
            utils_default.isString(domain) && cookie.push("domain=" + domain);
            secure === true && cookie.push("secure");
            document.cookie = cookie.join("; ");
          },
          read(name2) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove(name2) {
            this.write(name2, "", Date.now() - 864e5);
          }
        }
      ) : (
        // Non-standard browser env (web workers, react-native) lack needed support.
        {
          write() {
          },
          read() {
            return null;
          },
          remove() {
          }
        }
      );
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  var init_isAbsoluteURL = __esm({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  var init_combineURLs = __esm({
    "node_modules/axios/lib/helpers/combineURLs.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  var init_buildFullPath = __esm({
    "node_modules/axios/lib/core/buildFullPath.js"() {
      "use strict";
      init_isAbsoluteURL();
      init_combineURLs();
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var isURLSameOrigin_default;
  var init_isURLSameOrigin = __esm({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"() {
      "use strict";
      init_utils();
      init_platform();
      isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          const msie = /(msie|trident)/i.test(navigator.userAgent);
          const urlParsingNode = document.createElement("a");
          let originURL;
          function resolveURL(url) {
            let href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin(requestURL) {
            const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        /* @__PURE__ */ function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        }()
      );
    }
  });

  // node_modules/axios/lib/helpers/parseProtocol.js
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  var init_parseProtocol = __esm({
    "node_modules/axios/lib/helpers/parseProtocol.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/helpers/speedometer.js
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now3 = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now3;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now3;
      let i5 = tail;
      let bytesCount = 0;
      while (i5 !== head) {
        bytesCount += bytes[i5++];
        i5 = i5 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now3 - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now3 - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  var speedometer_default;
  var init_speedometer = __esm({
    "node_modules/axios/lib/helpers/speedometer.js"() {
      "use strict";
      speedometer_default = speedometer;
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer_default(50, 250);
    return (e4) => {
      const loaded = e4.loaded;
      const total = e4.lengthComputable ? e4.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e4
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    };
  }
  var isXHRAdapterSupported, xhr_default;
  var init_xhr = __esm({
    "node_modules/axios/lib/adapters/xhr.js"() {
      "use strict";
      init_utils();
      init_settle();
      init_cookies();
      init_buildURL();
      init_buildFullPath();
      init_isURLSameOrigin();
      init_transitional();
      init_AxiosError();
      init_CanceledError();
      init_parseProtocol();
      init_platform();
      init_AxiosHeaders();
      init_speedometer();
      isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
      xhr_default = isXHRAdapterSupported && function(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          let requestData = config.data;
          const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
          let { responseType, withXSRFToken } = config;
          let onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          let contentType;
          if (utils_default.isFormData(requestData)) {
            if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
              requestHeaders.setContentType(false);
            } else if ((contentType = requestHeaders.getContentType()) !== false) {
              const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
              requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
            }
          }
          let request = new XMLHttpRequest();
          if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
          }
          const fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            const responseHeaders = AxiosHeaders_default.from(
              "getAllResponseHeaders" in request && request.getAllResponseHeaders()
            );
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = config.transitional || transitional_default;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError_default(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
              config,
              request
            ));
            request = null;
          };
          if (platform_default.hasStandardBrowserEnv) {
            withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
              const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
              if (xsrfValue) {
                requestHeaders.set(config.xsrfHeaderName, xsrfValue);
              }
            }
          }
          requestData === void 0 && requestHeaders.setContentType(null);
          if ("setRequestHeader" in request) {
            utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
              request.setRequestHeader(key, val);
            });
          }
          if (!utils_default.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
          }
          if (config.cancelToken || config.signal) {
            onCanceled = (cancel) => {
              if (!request) {
                return;
              }
              reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          const protocol = parseProtocol(fullPath);
          if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
            reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
            return;
          }
          request.send(requestData || null);
        });
      };
    }
  });

  // node_modules/axios/lib/adapters/adapters.js
  var knownAdapters, renderReason, isResolvedHandle, adapters_default;
  var init_adapters = __esm({
    "node_modules/axios/lib/adapters/adapters.js"() {
      init_utils();
      init_null();
      init_xhr();
      init_AxiosError();
      knownAdapters = {
        http: null_default,
        xhr: xhr_default
      };
      utils_default.forEach(knownAdapters, (fn4, value) => {
        if (fn4) {
          try {
            Object.defineProperty(fn4, "name", { value });
          } catch (e4) {
          }
          Object.defineProperty(fn4, "adapterName", { value });
        }
      });
      renderReason = (reason) => `- ${reason}`;
      isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
      adapters_default = {
        getAdapter: (adapters) => {
          adapters = utils_default.isArray(adapters) ? adapters : [adapters];
          const { length: length3 } = adapters;
          let nameOrAdapter;
          let adapter;
          const rejectedReasons = {};
          for (let i5 = 0; i5 < length3; i5++) {
            nameOrAdapter = adapters[i5];
            let id2;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
              adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
              if (adapter === void 0) {
                throw new AxiosError_default(`Unknown adapter '${id2}'`);
              }
            }
            if (adapter) {
              break;
            }
            rejectedReasons[id2 || "#" + i5] = adapter;
          }
          if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(
              ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
            );
            let s4 = length3 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError_default(
              `There is no suitable adapter to dispatch the request ` + s4,
              "ERR_NOT_SUPPORT"
            );
          }
          return adapter;
        },
        adapters: knownAdapters
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError_default(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders_default.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  var init_dispatchRequest = __esm({
    "node_modules/axios/lib/core/dispatchRequest.js"() {
      "use strict";
      init_transformData();
      init_isCancel();
      init_defaults();
      init_CanceledError();
      init_AxiosHeaders();
      init_adapters();
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
      if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
        return utils_default.merge.call({ caseless }, target, source);
      } else if (utils_default.isPlainObject(source)) {
        return utils_default.merge({}, source);
      } else if (utils_default.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a4, b3, caseless) {
      if (!utils_default.isUndefined(b3)) {
        return getMergedValue(a4, b3, caseless);
      } else if (!utils_default.isUndefined(a4)) {
        return getMergedValue(void 0, a4, caseless);
      }
    }
    function valueFromConfig2(a4, b3) {
      if (!utils_default.isUndefined(b3)) {
        return getMergedValue(void 0, b3);
      }
    }
    function defaultToConfig2(a4, b3) {
      if (!utils_default.isUndefined(b3)) {
        return getMergedValue(void 0, b3);
      } else if (!utils_default.isUndefined(a4)) {
        return getMergedValue(void 0, a4);
      }
    }
    function mergeDirectKeys(a4, b3, prop) {
      if (prop in config2) {
        return getMergedValue(a4, b3);
      } else if (prop in config1) {
        return getMergedValue(void 0, a4);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a4, b3) => mergeDeepProperties(headersToObject(a4), headersToObject(b3), true)
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  var headersToObject;
  var init_mergeConfig = __esm({
    "node_modules/axios/lib/core/mergeConfig.js"() {
      "use strict";
      init_utils();
      init_AxiosHeaders();
      headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
    }
  });

  // node_modules/axios/lib/env/data.js
  var VERSION;
  var init_data = __esm({
    "node_modules/axios/lib/env/data.js"() {
      VERSION = "1.6.8";
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i5 = keys.length;
    while (i5-- > 0) {
      const opt = keys[i5];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === void 0 || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
      }
    }
  }
  var validators, deprecatedWarnings, validator_default;
  var init_validator = __esm({
    "node_modules/axios/lib/helpers/validator.js"() {
      "use strict";
      init_data();
      init_AxiosError();
      validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i5) => {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i5 < 1 ? "n " : " ") + type;
        };
      });
      deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return (value, opt, opts) => {
          if (validator === false) {
            throw new AxiosError_default(
              formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
              AxiosError_default.ERR_DEPRECATED
            );
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version + " and will be removed in the near future"
              )
            );
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      validator_default = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var validators2, Axios, Axios_default;
  var init_Axios = __esm({
    "node_modules/axios/lib/core/Axios.js"() {
      "use strict";
      init_utils();
      init_buildURL();
      init_InterceptorManager();
      init_dispatchRequest();
      init_mergeConfig();
      init_buildFullPath();
      init_validator();
      init_AxiosHeaders();
      validators2 = validator_default.validators;
      Axios = class {
        constructor(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager_default(),
            response: new InterceptorManager_default()
          };
        }
        /**
         * Dispatch a request
         *
         * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
         * @param {?Object} config
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        async request(configOrUrl, config) {
          try {
            return await this._request(configOrUrl, config);
          } catch (err) {
            if (err instanceof Error) {
              let dummy;
              Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
              const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            }
            throw err;
          }
        }
        _request(configOrUrl, config) {
          if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
          } else {
            config = configOrUrl || {};
          }
          config = mergeConfig(this.defaults, config);
          const { transitional: transitional2, paramsSerializer, headers } = config;
          if (transitional2 !== void 0) {
            validator_default.assertOptions(transitional2, {
              silentJSONParsing: validators2.transitional(validators2.boolean),
              forcedJSONParsing: validators2.transitional(validators2.boolean),
              clarifyTimeoutError: validators2.transitional(validators2.boolean)
            }, false);
          }
          if (paramsSerializer != null) {
            if (utils_default.isFunction(paramsSerializer)) {
              config.paramsSerializer = {
                serialize: paramsSerializer
              };
            } else {
              validator_default.assertOptions(paramsSerializer, {
                encode: validators2.function,
                serialize: validators2.function
              }, true);
            }
          }
          config.method = (config.method || this.defaults.method || "get").toLowerCase();
          let contextHeaders = headers && utils_default.merge(
            headers.common,
            headers[config.method]
          );
          headers && utils_default.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            (method2) => {
              delete headers[method2];
            }
          );
          config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
          const requestInterceptorChain = [];
          let synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          const responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          let promise;
          let i5 = 0;
          let len2;
          if (!synchronousRequestInterceptors) {
            const chain = [dispatchRequest.bind(this), void 0];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len2 = chain.length;
            promise = Promise.resolve(config);
            while (i5 < len2) {
              promise = promise.then(chain[i5++], chain[i5++]);
            }
            return promise;
          }
          len2 = requestInterceptorChain.length;
          let newConfig = config;
          i5 = 0;
          while (i5 < len2) {
            const onFulfilled = requestInterceptorChain[i5++];
            const onRejected = requestInterceptorChain[i5++];
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected.call(this, error);
              break;
            }
          }
          try {
            promise = dispatchRequest.call(this, newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          i5 = 0;
          len2 = responseInterceptorChain.length;
          while (i5 < len2) {
            promise = promise.then(responseInterceptorChain[i5++], responseInterceptorChain[i5++]);
          }
          return promise;
        }
        getUri(config) {
          config = mergeConfig(this.defaults, config);
          const fullPath = buildFullPath(config.baseURL, config.url);
          return buildURL(fullPath, config.params, config.paramsSerializer);
        }
      };
      utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
        Axios.prototype[method2] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method: method2,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data, config) {
            return this.request(mergeConfig(config || {}, {
              method: method2,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data
            }));
          };
        }
        Axios.prototype[method2] = generateHTTPMethod();
        Axios.prototype[method2 + "Form"] = generateHTTPMethod(true);
      });
      Axios_default = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var CancelToken, CancelToken_default;
  var init_CancelToken = __esm({
    "node_modules/axios/lib/cancel/CancelToken.js"() {
      "use strict";
      init_CanceledError();
      CancelToken = class _CancelToken {
        constructor(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          let resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          const token = this;
          this.promise.then((cancel) => {
            if (!token._listeners)
              return;
            let i5 = token._listeners.length;
            while (i5-- > 0) {
              token._listeners[i5](cancel);
            }
            token._listeners = null;
          });
          this.promise.then = (onfulfilled) => {
            let _resolve;
            const promise = new Promise((resolve) => {
              token.subscribe(resolve);
              _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
              token.unsubscribe(_resolve);
            };
            return promise;
          };
          executor(function cancel(message, config, request) {
            if (token.reason) {
              return;
            }
            token.reason = new CanceledError_default(message, config, request);
            resolvePromise(token.reason);
          });
        }
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        /**
         * Subscribe to the cancel signal
         */
        subscribe(listener) {
          if (this.reason) {
            listener(this.reason);
            return;
          }
          if (this._listeners) {
            this._listeners.push(listener);
          } else {
            this._listeners = [listener];
          }
        }
        /**
         * Unsubscribe from the cancel signal
         */
        unsubscribe(listener) {
          if (!this._listeners) {
            return;
          }
          const index = this._listeners.indexOf(listener);
          if (index !== -1) {
            this._listeners.splice(index, 1);
          }
        }
        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        static source() {
          let cancel;
          const token = new _CancelToken(function executor(c5) {
            cancel = c5;
          });
          return {
            token,
            cancel
          };
        }
      };
      CancelToken_default = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  var init_spread = __esm({
    "node_modules/axios/lib/helpers/spread.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
  }
  var init_isAxiosError = __esm({
    "node_modules/axios/lib/helpers/isAxiosError.js"() {
      "use strict";
      init_utils();
    }
  });

  // node_modules/axios/lib/helpers/HttpStatusCode.js
  var HttpStatusCode, HttpStatusCode_default;
  var init_HttpStatusCode = __esm({
    "node_modules/axios/lib/helpers/HttpStatusCode.js"() {
      HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(HttpStatusCode).forEach(([key, value]) => {
        HttpStatusCode[value] = key;
      });
      HttpStatusCode_default = HttpStatusCode;
    }
  });

  // node_modules/axios/lib/axios.js
  function createInstance(defaultConfig) {
    const context = new Axios_default(defaultConfig);
    const instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
    utils_default.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create7(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios, axios_default;
  var init_axios = __esm({
    "node_modules/axios/lib/axios.js"() {
      "use strict";
      init_utils();
      init_bind();
      init_Axios();
      init_mergeConfig();
      init_defaults();
      init_formDataToJSON();
      init_CanceledError();
      init_CancelToken();
      init_isCancel();
      init_data();
      init_toFormData();
      init_AxiosError();
      init_spread();
      init_isAxiosError();
      init_AxiosHeaders();
      init_adapters();
      init_HttpStatusCode();
      axios = createInstance(defaults_default);
      axios.Axios = Axios_default;
      axios.CanceledError = CanceledError_default;
      axios.CancelToken = CancelToken_default;
      axios.isCancel = isCancel;
      axios.VERSION = VERSION;
      axios.toFormData = toFormData_default;
      axios.AxiosError = AxiosError_default;
      axios.Cancel = axios.CanceledError;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = spread;
      axios.isAxiosError = isAxiosError;
      axios.mergeConfig = mergeConfig;
      axios.AxiosHeaders = AxiosHeaders_default;
      axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
      axios.getAdapter = adapters_default.getAdapter;
      axios.HttpStatusCode = HttpStatusCode_default;
      axios.default = axios;
      axios_default = axios;
    }
  });

  // node_modules/axios/index.js
  var Axios2, AxiosError2, CanceledError2, isCancel2, CancelToken2, VERSION2, all2, Cancel, isAxiosError2, spread2, toFormData2, AxiosHeaders2, HttpStatusCode2, formToJSON, getAdapter, mergeConfig2;
  var init_axios2 = __esm({
    "node_modules/axios/index.js"() {
      init_axios();
      ({
        Axios: Axios2,
        AxiosError: AxiosError2,
        CanceledError: CanceledError2,
        isCancel: isCancel2,
        CancelToken: CancelToken2,
        VERSION: VERSION2,
        all: all2,
        Cancel,
        isAxiosError: isAxiosError2,
        spread: spread2,
        toFormData: toFormData2,
        AxiosHeaders: AxiosHeaders2,
        HttpStatusCode: HttpStatusCode2,
        formToJSON,
        getAdapter,
        mergeConfig: mergeConfig2
      } = axios_default);
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports2) {
      "use strict";
      exports2.byteLength = byteLength;
      exports2.toByteArray = toByteArray;
      exports2.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i5 = 0, len2 = code.length; i5 < len2; ++i5) {
        lookup[i5] = code[i5];
        revLookup[code.charCodeAt(i5)] = i5;
      }
      var i5;
      var len2;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len3 = b64.length;
        if (len3 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len3;
        var placeHoldersLen = validLen === len3 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len3 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i6;
        for (i6 = 0; i6 < len3; i6 += 4) {
          tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i6 = start; i6 < end; i6 += 3) {
          tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len3 = uint8.length;
        var extraBytes = len3 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i6 = 0, len22 = len3 - extraBytes; i6 < len22; i6 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len3 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len3 - 2] << 8) + uint8[len3 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/js-sha256/src/sha256.js"(exports, module) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
            var type = OUTPUT_TYPES[i5];
            method2[type] = createOutputMethod(type, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
            var type = OUTPUT_TYPES[i5];
            method2[type] = createHmacOutputMethod(type, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i5, length3 = message.length, blocks2 = this.blocks;
          while (index < length3) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i5 = this.start; index < length3 && i5 < 64; ++index) {
                blocks2[i5 >> 2] |= message[index] << SHIFT[i5++ & 3];
              }
            } else {
              for (i5 = this.start; index < length3 && i5 < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i5 >> 2] |= code << SHIFT[i5++ & 3];
                } else if (code < 2048) {
                  blocks2[i5 >> 2] |= (192 | code >> 6) << SHIFT[i5++ & 3];
                  blocks2[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i5 >> 2] |= (224 | code >> 12) << SHIFT[i5++ & 3];
                  blocks2[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                  blocks2[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i5 >> 2] |= (240 | code >> 18) << SHIFT[i5++ & 3];
                  blocks2[i5 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i5++ & 3];
                  blocks2[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                  blocks2[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
                }
              }
            }
            this.lastByteIndex = i5;
            this.bytes += i5 - this.start;
            if (i5 >= 64) {
              this.block = blocks2[16];
              this.start = i5 - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i5;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i5 = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i5 >> 2] |= EXTRA[i5 & 3];
          this.block = blocks2[16];
          if (i5 >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a4 = this.h0, b3 = this.h1, c5 = this.h2, d4 = this.h3, e4 = this.h4, f3 = this.h5, g4 = this.h6, h4 = this.h7, blocks2 = this.blocks, j4, s0, s1, maj, t1, t22, ch3, ab2, da3, cd2, bc3;
          for (j4 = 16; j4 < 64; ++j4) {
            t1 = blocks2[j4 - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j4 - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j4] = blocks2[j4 - 16] + s0 + blocks2[j4 - 7] + s1 << 0;
          }
          bc3 = b3 & c5;
          for (j4 = 0; j4 < 64; j4 += 4) {
            if (this.first) {
              if (this.is224) {
                ab2 = 300032;
                t1 = blocks2[0] - 1413257819;
                h4 = t1 - 150054599 << 0;
                d4 = t1 + 24177077 << 0;
              } else {
                ab2 = 704751109;
                t1 = blocks2[0] - 210244248;
                h4 = t1 - 1521486534 << 0;
                d4 = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a4 >>> 2 | a4 << 30) ^ (a4 >>> 13 | a4 << 19) ^ (a4 >>> 22 | a4 << 10);
              s1 = (e4 >>> 6 | e4 << 26) ^ (e4 >>> 11 | e4 << 21) ^ (e4 >>> 25 | e4 << 7);
              ab2 = a4 & b3;
              maj = ab2 ^ a4 & c5 ^ bc3;
              ch3 = e4 & f3 ^ ~e4 & g4;
              t1 = h4 + s1 + ch3 + K[j4] + blocks2[j4];
              t22 = s0 + maj;
              h4 = d4 + t1 << 0;
              d4 = t1 + t22 << 0;
            }
            s0 = (d4 >>> 2 | d4 << 30) ^ (d4 >>> 13 | d4 << 19) ^ (d4 >>> 22 | d4 << 10);
            s1 = (h4 >>> 6 | h4 << 26) ^ (h4 >>> 11 | h4 << 21) ^ (h4 >>> 25 | h4 << 7);
            da3 = d4 & a4;
            maj = da3 ^ d4 & b3 ^ ab2;
            ch3 = h4 & e4 ^ ~h4 & f3;
            t1 = g4 + s1 + ch3 + K[j4 + 1] + blocks2[j4 + 1];
            t22 = s0 + maj;
            g4 = c5 + t1 << 0;
            c5 = t1 + t22 << 0;
            s0 = (c5 >>> 2 | c5 << 30) ^ (c5 >>> 13 | c5 << 19) ^ (c5 >>> 22 | c5 << 10);
            s1 = (g4 >>> 6 | g4 << 26) ^ (g4 >>> 11 | g4 << 21) ^ (g4 >>> 25 | g4 << 7);
            cd2 = c5 & d4;
            maj = cd2 ^ c5 & a4 ^ da3;
            ch3 = g4 & h4 ^ ~g4 & e4;
            t1 = f3 + s1 + ch3 + K[j4 + 2] + blocks2[j4 + 2];
            t22 = s0 + maj;
            f3 = b3 + t1 << 0;
            b3 = t1 + t22 << 0;
            s0 = (b3 >>> 2 | b3 << 30) ^ (b3 >>> 13 | b3 << 19) ^ (b3 >>> 22 | b3 << 10);
            s1 = (f3 >>> 6 | f3 << 26) ^ (f3 >>> 11 | f3 << 21) ^ (f3 >>> 25 | f3 << 7);
            bc3 = b3 & c5;
            maj = bc3 ^ b3 & d4 ^ cd2;
            ch3 = f3 & g4 ^ ~f3 & h4;
            t1 = e4 + s1 + ch3 + K[j4 + 3] + blocks2[j4 + 3];
            t22 = s0 + maj;
            e4 = a4 + t1 << 0;
            a4 = t1 + t22 << 0;
          }
          this.h0 = this.h0 + a4 << 0;
          this.h1 = this.h1 + b3 << 0;
          this.h2 = this.h2 + c5 << 0;
          this.h3 = this.h3 + d4 << 0;
          this.h4 = this.h4 + e4 << 0;
          this.h5 = this.h5 + f3 << 0;
          this.h6 = this.h6 + g4 << 0;
          this.h7 = this.h7 + h4 << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h22 = this.h2, h32 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h22 >> 28 & 15] + HEX_CHARS[h22 >> 24 & 15] + HEX_CHARS[h22 >> 20 & 15] + HEX_CHARS[h22 >> 16 & 15] + HEX_CHARS[h22 >> 12 & 15] + HEX_CHARS[h22 >> 8 & 15] + HEX_CHARS[h22 >> 4 & 15] + HEX_CHARS[h22 & 15] + HEX_CHARS[h32 >> 28 & 15] + HEX_CHARS[h32 >> 24 & 15] + HEX_CHARS[h32 >> 20 & 15] + HEX_CHARS[h32 >> 16 & 15] + HEX_CHARS[h32 >> 12 & 15] + HEX_CHARS[h32 >> 8 & 15] + HEX_CHARS[h32 >> 4 & 15] + HEX_CHARS[h32 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h22 = this.h2, h32 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h22 >> 24 & 255,
            h22 >> 16 & 255,
            h22 >> 8 & 255,
            h22 & 255,
            h32 >> 24 & 255,
            h32 >> 16 & 255,
            h32 >> 8 & 255,
            h32 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i5, type = typeof key;
          if (type === "string") {
            var bytes = [], length3 = key.length, index = 0, code;
            for (i5 = 0; i5 < length3; ++i5) {
              code = key.charCodeAt(i5);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i5) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i5 = 0; i5 < 64; ++i5) {
            var b3 = key[i5] || 0;
            oKeyPad[i5] = 92 ^ b3;
            iKeyPad[i5] = 54 ^ b3;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // node_modules/keycloak-js/dist/keycloak.mjs
  function Keycloak(config) {
    if (!(this instanceof Keycloak)) {
      throw new Error("The 'Keycloak' constructor must be invoked with 'new'.");
    }
    var kc3 = this;
    var adapter;
    var refreshQueue = [];
    var callbackStorage;
    var loginIframe = {
      enable: true,
      callbackList: [],
      interval: 5
    };
    var scripts = document.getElementsByTagName("script");
    for (var i5 = 0; i5 < scripts.length; i5++) {
      if ((scripts[i5].src.indexOf("keycloak.js") !== -1 || scripts[i5].src.indexOf("keycloak.min.js") !== -1) && scripts[i5].src.indexOf("version=") !== -1) {
        kc3.iframeVersion = scripts[i5].src.substring(scripts[i5].src.indexOf("version=") + 8).split("&")[0];
      }
    }
    var useNonce = true;
    var logInfo = createLogger(console.info);
    var logWarn = createLogger(console.warn);
    kc3.init = function(initOptions) {
      if (kc3.didInitialize) {
        throw new Error("A 'Keycloak' instance can only be initialized once.");
      }
      kc3.didInitialize = true;
      kc3.authenticated = false;
      callbackStorage = createCallbackStorage();
      var adapters = ["default", "cordova", "cordova-native"];
      if (initOptions && adapters.indexOf(initOptions.adapter) > -1) {
        adapter = loadAdapter(initOptions.adapter);
      } else if (initOptions && typeof initOptions.adapter === "object") {
        adapter = initOptions.adapter;
      } else {
        if (window.Cordova || window.cordova) {
          adapter = loadAdapter("cordova");
        } else {
          adapter = loadAdapter();
        }
      }
      if (initOptions) {
        if (typeof initOptions.useNonce !== "undefined") {
          useNonce = initOptions.useNonce;
        }
        if (typeof initOptions.checkLoginIframe !== "undefined") {
          loginIframe.enable = initOptions.checkLoginIframe;
        }
        if (initOptions.checkLoginIframeInterval) {
          loginIframe.interval = initOptions.checkLoginIframeInterval;
        }
        if (initOptions.onLoad === "login-required") {
          kc3.loginRequired = true;
        }
        if (initOptions.responseMode) {
          if (initOptions.responseMode === "query" || initOptions.responseMode === "fragment") {
            kc3.responseMode = initOptions.responseMode;
          } else {
            throw "Invalid value for responseMode";
          }
        }
        if (initOptions.flow) {
          switch (initOptions.flow) {
            case "standard":
              kc3.responseType = "code";
              break;
            case "implicit":
              kc3.responseType = "id_token token";
              break;
            case "hybrid":
              kc3.responseType = "code id_token token";
              break;
            default:
              throw "Invalid value for flow";
          }
          kc3.flow = initOptions.flow;
        }
        if (initOptions.timeSkew != null) {
          kc3.timeSkew = initOptions.timeSkew;
        }
        if (initOptions.redirectUri) {
          kc3.redirectUri = initOptions.redirectUri;
        }
        if (initOptions.silentCheckSsoRedirectUri) {
          kc3.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;
        }
        if (typeof initOptions.silentCheckSsoFallback === "boolean") {
          kc3.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;
        } else {
          kc3.silentCheckSsoFallback = true;
        }
        if (initOptions.pkceMethod) {
          if (initOptions.pkceMethod !== "S256") {
            throw "Invalid value for pkceMethod";
          }
          kc3.pkceMethod = initOptions.pkceMethod;
        }
        if (typeof initOptions.enableLogging === "boolean") {
          kc3.enableLogging = initOptions.enableLogging;
        } else {
          kc3.enableLogging = false;
        }
        if (typeof initOptions.scope === "string") {
          kc3.scope = initOptions.scope;
        }
        if (typeof initOptions.messageReceiveTimeout === "number" && initOptions.messageReceiveTimeout > 0) {
          kc3.messageReceiveTimeout = initOptions.messageReceiveTimeout;
        } else {
          kc3.messageReceiveTimeout = 1e4;
        }
      }
      if (!kc3.responseMode) {
        kc3.responseMode = "fragment";
      }
      if (!kc3.responseType) {
        kc3.responseType = "code";
        kc3.flow = "standard";
      }
      var promise = createPromise();
      var initPromise = createPromise();
      initPromise.promise.then(function() {
        kc3.onReady && kc3.onReady(kc3.authenticated);
        promise.setSuccess(kc3.authenticated);
      }).catch(function(error) {
        promise.setError(error);
      });
      var configPromise = loadConfig();
      function onLoad() {
        var doLogin = function(prompt) {
          if (!prompt) {
            options.prompt = "none";
          }
          if (initOptions && initOptions.locale) {
            options.locale = initOptions.locale;
          }
          kc3.login(options).then(function() {
            initPromise.setSuccess();
          }).catch(function(error) {
            initPromise.setError(error);
          });
        };
        var checkSsoSilently = function() {
          var ifrm = document.createElement("iframe");
          var src = kc3.createLoginUrl({ prompt: "none", redirectUri: kc3.silentCheckSsoRedirectUri });
          ifrm.setAttribute("src", src);
          ifrm.setAttribute("sandbox", "allow-scripts allow-same-origin");
          ifrm.setAttribute("title", "keycloak-silent-check-sso");
          ifrm.style.display = "none";
          document.body.appendChild(ifrm);
          var messageCallback = function(event) {
            if (event.origin !== window.location.origin || ifrm.contentWindow !== event.source) {
              return;
            }
            var oauth = parseCallback(event.data);
            processCallback(oauth, initPromise);
            document.body.removeChild(ifrm);
            window.removeEventListener("message", messageCallback);
          };
          window.addEventListener("message", messageCallback);
        };
        var options = {};
        switch (initOptions.onLoad) {
          case "check-sso":
            if (loginIframe.enable) {
              setupCheckLoginIframe().then(function() {
                checkLoginIframe().then(function(unchanged) {
                  if (!unchanged) {
                    kc3.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);
                  } else {
                    initPromise.setSuccess();
                  }
                }).catch(function(error) {
                  initPromise.setError(error);
                });
              });
            } else {
              kc3.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);
            }
            break;
          case "login-required":
            doLogin(true);
            break;
          default:
            throw "Invalid value for onLoad";
        }
      }
      function processInit() {
        var callback = parseCallback(window.location.href);
        if (callback) {
          window.history.replaceState(window.history.state, null, callback.newUrl);
        }
        if (callback && callback.valid) {
          return setupCheckLoginIframe().then(function() {
            processCallback(callback, initPromise);
          }).catch(function(error) {
            initPromise.setError(error);
          });
        } else if (initOptions) {
          if (initOptions.token && initOptions.refreshToken) {
            setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);
            if (loginIframe.enable) {
              setupCheckLoginIframe().then(function() {
                checkLoginIframe().then(function(unchanged) {
                  if (unchanged) {
                    kc3.onAuthSuccess && kc3.onAuthSuccess();
                    initPromise.setSuccess();
                    scheduleCheckIframe();
                  } else {
                    initPromise.setSuccess();
                  }
                }).catch(function(error) {
                  initPromise.setError(error);
                });
              });
            } else {
              kc3.updateToken(-1).then(function() {
                kc3.onAuthSuccess && kc3.onAuthSuccess();
                initPromise.setSuccess();
              }).catch(function(error) {
                kc3.onAuthError && kc3.onAuthError();
                if (initOptions.onLoad) {
                  onLoad();
                } else {
                  initPromise.setError(error);
                }
              });
            }
          } else if (initOptions.onLoad) {
            onLoad();
          } else {
            initPromise.setSuccess();
          }
        } else {
          initPromise.setSuccess();
        }
      }
      function domReady() {
        var promise2 = createPromise();
        var checkReadyState = function() {
          if (document.readyState === "interactive" || document.readyState === "complete") {
            document.removeEventListener("readystatechange", checkReadyState);
            promise2.setSuccess();
          }
        };
        document.addEventListener("readystatechange", checkReadyState);
        checkReadyState();
        return promise2.promise;
      }
      configPromise.then(function() {
        domReady().then(check3pCookiesSupported).then(processInit).catch(function(error) {
          promise.setError(error);
        });
      });
      configPromise.catch(function(error) {
        promise.setError(error);
      });
      return promise.promise;
    };
    kc3.login = function(options) {
      return adapter.login(options);
    };
    function generateRandomData(len2) {
      var array = null;
      var crypto2 = window.crypto || window.msCrypto;
      if (crypto2 && crypto2.getRandomValues && window.Uint8Array) {
        array = new Uint8Array(len2);
        crypto2.getRandomValues(array);
        return array;
      }
      array = new Array(len2);
      for (var j4 = 0; j4 < array.length; j4++) {
        array[j4] = Math.floor(256 * Math.random());
      }
      return array;
    }
    function generateCodeVerifier(len2) {
      return generateRandomString(len2, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    }
    function generateRandomString(len2, alphabet) {
      var randomData = generateRandomData(len2);
      var chars = new Array(len2);
      for (var i6 = 0; i6 < len2; i6++) {
        chars[i6] = alphabet.charCodeAt(randomData[i6] % alphabet.length);
      }
      return String.fromCharCode.apply(null, chars);
    }
    function generatePkceChallenge(pkceMethod, codeVerifier) {
      switch (pkceMethod) {
        case "S256":
          var hashBytes = new Uint8Array(import_js_sha256.default.arrayBuffer(codeVerifier));
          var encodedHash = import_base64_js.default.fromByteArray(hashBytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
          return encodedHash;
        default:
          throw "Invalid value for pkceMethod";
      }
    }
    function buildClaimsParameter(requestedAcr) {
      var claims = {
        id_token: {
          acr: requestedAcr
        }
      };
      return JSON.stringify(claims);
    }
    kc3.createLoginUrl = function(options) {
      var state = createUUID();
      var nonce = createUUID();
      var redirectUri = adapter.redirectUri(options);
      var callbackState = {
        state,
        nonce,
        redirectUri: encodeURIComponent(redirectUri)
      };
      if (options && options.prompt) {
        callbackState.prompt = options.prompt;
      }
      var baseUrl;
      if (options && options.action == "register") {
        baseUrl = kc3.endpoints.register();
      } else {
        baseUrl = kc3.endpoints.authorize();
      }
      var scope = options && options.scope || kc3.scope;
      if (!scope) {
        scope = "openid";
      } else if (scope.indexOf("openid") === -1) {
        scope = "openid " + scope;
      }
      var url = baseUrl + "?client_id=" + encodeURIComponent(kc3.clientId) + "&redirect_uri=" + encodeURIComponent(redirectUri) + "&state=" + encodeURIComponent(state) + "&response_mode=" + encodeURIComponent(kc3.responseMode) + "&response_type=" + encodeURIComponent(kc3.responseType) + "&scope=" + encodeURIComponent(scope);
      if (useNonce) {
        url = url + "&nonce=" + encodeURIComponent(nonce);
      }
      if (options && options.prompt) {
        url += "&prompt=" + encodeURIComponent(options.prompt);
      }
      if (options && options.maxAge) {
        url += "&max_age=" + encodeURIComponent(options.maxAge);
      }
      if (options && options.loginHint) {
        url += "&login_hint=" + encodeURIComponent(options.loginHint);
      }
      if (options && options.idpHint) {
        url += "&kc_idp_hint=" + encodeURIComponent(options.idpHint);
      }
      if (options && options.action && options.action != "register") {
        url += "&kc_action=" + encodeURIComponent(options.action);
      }
      if (options && options.locale) {
        url += "&ui_locales=" + encodeURIComponent(options.locale);
      }
      if (options && options.acr) {
        var claimsParameter = buildClaimsParameter(options.acr);
        url += "&claims=" + encodeURIComponent(claimsParameter);
      }
      if (kc3.pkceMethod) {
        var codeVerifier = generateCodeVerifier(96);
        callbackState.pkceCodeVerifier = codeVerifier;
        var pkceChallenge = generatePkceChallenge(kc3.pkceMethod, codeVerifier);
        url += "&code_challenge=" + pkceChallenge;
        url += "&code_challenge_method=" + kc3.pkceMethod;
      }
      callbackStorage.add(callbackState);
      return url;
    };
    kc3.logout = function(options) {
      return adapter.logout(options);
    };
    kc3.createLogoutUrl = function(options) {
      var url = kc3.endpoints.logout() + "?client_id=" + encodeURIComponent(kc3.clientId) + "&post_logout_redirect_uri=" + encodeURIComponent(adapter.redirectUri(options, false));
      if (kc3.idToken) {
        url += "&id_token_hint=" + encodeURIComponent(kc3.idToken);
      }
      return url;
    };
    kc3.register = function(options) {
      return adapter.register(options);
    };
    kc3.createRegisterUrl = function(options) {
      if (!options) {
        options = {};
      }
      options.action = "register";
      return kc3.createLoginUrl(options);
    };
    kc3.createAccountUrl = function(options) {
      var realm = getRealmUrl();
      var url = void 0;
      if (typeof realm !== "undefined") {
        url = realm + "/account?referrer=" + encodeURIComponent(kc3.clientId) + "&referrer_uri=" + encodeURIComponent(adapter.redirectUri(options));
      }
      return url;
    };
    kc3.accountManagement = function() {
      return adapter.accountManagement();
    };
    kc3.hasRealmRole = function(role) {
      var access = kc3.realmAccess;
      return !!access && access.roles.indexOf(role) >= 0;
    };
    kc3.hasResourceRole = function(role, resource) {
      if (!kc3.resourceAccess) {
        return false;
      }
      var access = kc3.resourceAccess[resource || kc3.clientId];
      return !!access && access.roles.indexOf(role) >= 0;
    };
    kc3.loadUserProfile = function() {
      var url = getRealmUrl() + "/account";
      var req = new XMLHttpRequest();
      req.open("GET", url, true);
      req.setRequestHeader("Accept", "application/json");
      req.setRequestHeader("Authorization", "bearer " + kc3.token);
      var promise = createPromise();
      req.onreadystatechange = function() {
        if (req.readyState == 4) {
          if (req.status == 200) {
            kc3.profile = JSON.parse(req.responseText);
            promise.setSuccess(kc3.profile);
          } else {
            promise.setError();
          }
        }
      };
      req.send();
      return promise.promise;
    };
    kc3.loadUserInfo = function() {
      var url = kc3.endpoints.userinfo();
      var req = new XMLHttpRequest();
      req.open("GET", url, true);
      req.setRequestHeader("Accept", "application/json");
      req.setRequestHeader("Authorization", "bearer " + kc3.token);
      var promise = createPromise();
      req.onreadystatechange = function() {
        if (req.readyState == 4) {
          if (req.status == 200) {
            kc3.userInfo = JSON.parse(req.responseText);
            promise.setSuccess(kc3.userInfo);
          } else {
            promise.setError();
          }
        }
      };
      req.send();
      return promise.promise;
    };
    kc3.isTokenExpired = function(minValidity) {
      if (!kc3.tokenParsed || !kc3.refreshToken && kc3.flow != "implicit") {
        throw "Not authenticated";
      }
      if (kc3.timeSkew == null) {
        logInfo("[KEYCLOAK] Unable to determine if token is expired as timeskew is not set");
        return true;
      }
      var expiresIn = kc3.tokenParsed["exp"] - Math.ceil((/* @__PURE__ */ new Date()).getTime() / 1e3) + kc3.timeSkew;
      if (minValidity) {
        if (isNaN(minValidity)) {
          throw "Invalid minValidity";
        }
        expiresIn -= minValidity;
      }
      return expiresIn < 0;
    };
    kc3.updateToken = function(minValidity) {
      var promise = createPromise();
      if (!kc3.refreshToken) {
        promise.setError();
        return promise.promise;
      }
      minValidity = minValidity || 5;
      var exec = function() {
        var refreshToken = false;
        if (minValidity == -1) {
          refreshToken = true;
          logInfo("[KEYCLOAK] Refreshing token: forced refresh");
        } else if (!kc3.tokenParsed || kc3.isTokenExpired(minValidity)) {
          refreshToken = true;
          logInfo("[KEYCLOAK] Refreshing token: token expired");
        }
        if (!refreshToken) {
          promise.setSuccess(false);
        } else {
          var params = "grant_type=refresh_token&refresh_token=" + kc3.refreshToken;
          var url = kc3.endpoints.token();
          refreshQueue.push(promise);
          if (refreshQueue.length == 1) {
            var req = new XMLHttpRequest();
            req.open("POST", url, true);
            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            req.withCredentials = true;
            params += "&client_id=" + encodeURIComponent(kc3.clientId);
            var timeLocal = (/* @__PURE__ */ new Date()).getTime();
            req.onreadystatechange = function() {
              if (req.readyState == 4) {
                if (req.status == 200) {
                  logInfo("[KEYCLOAK] Token refreshed");
                  timeLocal = (timeLocal + (/* @__PURE__ */ new Date()).getTime()) / 2;
                  var tokenResponse = JSON.parse(req.responseText);
                  setToken(tokenResponse["access_token"], tokenResponse["refresh_token"], tokenResponse["id_token"], timeLocal);
                  kc3.onAuthRefreshSuccess && kc3.onAuthRefreshSuccess();
                  for (var p4 = refreshQueue.pop(); p4 != null; p4 = refreshQueue.pop()) {
                    p4.setSuccess(true);
                  }
                } else {
                  logWarn("[KEYCLOAK] Failed to refresh token");
                  if (req.status == 400) {
                    kc3.clearToken();
                  }
                  kc3.onAuthRefreshError && kc3.onAuthRefreshError();
                  for (var p4 = refreshQueue.pop(); p4 != null; p4 = refreshQueue.pop()) {
                    p4.setError(true);
                  }
                }
              }
            };
            req.send(params);
          }
        }
      };
      if (loginIframe.enable) {
        var iframePromise = checkLoginIframe();
        iframePromise.then(function() {
          exec();
        }).catch(function(error) {
          promise.setError(error);
        });
      } else {
        exec();
      }
      return promise.promise;
    };
    kc3.clearToken = function() {
      if (kc3.token) {
        setToken(null, null, null);
        kc3.onAuthLogout && kc3.onAuthLogout();
        if (kc3.loginRequired) {
          kc3.login();
        }
      }
    };
    function getRealmUrl() {
      if (typeof kc3.authServerUrl !== "undefined") {
        if (kc3.authServerUrl.charAt(kc3.authServerUrl.length - 1) == "/") {
          return kc3.authServerUrl + "realms/" + encodeURIComponent(kc3.realm);
        } else {
          return kc3.authServerUrl + "/realms/" + encodeURIComponent(kc3.realm);
        }
      } else {
        return void 0;
      }
    }
    function getOrigin() {
      if (!window.location.origin) {
        return window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
      } else {
        return window.location.origin;
      }
    }
    function processCallback(oauth, promise) {
      var code = oauth.code;
      var error = oauth.error;
      var prompt = oauth.prompt;
      var timeLocal = (/* @__PURE__ */ new Date()).getTime();
      if (oauth["kc_action_status"]) {
        kc3.onActionUpdate && kc3.onActionUpdate(oauth["kc_action_status"]);
      }
      if (error) {
        if (prompt != "none") {
          var errorData = { error, error_description: oauth.error_description };
          kc3.onAuthError && kc3.onAuthError(errorData);
          promise && promise.setError(errorData);
        } else {
          promise && promise.setSuccess();
        }
        return;
      } else if (kc3.flow != "standard" && (oauth.access_token || oauth.id_token)) {
        authSuccess(oauth.access_token, null, oauth.id_token, true);
      }
      if (kc3.flow != "implicit" && code) {
        var params = "code=" + code + "&grant_type=authorization_code";
        var url = kc3.endpoints.token();
        var req = new XMLHttpRequest();
        req.open("POST", url, true);
        req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        params += "&client_id=" + encodeURIComponent(kc3.clientId);
        params += "&redirect_uri=" + oauth.redirectUri;
        if (oauth.pkceCodeVerifier) {
          params += "&code_verifier=" + oauth.pkceCodeVerifier;
        }
        req.withCredentials = true;
        req.onreadystatechange = function() {
          if (req.readyState == 4) {
            if (req.status == 200) {
              var tokenResponse = JSON.parse(req.responseText);
              authSuccess(tokenResponse["access_token"], tokenResponse["refresh_token"], tokenResponse["id_token"], kc3.flow === "standard");
              scheduleCheckIframe();
            } else {
              kc3.onAuthError && kc3.onAuthError();
              promise && promise.setError();
            }
          }
        };
        req.send(params);
      }
      function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {
        timeLocal = (timeLocal + (/* @__PURE__ */ new Date()).getTime()) / 2;
        setToken(accessToken, refreshToken, idToken, timeLocal);
        if (useNonce && (kc3.tokenParsed && kc3.tokenParsed.nonce != oauth.storedNonce || kc3.refreshTokenParsed && kc3.refreshTokenParsed.nonce != oauth.storedNonce || kc3.idTokenParsed && kc3.idTokenParsed.nonce != oauth.storedNonce)) {
          logInfo("[KEYCLOAK] Invalid nonce, clearing token");
          kc3.clearToken();
          promise && promise.setError();
        } else {
          if (fulfillPromise) {
            kc3.onAuthSuccess && kc3.onAuthSuccess();
            promise && promise.setSuccess();
          }
        }
      }
    }
    function loadConfig(url) {
      var promise = createPromise();
      var configUrl;
      if (!config) {
        configUrl = "keycloak.json";
      } else if (typeof config === "string") {
        configUrl = config;
      }
      function setupOidcEndoints(oidcConfiguration) {
        if (!oidcConfiguration) {
          kc3.endpoints = {
            authorize: function() {
              return getRealmUrl() + "/protocol/openid-connect/auth";
            },
            token: function() {
              return getRealmUrl() + "/protocol/openid-connect/token";
            },
            logout: function() {
              return getRealmUrl() + "/protocol/openid-connect/logout";
            },
            checkSessionIframe: function() {
              var src = getRealmUrl() + "/protocol/openid-connect/login-status-iframe.html";
              if (kc3.iframeVersion) {
                src = src + "?version=" + kc3.iframeVersion;
              }
              return src;
            },
            thirdPartyCookiesIframe: function() {
              var src = getRealmUrl() + "/protocol/openid-connect/3p-cookies/step1.html";
              if (kc3.iframeVersion) {
                src = src + "?version=" + kc3.iframeVersion;
              }
              return src;
            },
            register: function() {
              return getRealmUrl() + "/protocol/openid-connect/registrations";
            },
            userinfo: function() {
              return getRealmUrl() + "/protocol/openid-connect/userinfo";
            }
          };
        } else {
          kc3.endpoints = {
            authorize: function() {
              return oidcConfiguration.authorization_endpoint;
            },
            token: function() {
              return oidcConfiguration.token_endpoint;
            },
            logout: function() {
              if (!oidcConfiguration.end_session_endpoint) {
                throw "Not supported by the OIDC server";
              }
              return oidcConfiguration.end_session_endpoint;
            },
            checkSessionIframe: function() {
              if (!oidcConfiguration.check_session_iframe) {
                throw "Not supported by the OIDC server";
              }
              return oidcConfiguration.check_session_iframe;
            },
            register: function() {
              throw 'Redirection to "Register user" page not supported in standard OIDC mode';
            },
            userinfo: function() {
              if (!oidcConfiguration.userinfo_endpoint) {
                throw "Not supported by the OIDC server";
              }
              return oidcConfiguration.userinfo_endpoint;
            }
          };
        }
      }
      if (configUrl) {
        var req = new XMLHttpRequest();
        req.open("GET", configUrl, true);
        req.setRequestHeader("Accept", "application/json");
        req.onreadystatechange = function() {
          if (req.readyState == 4) {
            if (req.status == 200 || fileLoaded(req)) {
              var config2 = JSON.parse(req.responseText);
              kc3.authServerUrl = config2["auth-server-url"];
              kc3.realm = config2["realm"];
              kc3.clientId = config2["resource"];
              setupOidcEndoints(null);
              promise.setSuccess();
            } else {
              promise.setError();
            }
          }
        };
        req.send();
      } else {
        if (!config.clientId) {
          throw "clientId missing";
        }
        kc3.clientId = config.clientId;
        var oidcProvider = config["oidcProvider"];
        if (!oidcProvider) {
          if (!config["url"]) {
            var scripts2 = document.getElementsByTagName("script");
            for (var i6 = 0; i6 < scripts2.length; i6++) {
              if (scripts2[i6].src.match(/.*keycloak\.js/)) {
                config.url = scripts2[i6].src.substr(0, scripts2[i6].src.indexOf("/js/keycloak.js"));
                break;
              }
            }
          }
          if (!config.realm) {
            throw "realm missing";
          }
          kc3.authServerUrl = config.url;
          kc3.realm = config.realm;
          setupOidcEndoints(null);
          promise.setSuccess();
        } else {
          if (typeof oidcProvider === "string") {
            var oidcProviderConfigUrl;
            if (oidcProvider.charAt(oidcProvider.length - 1) == "/") {
              oidcProviderConfigUrl = oidcProvider + ".well-known/openid-configuration";
            } else {
              oidcProviderConfigUrl = oidcProvider + "/.well-known/openid-configuration";
            }
            var req = new XMLHttpRequest();
            req.open("GET", oidcProviderConfigUrl, true);
            req.setRequestHeader("Accept", "application/json");
            req.onreadystatechange = function() {
              if (req.readyState == 4) {
                if (req.status == 200 || fileLoaded(req)) {
                  var oidcProviderConfig = JSON.parse(req.responseText);
                  setupOidcEndoints(oidcProviderConfig);
                  promise.setSuccess();
                } else {
                  promise.setError();
                }
              }
            };
            req.send();
          } else {
            setupOidcEndoints(oidcProvider);
            promise.setSuccess();
          }
        }
      }
      return promise.promise;
    }
    function fileLoaded(xhr) {
      return xhr.status == 0 && xhr.responseText && xhr.responseURL.startsWith("file:");
    }
    function setToken(token, refreshToken, idToken, timeLocal) {
      if (kc3.tokenTimeoutHandle) {
        clearTimeout(kc3.tokenTimeoutHandle);
        kc3.tokenTimeoutHandle = null;
      }
      if (refreshToken) {
        kc3.refreshToken = refreshToken;
        kc3.refreshTokenParsed = decodeToken(refreshToken);
      } else {
        delete kc3.refreshToken;
        delete kc3.refreshTokenParsed;
      }
      if (idToken) {
        kc3.idToken = idToken;
        kc3.idTokenParsed = decodeToken(idToken);
      } else {
        delete kc3.idToken;
        delete kc3.idTokenParsed;
      }
      if (token) {
        kc3.token = token;
        kc3.tokenParsed = decodeToken(token);
        kc3.sessionId = kc3.tokenParsed.session_state;
        kc3.authenticated = true;
        kc3.subject = kc3.tokenParsed.sub;
        kc3.realmAccess = kc3.tokenParsed.realm_access;
        kc3.resourceAccess = kc3.tokenParsed.resource_access;
        if (timeLocal) {
          kc3.timeSkew = Math.floor(timeLocal / 1e3) - kc3.tokenParsed.iat;
        }
        if (kc3.timeSkew != null) {
          logInfo("[KEYCLOAK] Estimated time difference between browser and server is " + kc3.timeSkew + " seconds");
          if (kc3.onTokenExpired) {
            var expiresIn = (kc3.tokenParsed["exp"] - (/* @__PURE__ */ new Date()).getTime() / 1e3 + kc3.timeSkew) * 1e3;
            logInfo("[KEYCLOAK] Token expires in " + Math.round(expiresIn / 1e3) + " s");
            if (expiresIn <= 0) {
              kc3.onTokenExpired();
            } else {
              kc3.tokenTimeoutHandle = setTimeout(kc3.onTokenExpired, expiresIn);
            }
          }
        }
      } else {
        delete kc3.token;
        delete kc3.tokenParsed;
        delete kc3.subject;
        delete kc3.realmAccess;
        delete kc3.resourceAccess;
        kc3.authenticated = false;
      }
    }
    function decodeToken(str2) {
      str2 = str2.split(".")[1];
      str2 = str2.replace(/-/g, "+");
      str2 = str2.replace(/_/g, "/");
      switch (str2.length % 4) {
        case 0:
          break;
        case 2:
          str2 += "==";
          break;
        case 3:
          str2 += "=";
          break;
        default:
          throw "Invalid token";
      }
      str2 = decodeURIComponent(escape(atob(str2)));
      str2 = JSON.parse(str2);
      return str2;
    }
    function createUUID() {
      var hexDigits = "0123456789abcdef";
      var s4 = generateRandomString(36, hexDigits).split("");
      s4[14] = "4";
      s4[19] = hexDigits.substr(s4[19] & 3 | 8, 1);
      s4[8] = s4[13] = s4[18] = s4[23] = "-";
      var uuid = s4.join("");
      return uuid;
    }
    function parseCallback(url) {
      var oauth = parseCallbackUrl(url);
      if (!oauth) {
        return;
      }
      var oauthState = callbackStorage.get(oauth.state);
      if (oauthState) {
        oauth.valid = true;
        oauth.redirectUri = oauthState.redirectUri;
        oauth.storedNonce = oauthState.nonce;
        oauth.prompt = oauthState.prompt;
        oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;
      }
      return oauth;
    }
    function parseCallbackUrl(url) {
      var supportedParams;
      switch (kc3.flow) {
        case "standard":
          supportedParams = ["code", "state", "session_state", "kc_action_status", "iss"];
          break;
        case "implicit":
          supportedParams = ["access_token", "token_type", "id_token", "state", "session_state", "expires_in", "kc_action_status", "iss"];
          break;
        case "hybrid":
          supportedParams = ["access_token", "token_type", "id_token", "code", "state", "session_state", "expires_in", "kc_action_status", "iss"];
          break;
      }
      supportedParams.push("error");
      supportedParams.push("error_description");
      supportedParams.push("error_uri");
      var queryIndex = url.indexOf("?");
      var fragmentIndex = url.indexOf("#");
      var newUrl;
      var parsed;
      if (kc3.responseMode === "query" && queryIndex !== -1) {
        newUrl = url.substring(0, queryIndex);
        parsed = parseCallbackParams(url.substring(queryIndex + 1, fragmentIndex !== -1 ? fragmentIndex : url.length), supportedParams);
        if (parsed.paramsString !== "") {
          newUrl += "?" + parsed.paramsString;
        }
        if (fragmentIndex !== -1) {
          newUrl += url.substring(fragmentIndex);
        }
      } else if (kc3.responseMode === "fragment" && fragmentIndex !== -1) {
        newUrl = url.substring(0, fragmentIndex);
        parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams);
        if (parsed.paramsString !== "") {
          newUrl += "#" + parsed.paramsString;
        }
      }
      if (parsed && parsed.oauthParams) {
        if (kc3.flow === "standard" || kc3.flow === "hybrid") {
          if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {
            parsed.oauthParams.newUrl = newUrl;
            return parsed.oauthParams;
          }
        } else if (kc3.flow === "implicit") {
          if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {
            parsed.oauthParams.newUrl = newUrl;
            return parsed.oauthParams;
          }
        }
      }
    }
    function parseCallbackParams(paramsString, supportedParams) {
      var p4 = paramsString.split("&");
      var result = {
        paramsString: "",
        oauthParams: {}
      };
      for (var i6 = 0; i6 < p4.length; i6++) {
        var split = p4[i6].indexOf("=");
        var key = p4[i6].slice(0, split);
        if (supportedParams.indexOf(key) !== -1) {
          result.oauthParams[key] = p4[i6].slice(split + 1);
        } else {
          if (result.paramsString !== "") {
            result.paramsString += "&";
          }
          result.paramsString += p4[i6];
        }
      }
      return result;
    }
    function createPromise() {
      var p4 = {
        setSuccess: function(result) {
          p4.resolve(result);
        },
        setError: function(result) {
          p4.reject(result);
        }
      };
      p4.promise = new Promise(function(resolve, reject) {
        p4.resolve = resolve;
        p4.reject = reject;
      });
      return p4;
    }
    function applyTimeoutToPromise(promise, timeout, errorMessage) {
      var timeoutHandle = null;
      var timeoutPromise = new Promise(function(resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject({ "error": errorMessage || "Promise is not settled within timeout of " + timeout + "ms" });
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).finally(function() {
        clearTimeout(timeoutHandle);
      });
    }
    function setupCheckLoginIframe() {
      var promise = createPromise();
      if (!loginIframe.enable) {
        promise.setSuccess();
        return promise.promise;
      }
      if (loginIframe.iframe) {
        promise.setSuccess();
        return promise.promise;
      }
      var iframe = document.createElement("iframe");
      loginIframe.iframe = iframe;
      iframe.onload = function() {
        var authUrl = kc3.endpoints.authorize();
        if (authUrl.charAt(0) === "/") {
          loginIframe.iframeOrigin = getOrigin();
        } else {
          loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf("/", 8));
        }
        promise.setSuccess();
      };
      var src = kc3.endpoints.checkSessionIframe();
      iframe.setAttribute("src", src);
      iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
      iframe.setAttribute("title", "keycloak-session-iframe");
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      var messageCallback = function(event) {
        if (event.origin !== loginIframe.iframeOrigin || loginIframe.iframe.contentWindow !== event.source) {
          return;
        }
        if (!(event.data == "unchanged" || event.data == "changed" || event.data == "error")) {
          return;
        }
        if (event.data != "unchanged") {
          kc3.clearToken();
        }
        var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length);
        for (var i6 = callbacks.length - 1; i6 >= 0; --i6) {
          var promise2 = callbacks[i6];
          if (event.data == "error") {
            promise2.setError();
          } else {
            promise2.setSuccess(event.data == "unchanged");
          }
        }
      };
      window.addEventListener("message", messageCallback, false);
      return promise.promise;
    }
    function scheduleCheckIframe() {
      if (loginIframe.enable) {
        if (kc3.token) {
          setTimeout(function() {
            checkLoginIframe().then(function(unchanged) {
              if (unchanged) {
                scheduleCheckIframe();
              }
            });
          }, loginIframe.interval * 1e3);
        }
      }
    }
    function checkLoginIframe() {
      var promise = createPromise();
      if (loginIframe.iframe && loginIframe.iframeOrigin) {
        var msg = kc3.clientId + " " + (kc3.sessionId ? kc3.sessionId : "");
        loginIframe.callbackList.push(promise);
        var origin = loginIframe.iframeOrigin;
        if (loginIframe.callbackList.length == 1) {
          loginIframe.iframe.contentWindow.postMessage(msg, origin);
        }
      } else {
        promise.setSuccess();
      }
      return promise.promise;
    }
    function check3pCookiesSupported() {
      var promise = createPromise();
      if (loginIframe.enable || kc3.silentCheckSsoRedirectUri) {
        var iframe = document.createElement("iframe");
        iframe.setAttribute("src", kc3.endpoints.thirdPartyCookiesIframe());
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        iframe.setAttribute("title", "keycloak-3p-check-iframe");
        iframe.style.display = "none";
        document.body.appendChild(iframe);
        var messageCallback = function(event) {
          if (iframe.contentWindow !== event.source) {
            return;
          }
          if (event.data !== "supported" && event.data !== "unsupported") {
            return;
          } else if (event.data === "unsupported") {
            logWarn(
              "[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\n\n - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\n - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\n\nFor more information see: https://www.keycloak.org/docs/latest/securing_apps/#_modern_browsers"
            );
            loginIframe.enable = false;
            if (kc3.silentCheckSsoFallback) {
              kc3.silentCheckSsoRedirectUri = false;
            }
          }
          document.body.removeChild(iframe);
          window.removeEventListener("message", messageCallback);
          promise.setSuccess();
        };
        window.addEventListener("message", messageCallback, false);
      } else {
        promise.setSuccess();
      }
      return applyTimeoutToPromise(promise.promise, kc3.messageReceiveTimeout, "Timeout when waiting for 3rd party check iframe message.");
    }
    function loadAdapter(type) {
      if (!type || type == "default") {
        return {
          login: function(options) {
            window.location.assign(kc3.createLoginUrl(options));
            return createPromise().promise;
          },
          logout: function(options) {
            window.location.replace(kc3.createLogoutUrl(options));
            return createPromise().promise;
          },
          register: function(options) {
            window.location.assign(kc3.createRegisterUrl(options));
            return createPromise().promise;
          },
          accountManagement: function() {
            var accountUrl = kc3.createAccountUrl();
            if (typeof accountUrl !== "undefined") {
              window.location.href = accountUrl;
            } else {
              throw "Not supported by the OIDC server";
            }
            return createPromise().promise;
          },
          redirectUri: function(options, encodeHash) {
            if (options && options.redirectUri) {
              return options.redirectUri;
            } else if (kc3.redirectUri) {
              return kc3.redirectUri;
            } else {
              return location.href;
            }
          }
        };
      }
      if (type == "cordova") {
        loginIframe.enable = false;
        var cordovaOpenWindowWrapper = function(loginUrl, target, options) {
          if (window.cordova && window.cordova.InAppBrowser) {
            return window.cordova.InAppBrowser.open(loginUrl, target, options);
          } else {
            return window.open(loginUrl, target, options);
          }
        };
        var shallowCloneCordovaOptions = function(userOptions) {
          if (userOptions && userOptions.cordovaOptions) {
            return Object.keys(userOptions.cordovaOptions).reduce(function(options, optionName) {
              options[optionName] = userOptions.cordovaOptions[optionName];
              return options;
            }, {});
          } else {
            return {};
          }
        };
        var formatCordovaOptions = function(cordovaOptions) {
          return Object.keys(cordovaOptions).reduce(function(options, optionName) {
            options.push(optionName + "=" + cordovaOptions[optionName]);
            return options;
          }, []).join(",");
        };
        var createCordovaOptions = function(userOptions) {
          var cordovaOptions = shallowCloneCordovaOptions(userOptions);
          cordovaOptions.location = "no";
          if (userOptions && userOptions.prompt == "none") {
            cordovaOptions.hidden = "yes";
          }
          return formatCordovaOptions(cordovaOptions);
        };
        var cordovaRedirectUri = kc3.redirectUri || "http://localhost";
        return {
          login: function(options) {
            var promise = createPromise();
            var cordovaOptions = createCordovaOptions(options);
            var loginUrl = kc3.createLoginUrl(options);
            var ref = cordovaOpenWindowWrapper(loginUrl, "_blank", cordovaOptions);
            var completed = false;
            var closed = false;
            var closeBrowser = function() {
              closed = true;
              ref.close();
            };
            ref.addEventListener("loadstart", function(event) {
              if (event.url.indexOf(cordovaRedirectUri) == 0) {
                var callback = parseCallback(event.url);
                processCallback(callback, promise);
                closeBrowser();
                completed = true;
              }
            });
            ref.addEventListener("loaderror", function(event) {
              if (!completed) {
                if (event.url.indexOf(cordovaRedirectUri) == 0) {
                  var callback = parseCallback(event.url);
                  processCallback(callback, promise);
                  closeBrowser();
                  completed = true;
                } else {
                  promise.setError();
                  closeBrowser();
                }
              }
            });
            ref.addEventListener("exit", function(event) {
              if (!closed) {
                promise.setError({
                  reason: "closed_by_user"
                });
              }
            });
            return promise.promise;
          },
          logout: function(options) {
            var promise = createPromise();
            var logoutUrl = kc3.createLogoutUrl(options);
            var ref = cordovaOpenWindowWrapper(logoutUrl, "_blank", "location=no,hidden=yes,clearcache=yes");
            var error;
            ref.addEventListener("loadstart", function(event) {
              if (event.url.indexOf(cordovaRedirectUri) == 0) {
                ref.close();
              }
            });
            ref.addEventListener("loaderror", function(event) {
              if (event.url.indexOf(cordovaRedirectUri) == 0) {
                ref.close();
              } else {
                error = true;
                ref.close();
              }
            });
            ref.addEventListener("exit", function(event) {
              if (error) {
                promise.setError();
              } else {
                kc3.clearToken();
                promise.setSuccess();
              }
            });
            return promise.promise;
          },
          register: function(options) {
            var promise = createPromise();
            var registerUrl = kc3.createRegisterUrl();
            var cordovaOptions = createCordovaOptions(options);
            var ref = cordovaOpenWindowWrapper(registerUrl, "_blank", cordovaOptions);
            ref.addEventListener("loadstart", function(event) {
              if (event.url.indexOf(cordovaRedirectUri) == 0) {
                ref.close();
                var oauth = parseCallback(event.url);
                processCallback(oauth, promise);
              }
            });
            return promise.promise;
          },
          accountManagement: function() {
            var accountUrl = kc3.createAccountUrl();
            if (typeof accountUrl !== "undefined") {
              var ref = cordovaOpenWindowWrapper(accountUrl, "_blank", "location=no");
              ref.addEventListener("loadstart", function(event) {
                if (event.url.indexOf(cordovaRedirectUri) == 0) {
                  ref.close();
                }
              });
            } else {
              throw "Not supported by the OIDC server";
            }
          },
          redirectUri: function(options) {
            return cordovaRedirectUri;
          }
        };
      }
      if (type == "cordova-native") {
        loginIframe.enable = false;
        return {
          login: function(options) {
            var promise = createPromise();
            var loginUrl = kc3.createLoginUrl(options);
            universalLinks.subscribe("keycloak", function(event) {
              universalLinks.unsubscribe("keycloak");
              window.cordova.plugins.browsertab.close();
              var oauth = parseCallback(event.url);
              processCallback(oauth, promise);
            });
            window.cordova.plugins.browsertab.openUrl(loginUrl);
            return promise.promise;
          },
          logout: function(options) {
            var promise = createPromise();
            var logoutUrl = kc3.createLogoutUrl(options);
            universalLinks.subscribe("keycloak", function(event) {
              universalLinks.unsubscribe("keycloak");
              window.cordova.plugins.browsertab.close();
              kc3.clearToken();
              promise.setSuccess();
            });
            window.cordova.plugins.browsertab.openUrl(logoutUrl);
            return promise.promise;
          },
          register: function(options) {
            var promise = createPromise();
            var registerUrl = kc3.createRegisterUrl(options);
            universalLinks.subscribe("keycloak", function(event) {
              universalLinks.unsubscribe("keycloak");
              window.cordova.plugins.browsertab.close();
              var oauth = parseCallback(event.url);
              processCallback(oauth, promise);
            });
            window.cordova.plugins.browsertab.openUrl(registerUrl);
            return promise.promise;
          },
          accountManagement: function() {
            var accountUrl = kc3.createAccountUrl();
            if (typeof accountUrl !== "undefined") {
              window.cordova.plugins.browsertab.openUrl(accountUrl);
            } else {
              throw "Not supported by the OIDC server";
            }
          },
          redirectUri: function(options) {
            if (options && options.redirectUri) {
              return options.redirectUri;
            } else if (kc3.redirectUri) {
              return kc3.redirectUri;
            } else {
              return "http://localhost";
            }
          }
        };
      }
      throw "invalid adapter type: " + type;
    }
    var LocalStorage = function() {
      if (!(this instanceof LocalStorage)) {
        return new LocalStorage();
      }
      localStorage.setItem("kc-test", "test");
      localStorage.removeItem("kc-test");
      var cs3 = this;
      function clearExpired() {
        var time = (/* @__PURE__ */ new Date()).getTime();
        for (var i6 = 0; i6 < localStorage.length; i6++) {
          var key = localStorage.key(i6);
          if (key && key.indexOf("kc-callback-") == 0) {
            var value = localStorage.getItem(key);
            if (value) {
              try {
                var expires = JSON.parse(value).expires;
                if (!expires || expires < time) {
                  localStorage.removeItem(key);
                }
              } catch (err) {
                localStorage.removeItem(key);
              }
            }
          }
        }
      }
      cs3.get = function(state) {
        if (!state) {
          return;
        }
        var key = "kc-callback-" + state;
        var value = localStorage.getItem(key);
        if (value) {
          localStorage.removeItem(key);
          value = JSON.parse(value);
        }
        clearExpired();
        return value;
      };
      cs3.add = function(state) {
        clearExpired();
        var key = "kc-callback-" + state.state;
        state.expires = (/* @__PURE__ */ new Date()).getTime() + 60 * 60 * 1e3;
        localStorage.setItem(key, JSON.stringify(state));
      };
    };
    var CookieStorage = function() {
      if (!(this instanceof CookieStorage)) {
        return new CookieStorage();
      }
      var cs3 = this;
      cs3.get = function(state) {
        if (!state) {
          return;
        }
        var value = getCookie("kc-callback-" + state);
        setCookie("kc-callback-" + state, "", cookieExpiration(-100));
        if (value) {
          return JSON.parse(value);
        }
      };
      cs3.add = function(state) {
        setCookie("kc-callback-" + state.state, JSON.stringify(state), cookieExpiration(60));
      };
      cs3.removeItem = function(key) {
        setCookie(key, "", cookieExpiration(-100));
      };
      var cookieExpiration = function(minutes) {
        var exp = /* @__PURE__ */ new Date();
        exp.setTime(exp.getTime() + minutes * 60 * 1e3);
        return exp;
      };
      var getCookie = function(key) {
        var name2 = key + "=";
        var ca3 = document.cookie.split(";");
        for (var i6 = 0; i6 < ca3.length; i6++) {
          var c5 = ca3[i6];
          while (c5.charAt(0) == " ") {
            c5 = c5.substring(1);
          }
          if (c5.indexOf(name2) == 0) {
            return c5.substring(name2.length, c5.length);
          }
        }
        return "";
      };
      var setCookie = function(key, value, expirationDate) {
        var cookie = key + "=" + value + "; expires=" + expirationDate.toUTCString() + "; ";
        document.cookie = cookie;
      };
    };
    function createCallbackStorage() {
      try {
        return new LocalStorage();
      } catch (err) {
      }
      return new CookieStorage();
    }
    function createLogger(fn4) {
      return function() {
        if (kc3.enableLogging) {
          fn4.apply(console, Array.prototype.slice.call(arguments));
        }
      };
    }
  }
  var import_base64_js, import_js_sha256;
  var init_keycloak = __esm({
    "node_modules/keycloak-js/dist/keycloak.mjs"() {
      import_base64_js = __toESM(require_base64_js(), 1);
      import_js_sha256 = __toESM(require_sha256(), 1);
      if (typeof Promise === "undefined") {
        throw Error("Keycloak requires an environment that supports Promises. Make sure that you include the appropriate polyfill.");
      }
    }
  });

  // node_modules/@sermas/toolkit/logger.js
  var DefaultLogLevel, levels, Logger, logger;
  var init_logger = __esm({
    "node_modules/@sermas/toolkit/logger.js"() {
      DefaultLogLevel = "DEBUG";
      levels = {
        DEBUG: 100,
        LOG: 200,
        WARN: 300,
        ERROR: 400
      };
      Logger = class {
        constructor(prefix = "", showDates, formatterCallback, logLevel = DefaultLogLevel) {
          this.prefix = prefix;
          this.showDates = showDates;
          this.formatterCallback = formatterCallback;
          this.logLevel = logLevel;
        }
        format(level, v5) {
          v5 = v5 || [];
          if (this.formatterCallback) {
            return this.formatterCallback(v5);
          }
          return [`${this.showDates ? /* @__PURE__ */ new Date() + " " : ""}[${this.prefix}]`, ...v5];
        }
        clear() {
          console.clear();
        }
        debug(...v5) {
          if (levels[this.logLevel] !== levels.DEBUG)
            return;
          console.debug(...this.format("DEBUG", v5));
        }
        log(...v5) {
          if (levels[this.logLevel] > levels.DEBUG)
            return;
          console.log(...this.format("LOG", v5));
        }
        warn(...v5) {
          if (levels[this.logLevel] > levels.LOG)
            return;
          console.warn(...this.format("WARN", v5));
        }
        error(...v5) {
          if (levels[this.logLevel] > levels.WARN)
            return;
          console.error(...this.format("ERROR", v5));
        }
      };
      logger = new Logger("default");
    }
  });

  // node_modules/@sermas/toolkit/auth.js
  var parseJWT, AuthToken, AuthClient;
  var init_auth = __esm({
    "node_modules/@sermas/toolkit/auth.js"() {
      init_keycloak();
      init_logger();
      parseJWT = (token) => {
        if (!token)
          return void 0;
        try {
          return JSON.parse(atob(token.split(".")[1]));
        } catch (e4) {
          logger.warn(`failed to parse JWT: ${e4.message}`);
        }
        return void 0;
      };
      AuthToken = class {
        constructor(token) {
          this.set(token);
        }
        clear() {
          this.token = void 0;
          this.userInfo = void 0;
        }
        set(token) {
          if (!token) {
            return this.clear();
          }
          this.token = token;
          this.userInfo = parseJWT(this.token);
        }
        getToken() {
          return this.token;
        }
        getUserInfo() {
          return this.userInfo;
        }
      };
      AuthClient = class {
        constructor(options) {
          this.options = options;
          this.logger = new Logger("auth");
          this.auth = new AuthToken();
        }
        getUserInfo() {
          return this.auth.getUserInfo();
        }
        getKeycloak() {
          return this.kc;
        }
        async initAuth() {
          this.kc = new Keycloak({
            url: this.options.authUrl,
            realm: this.options.authRealm,
            clientId: this.options.authClientId
          });
          const logged_in = await this.kc.init({ onLoad: "login-required" });
          if (logged_in) {
            this.logger.debug(`User is already logged-in`);
            this.setToken(this.kc?.token);
            return;
          }
          this.clearToken();
        }
        clearToken() {
          this.auth.clear();
        }
        setToken(token) {
          this.auth.set(token);
        }
        //redirect to logout if token is expired
        isExpired() {
          if (!this.kc?.isTokenExpired())
            return false;
          this.logger.log("token expired");
          this.clearToken();
          this.kc?.logout();
          return true;
        }
        async refreshKeycloackToken() {
          this.logger.log("refresh token");
          const refreshed = await this.kc?.updateToken(this.options.tokenMinValidity || 60);
          if (refreshed) {
            this.logger.log("token refreshed");
            this.setToken(this.kc?.token);
            return;
          }
          this.isExpired();
        }
        async refreshToken() {
          if (this.options.refreshToken) {
            return await this.options.refreshToken();
          }
          await this.refreshKeycloackToken();
          const token = this.auth.getToken();
          if (!token)
            return null;
          const jwt = this.auth.getUserInfo();
          if (!jwt?.exp)
            return null;
          return {
            access_token: token,
            expires_in: jwt.exp
          };
        }
        registerRefreshTokenTimeout(expiresIn) {
          if (!expiresIn)
            return;
          if (this.refreshTokenTimeout) {
            clearTimeout(this.refreshTokenTimeout);
          }
          const refreshIn = new Date(expiresIn).getTime() - Date.now() - 60 * 1e3;
          this.logger.log(`Refreshing token in ${Math.round(refreshIn / 60 / 1e3)}s`);
          this.refreshTokenTimeout = setTimeout(async () => {
            this.logger.log(`refreshing token`);
            try {
              const res = await this.refreshToken();
              this.setToken(res?.access_token);
              if (res?.expires_in) {
                const expiresIn2 = new Date(Date.now() + res?.expires_in * 1e3);
                this.logger.log(`next token refresh at ${expiresIn2}`);
                this.registerRefreshTokenTimeout(expiresIn2);
              }
            } catch (e4) {
              this.logger.error(`Failed to refresh token: ${e4.message}`);
            }
          }, refreshIn);
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/dto/api.dto.js
  var init_api_dto = __esm({
    "node_modules/@sermas/toolkit/dto/api.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/detection.dto.js
  var InteractionType, UserCharacterizationEventSource;
  var init_detection_dto = __esm({
    "node_modules/@sermas/toolkit/dto/detection.dto.js"() {
      (function(InteractionType2) {
        InteractionType2["start"] = "start";
        InteractionType2["stop"] = "stop";
      })(InteractionType || (InteractionType = {}));
      (function(UserCharacterizationEventSource2) {
        UserCharacterizationEventSource2["deepface"] = "deepface";
        UserCharacterizationEventSource2["sentiment_analysis"] = "sentiment_analysis";
        UserCharacterizationEventSource2["emotion_tracker"] = "emotion_tracker";
        UserCharacterizationEventSource2["speechbrain"] = "speechbrain";
      })(UserCharacterizationEventSource || (UserCharacterizationEventSource = {}));
    }
  });

  // node_modules/@sermas/toolkit/dto/dialogue.dto.js
  var init_dialogue_dto = __esm({
    "node_modules/@sermas/toolkit/dto/dialogue.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/errors.dto.js
  var ErrorReason;
  var init_errors_dto = __esm({
    "node_modules/@sermas/toolkit/dto/errors.dto.js"() {
      (function(ErrorReason2) {
        ErrorReason2[ErrorReason2["MISSING_APP"] = 0] = "MISSING_APP";
      })(ErrorReason || (ErrorReason = {}));
    }
  });

  // node_modules/@sermas/toolkit/dto/events.dto.js
  var init_events_dto = __esm({
    "node_modules/@sermas/toolkit/dto/events.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/languages.dto.js
  var init_languages_dto = __esm({
    "node_modules/@sermas/toolkit/dto/languages.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/llm.dto.js
  var init_llm_dto = __esm({
    "node_modules/@sermas/toolkit/dto/llm.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/proxy.dto.js
  var init_proxy_dto = __esm({
    "node_modules/@sermas/toolkit/dto/proxy.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/session.dto.js
  var AgentStatus;
  var init_session_dto = __esm({
    "node_modules/@sermas/toolkit/dto/session.dto.js"() {
      (function(AgentStatus2) {
        AgentStatus2[AgentStatus2["unavailable"] = -3e3] = "unavailable";
        AgentStatus2[AgentStatus2["error"] = -2e3] = "error";
        AgentStatus2[AgentStatus2["not_ready"] = -1e3] = "not_ready";
        AgentStatus2[AgentStatus2["ready"] = 1e3] = "ready";
        AgentStatus2[AgentStatus2["loading"] = 2e3] = "loading";
        AgentStatus2[AgentStatus2["interacting"] = 3e3] = "interacting";
        AgentStatus2[AgentStatus2["waiting"] = 4e3] = "waiting";
        AgentStatus2[AgentStatus2["processing"] = 5e3] = "processing";
      })(AgentStatus || (AgentStatus = {}));
    }
  });

  // node_modules/@sermas/toolkit/dto/settings.dto.js
  var init_settings_dto = __esm({
    "node_modules/@sermas/toolkit/dto/settings.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto/ui.dto.js
  var init_ui_dto = __esm({
    "node_modules/@sermas/toolkit/dto/ui.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/dto.js
  var init_dto = __esm({
    "node_modules/@sermas/toolkit/dto.js"() {
      init_api_dto();
      init_detection_dto();
      init_dialogue_dto();
      init_errors_dto();
      init_events_dto();
      init_languages_dto();
      init_llm_dto();
      init_proxy_dto();
      init_session_dto();
      init_settings_dto();
      init_ui_dto();
    }
  });

  // node_modules/@sermas/toolkit/api.js
  var ApiClient;
  var init_api = __esm({
    "node_modules/@sermas/toolkit/api.js"() {
      init_axios2();
      init_auth();
      init_dto();
      init_logger();
      ApiClient = class {
        setUserId(userId) {
          this.userId = userId;
        }
        setAppId(appId) {
          this.appId = appId;
        }
        setSessionId(sessionId) {
          this.sessionId = sessionId;
        }
        constructor(options) {
          this.options = options;
          this.logger = new Logger("api");
          this.auth = new AuthToken();
          this.setToken(this.options.token);
          this.appId = this.options.appId;
        }
        setToken(token) {
          this.auth.set(token);
          this.client = this.createClient();
        }
        requireAppId() {
          if (!this.appId) {
            this.logger.error(`appId not set`);
          }
          return this.appId;
        }
        requireSessionId() {
          if (!this.sessionId) {
            this.logger.error(`sessionId not set`);
          }
          return this.sessionId;
        }
        createClient() {
          return new Axios2({
            baseURL: this.options.url,
            headers: {
              ...this.auth.getToken() ? { Authorization: `Bearer ${this.auth.getToken()}` } : {},
              "content-type": "application/json"
            },
            transformResponse: [
              (data, headers) => {
                if (headers["content-type"] === "application/octet-stream" || headers["content-type"] === "text/html; charset=utf-8" || headers["content-type"] === "application/zip") {
                  return data;
                }
                try {
                  const response = JSON.parse(data);
                  if (response && response.statusCode >= 400) {
                    throw new Error(`Request failed with ${response.statusCode}`);
                  }
                  return response;
                } catch (e4) {
                  return null;
                }
              }
            ],
            transformRequest: [
              (data, headers) => {
                if (headers["content-type"] === "multipart/form-data") {
                  return data;
                }
                return JSON.stringify(data);
              }
            ]
          });
        }
        getClient() {
          if (!this.client) {
            this.client = this.createClient();
          }
          return this.client;
        }
        async post(url, data, config) {
          try {
            if (!data.appId && this.appId)
              data.appId = this.appId;
            if (!data.userId && this.userId)
              data.userId = this.userId;
            if (!data.sessionId && this.sessionId)
              data.sessionId = this.sessionId;
            const res = await this.getClient().post(url, data, config);
            return res.data;
          } catch (e4) {
            if (isAxiosError2(e4)) {
              const err = e4;
              this.logger.error(`Request failed ${err.code} ${err.status} ${err.response?.data}`);
            } else
              this.logger.error(`Request failed ${e4?.message}`);
          }
          return null;
        }
        async put(url, data, config) {
          try {
            if (!data.appId && this.appId)
              data.appId = this.appId;
            if (!data.userId && this.userId)
              data.userId = this.userId;
            if (!data.sessionId && this.sessionId)
              data.sessionId = this.sessionId;
            const res = await this.getClient().put(url, data, config);
            return res.data;
          } catch (e4) {
            if (isAxiosError2(e4)) {
              const err = e4;
              this.logger.error(`Request failed ${err.code} ${err.status} ${err.response?.data}`);
            } else
              this.logger.error(`Request failed ${e4?.message}`);
          }
          return null;
        }
        async get(url, config) {
          try {
            const res = await this.getClient().get(url, config);
            return res.data;
          } catch (e4) {
            if (isAxiosError2(e4)) {
              const err = e4;
              this.logger.error(`Request failed ${err.code} ${err.status} ${err.response?.data}`);
            } else
              this.logger.error(`Request failed ${e4?.message}`);
          }
          return null;
        }
        async refreshToken() {
          const jwt = this.auth.getUserInfo();
          const data = {
            appId: this.appId,
            clientId: jwt?.azp
          };
          return await this.post(`platform/token/refresh`, data);
        }
        async sendForceStop() {
          const appId = this.requireAppId();
          if (!appId)
            return null;
          const sessionId = this.requireSessionId();
          if (!sessionId)
            return null;
          return await this.post(`dialogue/speech/stop/${appId}/${sessionId}`, {}) || [];
        }
        async login(form) {
          return await this.post(`auth/login`, form);
        }
        async whoAmI(token) {
          const headers = { Authorization: `Bearer ${token}` };
          return await this.get(`auth/whoami`, { headers });
        }
        async sendAudio(data, params) {
          const appId = this.requireAppId();
          if (!appId)
            return null;
          const sessionId = this.requireSessionId();
          if (!sessionId)
            return null;
          params = params || {};
          const qs3 = Object.keys(params).reduce((arr, key) => {
            if (!params || !params[key])
              return arr;
            return [...arr, `${key}=${params[key]}`];
          }, []).join("&");
          return await this.post(`dialogue/speech/stt/${appId}/${sessionId}?${qs3}`, data, { headers: { "content-type": "multipart/form-data" } }) || [];
        }
        async sendChatMessage(data) {
          const appId = this.requireAppId();
          if (!appId)
            return null;
          const sessionId = this.requireSessionId();
          if (!sessionId)
            return null;
          return await this.post(`dialogue/speech/chat/${appId}/${sessionId}`, data) || [];
        }
        async sendAgentHeartBeat(heartbit) {
          if (!heartbit.moduleId)
            return null;
          if (!heartbit.appId)
            return null;
          this.logger.log(`Sending heartbit status=${AgentStatus[heartbit.status]} for moduleId=${heartbit.moduleId}`);
          await this.post(`session/agent`, heartbit);
        }
        async listTopics(moduleId) {
          const appId = this.requireAppId();
          if (!appId)
            return null;
          return await this.get(`platform/app/${appId}/client/${moduleId}/topics`);
        }
        async interactionIntention(moduleId = "avatar", source, interactionType, sessionId) {
          const appId = this.requireAppId();
          if (!appId)
            return null;
          const payload = {
            appId,
            moduleId,
            source,
            sessionId,
            probability: 1,
            interactionType
          };
          return await this.post("detection/interaction", payload);
        }
        async mapBlendShapes(blendShapes) {
          if (!blendShapes || !blendShapes.length)
            return {};
          const payload = {
            blendShapes
          };
          const res = await this.post("ui/model/map-blend-shapes", payload);
          if (!res?.blendShapes)
            return {};
          return res?.blendShapes;
        }
        async getApp(appId) {
          appId = appId || this.requireAppId();
          if (!appId) {
            this.logger.warn("getApp: no appId available");
            return null;
          }
          return await this.get(`app/${appId}`);
        }
        async getApps() {
          return await this.get(`app`);
        }
        async getAsset(path) {
          const appId = this.requireAppId();
          if (!appId) {
            this.logger.warn("getApp: no appId available");
            return null;
          }
          return await this.get(`ui/asset/${appId}`, { params: { path } });
        }
        async getUserSession(appId, token) {
          appId = appId || this.requireAppId();
          if (!appId) {
            this.logger.warn("getApp: no appId available");
            return null;
          }
          return await this.get(`session/user/${appId}`, !token ? void 0 : {
            headers: {
              Authorization: `Bearer ${token}`
            }
          });
        }
        async getRepositoryDefaults() {
          return await this.get(`app/repository/defaults`);
        }
        getSession(sessionId) {
          return this.get(`session/${sessionId}`);
        }
        updateSession(session) {
          return this.put(`session`, session);
        }
      };
    }
  });

  // node_modules/eventemitter2/lib/eventemitter2.js
  var require_eventemitter2 = __commonJS({
    "node_modules/eventemitter2/lib/eventemitter2.js"(exports2, module2) {
      !function(undefined2) {
        var hasOwnProperty2 = Object.hasOwnProperty;
        var isArray2 = Array.isArray ? Array.isArray : function _isArray(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        var defaultMaxListeners = 10;
        var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
        var symbolsSupported = typeof Symbol === "function";
        var reflectSupported = typeof Reflect === "object";
        var setImmediateSupported = typeof setImmediate === "function";
        var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
        var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
          var arr = Object.getOwnPropertyNames(obj);
          arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
          return arr;
        } : Object.keys;
        function init() {
          this._events = {};
          if (this._conf) {
            configure.call(this, this._conf);
          }
        }
        function configure(conf) {
          if (conf) {
            this._conf = conf;
            conf.delimiter && (this.delimiter = conf.delimiter);
            if (conf.maxListeners !== undefined2) {
              this._maxListeners = conf.maxListeners;
            }
            conf.wildcard && (this.wildcard = conf.wildcard);
            conf.newListener && (this._newListener = conf.newListener);
            conf.removeListener && (this._removeListener = conf.removeListener);
            conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
            conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
            if (this.wildcard) {
              this.listenerTree = {};
            }
          }
        }
        function logPossibleMemoryLeak(count, eventName) {
          var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
          if (this.verboseMemoryLeak) {
            errorMsg += " Event name: " + eventName + ".";
          }
          if (typeof process !== "undefined" && process.emitWarning) {
            var e4 = new Error(errorMsg);
            e4.name = "MaxListenersExceededWarning";
            e4.emitter = this;
            e4.count = count;
            process.emitWarning(e4);
          } else {
            console.error(errorMsg);
            if (console.trace) {
              console.trace();
            }
          }
        }
        var toArray2 = function(a4, b3, c5) {
          var n4 = arguments.length;
          switch (n4) {
            case 0:
              return [];
            case 1:
              return [a4];
            case 2:
              return [a4, b3];
            case 3:
              return [a4, b3, c5];
            default:
              var arr = new Array(n4);
              while (n4--) {
                arr[n4] = arguments[n4];
              }
              return arr;
          }
        };
        function toObject(keys, values) {
          var obj = {};
          var key;
          var len2 = keys.length;
          var valuesCount = values ? values.length : 0;
          for (var i5 = 0; i5 < len2; i5++) {
            key = keys[i5];
            obj[key] = i5 < valuesCount ? values[i5] : undefined2;
          }
          return obj;
        }
        function TargetObserver(emitter2, target, options) {
          this._emitter = emitter2;
          this._target = target;
          this._listeners = {};
          this._listenersCount = 0;
          var on4, off;
          if (options.on || options.off) {
            on4 = options.on;
            off = options.off;
          }
          if (target.addEventListener) {
            on4 = target.addEventListener;
            off = target.removeEventListener;
          } else if (target.addListener) {
            on4 = target.addListener;
            off = target.removeListener;
          } else if (target.on) {
            on4 = target.on;
            off = target.off;
          }
          if (!on4 && !off) {
            throw Error("target does not implement any known event API");
          }
          if (typeof on4 !== "function") {
            throw TypeError("on method must be a function");
          }
          if (typeof off !== "function") {
            throw TypeError("off method must be a function");
          }
          this._on = on4;
          this._off = off;
          var _observers = emitter2._observers;
          if (_observers) {
            _observers.push(this);
          } else {
            emitter2._observers = [this];
          }
        }
        Object.assign(TargetObserver.prototype, {
          subscribe: function(event, localEvent, reducer) {
            var observer = this;
            var target = this._target;
            var emitter2 = this._emitter;
            var listeners = this._listeners;
            var handler = function() {
              var args = toArray2.apply(null, arguments);
              var eventObj = {
                data: args,
                name: localEvent,
                original: event
              };
              if (reducer) {
                var result = reducer.call(target, eventObj);
                if (result !== false) {
                  emitter2.emit.apply(emitter2, [eventObj.name].concat(args));
                }
                return;
              }
              emitter2.emit.apply(emitter2, [localEvent].concat(args));
            };
            if (listeners[event]) {
              throw Error("Event '" + event + "' is already listening");
            }
            this._listenersCount++;
            if (emitter2._newListener && emitter2._removeListener && !observer._onNewListener) {
              this._onNewListener = function(_event) {
                if (_event === localEvent && listeners[event] === null) {
                  listeners[event] = handler;
                  observer._on.call(target, event, handler);
                }
              };
              emitter2.on("newListener", this._onNewListener);
              this._onRemoveListener = function(_event) {
                if (_event === localEvent && !emitter2.hasListeners(_event) && listeners[event]) {
                  listeners[event] = null;
                  observer._off.call(target, event, handler);
                }
              };
              listeners[event] = null;
              emitter2.on("removeListener", this._onRemoveListener);
            } else {
              listeners[event] = handler;
              observer._on.call(target, event, handler);
            }
          },
          unsubscribe: function(event) {
            var observer = this;
            var listeners = this._listeners;
            var emitter2 = this._emitter;
            var handler;
            var events;
            var off = this._off;
            var target = this._target;
            var i5;
            if (event && typeof event !== "string") {
              throw TypeError("event must be a string");
            }
            function clearRefs() {
              if (observer._onNewListener) {
                emitter2.off("newListener", observer._onNewListener);
                emitter2.off("removeListener", observer._onRemoveListener);
                observer._onNewListener = null;
                observer._onRemoveListener = null;
              }
              var index = findTargetIndex.call(emitter2, observer);
              emitter2._observers.splice(index, 1);
            }
            if (event) {
              handler = listeners[event];
              if (!handler)
                return;
              off.call(target, event, handler);
              delete listeners[event];
              if (!--this._listenersCount) {
                clearRefs();
              }
            } else {
              events = ownKeys(listeners);
              i5 = events.length;
              while (i5-- > 0) {
                event = events[i5];
                off.call(target, event, listeners[event]);
              }
              this._listeners = {};
              this._listenersCount = 0;
              clearRefs();
            }
          }
        });
        function resolveOptions(options, schema, reducers, allowUnknown) {
          var computedOptions = Object.assign({}, schema);
          if (!options)
            return computedOptions;
          if (typeof options !== "object") {
            throw TypeError("options must be an object");
          }
          var keys = Object.keys(options);
          var length3 = keys.length;
          var option, value;
          var reducer;
          function reject(reason) {
            throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
          }
          for (var i5 = 0; i5 < length3; i5++) {
            option = keys[i5];
            if (!allowUnknown && !hasOwnProperty2.call(schema, option)) {
              throw Error('Unknown "' + option + '" option');
            }
            value = options[option];
            if (value !== undefined2) {
              reducer = reducers[option];
              computedOptions[option] = reducer ? reducer(value, reject) : value;
            }
          }
          return computedOptions;
        }
        function constructorReducer(value, reject) {
          if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
            reject("value must be a constructor");
          }
          return value;
        }
        function makeTypeReducer(types) {
          var message = "value must be type of " + types.join("|");
          var len2 = types.length;
          var firstType = types[0];
          var secondType = types[1];
          if (len2 === 1) {
            return function(v5, reject) {
              if (typeof v5 === firstType) {
                return v5;
              }
              reject(message);
            };
          }
          if (len2 === 2) {
            return function(v5, reject) {
              var kind = typeof v5;
              if (kind === firstType || kind === secondType)
                return v5;
              reject(message);
            };
          }
          return function(v5, reject) {
            var kind = typeof v5;
            var i5 = len2;
            while (i5-- > 0) {
              if (kind === types[i5])
                return v5;
            }
            reject(message);
          };
        }
        var functionReducer = makeTypeReducer(["function"]);
        var objectFunctionReducer = makeTypeReducer(["object", "function"]);
        function makeCancelablePromise(Promise2, executor, options) {
          var isCancelable;
          var callbacks;
          var timer = 0;
          var subscriptionClosed;
          var promise = new Promise2(function(resolve, reject, onCancel) {
            options = resolveOptions(options, {
              timeout: 0,
              overload: false
            }, {
              timeout: function(value, reject2) {
                value *= 1;
                if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                  reject2("timeout must be a positive number");
                }
                return value;
              }
            });
            isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
            function cleanup() {
              if (callbacks) {
                callbacks = null;
              }
              if (timer) {
                clearTimeout(timer);
                timer = 0;
              }
            }
            var _resolve = function(value) {
              cleanup();
              resolve(value);
            };
            var _reject = function(err) {
              cleanup();
              reject(err);
            };
            if (isCancelable) {
              executor(_resolve, _reject, onCancel);
            } else {
              callbacks = [function(reason) {
                _reject(reason || Error("canceled"));
              }];
              executor(_resolve, _reject, function(cb2) {
                if (subscriptionClosed) {
                  throw Error("Unable to subscribe on cancel event asynchronously");
                }
                if (typeof cb2 !== "function") {
                  throw TypeError("onCancel callback must be a function");
                }
                callbacks.push(cb2);
              });
              subscriptionClosed = true;
            }
            if (options.timeout > 0) {
              timer = setTimeout(function() {
                var reason = Error("timeout");
                reason.code = "ETIMEDOUT";
                timer = 0;
                promise.cancel(reason);
                reject(reason);
              }, options.timeout);
            }
          });
          if (!isCancelable) {
            promise.cancel = function(reason) {
              if (!callbacks) {
                return;
              }
              var length3 = callbacks.length;
              for (var i5 = 1; i5 < length3; i5++) {
                callbacks[i5](reason);
              }
              callbacks[0](reason);
              callbacks = null;
            };
          }
          return promise;
        }
        function findTargetIndex(observer) {
          var observers = this._observers;
          if (!observers) {
            return -1;
          }
          var len2 = observers.length;
          for (var i5 = 0; i5 < len2; i5++) {
            if (observers[i5]._target === observer)
              return i5;
          }
          return -1;
        }
        function searchListenerTree(handlers, type, tree, i5, typeLength) {
          if (!tree) {
            return null;
          }
          if (i5 === 0) {
            var kind = typeof type;
            if (kind === "string") {
              var ns3, n4, l4 = 0, j4 = 0, delimiter = this.delimiter, dl2 = delimiter.length;
              if ((n4 = type.indexOf(delimiter)) !== -1) {
                ns3 = new Array(5);
                do {
                  ns3[l4++] = type.slice(j4, n4);
                  j4 = n4 + dl2;
                } while ((n4 = type.indexOf(delimiter, j4)) !== -1);
                ns3[l4++] = type.slice(j4);
                type = ns3;
                typeLength = l4;
              } else {
                type = [type];
                typeLength = 1;
              }
            } else if (kind === "object") {
              typeLength = type.length;
            } else {
              type = [type];
              typeLength = 1;
            }
          }
          var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i5], nextType = type[i5 + 1], branches, _listeners;
          if (i5 === typeLength) {
            if (tree._listeners) {
              if (typeof tree._listeners === "function") {
                handlers && handlers.push(tree._listeners);
                listeners = [tree];
              } else {
                handlers && handlers.push.apply(handlers, tree._listeners);
                listeners = [tree];
              }
            }
          } else {
            if (currentType === "*") {
              branches = ownKeys(tree);
              n4 = branches.length;
              while (n4-- > 0) {
                branch = branches[n4];
                if (branch !== "_listeners") {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i5 + 1, typeLength);
                  if (_listeners) {
                    if (listeners) {
                      listeners.push.apply(listeners, _listeners);
                    } else {
                      listeners = _listeners;
                    }
                  }
                }
              }
              return listeners;
            } else if (currentType === "**") {
              endReached = i5 + 1 === typeLength || i5 + 2 === typeLength && nextType === "*";
              if (endReached && tree._listeners) {
                listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
              }
              branches = ownKeys(tree);
              n4 = branches.length;
              while (n4-- > 0) {
                branch = branches[n4];
                if (branch !== "_listeners") {
                  if (branch === "*" || branch === "**") {
                    if (tree[branch]._listeners && !endReached) {
                      _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                      if (_listeners) {
                        if (listeners) {
                          listeners.push.apply(listeners, _listeners);
                        } else {
                          listeners = _listeners;
                        }
                      }
                    }
                    _listeners = searchListenerTree(handlers, type, tree[branch], i5, typeLength);
                  } else if (branch === nextType) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], i5 + 2, typeLength);
                  } else {
                    _listeners = searchListenerTree(handlers, type, tree[branch], i5, typeLength);
                  }
                  if (_listeners) {
                    if (listeners) {
                      listeners.push.apply(listeners, _listeners);
                    } else {
                      listeners = _listeners;
                    }
                  }
                }
              }
              return listeners;
            } else if (tree[currentType]) {
              listeners = searchListenerTree(handlers, type, tree[currentType], i5 + 1, typeLength);
            }
          }
          xTree = tree["*"];
          if (xTree) {
            searchListenerTree(handlers, type, xTree, i5 + 1, typeLength);
          }
          xxTree = tree["**"];
          if (xxTree) {
            if (i5 < typeLength) {
              if (xxTree._listeners) {
                searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
              }
              branches = ownKeys(xxTree);
              n4 = branches.length;
              while (n4-- > 0) {
                branch = branches[n4];
                if (branch !== "_listeners") {
                  if (branch === nextType) {
                    searchListenerTree(handlers, type, xxTree[branch], i5 + 2, typeLength);
                  } else if (branch === currentType) {
                    searchListenerTree(handlers, type, xxTree[branch], i5 + 1, typeLength);
                  } else {
                    isolatedBranch = {};
                    isolatedBranch[branch] = xxTree[branch];
                    searchListenerTree(handlers, type, { "**": isolatedBranch }, i5 + 1, typeLength);
                  }
                }
              }
            } else if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            } else if (xxTree["*"] && xxTree["*"]._listeners) {
              searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
            }
          }
          return listeners;
        }
        function growListenerTree(type, listener, prepend) {
          var len2 = 0, j4 = 0, i5, delimiter = this.delimiter, dl2 = delimiter.length, ns3;
          if (typeof type === "string") {
            if ((i5 = type.indexOf(delimiter)) !== -1) {
              ns3 = new Array(5);
              do {
                ns3[len2++] = type.slice(j4, i5);
                j4 = i5 + dl2;
              } while ((i5 = type.indexOf(delimiter, j4)) !== -1);
              ns3[len2++] = type.slice(j4);
            } else {
              ns3 = [type];
              len2 = 1;
            }
          } else {
            ns3 = type;
            len2 = type.length;
          }
          if (len2 > 1) {
            for (i5 = 0; i5 + 1 < len2; i5++) {
              if (ns3[i5] === "**" && ns3[i5 + 1] === "**") {
                return;
              }
            }
          }
          var tree = this.listenerTree, name2;
          for (i5 = 0; i5 < len2; i5++) {
            name2 = ns3[i5];
            tree = tree[name2] || (tree[name2] = {});
            if (i5 === len2 - 1) {
              if (!tree._listeners) {
                tree._listeners = listener;
              } else {
                if (typeof tree._listeners === "function") {
                  tree._listeners = [tree._listeners];
                }
                if (prepend) {
                  tree._listeners.unshift(listener);
                } else {
                  tree._listeners.push(listener);
                }
                if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                  tree._listeners.warned = true;
                  logPossibleMemoryLeak.call(this, tree._listeners.length, name2);
                }
              }
              return true;
            }
          }
          return true;
        }
        function collectTreeEvents(tree, events, root2, asArray) {
          var branches = ownKeys(tree);
          var i5 = branches.length;
          var branch, branchName, path;
          var hasListeners = tree["_listeners"];
          var isArrayPath;
          while (i5-- > 0) {
            branchName = branches[i5];
            branch = tree[branchName];
            if (branchName === "_listeners") {
              path = root2;
            } else {
              path = root2 ? root2.concat(branchName) : [branchName];
            }
            isArrayPath = asArray || typeof branchName === "symbol";
            hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
            if (typeof branch === "object") {
              collectTreeEvents.call(this, branch, events, path, isArrayPath);
            }
          }
          return events;
        }
        function recursivelyGarbageCollect(root2) {
          var keys = ownKeys(root2);
          var i5 = keys.length;
          var obj, key, flag;
          while (i5-- > 0) {
            key = keys[i5];
            obj = root2[key];
            if (obj) {
              flag = true;
              if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
                delete root2[key];
              }
            }
          }
          return flag;
        }
        function Listener(emitter2, event, listener) {
          this.emitter = emitter2;
          this.event = event;
          this.listener = listener;
        }
        Listener.prototype.off = function() {
          this.emitter.off(this.event, this.listener);
          return this;
        };
        function setupListener(event, listener, options) {
          if (options === true) {
            promisify = true;
          } else if (options === false) {
            async = true;
          } else {
            if (!options || typeof options !== "object") {
              throw TypeError("options should be an object or true");
            }
            var async = options.async;
            var promisify = options.promisify;
            var nextTick = options.nextTick;
            var objectify = options.objectify;
          }
          if (async || nextTick || promisify) {
            var _listener = listener;
            var _origin = listener._origin || listener;
            if (nextTick && !nextTickSupported) {
              throw Error("process.nextTick is not supported");
            }
            if (promisify === undefined2) {
              promisify = listener.constructor.name === "AsyncFunction";
            }
            listener = function() {
              var args = arguments;
              var context = this;
              var event2 = this.event;
              return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
                _setImmediate(resolve);
              }).then(function() {
                context.event = event2;
                return _listener.apply(context, args);
              }) : (nextTick ? process.nextTick : _setImmediate)(function() {
                context.event = event2;
                _listener.apply(context, args);
              });
            };
            listener._async = true;
            listener._origin = _origin;
          }
          return [listener, objectify ? new Listener(this, event, listener) : this];
        }
        function EventEmitter(conf) {
          this._events = {};
          this._newListener = false;
          this._removeListener = false;
          this.verboseMemoryLeak = false;
          configure.call(this, conf);
        }
        EventEmitter.EventEmitter2 = EventEmitter;
        EventEmitter.prototype.listenTo = function(target, events, options) {
          if (typeof target !== "object") {
            throw TypeError("target musts be an object");
          }
          var emitter2 = this;
          options = resolveOptions(options, {
            on: undefined2,
            off: undefined2,
            reducers: undefined2
          }, {
            on: functionReducer,
            off: functionReducer,
            reducers: objectFunctionReducer
          });
          function listen(events2) {
            if (typeof events2 !== "object") {
              throw TypeError("events must be an object");
            }
            var reducers = options.reducers;
            var index = findTargetIndex.call(emitter2, target);
            var observer;
            if (index === -1) {
              observer = new TargetObserver(emitter2, target, options);
            } else {
              observer = emitter2._observers[index];
            }
            var keys = ownKeys(events2);
            var len2 = keys.length;
            var event;
            var isSingleReducer = typeof reducers === "function";
            for (var i5 = 0; i5 < len2; i5++) {
              event = keys[i5];
              observer.subscribe(
                event,
                events2[event] || event,
                isSingleReducer ? reducers : reducers && reducers[event]
              );
            }
          }
          isArray2(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
          return this;
        };
        EventEmitter.prototype.stopListeningTo = function(target, event) {
          var observers = this._observers;
          if (!observers) {
            return false;
          }
          var i5 = observers.length;
          var observer;
          var matched = false;
          if (target && typeof target !== "object") {
            throw TypeError("target should be an object");
          }
          while (i5-- > 0) {
            observer = observers[i5];
            if (!target || observer._target === target) {
              observer.unsubscribe(event);
              matched = true;
            }
          }
          return matched;
        };
        EventEmitter.prototype.delimiter = ".";
        EventEmitter.prototype.setMaxListeners = function(n4) {
          if (n4 !== undefined2) {
            this._maxListeners = n4;
            if (!this._conf)
              this._conf = {};
            this._conf.maxListeners = n4;
          }
        };
        EventEmitter.prototype.getMaxListeners = function() {
          return this._maxListeners;
        };
        EventEmitter.prototype.event = "";
        EventEmitter.prototype.once = function(event, fn4, options) {
          return this._once(event, fn4, false, options);
        };
        EventEmitter.prototype.prependOnceListener = function(event, fn4, options) {
          return this._once(event, fn4, true, options);
        };
        EventEmitter.prototype._once = function(event, fn4, prepend, options) {
          return this._many(event, 1, fn4, prepend, options);
        };
        EventEmitter.prototype.many = function(event, ttl, fn4, options) {
          return this._many(event, ttl, fn4, false, options);
        };
        EventEmitter.prototype.prependMany = function(event, ttl, fn4, options) {
          return this._many(event, ttl, fn4, true, options);
        };
        EventEmitter.prototype._many = function(event, ttl, fn4, prepend, options) {
          var self2 = this;
          if (typeof fn4 !== "function") {
            throw new Error("many only accepts instances of Function");
          }
          function listener() {
            if (--ttl === 0) {
              self2.off(event, listener);
            }
            return fn4.apply(this, arguments);
          }
          listener._origin = fn4;
          return this._on(event, listener, prepend, options);
        };
        EventEmitter.prototype.emit = function() {
          if (!this._events && !this._all) {
            return false;
          }
          this._events || init.call(this);
          var type = arguments[0], ns3, wildcard = this.wildcard;
          var args, l4, i5, j4, containsSymbol;
          if (type === "newListener" && !this._newListener) {
            if (!this._events.newListener) {
              return false;
            }
          }
          if (wildcard) {
            ns3 = type;
            if (type !== "newListener" && type !== "removeListener") {
              if (typeof type === "object") {
                l4 = type.length;
                if (symbolsSupported) {
                  for (i5 = 0; i5 < l4; i5++) {
                    if (typeof type[i5] === "symbol") {
                      containsSymbol = true;
                      break;
                    }
                  }
                }
                if (!containsSymbol) {
                  type = type.join(this.delimiter);
                }
              }
            }
          }
          var al2 = arguments.length;
          var handler;
          if (this._all && this._all.length) {
            handler = this._all.slice();
            for (i5 = 0, l4 = handler.length; i5 < l4; i5++) {
              this.event = type;
              switch (al2) {
                case 1:
                  handler[i5].call(this, type);
                  break;
                case 2:
                  handler[i5].call(this, type, arguments[1]);
                  break;
                case 3:
                  handler[i5].call(this, type, arguments[1], arguments[2]);
                  break;
                default:
                  handler[i5].apply(this, arguments);
              }
            }
          }
          if (wildcard) {
            handler = [];
            searchListenerTree.call(this, handler, ns3, this.listenerTree, 0, l4);
          } else {
            handler = this._events[type];
            if (typeof handler === "function") {
              this.event = type;
              switch (al2) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  args = new Array(al2 - 1);
                  for (j4 = 1; j4 < al2; j4++)
                    args[j4 - 1] = arguments[j4];
                  handler.apply(this, args);
              }
              return true;
            } else if (handler) {
              handler = handler.slice();
            }
          }
          if (handler && handler.length) {
            if (al2 > 3) {
              args = new Array(al2 - 1);
              for (j4 = 1; j4 < al2; j4++)
                args[j4 - 1] = arguments[j4];
            }
            for (i5 = 0, l4 = handler.length; i5 < l4; i5++) {
              this.event = type;
              switch (al2) {
                case 1:
                  handler[i5].call(this);
                  break;
                case 2:
                  handler[i5].call(this, arguments[1]);
                  break;
                case 3:
                  handler[i5].call(this, arguments[1], arguments[2]);
                  break;
                default:
                  handler[i5].apply(this, args);
              }
            }
            return true;
          } else if (!this.ignoreErrors && !this._all && type === "error") {
            if (arguments[1] instanceof Error) {
              throw arguments[1];
            } else {
              throw new Error("Uncaught, unspecified 'error' event.");
            }
          }
          return !!this._all;
        };
        EventEmitter.prototype.emitAsync = function() {
          if (!this._events && !this._all) {
            return false;
          }
          this._events || init.call(this);
          var type = arguments[0], wildcard = this.wildcard, ns3, containsSymbol;
          var args, l4, i5, j4;
          if (type === "newListener" && !this._newListener) {
            if (!this._events.newListener) {
              return Promise.resolve([false]);
            }
          }
          if (wildcard) {
            ns3 = type;
            if (type !== "newListener" && type !== "removeListener") {
              if (typeof type === "object") {
                l4 = type.length;
                if (symbolsSupported) {
                  for (i5 = 0; i5 < l4; i5++) {
                    if (typeof type[i5] === "symbol") {
                      containsSymbol = true;
                      break;
                    }
                  }
                }
                if (!containsSymbol) {
                  type = type.join(this.delimiter);
                }
              }
            }
          }
          var promises = [];
          var al2 = arguments.length;
          var handler;
          if (this._all) {
            for (i5 = 0, l4 = this._all.length; i5 < l4; i5++) {
              this.event = type;
              switch (al2) {
                case 1:
                  promises.push(this._all[i5].call(this, type));
                  break;
                case 2:
                  promises.push(this._all[i5].call(this, type, arguments[1]));
                  break;
                case 3:
                  promises.push(this._all[i5].call(this, type, arguments[1], arguments[2]));
                  break;
                default:
                  promises.push(this._all[i5].apply(this, arguments));
              }
            }
          }
          if (wildcard) {
            handler = [];
            searchListenerTree.call(this, handler, ns3, this.listenerTree, 0);
          } else {
            handler = this._events[type];
          }
          if (typeof handler === "function") {
            this.event = type;
            switch (al2) {
              case 1:
                promises.push(handler.call(this));
                break;
              case 2:
                promises.push(handler.call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler.call(this, arguments[1], arguments[2]));
                break;
              default:
                args = new Array(al2 - 1);
                for (j4 = 1; j4 < al2; j4++)
                  args[j4 - 1] = arguments[j4];
                promises.push(handler.apply(this, args));
            }
          } else if (handler && handler.length) {
            handler = handler.slice();
            if (al2 > 3) {
              args = new Array(al2 - 1);
              for (j4 = 1; j4 < al2; j4++)
                args[j4 - 1] = arguments[j4];
            }
            for (i5 = 0, l4 = handler.length; i5 < l4; i5++) {
              this.event = type;
              switch (al2) {
                case 1:
                  promises.push(handler[i5].call(this));
                  break;
                case 2:
                  promises.push(handler[i5].call(this, arguments[1]));
                  break;
                case 3:
                  promises.push(handler[i5].call(this, arguments[1], arguments[2]));
                  break;
                default:
                  promises.push(handler[i5].apply(this, args));
              }
            }
          } else if (!this.ignoreErrors && !this._all && type === "error") {
            if (arguments[1] instanceof Error) {
              return Promise.reject(arguments[1]);
            } else {
              return Promise.reject("Uncaught, unspecified 'error' event.");
            }
          }
          return Promise.all(promises);
        };
        EventEmitter.prototype.on = function(type, listener, options) {
          return this._on(type, listener, false, options);
        };
        EventEmitter.prototype.prependListener = function(type, listener, options) {
          return this._on(type, listener, true, options);
        };
        EventEmitter.prototype.onAny = function(fn4) {
          return this._onAny(fn4, false);
        };
        EventEmitter.prototype.prependAny = function(fn4) {
          return this._onAny(fn4, true);
        };
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        EventEmitter.prototype._onAny = function(fn4, prepend) {
          if (typeof fn4 !== "function") {
            throw new Error("onAny only accepts instances of Function");
          }
          if (!this._all) {
            this._all = [];
          }
          if (prepend) {
            this._all.unshift(fn4);
          } else {
            this._all.push(fn4);
          }
          return this;
        };
        EventEmitter.prototype._on = function(type, listener, prepend, options) {
          if (typeof type === "function") {
            this._onAny(type, listener);
            return this;
          }
          if (typeof listener !== "function") {
            throw new Error("on only accepts instances of Function");
          }
          this._events || init.call(this);
          var returnValue = this, temp;
          if (options !== undefined2) {
            temp = setupListener.call(this, type, listener, options);
            listener = temp[0];
            returnValue = temp[1];
          }
          if (this._newListener) {
            this.emit("newListener", type, listener);
          }
          if (this.wildcard) {
            growListenerTree.call(this, type, listener, prepend);
            return returnValue;
          }
          if (!this._events[type]) {
            this._events[type] = listener;
          } else {
            if (typeof this._events[type] === "function") {
              this._events[type] = [this._events[type]];
            }
            if (prepend) {
              this._events[type].unshift(listener);
            } else {
              this._events[type].push(listener);
            }
            if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
              this._events[type].warned = true;
              logPossibleMemoryLeak.call(this, this._events[type].length, type);
            }
          }
          return returnValue;
        };
        EventEmitter.prototype.off = function(type, listener) {
          if (typeof listener !== "function") {
            throw new Error("removeListener only takes instances of Function");
          }
          var handlers, leafs = [];
          if (this.wildcard) {
            var ns3 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            leafs = searchListenerTree.call(this, null, ns3, this.listenerTree, 0);
            if (!leafs)
              return this;
          } else {
            if (!this._events[type])
              return this;
            handlers = this._events[type];
            leafs.push({ _listeners: handlers });
          }
          for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
            var leaf = leafs[iLeaf];
            handlers = leaf._listeners;
            if (isArray2(handlers)) {
              var position = -1;
              for (var i5 = 0, length3 = handlers.length; i5 < length3; i5++) {
                if (handlers[i5] === listener || handlers[i5].listener && handlers[i5].listener === listener || handlers[i5]._origin && handlers[i5]._origin === listener) {
                  position = i5;
                  break;
                }
              }
              if (position < 0) {
                continue;
              }
              if (this.wildcard) {
                leaf._listeners.splice(position, 1);
              } else {
                this._events[type].splice(position, 1);
              }
              if (handlers.length === 0) {
                if (this.wildcard) {
                  delete leaf._listeners;
                } else {
                  delete this._events[type];
                }
              }
              if (this._removeListener)
                this.emit("removeListener", type, listener);
              return this;
            } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
              if (this._removeListener)
                this.emit("removeListener", type, listener);
            }
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
          return this;
        };
        EventEmitter.prototype.offAny = function(fn4) {
          var i5 = 0, l4 = 0, fns;
          if (fn4 && this._all && this._all.length > 0) {
            fns = this._all;
            for (i5 = 0, l4 = fns.length; i5 < l4; i5++) {
              if (fn4 === fns[i5]) {
                fns.splice(i5, 1);
                if (this._removeListener)
                  this.emit("removeListenerAny", fn4);
                return this;
              }
            }
          } else {
            fns = this._all;
            if (this._removeListener) {
              for (i5 = 0, l4 = fns.length; i5 < l4; i5++)
                this.emit("removeListenerAny", fns[i5]);
            }
            this._all = [];
          }
          return this;
        };
        EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
        EventEmitter.prototype.removeAllListeners = function(type) {
          if (type === undefined2) {
            !this._events || init.call(this);
            return this;
          }
          if (this.wildcard) {
            var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i5;
            if (!leafs)
              return this;
            for (i5 = 0; i5 < leafs.length; i5++) {
              leaf = leafs[i5];
              leaf._listeners = null;
            }
            this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
          } else if (this._events) {
            this._events[type] = null;
          }
          return this;
        };
        EventEmitter.prototype.listeners = function(type) {
          var _events = this._events;
          var keys, listeners, allListeners;
          var i5;
          var listenerTree;
          if (type === undefined2) {
            if (this.wildcard) {
              throw Error("event name required for wildcard emitter");
            }
            if (!_events) {
              return [];
            }
            keys = ownKeys(_events);
            i5 = keys.length;
            allListeners = [];
            while (i5-- > 0) {
              listeners = _events[keys[i5]];
              if (typeof listeners === "function") {
                allListeners.push(listeners);
              } else {
                allListeners.push.apply(allListeners, listeners);
              }
            }
            return allListeners;
          } else {
            if (this.wildcard) {
              listenerTree = this.listenerTree;
              if (!listenerTree)
                return [];
              var handlers = [];
              var ns3 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
              searchListenerTree.call(this, handlers, ns3, listenerTree, 0);
              return handlers;
            }
            if (!_events) {
              return [];
            }
            listeners = _events[type];
            if (!listeners) {
              return [];
            }
            return typeof listeners === "function" ? [listeners] : listeners;
          }
        };
        EventEmitter.prototype.eventNames = function(nsAsArray) {
          var _events = this._events;
          return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
        };
        EventEmitter.prototype.listenerCount = function(type) {
          return this.listeners(type).length;
        };
        EventEmitter.prototype.hasListeners = function(type) {
          if (this.wildcard) {
            var handlers = [];
            var ns3 = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns3, this.listenerTree, 0);
            return handlers.length > 0;
          }
          var _events = this._events;
          var _all = this._all;
          return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
        };
        EventEmitter.prototype.listenersAny = function() {
          if (this._all) {
            return this._all;
          } else {
            return [];
          }
        };
        EventEmitter.prototype.waitFor = function(event, options) {
          var self2 = this;
          var type = typeof options;
          if (type === "number") {
            options = { timeout: options };
          } else if (type === "function") {
            options = { filter: options };
          }
          options = resolveOptions(options, {
            timeout: 0,
            filter: undefined2,
            handleError: false,
            Promise,
            overload: false
          }, {
            filter: functionReducer,
            Promise: constructorReducer
          });
          return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
            function listener() {
              var filter2 = options.filter;
              if (filter2 && !filter2.apply(self2, arguments)) {
                return;
              }
              self2.off(event, listener);
              if (options.handleError) {
                var err = arguments[0];
                err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
              } else {
                resolve(toArray2.apply(null, arguments));
              }
            }
            onCancel(function() {
              self2.off(event, listener);
            });
            self2._on(event, listener, false);
          }, {
            timeout: options.timeout,
            overload: options.overload
          });
        };
        function once(emitter2, name2, options) {
          options = resolveOptions(options, {
            Promise,
            timeout: 0,
            overload: false
          }, {
            Promise: constructorReducer
          });
          var _Promise = options.Promise;
          return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
            var handler;
            if (typeof emitter2.addEventListener === "function") {
              handler = function() {
                resolve(toArray2.apply(null, arguments));
              };
              onCancel(function() {
                emitter2.removeEventListener(name2, handler);
              });
              emitter2.addEventListener(
                name2,
                handler,
                { once: true }
              );
              return;
            }
            var eventListener = function() {
              errorListener && emitter2.removeListener("error", errorListener);
              resolve(toArray2.apply(null, arguments));
            };
            var errorListener;
            if (name2 !== "error") {
              errorListener = function(err) {
                emitter2.removeListener(name2, eventListener);
                reject(err);
              };
              emitter2.once("error", errorListener);
            }
            onCancel(function() {
              errorListener && emitter2.removeListener("error", errorListener);
              emitter2.removeListener(name2, eventListener);
            });
            emitter2.once(name2, eventListener);
          }, {
            timeout: options.timeout,
            overload: options.overload
          });
        }
        var prototype3 = EventEmitter.prototype;
        Object.defineProperties(EventEmitter, {
          defaultMaxListeners: {
            get: function() {
              return prototype3._maxListeners;
            },
            set: function(n4) {
              if (typeof n4 !== "number" || n4 < 0 || Number.isNaN(n4)) {
                throw TypeError("n must be a non-negative number");
              }
              prototype3._maxListeners = n4;
            },
            enumerable: true
          },
          once: {
            value: once,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperties(prototype3, {
          _maxListeners: {
            value: defaultMaxListeners,
            writable: true,
            configurable: true
          },
          _observers: { value: null, writable: true, configurable: true }
        });
        if (typeof define === "function" && define.amd) {
          define(function() {
            return EventEmitter;
          });
        } else if (typeof exports2 === "object") {
          module2.exports = EventEmitter;
        } else {
          var _global3 = new Function("", "return this")();
          _global3.EventEmitter2 = EventEmitter;
        }
      }();
    }
  });

  // node_modules/@sermas/toolkit/avatar/lipsync/lipsync.dto.js
  var neutral;
  var init_lipsync_dto = __esm({
    "node_modules/@sermas/toolkit/avatar/lipsync/lipsync.dto.js"() {
      neutral = {
        key: "neutral",
        value: 1
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/lipsync/index.js
  var import_eventemitter2, logger2, LipSync;
  var init_lipsync = __esm({
    "node_modules/@sermas/toolkit/avatar/lipsync/index.js"() {
      import_eventemitter2 = __toESM(require_eventemitter2(), 1);
      init_logger();
      init_lipsync_dto();
      logger2 = new Logger("webavatar.lipsync");
      LipSync = class extends import_eventemitter2.default {
        constructor() {
          super();
          this.audioEnabled = true;
          this.paused = true;
          this.stopped = false;
          this.lastVowelIndex = 0;
          this.lastDelta = 0;
          this.vowels = ["neutral", "a", "e", "i", "o", "u"];
          const update = (deltaTime = 0) => {
            this.updateExpression(deltaTime);
            if (!this.stopped)
              requestAnimationFrame(update);
          };
          update();
        }
        toggleAudio(enabled) {
          this.audioEnabled = enabled === void 0 ? !this.audioEnabled : enabled;
          logger2.log(`Set audio enabled=${this.audioEnabled}`);
        }
        async stopAudio() {
          this.source?.stop();
          if (this.source?.onended)
            this.source?.onended({});
        }
        async startFromAudioFile(raw) {
          if (!this.audioEnabled)
            return;
          const rawBuffer = raw.buffer.slice(raw.byteOffset, raw.byteLength + raw.byteOffset);
          if (this.audioContext)
            await this.destroy();
          this.audioContext = new AudioContext();
          const buffer = await this.audioContext.decodeAudioData(rawBuffer);
          this.source = new AudioBufferSourceNode(this.audioContext, {
            buffer,
            loop: false
          });
          this.analyzer = this.audioContext.createAnalyser();
          this.analyzer.fftSize = 1024;
          this.source.connect(this.analyzer);
          this.source.connect(this.audioContext.destination);
          this.source.onended = () => {
            this.paused = true;
            this.emit("viseme", neutral);
            this.emit("end");
          };
          this.source.start();
          this.paused = false;
          this.emit("start");
        }
        async destroy() {
          if (this.source) {
            this.source.disconnect();
            this.source.stop();
            this.source.onended = () => {
            };
            this.source = void 0;
          }
          if (this.analyzer) {
            this.analyzer.disconnect();
            this.analyzer = void 0;
          }
          if (this.audioContext) {
            try {
              await this.audioContext?.close();
              this.audioContext = void 0;
            } catch {
            }
          }
        }
        getVolume() {
          if (!this.analyzer)
            return 0;
          const bufferLength = this.analyzer.frequencyBinCount;
          if (!bufferLength)
            return 0;
          const dataArray2 = new Uint8Array(bufferLength);
          this.analyzer?.getByteFrequencyData(dataArray2);
          const volume = dataArray2.reduce((sum, val) => sum + val, 0) / dataArray2.length;
          return volume;
        }
        updateExpression(deltaTime) {
          const volume = this.getVolume();
          if (volume < 10) {
            this.lastVowelIndex = 0;
            this.lastDelta = deltaTime;
            this.emit("viseme", neutral);
            return;
          }
          if (deltaTime - this.lastDelta < 70) {
            return;
          }
          let index = this.lastVowelIndex + 1;
          if (index === this.vowels.length) {
            index = 0;
          }
          this.lastDelta = deltaTime;
          this.lastVowelIndex = index;
          this.emit("viseme", { key: this.vowels[this.lastVowelIndex], value: 1 });
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/webavatar.dto.js
  var init_webavatar_dto = __esm({
    "node_modules/@sermas/toolkit/avatar/webavatar.dto.js"() {
    }
  });

  // node_modules/three/build/three.module.js
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d22 = Math.random() * 4294967295 | 0;
    const d32 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d22 & 63 | 128] + _lut[d22 >> 8 & 255] + "-" + _lut[d22 >> 16 & 255] + _lut[d22 >> 24 & 255] + _lut[d32 & 255] + _lut[d32 >> 8 & 255] + _lut[d32 >> 16 & 255] + _lut[d32 >> 24 & 255];
    return uuid.toLowerCase();
  }
  function clamp(value, min, max2) {
    return Math.max(min, Math.min(max2, value));
  }
  function euclideanModulo(n4, m4) {
    return (n4 % m4 + m4) % m4;
  }
  function mapLinear(x4, a1, a22, b1, b22) {
    return b1 + (x4 - a1) * (b22 - b1) / (a22 - a1);
  }
  function inverseLerp(x4, y3, value) {
    if (x4 !== y3) {
      return (value - x4) / (y3 - x4);
    } else {
      return 0;
    }
  }
  function lerp(x4, y3, t4) {
    return (1 - t4) * x4 + t4 * y3;
  }
  function damp(x4, y3, lambda, dt5) {
    return lerp(x4, y3, 1 - Math.exp(-lambda * dt5));
  }
  function pingpong(x4, length3 = 1) {
    return length3 - Math.abs(euclideanModulo(x4, length3 * 2) - length3);
  }
  function smoothstep(x4, min, max2) {
    if (x4 <= min)
      return 0;
    if (x4 >= max2)
      return 1;
    x4 = (x4 - min) / (max2 - min);
    return x4 * x4 * (3 - 2 * x4);
  }
  function smootherstep(x4, min, max2) {
    if (x4 <= min)
      return 0;
    if (x4 >= max2)
      return 1;
    x4 = (x4 - min) / (max2 - min);
    return x4 * x4 * x4 * (x4 * (x4 * 6 - 15) + 10);
  }
  function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  }
  function randFloat(low, high) {
    return low + Math.random() * (high - low);
  }
  function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  }
  function seededRandom(s4) {
    if (s4 !== void 0)
      _seed = s4;
    let t4 = _seed += 1831565813;
    t4 = Math.imul(t4 ^ t4 >>> 15, t4 | 1);
    t4 ^= t4 + Math.imul(t4 ^ t4 >>> 7, t4 | 61);
    return ((t4 ^ t4 >>> 14) >>> 0) / 4294967296;
  }
  function degToRad(degrees) {
    return degrees * DEG2RAD;
  }
  function radToDeg(radians) {
    return radians * RAD2DEG;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  function setQuaternionFromProperEuler(q4, a4, b3, c5, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c22 = cos(b3 / 2);
    const s22 = sin(b3 / 2);
    const c13 = cos((a4 + c5) / 2);
    const s13 = sin((a4 + c5) / 2);
    const c1_3 = cos((a4 - c5) / 2);
    const s1_3 = sin((a4 - c5) / 2);
    const c3_1 = cos((c5 - a4) / 2);
    const s3_1 = sin((c5 - a4) / 2);
    switch (order) {
      case "XYX":
        q4.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
        break;
      case "YZY":
        q4.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
        break;
      case "ZXZ":
        q4.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
        break;
      case "XZX":
        q4.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
        break;
      case "YXY":
        q4.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
        break;
      case "ZYZ":
        q4.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
  function denormalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return value / 4294967295;
      case Uint16Array:
        return value / 65535;
      case Uint8Array:
        return value / 255;
      case Int32Array:
        return Math.max(value / 2147483647, -1);
      case Int16Array:
        return Math.max(value / 32767, -1);
      case Int8Array:
        return Math.max(value / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function normalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return Math.round(value * 4294967295);
      case Uint16Array:
        return Math.round(value * 65535);
      case Uint8Array:
        return Math.round(value * 255);
      case Int32Array:
        return Math.round(value * 2147483647);
      case Int16Array:
        return Math.round(value * 32767);
      case Int8Array:
        return Math.round(value * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function arrayNeedsUint32(array) {
    for (let i5 = array.length - 1; i5 >= 0; --i5) {
      if (array[i5] >= 65535)
        return true;
    }
    return false;
  }
  function createElementNS(name2) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name2);
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function warnOnce(message) {
    if (message in _cache)
      return;
    _cache[message] = true;
    console.warn(message);
  }
  function SRGBToLinear(c5) {
    return c5 < 0.04045 ? c5 * 0.0773993808 : Math.pow(c5 * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c5) {
    return c5 < 31308e-7 ? c5 * 12.92 : 1.055 * Math.pow(c5, 0.41666) - 0.055;
  }
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.from(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  function satForAxes(axes, v0, v1, v22, extents) {
    for (let i5 = 0, j4 = axes.length - 3; i5 <= j4; i5 += 3) {
      _testAxis.fromArray(axes, i5);
      const r4 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p22 = v22.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p22), Math.min(p0, p1, p22)) > r4) {
        return false;
      }
    }
    return true;
  }
  function hue2rgb(p4, q4, t4) {
    if (t4 < 0)
      t4 += 1;
    if (t4 > 1)
      t4 -= 1;
    if (t4 < 1 / 6)
      return p4 + (q4 - p4) * 6 * t4;
    if (t4 < 1 / 2)
      return q4;
    if (t4 < 2 / 3)
      return p4 + (q4 - p4) * 6 * (2 / 3 - t4);
    return p4;
  }
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a4, b3, c5) {
    object.getVertexPosition(a4, _vA$1);
    object.getVertexPosition(b3, _vB$1);
    object.getVertexPosition(c5, _vC$1);
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a4);
        _uvB$1.fromBufferAttribute(uv, b3);
        _uvC$1.fromBufferAttribute(uv, c5);
        intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv1) {
        _uvA$1.fromBufferAttribute(uv1, a4);
        _uvB$1.fromBufferAttribute(uv1, b3);
        _uvC$1.fromBufferAttribute(uv1, c5);
        intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
        intersection.uv2 = intersection.uv1;
      }
      if (normal) {
        _normalA.fromBufferAttribute(normal, a4);
        _normalB.fromBufferAttribute(normal, b3);
        _normalC.fromBufferAttribute(normal, c5);
        intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
        if (intersection.normal.dot(ray.direction) > 0) {
          intersection.normal.multiplyScalar(-1);
        }
      }
      const face = {
        a: a4,
        b: b3,
        c: c5,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  function cloneUniforms(src) {
    const dst = {};
    for (const u4 in src) {
      dst[u4] = {};
      for (const p4 in src[u4]) {
        const property = src[u4][p4];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          if (property.isRenderTargetTexture) {
            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
            dst[u4][p4] = null;
          } else {
            dst[u4][p4] = property.clone();
          }
        } else if (Array.isArray(property)) {
          dst[u4][p4] = property.slice();
        } else {
          dst[u4][p4] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u4 = 0; u4 < uniforms.length; u4++) {
      const tmp = cloneUniforms(uniforms[u4]);
      for (const p4 in tmp) {
        merged[p4] = tmp[p4];
      }
    }
    return merged;
  }
  function cloneUniformsGroups(src) {
    const dst = [];
    for (let u4 = 0; u4 < src.length; u4++) {
      dst.push(src[u4].clone());
    }
    return dst;
  }
  function getUnlitUniformColorSpace(renderer) {
    if (renderer.getRenderTarget() === null) {
      return renderer.outputColorSpace;
    }
    return ColorManagement.workingColorSpace;
  }
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl3, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl3.createBuffer();
      gl3.bindBuffer(bufferType, buffer);
      gl3.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type;
      if (array instanceof Float32Array) {
        type = gl3.FLOAT;
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = gl3.HALF_FLOAT;
          } else {
            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = gl3.UNSIGNED_SHORT;
        }
      } else if (array instanceof Int16Array) {
        type = gl3.SHORT;
      } else if (array instanceof Uint32Array) {
        type = gl3.UNSIGNED_INT;
      } else if (array instanceof Int32Array) {
        type = gl3.INT;
      } else if (array instanceof Int8Array) {
        type = gl3.BYTE;
      } else if (array instanceof Uint8Array) {
        type = gl3.UNSIGNED_BYTE;
      } else if (array instanceof Uint8ClampedArray) {
        type = gl3.UNSIGNED_BYTE;
      } else {
        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl3.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl3.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl3.bufferSubData(
            bufferType,
            updateRange.offset * array.BYTES_PER_ELEMENT,
            array,
            updateRange.offset,
            updateRange.count
          );
        } else {
          gl3.bufferSubData(
            bufferType,
            updateRange.offset * array.BYTES_PER_ELEMENT,
            array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
          );
        }
        updateRange.count = -1;
      }
      attribute.onUploadCallback();
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl3.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update
    };
  }
  function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
      let forceClear = false;
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        const usePMREM = scene.backgroundBlurriness > 0;
        background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
      if (environmentBlendMode === "additive") {
        state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
      } else if (environmentBlendMode === "alpha-blend") {
        state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
      }
      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
              vertexShader: ShaderLib.backgroundCube.vertexShader,
              fragmentShader: ShaderLib.backgroundCube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
        boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        boxMesh.layers.enableAll();
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        planeMesh.layers.enableAll();
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
      state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl3, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl3.getParameter(gl3.MAX_VERTEX_ATTRIBS);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state = getBindingState(geometry, program, material);
        if (currentState !== state) {
          currentState = state;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(object, geometry, program, index);
        if (updateBuffers)
          saveCache(object, geometry, program, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (index !== null) {
        attributes.update(index, gl3.ELEMENT_ARRAY_BUFFER);
      }
      if (updateBuffers || forceUpdate) {
        forceUpdate = false;
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl3.bindBuffer(gl3.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl3.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl3.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl3.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i5 = 0; i5 < maxVertexAttributes; i5++) {
        newAttributes[i5] = 0;
        enabledAttributes[i5] = 0;
        attributeDivisors[i5] = 0;
      }
      return {
        // for backward compatibility on non-VAO support browser
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(object, geometry, program, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name2 in programAttributes) {
        const programAttribute = programAttributes[name2];
        if (programAttribute.location >= 0) {
          const cachedAttribute = cachedAttributes[name2];
          let geometryAttribute = geometryAttributes[name2];
          if (geometryAttribute === void 0) {
            if (name2 === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name2 === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (cachedAttribute === void 0)
            return true;
          if (cachedAttribute.attribute !== geometryAttribute)
            return true;
          if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
            return true;
          attributesNum++;
        }
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(object, geometry, program, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name2 in programAttributes) {
        const programAttribute = programAttributes[name2];
        if (programAttribute.location >= 0) {
          let attribute = attributes2[name2];
          if (attribute === void 0) {
            if (name2 === "instanceMatrix" && object.instanceMatrix)
              attribute = object.instanceMatrix;
            if (name2 === "instanceColor" && object.instanceColor)
              attribute = object.instanceColor;
          }
          const data = {};
          data.attribute = attribute;
          if (attribute && attribute.data) {
            data.data = attribute.data;
          }
          cache[name2] = data;
          attributesNum++;
        }
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i5 = 0, il3 = newAttributes.length; i5 < il3; i5++) {
        newAttributes[i5] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl3.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl3 : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i5 = 0, il3 = enabledAttributes.length; i5 < il3; i5++) {
        if (enabledAttributes[i5] !== newAttributes[i5]) {
          gl3.disableVertexAttribArray(i5);
          enabledAttributes[i5] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
      if (integer === true) {
        gl3.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl3.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name2 in programAttributes) {
        const programAttribute = programAttributes[name2];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name2];
          if (geometryAttribute === void 0) {
            if (name2 === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name2 === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            const integer = capabilities.isWebGL2 === true && (type === gl3.INT || type === gl3.UNSIGNED_INT || geometryAttribute.gpuType === IntType);
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data.isInstancedInterleavedBuffer) {
                for (let i5 = 0; i5 < programAttribute.locationSize; i5++) {
                  enableAttributeAndDivisor(programAttribute.location + i5, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i5 = 0; i5 < programAttribute.locationSize; i5++) {
                  enableAttribute(programAttribute.location + i5);
                }
              }
              gl3.bindBuffer(gl3.ARRAY_BUFFER, buffer);
              for (let i5 = 0; i5 < programAttribute.locationSize; i5++) {
                vertexAttribPointer(
                  programAttribute.location + i5,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  stride * bytesPerElement,
                  (offset + size / programAttribute.locationSize * i5) * bytesPerElement,
                  integer
                );
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i5 = 0; i5 < programAttribute.locationSize; i5++) {
                  enableAttributeAndDivisor(programAttribute.location + i5, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i5 = 0; i5 < programAttribute.locationSize; i5++) {
                  enableAttribute(programAttribute.location + i5);
                }
              }
              gl3.bindBuffer(gl3.ARRAY_BUFFER, buffer);
              for (let i5 = 0; i5 < programAttribute.locationSize; i5++) {
                vertexAttribPointer(
                  programAttribute.location + i5,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  size * bytesPerElement,
                  size / programAttribute.locationSize * i5 * bytesPerElement,
                  integer
                );
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name2];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl3.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl3.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl3.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl3.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      forceUpdate = true;
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl3, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      gl3.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl3;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl3, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl3.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl3.getShaderPrecisionFormat(gl3.VERTEX_SHADER, gl3.HIGH_FLOAT).precision > 0 && gl3.getShaderPrecisionFormat(gl3.FRAGMENT_SHADER, gl3.HIGH_FLOAT).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl3.getShaderPrecisionFormat(gl3.VERTEX_SHADER, gl3.MEDIUM_FLOAT).precision > 0 && gl3.getShaderPrecisionFormat(gl3.FRAGMENT_SHADER, gl3.MEDIUM_FLOAT).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl3.constructor.name === "WebGL2RenderingContext";
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl3.getParameter(gl3.MAX_TEXTURE_IMAGE_UNITS);
    const maxVertexTextures = gl3.getParameter(gl3.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    const maxTextureSize = gl3.getParameter(gl3.MAX_TEXTURE_SIZE);
    const maxCubemapSize = gl3.getParameter(gl3.MAX_CUBE_MAP_TEXTURE_SIZE);
    const maxAttributes = gl3.getParameter(gl3.MAX_VERTEX_ATTRIBS);
    const maxVertexUniforms = gl3.getParameter(gl3.MAX_VERTEX_UNIFORM_VECTORS);
    const maxVaryings = gl3.getParameter(gl3.MAX_VARYING_VECTORS);
    const maxFragmentUniforms = gl3.getParameter(gl3.MAX_FRAGMENT_UNIFORM_VECTORS);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl3.getParameter(gl3.MAX_SAMPLES) : 0;
    return {
      isWebGL2,
      drawBuffers,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping) {
      const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
      // run another frame in order to reset the state:
      numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
    };
    this.setGlobalState = function(planes, camera) {
      globalState = projectPlanes(planes, camera, 0);
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i5 = 0; i5 !== lGlobal; ++i5) {
          dstArray[i5] = globalState[i5];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i5 = 0, i42 = dstOffset; i5 !== nPlanes; ++i5, i42 += 4) {
            plane.copy(planes[i5]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i42);
            dstArray[i42 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function _createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i5 = 0; i5 < totalLods; i5++) {
      const sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i5 > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i5 - lodMax + LOD_MIN - 1];
      } else if (i5 === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      const texelSize = 1 / (sizeLod - 2);
      const min = -texelSize;
      const max2 = 1 + texelSize;
      const uv1 = [min, min, max2, min, max2, max2, min, min, max2, max2, min, max2];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x4 = face % 3 * 2 / 3 - 1;
        const y3 = face > 2 ? 0 : -1;
        const coordinates = [
          x4,
          y3,
          0,
          x4 + 2 / 3,
          y3,
          0,
          x4 + 2 / 3,
          y3 + 1,
          0,
          x4,
          y3,
          0,
          x4 + 2 / 3,
          y3 + 1,
          0,
          x4,
          y3 + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { lodPlanes, sizeLods, sigmas };
  }
  function _createRenderTarget(width, height, params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x4, y3, width, height) {
    target.viewport.set(x4, y3, width, height);
    target.scissor.set(x4, y3, width, height);
  }
  function _getBlurShader(lodMax, width, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: {
        "n": MAX_SAMPLES,
        "CUBEUV_TEXEL_WIDTH": 1 / width,
        "CUBEUV_TEXEL_HEIGHT": 1 / height,
        "CUBEUV_MAX_MIP": `${lodMax}.0`
      },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectMaterial() {
    return new ShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCubemapMaterial() {
    return new ShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCommonVertexShader() {
    return (
      /* glsl */
      `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    );
  }
  function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
            texture.needsPMREMUpdate = false;
            let renderTarget = cubeUVmaps.get(texture);
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (cubeUVmaps.has(texture)) {
              return cubeUVmaps.get(texture).texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length3 = 6;
      for (let i5 = 0; i5 < length3; i5++) {
        if (image[i5] !== void 0)
          count++;
      }
      return count === length3;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl3) {
    const extensions = {};
    function getExtension(name2) {
      if (extensions[name2] !== void 0) {
        return extensions[name2];
      }
      let extension;
      switch (name2) {
        case "WEBGL_depth_texture":
          extension = gl3.getExtension("WEBGL_depth_texture") || gl3.getExtension("MOZ_WEBGL_depth_texture") || gl3.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl3.getExtension("EXT_texture_filter_anisotropic") || gl3.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl3.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl3.getExtension("WEBGL_compressed_texture_s3tc") || gl3.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl3.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl3.getExtension("WEBGL_compressed_texture_pvrtc") || gl3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl3.getExtension(name2);
      }
      extensions[name2] = extension;
      return extension;
    }
    return {
      has: function(name2) {
        return getExtension(name2) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension("EXT_color_buffer_float");
        } else {
          getExtension("WEBGL_depth_texture");
          getExtension("OES_texture_float");
          getExtension("OES_texture_half_float");
          getExtension("OES_texture_half_float_linear");
          getExtension("OES_standard_derivatives");
          getExtension("OES_element_index_uint");
          getExtension("OES_vertex_array_object");
          getExtension("ANGLE_instanced_arrays");
        }
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
        getExtension("WEBGL_multisampled_render_to_texture");
      },
      get: function(name2) {
        const extension = getExtension(name2);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl3, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name2 in geometry.attributes) {
        attributes.remove(geometry.attributes[name2]);
      }
      for (const name2 in geometry.morphAttributes) {
        const array = geometry.morphAttributes[name2];
        for (let i5 = 0, l4 = array.length; i5 < l4; i5++) {
          attributes.remove(array[i5]);
        }
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name2 in geometryAttributes) {
        attributes.update(geometryAttributes[name2], gl3.ARRAY_BUFFER);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name2 in morphAttributes) {
        const array = morphAttributes[name2];
        for (let i5 = 0, l4 = array.length; i5 < l4; i5++) {
          attributes.update(array[i5], gl3.ARRAY_BUFFER);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i5 = 0, l4 = array.length; i5 < l4; i5 += 3) {
          const a4 = array[i5 + 0];
          const b3 = array[i5 + 1];
          const c5 = array[i5 + 2];
          indices.push(a4, b3, b3, c5, c5, a4);
        }
      } else if (geometryPosition !== void 0) {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i5 = 0, l4 = array.length / 3 - 1; i5 < l4; i5 += 3) {
          const a4 = i5 + 0;
          const b3 = i5 + 1;
          const c5 = i5 + 2;
          indices.push(a4, b3, b3, c5, c5, a4);
        }
      } else {
        return;
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl3, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
      gl3.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl3;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl3) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case gl3.TRIANGLES:
          render.triangles += instanceCount * (count / 3);
          break;
        case gl3.LINES:
          render.lines += instanceCount * (count / 2);
          break;
        case gl3.LINE_STRIP:
          render.lines += instanceCount * (count - 1);
          break;
        case gl3.LINE_LOOP:
          render.lines += instanceCount * count;
          break;
        case gl3.POINTS:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function numericalSort(a4, b3) {
    return a4[0] - b3[0];
  }
  function absNumericalSort(a4, b3) {
    return Math.abs(b3[1]) - Math.abs(a4[1]);
  }
  function WebGLMorphtargets(gl3, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector4();
    const workInfluences = [];
    for (let i5 = 0; i5 < 8; i5++) {
      workInfluences[i5] = [i5, 0];
    }
    function update(object, geometry, program) {
      const objectInfluences = object.morphTargetInfluences;
      if (capabilities.isWebGL2 === true) {
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
        let entry = morphTextures.get(geometry);
        if (entry === void 0 || entry.count !== morphTargetsCount) {
          let disposeTexture = function() {
            texture.dispose();
            morphTextures.delete(geometry);
            geometry.removeEventListener("dispose", disposeTexture);
          };
          if (entry !== void 0)
            entry.texture.dispose();
          const hasMorphPosition = geometry.morphAttributes.position !== void 0;
          const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
          const hasMorphColors = geometry.morphAttributes.color !== void 0;
          const morphTargets = geometry.morphAttributes.position || [];
          const morphNormals = geometry.morphAttributes.normal || [];
          const morphColors = geometry.morphAttributes.color || [];
          let vertexDataCount = 0;
          if (hasMorphPosition === true)
            vertexDataCount = 1;
          if (hasMorphNormals === true)
            vertexDataCount = 2;
          if (hasMorphColors === true)
            vertexDataCount = 3;
          let width = geometry.attributes.position.count * vertexDataCount;
          let height = 1;
          if (width > capabilities.maxTextureSize) {
            height = Math.ceil(width / capabilities.maxTextureSize);
            width = capabilities.maxTextureSize;
          }
          const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
          const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
          texture.type = FloatType;
          texture.needsUpdate = true;
          const vertexDataStride = vertexDataCount * 4;
          for (let i5 = 0; i5 < morphTargetsCount; i5++) {
            const morphTarget = morphTargets[i5];
            const morphNormal = morphNormals[i5];
            const morphColor = morphColors[i5];
            const offset = width * height * 4 * i5;
            for (let j4 = 0; j4 < morphTarget.count; j4++) {
              const stride = j4 * vertexDataStride;
              if (hasMorphPosition === true) {
                morph.fromBufferAttribute(morphTarget, j4);
                buffer[offset + stride + 0] = morph.x;
                buffer[offset + stride + 1] = morph.y;
                buffer[offset + stride + 2] = morph.z;
                buffer[offset + stride + 3] = 0;
              }
              if (hasMorphNormals === true) {
                morph.fromBufferAttribute(morphNormal, j4);
                buffer[offset + stride + 4] = morph.x;
                buffer[offset + stride + 5] = morph.y;
                buffer[offset + stride + 6] = morph.z;
                buffer[offset + stride + 7] = 0;
              }
              if (hasMorphColors === true) {
                morph.fromBufferAttribute(morphColor, j4);
                buffer[offset + stride + 8] = morph.x;
                buffer[offset + stride + 9] = morph.y;
                buffer[offset + stride + 10] = morph.z;
                buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
              }
            }
          }
          entry = {
            count: morphTargetsCount,
            texture,
            size: new Vector2(width, height)
          };
          morphTextures.set(geometry, entry);
          geometry.addEventListener("dispose", disposeTexture);
        }
        let morphInfluencesSum = 0;
        for (let i5 = 0; i5 < objectInfluences.length; i5++) {
          morphInfluencesSum += objectInfluences[i5];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl3, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl3, "morphTargetInfluences", objectInfluences);
        program.getUniforms().setValue(gl3, "morphTargetsTexture", entry.texture, textures);
        program.getUniforms().setValue(gl3, "morphTargetsTextureSize", entry.size);
      } else {
        const length3 = objectInfluences === void 0 ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === void 0 || influences.length !== length3) {
          influences = [];
          for (let i5 = 0; i5 < length3; i5++) {
            influences[i5] = [i5, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (let i5 = 0; i5 < length3; i5++) {
          const influence = influences[i5];
          influence[0] = i5;
          influence[1] = objectInfluences[i5];
        }
        influences.sort(absNumericalSort);
        for (let i5 = 0; i5 < 8; i5++) {
          if (i5 < length3 && influences[i5][1]) {
            workInfluences[i5][0] = influences[i5][0];
            workInfluences[i5][1] = influences[i5][1];
          } else {
            workInfluences[i5][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i5][1] = 0;
          }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for (let i5 = 0; i5 < 8; i5++) {
          const influence = workInfluences[i5];
          const index = influence[0];
          const value = influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + i5) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + i5, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + i5) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + i5, morphNormals[index]);
            }
            morphInfluences[i5] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + i5) === true) {
              geometry.deleteAttribute("morphTarget" + i5);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + i5) === true) {
              geometry.deleteAttribute("morphNormal" + i5);
            }
            morphInfluences[i5] = 0;
          }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl3, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl3, "morphTargetInfluences", morphInfluences);
      }
    }
    return {
      update
    };
  }
  function WebGLObjects(gl3, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        if (updateMap.get(object) !== frame) {
          attributes.update(object.instanceMatrix, gl3.ARRAY_BUFFER);
          if (object.instanceColor !== null) {
            attributes.update(object.instanceColor, gl3.ARRAY_BUFFER);
          }
          updateMap.set(object, frame);
        }
      }
      if (object.isSkinnedMesh) {
        const skeleton = object.skeleton;
        if (updateMap.get(skeleton) !== frame) {
          skeleton.update();
          updateMap.set(skeleton, frame);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n4 = nBlocks * blockSize;
    let r4 = arrayCacheF32[n4];
    if (r4 === void 0) {
      r4 = new Float32Array(n4);
      arrayCacheF32[n4] = r4;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r4, 0);
      for (let i5 = 1, offset = 0; i5 !== nBlocks; ++i5) {
        offset += blockSize;
        array[i5].toArray(r4, offset);
      }
    }
    return r4;
  }
  function arraysEqual(a4, b3) {
    if (a4.length !== b3.length)
      return false;
    for (let i5 = 0, l4 = a4.length; i5 < l4; i5++) {
      if (a4[i5] !== b3[i5])
        return false;
    }
    return true;
  }
  function copyArray(a4, b3) {
    for (let i5 = 0, l4 = b3.length; i5 < l4; i5++) {
      a4[i5] = b3[i5];
    }
  }
  function allocTexUnits(textures, n4) {
    let r4 = arrayCacheI32[n4];
    if (r4 === void 0) {
      r4 = new Int32Array(n4);
      arrayCacheI32[n4] = r4;
    }
    for (let i5 = 0; i5 !== n4; ++i5) {
      r4[i5] = textures.allocateTextureUnit();
    }
    return r4;
  }
  function setValueV1f(gl3, v5) {
    const cache = this.cache;
    if (cache[0] === v5)
      return;
    gl3.uniform1f(this.addr, v5);
    cache[0] = v5;
  }
  function setValueV2f(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y) {
        gl3.uniform2f(this.addr, v5.x, v5.y);
        cache[0] = v5.x;
        cache[1] = v5.y;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform2fv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV3f(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y || cache[2] !== v5.z) {
        gl3.uniform3f(this.addr, v5.x, v5.y, v5.z);
        cache[0] = v5.x;
        cache[1] = v5.y;
        cache[2] = v5.z;
      }
    } else if (v5.r !== void 0) {
      if (cache[0] !== v5.r || cache[1] !== v5.g || cache[2] !== v5.b) {
        gl3.uniform3f(this.addr, v5.r, v5.g, v5.b);
        cache[0] = v5.r;
        cache[1] = v5.g;
        cache[2] = v5.b;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform3fv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV4f(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y || cache[2] !== v5.z || cache[3] !== v5.w) {
        gl3.uniform4f(this.addr, v5.x, v5.y, v5.z, v5.w);
        cache[0] = v5.x;
        cache[1] = v5.y;
        cache[2] = v5.z;
        cache[3] = v5.w;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform4fv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueM2(gl3, v5) {
    const cache = this.cache;
    const elements = v5.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniformMatrix2fv(this.addr, false, v5);
      copyArray(cache, v5);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl3.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl3, v5) {
    const cache = this.cache;
    const elements = v5.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniformMatrix3fv(this.addr, false, v5);
      copyArray(cache, v5);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl3.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl3, v5) {
    const cache = this.cache;
    const elements = v5.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniformMatrix4fv(this.addr, false, v5);
      copyArray(cache, v5);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl3.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl3, v5) {
    const cache = this.cache;
    if (cache[0] === v5)
      return;
    gl3.uniform1i(this.addr, v5);
    cache[0] = v5;
  }
  function setValueV2i(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y) {
        gl3.uniform2i(this.addr, v5.x, v5.y);
        cache[0] = v5.x;
        cache[1] = v5.y;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform2iv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV3i(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y || cache[2] !== v5.z) {
        gl3.uniform3i(this.addr, v5.x, v5.y, v5.z);
        cache[0] = v5.x;
        cache[1] = v5.y;
        cache[2] = v5.z;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform3iv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV4i(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y || cache[2] !== v5.z || cache[3] !== v5.w) {
        gl3.uniform4i(this.addr, v5.x, v5.y, v5.z, v5.w);
        cache[0] = v5.x;
        cache[1] = v5.y;
        cache[2] = v5.z;
        cache[3] = v5.w;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform4iv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV1ui(gl3, v5) {
    const cache = this.cache;
    if (cache[0] === v5)
      return;
    gl3.uniform1ui(this.addr, v5);
    cache[0] = v5;
  }
  function setValueV2ui(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y) {
        gl3.uniform2ui(this.addr, v5.x, v5.y);
        cache[0] = v5.x;
        cache[1] = v5.y;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform2uiv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV3ui(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y || cache[2] !== v5.z) {
        gl3.uniform3ui(this.addr, v5.x, v5.y, v5.z);
        cache[0] = v5.x;
        cache[1] = v5.y;
        cache[2] = v5.z;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform3uiv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueV4ui(gl3, v5) {
    const cache = this.cache;
    if (v5.x !== void 0) {
      if (cache[0] !== v5.x || cache[1] !== v5.y || cache[2] !== v5.z || cache[3] !== v5.w) {
        gl3.uniform4ui(this.addr, v5.x, v5.y, v5.z, v5.w);
        cache[0] = v5.x;
        cache[1] = v5.y;
        cache[2] = v5.z;
        cache[3] = v5.w;
      }
    } else {
      if (arraysEqual(cache, v5))
        return;
      gl3.uniform4uiv(this.addr, v5);
      copyArray(cache, v5);
    }
  }
  function setValueT1(gl3, v5, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl3.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2D(v5 || emptyTexture, unit);
  }
  function setValueT3D1(gl3, v5, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl3.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v5 || empty3dTexture, unit);
  }
  function setValueT6(gl3, v5, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl3.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTextureCube(v5 || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl3, v5, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl3.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v5 || emptyArrayTexture, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl3, v5) {
    gl3.uniform1fv(this.addr, v5);
  }
  function setValueV2fArray(gl3, v5) {
    const data = flatten(v5, this.size, 2);
    gl3.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl3, v5) {
    const data = flatten(v5, this.size, 3);
    gl3.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl3, v5) {
    const data = flatten(v5, this.size, 4);
    gl3.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl3, v5) {
    const data = flatten(v5, this.size, 4);
    gl3.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl3, v5) {
    const data = flatten(v5, this.size, 9);
    gl3.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl3, v5) {
    const data = flatten(v5, this.size, 16);
    gl3.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl3, v5) {
    gl3.uniform1iv(this.addr, v5);
  }
  function setValueV2iArray(gl3, v5) {
    gl3.uniform2iv(this.addr, v5);
  }
  function setValueV3iArray(gl3, v5) {
    gl3.uniform3iv(this.addr, v5);
  }
  function setValueV4iArray(gl3, v5) {
    gl3.uniform4iv(this.addr, v5);
  }
  function setValueV1uiArray(gl3, v5) {
    gl3.uniform1uiv(this.addr, v5);
  }
  function setValueV2uiArray(gl3, v5) {
    gl3.uniform2uiv(this.addr, v5);
  }
  function setValueV3uiArray(gl3, v5) {
    gl3.uniform3uiv(this.addr, v5);
  }
  function setValueV4uiArray(gl3, v5) {
    gl3.uniform4uiv(this.addr, v5);
  }
  function setValueT1Array(gl3, v5, textures) {
    const cache = this.cache;
    const n4 = v5.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl3.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i5 = 0; i5 !== n4; ++i5) {
      textures.setTexture2D(v5[i5] || emptyTexture, units[i5]);
    }
  }
  function setValueT3DArray(gl3, v5, textures) {
    const cache = this.cache;
    const n4 = v5.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl3.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i5 = 0; i5 !== n4; ++i5) {
      textures.setTexture3D(v5[i5] || empty3dTexture, units[i5]);
    }
  }
  function setValueT6Array(gl3, v5, textures) {
    const cache = this.cache;
    const n4 = v5.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl3.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i5 = 0; i5 !== n4; ++i5) {
      textures.setTextureCube(v5[i5] || emptyCubeTexture, units[i5]);
    }
  }
  function setValueT2DArrayArray(gl3, v5, textures) {
    const cache = this.cache;
    const n4 = v5.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl3.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i5 = 0; i5 !== n4; ++i5) {
      textures.setTexture2DArray(v5[i5] || emptyArrayTexture, units[i5]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3DArray;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id2 = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id2 = id2 | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id2];
        if (next === void 0) {
          next = new StructuredUniform(id2);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLShader(gl3, type, string) {
    const shader = gl3.createShader(type);
    gl3.shaderSource(shader, string);
    gl3.compileShader(shader);
    return shader;
  }
  function handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to4 = Math.min(errorLine + 6, lines.length);
    for (let i5 = from; i5 < to4; i5++) {
      const line = i5 + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i5]}`);
    }
    return lines2.join("\n");
  }
  function getEncodingComponents(colorSpace) {
    const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
    const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
    let gamutMapping;
    if (workingPrimaries === encodingPrimaries) {
      gamutMapping = "";
    } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
      gamutMapping = "LinearDisplayP3ToLinearSRGB";
    } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
      gamutMapping = "LinearSRGBToLinearDisplayP3";
    }
    switch (colorSpace) {
      case LinearSRGBColorSpace:
      case LinearDisplayP3ColorSpace:
        return [gamutMapping, "LinearTransferOETF"];
      case SRGBColorSpace:
      case DisplayP3ColorSpace:
        return [gamutMapping, "sRGBTransferOETF"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
        return [gamutMapping, "LinearTransferOETF"];
    }
  }
  function getShaderErrors(gl3, shader, type) {
    const status = gl3.getShaderParameter(shader, gl3.COMPILE_STATUS);
    const errors = gl3.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl3.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  function getTexelEncodingFunction(functionName, colorSpace) {
    const components = getEncodingComponents(colorSpace);
    return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name2 in defines) {
      const value = defines[name2];
      if (value === false)
        continue;
      chunks.push("#define " + name2 + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl3, program) {
    const attributes = {};
    const n4 = gl3.getProgramParameter(program, gl3.ACTIVE_ATTRIBUTES);
    for (let i5 = 0; i5 < n4; i5++) {
      const info = gl3.getActiveAttrib(program, i5);
      const name2 = info.name;
      let locationSize = 1;
      if (info.type === gl3.FLOAT_MAT2)
        locationSize = 2;
      if (info.type === gl3.FLOAT_MAT3)
        locationSize = 3;
      if (info.type === gl3.FLOAT_MAT4)
        locationSize = 4;
      attributes[name2] = {
        type: info.type,
        location: gl3.getAttribLocation(program, name2),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    let string = ShaderChunk[include];
    if (string === void 0) {
      const newInclude = shaderChunkMap.get(include);
      if (newInclude !== void 0) {
        string = ShaderChunk[newInclude];
        console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
      } else {
        throw new Error("Can not resolve #include <" + include + ">");
      }
    }
    return resolveIncludes(string);
  }
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i5 = parseInt(start); i5 < parseInt(end); i5++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i5 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i5);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null)
      return null;
    const maxMip = Math.log2(imageHeight) - 2;
    const texelHeight = 1 / imageHeight;
    const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl3 = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = generateCubeUVSize(parameters);
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl3.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
        parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        //
        parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
        parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
        parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
        parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
        parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
        parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
        parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
        parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
        parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
        parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
        parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
        parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
        parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
        parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
        parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
        parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
        parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
        parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
        parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
        parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
        parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
        parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
        parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
        //
        parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUv1s ? "#define USE_UV1" : "",
        parameters.vertexUv2s ? "#define USE_UV2" : "",
        parameters.vertexUv3s ? "#define USE_UV3" : "",
        parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
        envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
        parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUv1s ? "#define USE_UV1" : "",
        parameters.vertexUv2s ? "#define USE_UV2" : "",
        parameters.vertexUv3s ? "#define USE_UV3" : "",
        parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        // this code is required here because it is used by the toneMapping() function defined below
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.opaque ? "#define OPAQUE" : "",
        ShaderChunk["colorspace_pars_fragment"],
        // this code is required here because it is used by the various encoding/decoding function defined below
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
        parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "precision mediump sampler2DArray;",
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl3, gl3.VERTEX_SHADER, vertexGlsl);
    const glFragmentShader = WebGLShader(gl3, gl3.FRAGMENT_SHADER, fragmentGlsl);
    gl3.attachShader(program, glVertexShader);
    gl3.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl3.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl3.bindAttribLocation(program, 0, "position");
    }
    gl3.linkProgram(program);
    function onFirstUse(self2) {
      if (renderer.debug.checkShaderErrors) {
        const programLog = gl3.getProgramInfoLog(program).trim();
        const vertexLog = gl3.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl3.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl3.getProgramParameter(program, gl3.LINK_STATUS) === false) {
          runnable = false;
          if (typeof renderer.debug.onShaderError === "function") {
            renderer.debug.onShaderError(gl3, program, glVertexShader, glFragmentShader);
          } else {
            const vertexErrors = getShaderErrors(gl3, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl3, glFragmentShader, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " + gl3.getError() + " - VALIDATE_STATUS " + gl3.getProgramParameter(program, gl3.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
            );
          }
        } else if (programLog !== "") {
          console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          self2.diagnostics = {
            runnable,
            programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
      }
      gl3.deleteShader(glVertexShader);
      gl3.deleteShader(glFragmentShader);
      cachedUniforms = new WebGLUniforms(gl3, program);
      cachedAttributes = fetchAttributeLocations(gl3, program);
    }
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        onFirstUse(this);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        onFirstUse(this);
      }
      return cachedAttributes;
    };
    let programReady = parameters.rendererExtensionParallelShaderCompile === false;
    this.isReady = function() {
      if (programReady === false) {
        programReady = gl3.getProgramParameter(program, COMPLETION_STATUS_KHR);
      }
      return programReady;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl3.deleteProgram(program);
      this.program = void 0;
    };
    this.type = parameters.shaderType;
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const programs = [];
    const IS_WEBGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getChannel(value) {
      if (value === 0)
        return "uv";
      return `uv${value}`;
    }
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const geometry = object.geometry;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
      const shaderID = shaderIDs[material.type];
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let morphTextureStride = 0;
      if (geometry.morphAttributes.position !== void 0)
        morphTextureStride = 1;
      if (geometry.morphAttributes.normal !== void 0)
        morphTextureStride = 2;
      if (geometry.morphAttributes.color !== void 0)
        morphTextureStride = 3;
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const IS_INSTANCEDMESH = object.isInstancedMesh === true;
      const HAS_MAP = !!material.map;
      const HAS_MATCAP = !!material.matcap;
      const HAS_ENVMAP = !!envMap;
      const HAS_AOMAP = !!material.aoMap;
      const HAS_LIGHTMAP = !!material.lightMap;
      const HAS_BUMPMAP = !!material.bumpMap;
      const HAS_NORMALMAP = !!material.normalMap;
      const HAS_DISPLACEMENTMAP = !!material.displacementMap;
      const HAS_EMISSIVEMAP = !!material.emissiveMap;
      const HAS_METALNESSMAP = !!material.metalnessMap;
      const HAS_ROUGHNESSMAP = !!material.roughnessMap;
      const HAS_ANISOTROPY = material.anisotropy > 0;
      const HAS_CLEARCOAT = material.clearcoat > 0;
      const HAS_IRIDESCENCE = material.iridescence > 0;
      const HAS_SHEEN = material.sheen > 0;
      const HAS_TRANSMISSION = material.transmission > 0;
      const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
      const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
      const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
      const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
      const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
      const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
      const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
      const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
      const HAS_SPECULARMAP = !!material.specularMap;
      const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
      const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
      const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
      const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
      const HAS_GRADIENTMAP = !!material.gradientMap;
      const HAS_ALPHAMAP = !!material.alphaMap;
      const HAS_ALPHATEST = material.alphaTest > 0;
      const HAS_ALPHAHASH = !!material.alphaHash;
      const HAS_EXTENSIONS = !!material.extensions;
      const HAS_ATTRIBUTE_UV1 = !!geometry.attributes.uv1;
      const HAS_ATTRIBUTE_UV2 = !!geometry.attributes.uv2;
      const HAS_ATTRIBUTE_UV3 = !!geometry.attributes.uv3;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = renderer.toneMapping;
        }
      }
      const parameters = {
        isWebGL2: IS_WEBGL2,
        shaderID,
        shaderType: material.type,
        shaderName: material.name,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: IS_INSTANCEDMESH,
        instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
        supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
        outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
        map: HAS_MAP,
        matcap: HAS_MATCAP,
        envMap: HAS_ENVMAP,
        envMapMode: HAS_ENVMAP && envMap.mapping,
        envMapCubeUVHeight,
        aoMap: HAS_AOMAP,
        lightMap: HAS_LIGHTMAP,
        bumpMap: HAS_BUMPMAP,
        normalMap: HAS_NORMALMAP,
        displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
        emissiveMap: HAS_EMISSIVEMAP,
        normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
        normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
        metalnessMap: HAS_METALNESSMAP,
        roughnessMap: HAS_ROUGHNESSMAP,
        anisotropy: HAS_ANISOTROPY,
        anisotropyMap: HAS_ANISOTROPYMAP,
        clearcoat: HAS_CLEARCOAT,
        clearcoatMap: HAS_CLEARCOATMAP,
        clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
        clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
        iridescence: HAS_IRIDESCENCE,
        iridescenceMap: HAS_IRIDESCENCEMAP,
        iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
        sheen: HAS_SHEEN,
        sheenColorMap: HAS_SHEEN_COLORMAP,
        sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
        specularMap: HAS_SPECULARMAP,
        specularColorMap: HAS_SPECULAR_COLORMAP,
        specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
        transmission: HAS_TRANSMISSION,
        transmissionMap: HAS_TRANSMISSIONMAP,
        thicknessMap: HAS_THICKNESSMAP,
        gradientMap: HAS_GRADIENTMAP,
        opaque: material.transparent === false && material.blending === NormalBlending,
        alphaMap: HAS_ALPHAMAP,
        alphaTest: HAS_ALPHATEST,
        alphaHash: HAS_ALPHAHASH,
        combine: material.combine,
        //
        mapUv: HAS_MAP && getChannel(material.map.channel),
        aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
        lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
        bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
        normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
        displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
        emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
        metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
        roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
        anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
        clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
        clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
        iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
        iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
        sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
        sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
        specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
        specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
        specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
        transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
        thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
        alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
        //
        vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
        vertexUv1s: HAS_ATTRIBUTE_UV1,
        vertexUv2s: HAS_ATTRIBUTE_UV2,
        vertexUv3s: HAS_ATTRIBUTE_UV3,
        pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
        fog: !!fog,
        useFog: material.fog === true,
        fogExp2: fog && fog.isFogExp2,
        flatShading: material.flatShading === true,
        sizeAttenuation: material.sizeAttenuation === true,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true,
        morphTargets: geometry.morphAttributes.position !== void 0,
        morphNormals: geometry.morphAttributes.normal !== void 0,
        morphColors: geometry.morphAttributes.color !== void 0,
        morphTargetsCount,
        morphTextureStride,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numSpotLightMaps: lights.spotLightMap.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
        numLightProbes: lights.numLightProbes,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping,
        useLegacyLights: renderer._useLegacyLights,
        decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        useDepthPacking: material.depthPacking >= 0,
        depthPacking: material.depthPacking || 0,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
        extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
        extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
        extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,
        rendererExtensionFragDepth: IS_WEBGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name2 in parameters.defines) {
          array.push(name2);
          array.push(parameters.defines[name2]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer.outputColorSpace);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputColorSpace);
      array.push(parameters.envMapMode);
      array.push(parameters.envMapCubeUVHeight);
      array.push(parameters.mapUv);
      array.push(parameters.alphaMapUv);
      array.push(parameters.lightMapUv);
      array.push(parameters.aoMapUv);
      array.push(parameters.bumpMapUv);
      array.push(parameters.normalMapUv);
      array.push(parameters.displacementMapUv);
      array.push(parameters.emissiveMapUv);
      array.push(parameters.metalnessMapUv);
      array.push(parameters.roughnessMapUv);
      array.push(parameters.anisotropyMapUv);
      array.push(parameters.clearcoatMapUv);
      array.push(parameters.clearcoatNormalMapUv);
      array.push(parameters.clearcoatRoughnessMapUv);
      array.push(parameters.iridescenceMapUv);
      array.push(parameters.iridescenceThicknessMapUv);
      array.push(parameters.sheenColorMapUv);
      array.push(parameters.sheenRoughnessMapUv);
      array.push(parameters.specularMapUv);
      array.push(parameters.specularColorMapUv);
      array.push(parameters.specularIntensityMapUv);
      array.push(parameters.transmissionMapUv);
      array.push(parameters.thicknessMapUv);
      array.push(parameters.combine);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.morphAttributeCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numSpotLightMaps);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.numSpotLightShadowsWithMaps);
      array.push(parameters.numLightProbes);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
      array.push(parameters.depthPacking);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.isWebGL2)
        _programLayers.enable(0);
      if (parameters.supportsVertexTextures)
        _programLayers.enable(1);
      if (parameters.instancing)
        _programLayers.enable(2);
      if (parameters.instancingColor)
        _programLayers.enable(3);
      if (parameters.matcap)
        _programLayers.enable(4);
      if (parameters.envMap)
        _programLayers.enable(5);
      if (parameters.normalMapObjectSpace)
        _programLayers.enable(6);
      if (parameters.normalMapTangentSpace)
        _programLayers.enable(7);
      if (parameters.clearcoat)
        _programLayers.enable(8);
      if (parameters.iridescence)
        _programLayers.enable(9);
      if (parameters.alphaTest)
        _programLayers.enable(10);
      if (parameters.vertexColors)
        _programLayers.enable(11);
      if (parameters.vertexAlphas)
        _programLayers.enable(12);
      if (parameters.vertexUv1s)
        _programLayers.enable(13);
      if (parameters.vertexUv2s)
        _programLayers.enable(14);
      if (parameters.vertexUv3s)
        _programLayers.enable(15);
      if (parameters.vertexTangents)
        _programLayers.enable(16);
      if (parameters.anisotropy)
        _programLayers.enable(17);
      if (parameters.alphaHash)
        _programLayers.enable(18);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.fog)
        _programLayers.enable(0);
      if (parameters.useFog)
        _programLayers.enable(1);
      if (parameters.flatShading)
        _programLayers.enable(2);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(3);
      if (parameters.skinning)
        _programLayers.enable(4);
      if (parameters.morphTargets)
        _programLayers.enable(5);
      if (parameters.morphNormals)
        _programLayers.enable(6);
      if (parameters.morphColors)
        _programLayers.enable(7);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(8);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(9);
      if (parameters.useLegacyLights)
        _programLayers.enable(10);
      if (parameters.doubleSided)
        _programLayers.enable(11);
      if (parameters.flipSided)
        _programLayers.enable(12);
      if (parameters.useDepthPacking)
        _programLayers.enable(13);
      if (parameters.dithering)
        _programLayers.enable(14);
      if (parameters.transmission)
        _programLayers.enable(15);
      if (parameters.sheen)
        _programLayers.enable(16);
      if (parameters.opaque)
        _programLayers.enable(17);
      if (parameters.pointsUvs)
        _programLayers.enable(18);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(19);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p4 = 0, pl2 = programs.length; p4 < pl2; p4++) {
        const preexistingProgram = programs[p4];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i5 = programs.indexOf(program);
        programs[i5] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      // Exposed for resource monitoring & error feedback via renderer.info:
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove,
      update,
      dispose
    };
  }
  function painterSortStable(a4, b3) {
    if (a4.groupOrder !== b3.groupOrder) {
      return a4.groupOrder - b3.groupOrder;
    } else if (a4.renderOrder !== b3.renderOrder) {
      return a4.renderOrder - b3.renderOrder;
    } else if (a4.material.id !== b3.material.id) {
      return a4.material.id - b3.material.id;
    } else if (a4.z !== b3.z) {
      return a4.z - b3.z;
    } else {
      return a4.id - b3.id;
    }
  }
  function reversePainterSortStable(a4, b3) {
    if (a4.groupOrder !== b3.groupOrder) {
      return a4.groupOrder - b3.groupOrder;
    } else if (a4.renderOrder !== b3.renderOrder) {
      return a4.renderOrder - b3.renderOrder;
    } else if (a4.z !== b3.z) {
      return b3.z - a4.z;
    } else {
      return a4.id - b3.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z4, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z: z4,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z4;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z4, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z4, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z4, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z4, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i5 = renderItemsIndex, il3 = renderItems.length; i5 < il3; i5++) {
        const renderItem = renderItems[i5];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      const listArray = lists.get(scene);
      let list;
      if (listArray === void 0) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= listArray.length) {
          list = new WebGLRenderList();
          listArray.push(list);
        } else {
          list = listArray[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
    for (let i5 = 0; i5 < 9; i5++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, useLegacyLights) {
      let r4 = 0, g4 = 0, b3 = 0;
      for (let i5 = 0; i5 < 9; i5++)
        state.probe[i5].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      let numSpotMaps = 0;
      let numSpotShadowsWithMaps = 0;
      let numLightProbes = 0;
      lights.sort(shadowCastingAndTexturingLightsFirst);
      const scaleFactor = useLegacyLights === true ? Math.PI : 1;
      for (let i5 = 0, l4 = lights.length; i5 < l4; i5++) {
        const light = lights[i5];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r4 += color.r * intensity * scaleFactor;
          g4 += color.g * intensity * scaleFactor;
          b3 += color.b * intensity * scaleFactor;
        } else if (light.isLightProbe) {
          for (let j4 = 0; j4 < 9; j4++) {
            state.probe[j4].addScaledVector(light.sh.coefficients[j4], intensity);
          }
          numLightProbes++;
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          state.spot[spotLength] = uniforms;
          const shadow = light.shadow;
          if (light.map) {
            state.spotLightMap[numSpotMaps] = light.map;
            numSpotMaps++;
            shadow.updateMatrices(light);
            if (light.castShadow)
              numSpotShadowsWithMaps++;
          }
          state.spotLightMatrix[spotLength] = shadow.matrix;
          if (light.castShadow) {
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            numSpotShadows++;
          }
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state.ambient[0] = r4;
      state.ambient[1] = g4;
      state.ambient[2] = b3;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
        state.spotLightMap.length = numSpotMaps;
        state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
        state.numLightProbes = numLightProbes;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        hash.numSpotMaps = numSpotMaps;
        hash.numLightProbes = numLightProbes;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i5 = 0, l4 = lights.length; i5 < l4; i5++) {
        const light = lights[i5];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(useLegacyLights) {
      lights.setup(lightsArray, useLegacyLights);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      const renderStateArray = renderStates.get(scene);
      let renderState;
      if (renderStateArray === void 0) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStateArray.length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStateArray.push(renderState);
        } else {
          renderState = renderStateArray[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute(
      "position",
      new BufferAttribute(
        new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
        3
      )
    );
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    let _previousType = this.type;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
      const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
      for (let i5 = 0, il3 = lights.length; i5 < il3; i5++) {
        const light = lights[i5];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null || toVSM === true || fromVSM === true) {
          const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
          if (shadow.map !== null) {
            shadow.map.dispose();
          }
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp2 = 0; vp2 < viewportCount; vp2++) {
          const viewport = shadow.getViewport(vp2);
          _viewport.set(
            _viewportSize.x * viewport.x,
            _viewportSize.y * viewport.y,
            _viewportSize.x * viewport.z,
            _viewportSize.y * viewport.w
          );
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp2);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      _previousType = this.type;
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = _objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      if (shadow.mapPass === null) {
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, type) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
          const keyA = result.uuid, keyB = material.uuid;
          let materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          let cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
          }
          result = cachedMaterial;
        }
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.map = material.map;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        const materialProperties = _renderer.properties.get(result);
        materialProperties.light = light;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k4 = 0, kl3 = groups.length; k4 < kl3; k4++) {
              const group = groups[k4];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, material, light, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
        renderObject(children[i5], camera, shadowCamera, light, type);
      }
    }
  }
  function WebGLState(gl3, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl3.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r4, g4, b3, a4, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r4 *= a4;
            g4 *= a4;
            b3 *= a4;
          }
          color.set(r4, g4, b3, a4);
          if (currentColorClear.equals(color) === false) {
            gl3.clearColor(r4, g4, b3, a4);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(gl3.DEPTH_TEST);
          } else {
            disable(gl3.DEPTH_TEST);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl3.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl3.depthFunc(gl3.NEVER);
                break;
              case AlwaysDepth:
                gl3.depthFunc(gl3.ALWAYS);
                break;
              case LessDepth:
                gl3.depthFunc(gl3.LESS);
                break;
              case LessEqualDepth:
                gl3.depthFunc(gl3.LEQUAL);
                break;
              case EqualDepth:
                gl3.depthFunc(gl3.EQUAL);
                break;
              case GreaterEqualDepth:
                gl3.depthFunc(gl3.GEQUAL);
                break;
              case GreaterDepth:
                gl3.depthFunc(gl3.GREATER);
                break;
              case NotEqualDepth:
                gl3.depthFunc(gl3.NOTEQUAL);
                break;
              default:
                gl3.depthFunc(gl3.LEQUAL);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl3.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(gl3.STENCIL_TEST);
            } else {
              disable(gl3.STENCIL_TEST);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl3.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl3.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl3.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl3.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    const uboBindings = /* @__PURE__ */ new WeakMap();
    const uboProgramMap = /* @__PURE__ */ new WeakMap();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentBlendColor = new Color(0, 0, 0);
    let currentBlendAlpha = 0;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl3.getParameter(gl3.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl3.getParameter(gl3.VERSION);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl3.getParameter(gl3.SCISSOR_BOX);
    const viewportParam = gl3.getParameter(gl3.VIEWPORT);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count, dimensions) {
      const data = new Uint8Array(4);
      const texture = gl3.createTexture();
      gl3.bindTexture(type, texture);
      gl3.texParameteri(type, gl3.TEXTURE_MIN_FILTER, gl3.NEAREST);
      gl3.texParameteri(type, gl3.TEXTURE_MAG_FILTER, gl3.NEAREST);
      for (let i5 = 0; i5 < count; i5++) {
        if (isWebGL2 && (type === gl3.TEXTURE_3D || type === gl3.TEXTURE_2D_ARRAY)) {
          gl3.texImage3D(target, 0, gl3.RGBA, 1, 1, dimensions, 0, gl3.RGBA, gl3.UNSIGNED_BYTE, data);
        } else {
          gl3.texImage2D(target + i5, 0, gl3.RGBA, 1, 1, 0, gl3.RGBA, gl3.UNSIGNED_BYTE, data);
        }
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[gl3.TEXTURE_2D] = createTexture(gl3.TEXTURE_2D, gl3.TEXTURE_2D, 1);
    emptyTextures[gl3.TEXTURE_CUBE_MAP] = createTexture(gl3.TEXTURE_CUBE_MAP, gl3.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    if (isWebGL2) {
      emptyTextures[gl3.TEXTURE_2D_ARRAY] = createTexture(gl3.TEXTURE_2D_ARRAY, gl3.TEXTURE_2D_ARRAY, 1, 1);
      emptyTextures[gl3.TEXTURE_3D] = createTexture(gl3.TEXTURE_3D, gl3.TEXTURE_3D, 1, 1);
    }
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl3.DEPTH_TEST);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl3.CULL_FACE);
    setBlending(NoBlending);
    function enable(id2) {
      if (enabledCapabilities[id2] !== true) {
        gl3.enable(id2);
        enabledCapabilities[id2] = true;
      }
    }
    function disable(id2) {
      if (enabledCapabilities[id2] !== false) {
        gl3.disable(id2);
        enabledCapabilities[id2] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl3.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (isWebGL2) {
          if (target === gl3.DRAW_FRAMEBUFFER) {
            currentBoundFramebuffers[gl3.FRAMEBUFFER] = framebuffer;
          }
          if (target === gl3.FRAMEBUFFER) {
            currentBoundFramebuffers[gl3.DRAW_FRAMEBUFFER] = framebuffer;
          }
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures = renderTarget.texture;
          if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl3.COLOR_ATTACHMENT0) {
            for (let i5 = 0, il3 = textures.length; i5 < il3; i5++) {
              drawBuffers2[i5] = gl3.COLOR_ATTACHMENT0 + i5;
            }
            drawBuffers2.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (drawBuffers2[0] !== gl3.COLOR_ATTACHMENT0) {
            drawBuffers2[0] = gl3.COLOR_ATTACHMENT0;
            needsUpdate = true;
          }
        }
      } else {
        if (drawBuffers2[0] !== gl3.BACK) {
          drawBuffers2[0] = gl3.BACK;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          gl3.drawBuffers(drawBuffers2);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
        }
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl3.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: gl3.FUNC_ADD,
      [SubtractEquation]: gl3.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl3.FUNC_REVERSE_SUBTRACT
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = gl3.MIN;
      equationToGL[MaxEquation] = gl3.MAX;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: gl3.ZERO,
      [OneFactor]: gl3.ONE,
      [SrcColorFactor]: gl3.SRC_COLOR,
      [SrcAlphaFactor]: gl3.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl3.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl3.DST_COLOR,
      [DstAlphaFactor]: gl3.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl3.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl3.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl3.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl3.ONE_MINUS_DST_ALPHA,
      [ConstantColorFactor]: gl3.CONSTANT_COLOR,
      [OneMinusConstantColorFactor]: gl3.ONE_MINUS_CONSTANT_COLOR,
      [ConstantAlphaFactor]: gl3.CONSTANT_ALPHA,
      [OneMinusConstantAlphaFactor]: gl3.ONE_MINUS_CONSTANT_ALPHA
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(gl3.BLEND);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(gl3.BLEND);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl3.blendEquation(gl3.FUNC_ADD);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl3.blendFuncSeparate(gl3.ONE, gl3.ONE_MINUS_SRC_ALPHA, gl3.ONE, gl3.ONE_MINUS_SRC_ALPHA);
                break;
              case AdditiveBlending:
                gl3.blendFunc(gl3.ONE, gl3.ONE);
                break;
              case SubtractiveBlending:
                gl3.blendFuncSeparate(gl3.ZERO, gl3.ONE_MINUS_SRC_COLOR, gl3.ZERO, gl3.ONE);
                break;
              case MultiplyBlending:
                gl3.blendFuncSeparate(gl3.ZERO, gl3.SRC_COLOR, gl3.ZERO, gl3.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl3.blendFuncSeparate(gl3.SRC_ALPHA, gl3.ONE_MINUS_SRC_ALPHA, gl3.ONE, gl3.ONE_MINUS_SRC_ALPHA);
                break;
              case AdditiveBlending:
                gl3.blendFunc(gl3.SRC_ALPHA, gl3.ONE);
                break;
              case SubtractiveBlending:
                gl3.blendFuncSeparate(gl3.ZERO, gl3.ONE_MINUS_SRC_COLOR, gl3.ZERO, gl3.ONE);
                break;
              case MultiplyBlending:
                gl3.blendFunc(gl3.ZERO, gl3.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlendColor.set(0, 0, 0);
          currentBlendAlpha = 0;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl3.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl3.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
        gl3.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
        currentBlendColor.copy(blendColor);
        currentBlendAlpha = blendAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = false;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(gl3.CULL_FACE) : enable(gl3.CULL_FACE);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(gl3.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl3.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl3.frontFace(gl3.CW);
        } else {
          gl3.frontFace(gl3.CCW);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(gl3.CULL_FACE);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl3.cullFace(gl3.BACK);
          } else if (cullFace === CullFaceFront) {
            gl3.cullFace(gl3.FRONT);
          } else {
            gl3.cullFace(gl3.FRONT_AND_BACK);
          }
        }
      } else {
        disable(gl3.CULL_FACE);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable)
          gl3.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(gl3.POLYGON_OFFSET_FILL);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl3.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(gl3.POLYGON_OFFSET_FILL);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(gl3.SCISSOR_TEST);
      } else {
        disable(gl3.SCISSOR_TEST);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = gl3.TEXTURE0 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl3.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture, webglSlot) {
      if (webglSlot === void 0) {
        if (currentTextureSlot === null) {
          webglSlot = gl3.TEXTURE0 + maxTextures - 1;
        } else {
          webglSlot = currentTextureSlot;
        }
      }
      let boundTexture = currentBoundTextures[webglSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[webglSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        if (currentTextureSlot !== webglSlot) {
          gl3.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
        gl3.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl3.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl3.compressedTexImage2D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexImage3D() {
      try {
        gl3.compressedTexImage3D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage2D() {
      try {
        gl3.texSubImage2D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage3D() {
      try {
        gl3.texSubImage3D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl3.compressedTexSubImage2D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage3D() {
      try {
        gl3.compressedTexSubImage3D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage2D() {
      try {
        gl3.texStorage2D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage3D() {
      try {
        gl3.texStorage3D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl3.texImage2D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl3.texImage3D.apply(gl3, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl3.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl3.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function updateUBOMapping(uniformsGroup, program) {
      let mapping = uboProgramMap.get(program);
      if (mapping === void 0) {
        mapping = /* @__PURE__ */ new WeakMap();
        uboProgramMap.set(program, mapping);
      }
      let blockIndex = mapping.get(uniformsGroup);
      if (blockIndex === void 0) {
        blockIndex = gl3.getUniformBlockIndex(program, uniformsGroup.name);
        mapping.set(uniformsGroup, blockIndex);
      }
    }
    function uniformBlockBinding(uniformsGroup, program) {
      const mapping = uboProgramMap.get(program);
      const blockIndex = mapping.get(uniformsGroup);
      if (uboBindings.get(program) !== blockIndex) {
        gl3.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
        uboBindings.set(program, blockIndex);
      }
    }
    function reset() {
      gl3.disable(gl3.BLEND);
      gl3.disable(gl3.CULL_FACE);
      gl3.disable(gl3.DEPTH_TEST);
      gl3.disable(gl3.POLYGON_OFFSET_FILL);
      gl3.disable(gl3.SCISSOR_TEST);
      gl3.disable(gl3.STENCIL_TEST);
      gl3.disable(gl3.SAMPLE_ALPHA_TO_COVERAGE);
      gl3.blendEquation(gl3.FUNC_ADD);
      gl3.blendFunc(gl3.ONE, gl3.ZERO);
      gl3.blendFuncSeparate(gl3.ONE, gl3.ZERO, gl3.ONE, gl3.ZERO);
      gl3.blendColor(0, 0, 0, 0);
      gl3.colorMask(true, true, true, true);
      gl3.clearColor(0, 0, 0, 0);
      gl3.depthMask(true);
      gl3.depthFunc(gl3.LESS);
      gl3.clearDepth(1);
      gl3.stencilMask(4294967295);
      gl3.stencilFunc(gl3.ALWAYS, 0, 4294967295);
      gl3.stencilOp(gl3.KEEP, gl3.KEEP, gl3.KEEP);
      gl3.clearStencil(0);
      gl3.cullFace(gl3.BACK);
      gl3.frontFace(gl3.CCW);
      gl3.polygonOffset(0, 0);
      gl3.activeTexture(gl3.TEXTURE0);
      gl3.bindFramebuffer(gl3.FRAMEBUFFER, null);
      if (isWebGL2 === true) {
        gl3.bindFramebuffer(gl3.DRAW_FRAMEBUFFER, null);
        gl3.bindFramebuffer(gl3.READ_FRAMEBUFFER, null);
      }
      gl3.useProgram(null);
      gl3.lineWidth(1);
      gl3.scissor(0, 0, gl3.canvas.width, gl3.canvas.height);
      gl3.viewport(0, 0, gl3.canvas.width, gl3.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentBlendColor = new Color(0, 0, 0);
      currentBlendAlpha = 0;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl3.canvas.width, gl3.canvas.height);
      currentViewport.set(0, 0, gl3.canvas.width, gl3.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      compressedTexImage3D,
      texImage2D,
      texImage3D,
      updateUBOMapping,
      uniformBlockBinding,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      compressedTexSubImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    const _sources = /* @__PURE__ */ new WeakMap();
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? (
        // eslint-disable-next-line compat/compat
        new OffscreenCanvas(width, height)
      ) : createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale4 = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale4 = maxSize / Math.max(image.width, image.height);
      }
      if (scale4 < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
          const width = floor(scale4 * image.width);
          const height = floor(scale4 * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width, height);
          const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo$1(image) {
      return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === _gl.RED) {
        if (glType === _gl.FLOAT)
          internalFormat = _gl.R32F;
        if (glType === _gl.HALF_FLOAT)
          internalFormat = _gl.R16F;
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.R8;
      }
      if (glFormat === _gl.RED_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.R8UI;
        if (glType === _gl.UNSIGNED_SHORT)
          internalFormat = _gl.R16UI;
        if (glType === _gl.UNSIGNED_INT)
          internalFormat = _gl.R32UI;
        if (glType === _gl.BYTE)
          internalFormat = _gl.R8I;
        if (glType === _gl.SHORT)
          internalFormat = _gl.R16I;
        if (glType === _gl.INT)
          internalFormat = _gl.R32I;
      }
      if (glFormat === _gl.RG) {
        if (glType === _gl.FLOAT)
          internalFormat = _gl.RG32F;
        if (glType === _gl.HALF_FLOAT)
          internalFormat = _gl.RG16F;
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = _gl.RG8;
      }
      if (glFormat === _gl.RGBA) {
        const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
        if (glType === _gl.FLOAT)
          internalFormat = _gl.RGBA32F;
        if (glType === _gl.HALF_FLOAT)
          internalFormat = _gl.RGBA16F;
        if (glType === _gl.UNSIGNED_BYTE)
          internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
        if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
          internalFormat = _gl.RGBA4;
        if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
          internalFormat = _gl.RGB5_A1;
      }
      if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getMipLevels(texture, image, supportsMips) {
      if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image.width, image.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image.mipmaps.length;
      } else {
        return 1;
      }
    }
    function filterFallback(f3) {
      if (f3 === NearestFilter || f3 === NearestMipmapNearestFilter || f3 === NearestMipmapLinearFilter) {
        return _gl.NEAREST;
      }
      return _gl.LINEAR;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      const source = texture.source;
      const webglTextures = _sources.get(source);
      if (webglTextures) {
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        webglTexture.usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
        if (Object.keys(webglTextures).length === 0) {
          _sources.delete(source);
        }
      }
      properties.remove(texture);
    }
    function deleteTexture(texture) {
      const textureProperties = properties.get(texture);
      _gl.deleteTexture(textureProperties.__webglTexture);
      const source = texture.source;
      const webglTextures = _sources.get(source);
      delete webglTextures[textureProperties.__cacheKey];
      info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
        info.memory.textures--;
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i5 = 0; i5 < 6; i5++) {
          if (Array.isArray(renderTargetProperties.__webglFramebuffer[i5])) {
            for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i5].length; level++)
              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i5][level]);
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i5]);
          }
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i5]);
        }
      } else {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++)
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        }
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer) {
          for (let i5 = 0; i5 < renderTargetProperties.__webglColorRenderbuffer.length; i5++) {
            if (renderTargetProperties.__webglColorRenderbuffer[i5])
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i5]);
          }
        }
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        for (let i5 = 0, il3 = texture.length; i5 < il3; i5++) {
          const attachmentProperties = properties.get(texture[i5]);
          if (attachmentProperties.__webglTexture) {
            _gl.deleteTexture(attachmentProperties.__webglTexture);
            info.memory.textures--;
          }
          properties.remove(texture[i5]);
        }
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function getTextureCacheKey(texture) {
      const array = [];
      array.push(texture.wrapS);
      array.push(texture.wrapT);
      array.push(texture.wrapR || 0);
      array.push(texture.magFilter);
      array.push(texture.minFilter);
      array.push(texture.anisotropy);
      array.push(texture.internalFormat);
      array.push(texture.format);
      array.push(texture.type);
      array.push(texture.generateMipmaps);
      array.push(texture.premultiplyAlpha);
      array.push(texture.flipY);
      array.push(texture.unpackAlignment);
      array.push(texture.colorSpace);
      return array.join();
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === null) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    const wrappingToGL = {
      [RepeatWrapping]: _gl.REPEAT,
      [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
    };
    const filterToGL = {
      [NearestFilter]: _gl.NEAREST,
      [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: _gl.LINEAR,
      [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
    };
    const compareToGL = {
      [NeverCompare]: _gl.NEVER,
      [AlwaysCompare]: _gl.ALWAYS,
      [LessCompare]: _gl.LESS,
      [LessEqualCompare]: _gl.LEQUAL,
      [EqualCompare]: _gl.EQUAL,
      [GreaterEqualCompare]: _gl.GEQUAL,
      [GreaterCompare]: _gl.GREATER,
      [NotEqualCompare]: _gl.NOTEQUAL
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
        if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
        if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (texture.compareFunction) {
        _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
        _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.magFilter === NearestFilter)
          return;
        if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter)
          return;
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      let forceUpload = false;
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
      }
      const source = texture.source;
      let webglTextures = _sources.get(source);
      if (webglTextures === void 0) {
        webglTextures = {};
        _sources.set(source, webglTextures);
      }
      const textureCacheKey = getTextureCacheKey(texture);
      if (textureCacheKey !== textureProperties.__cacheKey) {
        if (webglTextures[textureCacheKey] === void 0) {
          webglTextures[textureCacheKey] = {
            texture: _gl.createTexture(),
            usedTimes: 0
          };
          info.memory.textures++;
          forceUpload = true;
        }
        webglTextures[textureCacheKey].usedTimes++;
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        if (webglTexture !== void 0) {
          webglTextures[textureProperties.__cacheKey].usedTimes--;
          if (webglTexture.usedTimes === 0) {
            deleteTexture(texture);
          }
        }
        textureProperties.__cacheKey = textureCacheKey;
        textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
      }
      return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = _gl.TEXTURE_2D;
      if (texture.isDataArrayTexture || texture.isCompressedArrayTexture)
        textureType = _gl.TEXTURE_2D_ARRAY;
      if (texture.isData3DTexture)
        textureType = _gl.TEXTURE_3D;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
        const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
        const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
        let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        image = verifyColorSpace(texture, image);
        const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.colorSpace);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        const levels2 = getMipLevels(texture, image, supportsMips);
        if (texture.isDepthTexture) {
          glInternalFormat = _gl.DEPTH_COMPONENT;
          if (isWebGL2) {
            if (texture.type === FloatType) {
              glInternalFormat = _gl.DEPTH_COMPONENT32F;
            } else if (texture.type === UnsignedIntType) {
              glInternalFormat = _gl.DEPTH_COMPONENT24;
            } else if (texture.type === UnsignedInt248Type) {
              glInternalFormat = _gl.DEPTH24_STENCIL8;
            } else {
              glInternalFormat = _gl.DEPTH_COMPONENT16;
            }
          } else {
            if (texture.type === FloatType) {
              console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
            }
          }
          if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedIntType;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
            glInternalFormat = _gl.DEPTH_STENCIL;
            if (texture.type !== UnsignedInt248Type) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type;
              glType = utils.convert(texture.type);
            }
          }
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
          }
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels2, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i5 = 0, il3 = mipmaps.length; i5 < il3; i5++) {
              mipmap = mipmaps[i5];
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_2D, i5, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i5, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels2, glInternalFormat, image.width, image.height);
              }
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
          }
        } else if (texture.isCompressedTexture) {
          if (texture.isCompressedArrayTexture) {
            if (useTexStorage && allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels2, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
            }
            for (let i5 = 0, il3 = mipmaps.length; i5 < il3; i5++) {
              mipmap = mipmaps[i5];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i5, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                  } else {
                    state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i5, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i5, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                } else {
                  state.texImage3D(_gl.TEXTURE_2D_ARRAY, i5, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          } else {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels2, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i5 = 0, il3 = mipmaps.length; i5 < il3; i5++) {
              mipmap = mipmaps[i5];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i5, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_2D, i5, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i5, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i5, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else if (texture.isDataArrayTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels2, glInternalFormat, image.width, image.height, image.depth);
            }
            state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isData3DTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_3D, levels2, glInternalFormat, image.width, image.height, image.depth);
            }
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isFramebufferTexture) {
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(_gl.TEXTURE_2D, levels2, glInternalFormat, image.width, image.height);
            } else {
              let width = image.width, height = image.height;
              for (let i5 = 0; i5 < levels2; i5++) {
                state.texImage2D(_gl.TEXTURE_2D, i5, glInternalFormat, width, height, 0, glFormat, glType, null);
                width >>= 1;
                height >>= 1;
              }
            }
          }
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels2, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i5 = 0, il3 = mipmaps.length; i5 < il3; i5++) {
              mipmap = mipmaps[i5];
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_2D, i5, 0, 0, glFormat, glType, mipmap);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i5, glInternalFormat, glFormat, glType, mipmap);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels2, glInternalFormat, image.width, image.height);
              }
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
        const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
        const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
        const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i5 = 0; i5 < 6; i5++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i5] = resizeImage(texture.image[i5], false, true, maxCubemapSize);
          } else {
            cubeImage[i5] = isDataTexture ? texture.image[i5].image : texture.image[i5];
          }
          cubeImage[i5] = verifyColorSpace(texture, cubeImage[i5]);
        }
        const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        let levels2 = getMipLevels(texture, image, supportsMips);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels2, glInternalFormat, image.width, image.height);
          }
          for (let i5 = 0; i5 < 6; i5++) {
            mipmaps = cubeImage[i5].mipmaps;
            for (let j4 = 0; j4 < mipmaps.length; j4++) {
              const mipmap = mipmaps[j4];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else {
          mipmaps = texture.mipmaps;
          if (useTexStorage && allocateMemory) {
            if (mipmaps.length > 0)
              levels2++;
            state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels2, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
          }
          for (let i5 = 0; i5 < 6; i5++) {
            if (isDataTexture) {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, 0, 0, 0, cubeImage[i5].width, cubeImage[i5].height, glFormat, glType, cubeImage[i5].data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, 0, glInternalFormat, cubeImage[i5].width, cubeImage[i5].height, 0, glFormat, glType, cubeImage[i5].data);
              }
              for (let j4 = 0; j4 < mipmaps.length; j4++) {
                const mipmap = mipmaps[j4];
                const mipmapImage = mipmap.image[i5].image;
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, 0, 0, 0, glFormat, glType, cubeImage[i5]);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, 0, glInternalFormat, glFormat, glType, cubeImage[i5]);
              }
              for (let j4 = 0; j4 < mipmaps.length; j4++) {
                const mipmap = mipmaps[j4];
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4 + 1, 0, 0, glFormat, glType, mipmap.image[i5]);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, j4 + 1, glInternalFormat, glFormat, glType, mipmap.image[i5]);
                }
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const renderTargetProperties = properties.get(renderTarget);
      if (!renderTargetProperties.__hasExternalTextures) {
        const width = Math.max(1, renderTarget.width >> level);
        const height = Math.max(1, renderTarget.height >> level);
        if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
          state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
        }
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = isWebGL2 === true ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16;
        if (isMultisample || useMultisampledRTT(renderTarget)) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = _gl.DEPTH_COMPONENT32F;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = _gl.DEPTH_COMPONENT24;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
      } else {
        const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
        for (let i5 = 0; i5 < textures.length; i5++) {
          const texture = textures[i5];
          const glFormat = utils.convert(texture.format, texture.colorSpace);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
          const samples = getRenderTargetSamples(renderTarget);
          if (isMultisample && useMultisampledRTT(renderTarget) === false) {
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
      }
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i5 = 0; i5 < 6; i5++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i5]);
            renderTargetProperties.__webglDepthbuffer[i5] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i5], renderTarget, false);
          }
        } else {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      if (renderTarget.isWebGLMultipleRenderTargets !== true) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i5 = 0; i5 < 6; i5++) {
          if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
            renderTargetProperties.__webglFramebuffer[i5] = [];
            for (let level = 0; level < texture.mipmaps.length; level++) {
              renderTargetProperties.__webglFramebuffer[i5][level] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer[i5] = _gl.createFramebuffer();
          }
        }
      } else {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        }
        if (isMultipleRenderTargets) {
          if (capabilities.drawBuffers) {
            const textures = renderTarget.texture;
            for (let i5 = 0, il3 = textures.length; i5 < il3; i5++) {
              const attachmentProperties = properties.get(textures[i5]);
              if (attachmentProperties.__webglTexture === void 0) {
                attachmentProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
              }
            }
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          }
        }
        if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
          const textures = isMultipleRenderTargets ? texture : [texture];
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = [];
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          for (let i5 = 0; i5 < textures.length; i5++) {
            const texture2 = textures[i5];
            renderTargetProperties.__webglColorRenderbuffer[i5] = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i5]);
            const glFormat = utils.convert(texture2.format, texture2.colorSpace);
            const glType = utils.convert(texture2.type);
            const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i5, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i5]);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
      }
      if (isCube) {
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
        for (let i5 = 0; i5 < 6; i5++) {
          if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
            for (let level = 0; level < texture.mipmaps.length; level++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i5][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, level);
            }
          } else {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i5], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i5, 0);
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        state.unbindTexture();
      } else if (isMultipleRenderTargets) {
        const textures = renderTarget.texture;
        for (let i5 = 0, il3 = textures.length; i5 < il3; i5++) {
          const attachment = textures[i5];
          const attachmentProperties = properties.get(attachment);
          state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
          setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i5, _gl.TEXTURE_2D, 0);
          if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
            generateMipmap(_gl.TEXTURE_2D);
          }
        }
        state.unbindTexture();
      } else {
        let glTextureType = _gl.TEXTURE_2D;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          if (isWebGL2) {
            glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
          } else {
            console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
          }
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(glTextureType);
        }
        state.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i5 = 0, il3 = textures.length; i5 < il3; i5++) {
        const texture = textures[i5];
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
          const webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target);
          state.unbindTexture();
        }
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const invalidationArray = [];
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
        if (isMultipleRenderTargets) {
          for (let i5 = 0; i5 < textures.length; i5++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i5, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i5, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (let i5 = 0; i5 < textures.length; i5++) {
          invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i5);
          if (renderTarget.depthBuffer) {
            invalidationArray.push(depthStyle);
          }
          const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
          if (ignoreDepthValues === false) {
            if (renderTarget.depthBuffer)
              mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer)
              mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i5]);
          }
          if (ignoreDepthValues === true) {
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
            _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
          }
          if (isMultipleRenderTargets) {
            const webglTexture = properties.get(textures[i5]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer) {
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i5 = 0; i5 < textures.length; i5++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i5, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i5]);
            const webglTexture = properties.get(textures[i5]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i5, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return Math.min(maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image) {
      const colorSpace = texture.colorSpace;
      const format = texture.format;
      const type = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
        return image;
      if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
        if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
          if (isWebGL2 === false) {
            if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
              texture.format = _SRGBAFormat;
              texture.minFilter = LinearFilter;
              texture.generateMipmaps = false;
            } else {
              image = ImageUtils.sRGBToLinear(image);
            }
          } else {
            if (format !== RGBAFormat || type !== UnsignedByteType) {
              console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
            }
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
        }
      }
      return image;
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
  }
  function WebGLUtils(gl3, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p4, colorSpace = NoColorSpace) {
      let extension;
      const transfer = ColorManagement.getTransfer(colorSpace);
      if (p4 === UnsignedByteType)
        return gl3.UNSIGNED_BYTE;
      if (p4 === UnsignedShort4444Type)
        return gl3.UNSIGNED_SHORT_4_4_4_4;
      if (p4 === UnsignedShort5551Type)
        return gl3.UNSIGNED_SHORT_5_5_5_1;
      if (p4 === ByteType)
        return gl3.BYTE;
      if (p4 === ShortType)
        return gl3.SHORT;
      if (p4 === UnsignedShortType)
        return gl3.UNSIGNED_SHORT;
      if (p4 === IntType)
        return gl3.INT;
      if (p4 === UnsignedIntType)
        return gl3.UNSIGNED_INT;
      if (p4 === FloatType)
        return gl3.FLOAT;
      if (p4 === HalfFloatType) {
        if (isWebGL2)
          return gl3.HALF_FLOAT;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p4 === AlphaFormat)
        return gl3.ALPHA;
      if (p4 === RGBAFormat)
        return gl3.RGBA;
      if (p4 === LuminanceFormat)
        return gl3.LUMINANCE;
      if (p4 === LuminanceAlphaFormat)
        return gl3.LUMINANCE_ALPHA;
      if (p4 === DepthFormat)
        return gl3.DEPTH_COMPONENT;
      if (p4 === DepthStencilFormat)
        return gl3.DEPTH_STENCIL;
      if (p4 === _SRGBAFormat) {
        extension = extensions.get("EXT_sRGB");
        if (extension !== null) {
          return extension.SRGB_ALPHA_EXT;
        } else {
          return null;
        }
      }
      if (p4 === RedFormat)
        return gl3.RED;
      if (p4 === RedIntegerFormat)
        return gl3.RED_INTEGER;
      if (p4 === RGFormat)
        return gl3.RG;
      if (p4 === RGIntegerFormat)
        return gl3.RG_INTEGER;
      if (p4 === RGBAIntegerFormat)
        return gl3.RGBA_INTEGER;
      if (p4 === RGB_S3TC_DXT1_Format || p4 === RGBA_S3TC_DXT1_Format || p4 === RGBA_S3TC_DXT3_Format || p4 === RGBA_S3TC_DXT5_Format) {
        if (transfer === SRGBTransfer) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p4 === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p4 === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p4 === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p4 === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p4 === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p4 === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p4 === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p4 === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p4 === RGB_PVRTC_4BPPV1_Format || p4 === RGB_PVRTC_2BPPV1_Format || p4 === RGBA_PVRTC_4BPPV1_Format || p4 === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p4 === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p4 === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p4 === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p4 === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p4 === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p4 === RGB_ETC2_Format || p4 === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p4 === RGB_ETC2_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p4 === RGBA_ETC2_EAC_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p4 === RGBA_ASTC_4x4_Format || p4 === RGBA_ASTC_5x4_Format || p4 === RGBA_ASTC_5x5_Format || p4 === RGBA_ASTC_6x5_Format || p4 === RGBA_ASTC_6x6_Format || p4 === RGBA_ASTC_8x5_Format || p4 === RGBA_ASTC_8x6_Format || p4 === RGBA_ASTC_8x8_Format || p4 === RGBA_ASTC_10x5_Format || p4 === RGBA_ASTC_10x6_Format || p4 === RGBA_ASTC_10x8_Format || p4 === RGBA_ASTC_10x10_Format || p4 === RGBA_ASTC_12x10_Format || p4 === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p4 === RGBA_ASTC_4x4_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p4 === RGBA_ASTC_5x4_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p4 === RGBA_ASTC_5x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p4 === RGBA_ASTC_6x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p4 === RGBA_ASTC_6x6_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p4 === RGBA_ASTC_8x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p4 === RGBA_ASTC_8x6_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p4 === RGBA_ASTC_8x8_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p4 === RGBA_ASTC_10x5_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p4 === RGBA_ASTC_10x6_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p4 === RGBA_ASTC_10x8_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p4 === RGBA_ASTC_10x10_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p4 === RGBA_ASTC_12x10_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p4 === RGBA_ASTC_12x12_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p4 === RGBA_BPTC_Format || p4 === RGB_BPTC_SIGNED_Format || p4 === RGB_BPTC_UNSIGNED_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p4 === RGBA_BPTC_Format)
            return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (p4 === RGB_BPTC_SIGNED_Format)
            return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (p4 === RGB_BPTC_UNSIGNED_Format)
            return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        } else {
          return null;
        }
      }
      if (p4 === RED_RGTC1_Format || p4 === SIGNED_RED_RGTC1_Format || p4 === RED_GREEN_RGTC2_Format || p4 === SIGNED_RED_GREEN_RGTC2_Format) {
        extension = extensions.get("EXT_texture_compression_rgtc");
        if (extension !== null) {
          if (p4 === RGBA_BPTC_Format)
            return extension.COMPRESSED_RED_RGTC1_EXT;
          if (p4 === SIGNED_RED_RGTC1_Format)
            return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (p4 === RED_GREEN_RGTC2_Format)
            return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (p4 === SIGNED_RED_GREEN_RGTC2_Format)
            return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        } else {
          return null;
        }
      }
      if (p4 === UnsignedInt248Type) {
        if (isWebGL2)
          return gl3.UNSIGNED_INT_24_8;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
      return gl3[p4] !== void 0 ? gl3[p4] : null;
    }
    return { convert };
  }
  function WebGLMaterials(renderer, properties) {
    function refreshTransformUniform(map, uniform) {
      if (map.matrixAutoUpdate === true) {
        map.updateMatrix();
      }
      uniform.value.copy(map.matrix);
    }
    function refreshFogUniforms(uniforms, fog) {
      fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsStandard(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) {
          uniforms.bumpScale.value *= -1;
        }
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) {
          uniforms.normalScale.value.negate();
        }
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
        refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
        refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        const scaleFactor = renderer._useLegacyLights === true ? Math.PI : 1;
        uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
        refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
        refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.uvTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.metalness.value = material.metalness;
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
        refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
      }
      uniforms.roughness.value = material.roughness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
        refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
          refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
          refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
          refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
          refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.iridescence > 0) {
        uniforms.iridescence.value = material.iridescence;
        uniforms.iridescenceIOR.value = material.iridescenceIOR;
        uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
        uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
        if (material.iridescenceMap) {
          uniforms.iridescenceMap.value = material.iridescenceMap;
          refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
        }
        if (material.iridescenceThicknessMap) {
          uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
          refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
          refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
          refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      if (material.anisotropy > 0) {
        uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
        if (material.anisotropyMap) {
          uniforms.anisotropyMap.value = material.anisotropyMap;
          refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
        }
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
        refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
      }
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
        refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      const light = properties.get(material).light;
      uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
      uniforms.nearDistance.value = light.shadow.camera.near;
      uniforms.farDistance.value = light.shadow.camera.far;
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function WebGLUniformsGroups(gl3, info, capabilities, state) {
    let buffers = {};
    let updateList = {};
    let allocatedBindingPoints = [];
    const maxBindingPoints = capabilities.isWebGL2 ? gl3.getParameter(gl3.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function bind2(uniformsGroup, program) {
      const webglProgram = program.program;
      state.uniformBlockBinding(uniformsGroup, webglProgram);
    }
    function update(uniformsGroup, program) {
      let buffer = buffers[uniformsGroup.id];
      if (buffer === void 0) {
        prepareUniformsGroup(uniformsGroup);
        buffer = createBuffer(uniformsGroup);
        buffers[uniformsGroup.id] = buffer;
        uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
      }
      const webglProgram = program.program;
      state.updateUBOMapping(uniformsGroup, webglProgram);
      const frame = info.render.frame;
      if (updateList[uniformsGroup.id] !== frame) {
        updateBufferData(uniformsGroup);
        updateList[uniformsGroup.id] = frame;
      }
    }
    function createBuffer(uniformsGroup) {
      const bindingPointIndex = allocateBindingPointIndex();
      uniformsGroup.__bindingPointIndex = bindingPointIndex;
      const buffer = gl3.createBuffer();
      const size = uniformsGroup.__size;
      const usage = uniformsGroup.usage;
      gl3.bindBuffer(gl3.UNIFORM_BUFFER, buffer);
      gl3.bufferData(gl3.UNIFORM_BUFFER, size, usage);
      gl3.bindBuffer(gl3.UNIFORM_BUFFER, null);
      gl3.bindBufferBase(gl3.UNIFORM_BUFFER, bindingPointIndex, buffer);
      return buffer;
    }
    function allocateBindingPointIndex() {
      for (let i5 = 0; i5 < maxBindingPoints; i5++) {
        if (allocatedBindingPoints.indexOf(i5) === -1) {
          allocatedBindingPoints.push(i5);
          return i5;
        }
      }
      console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
      return 0;
    }
    function updateBufferData(uniformsGroup) {
      const buffer = buffers[uniformsGroup.id];
      const uniforms = uniformsGroup.uniforms;
      const cache = uniformsGroup.__cache;
      gl3.bindBuffer(gl3.UNIFORM_BUFFER, buffer);
      for (let i5 = 0, il3 = uniforms.length; i5 < il3; i5++) {
        const uniform = uniforms[i5];
        if (hasUniformChanged(uniform, i5, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let i6 = 0; i6 < values.length; i6++) {
            const value = values[i6];
            const info2 = getUniformSize(value);
            if (typeof value === "number") {
              uniform.__data[0] = value;
              gl3.bufferSubData(gl3.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = value.elements[0];
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = value.elements[0];
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = value.elements[0];
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl3.bufferSubData(gl3.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
      gl3.bindBuffer(gl3.UNIFORM_BUFFER, null);
    }
    function hasUniformChanged(uniform, index, cache) {
      const value = uniform.value;
      if (cache[index] === void 0) {
        if (typeof value === "number") {
          cache[index] = value;
        } else {
          const values = Array.isArray(value) ? value : [value];
          const tempValues = [];
          for (let i5 = 0; i5 < values.length; i5++) {
            tempValues.push(values[i5].clone());
          }
          cache[index] = tempValues;
        }
        return true;
      } else {
        if (typeof value === "number") {
          if (cache[index] !== value) {
            cache[index] = value;
            return true;
          }
        } else {
          const cachedObjects = Array.isArray(cache[index]) ? cache[index] : [cache[index]];
          const values = Array.isArray(value) ? value : [value];
          for (let i5 = 0; i5 < cachedObjects.length; i5++) {
            const cachedObject = cachedObjects[i5];
            if (cachedObject.equals(values[i5]) === false) {
              cachedObject.copy(values[i5]);
              return true;
            }
          }
        }
      }
      return false;
    }
    function prepareUniformsGroup(uniformsGroup) {
      const uniforms = uniformsGroup.uniforms;
      let offset = 0;
      const chunkSize = 16;
      let chunkOffset = 0;
      for (let i5 = 0, l4 = uniforms.length; i5 < l4; i5++) {
        const uniform = uniforms[i5];
        const infos = {
          boundary: 0,
          // bytes
          storage: 0
          // bytes
        };
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let j4 = 0, jl3 = values.length; j4 < jl3; j4++) {
          const value = values[j4];
          const info2 = getUniformSize(value);
          infos.boundary += info2.boundary;
          infos.storage += info2.storage;
        }
        uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
        uniform.__offset = offset;
        if (i5 > 0) {
          chunkOffset = offset % chunkSize;
          const remainingSizeInChunk = chunkSize - chunkOffset;
          if (chunkOffset !== 0 && remainingSizeInChunk - infos.boundary < 0) {
            offset += chunkSize - chunkOffset;
            uniform.__offset = offset;
          }
        }
        offset += infos.storage;
      }
      chunkOffset = offset % chunkSize;
      if (chunkOffset > 0)
        offset += chunkSize - chunkOffset;
      uniformsGroup.__size = offset;
      uniformsGroup.__cache = {};
      return this;
    }
    function getUniformSize(value) {
      const info2 = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      };
      if (typeof value === "number") {
        info2.boundary = 4;
        info2.storage = 4;
      } else if (value.isVector2) {
        info2.boundary = 8;
        info2.storage = 8;
      } else if (value.isVector3 || value.isColor) {
        info2.boundary = 16;
        info2.storage = 12;
      } else if (value.isVector4) {
        info2.boundary = 16;
        info2.storage = 16;
      } else if (value.isMatrix3) {
        info2.boundary = 48;
        info2.storage = 48;
      } else if (value.isMatrix4) {
        info2.boundary = 64;
        info2.storage = 64;
      } else if (value.isTexture) {
        console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
      } else {
        console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
      }
      return info2;
    }
    function onUniformsGroupsDispose(event) {
      const uniformsGroup = event.target;
      uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
      const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
      allocatedBindingPoints.splice(index, 1);
      gl3.deleteBuffer(buffers[uniformsGroup.id]);
      delete buffers[uniformsGroup.id];
      delete updateList[uniformsGroup.id];
    }
    function dispose() {
      for (const id2 in buffers) {
        gl3.deleteBuffer(buffers[id2]);
      }
      allocatedBindingPoints = [];
      buffers = {};
      updateList = {};
    }
    return {
      bind: bind2,
      update,
      dispose
    };
  }
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  function convertArray(array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  }
  function isTypedArray2(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  }
  function getKeyframeOrder(times) {
    function compareTime(i5, j4) {
      return times[i5] - times[j4];
    }
    const n4 = times.length;
    const result = new Array(n4);
    for (let i5 = 0; i5 !== n4; ++i5)
      result[i5] = i5;
    result.sort(compareTime);
    return result;
  }
  function sortedArray(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i5 = 0, dstOffset = 0; dstOffset !== nValues; ++i5) {
      const srcOffset = order[i5] * stride;
      for (let j4 = 0; j4 !== stride; ++j4) {
        result[dstOffset++] = values[srcOffset + j4];
      }
    }
    return result;
  }
  function flattenJSON(jsonKeys, times, values, valuePropertyName) {
    let i5 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i5++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i5++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i5++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i5++];
      } while (key !== void 0);
    }
  }
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  function now() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  function getBoneList(object) {
    const boneList = [];
    if (object.isBone === true) {
      boneList.push(object);
    }
    for (let i5 = 0; i5 < object.children.length; i5++) {
      boneList.push.apply(boneList, getBoneList(object.children[i5]));
    }
    return boneList;
  }
  var REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, ConstantColorFactor, OneMinusConstantColorFactor, ConstantAlphaFactor, OneMinusConstantAlphaFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, AttachedBindMode, DetachedBindMode, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt248Type, AlphaFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, NoColorSpace, SRGBColorSpace, LinearSRGBColorSpace, DisplayP3ColorSpace, LinearDisplayP3ColorSpace, LinearTransfer, SRGBTransfer, Rec709Primaries, P3Primaries, KeepStencilOp, AlwaysStencilFunc, NeverCompare, LessCompare, EqualCompare, LessEqualCompare, GreaterCompare, NotEqualCompare, GreaterEqualCompare, AlwaysCompare, StaticDrawUsage, GLSL3, _SRGBAFormat, WebGLCoordinateSystem, WebGPUCoordinateSystem, EventDispatcher, _lut, _seed, DEG2RAD, RAD2DEG, MathUtils, Vector2, Matrix3, _m3, _cache, LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, COLOR_SPACES, SUPPORTED_WORKING_COLOR_SPACES, ColorManagement, _canvas, ImageUtils, _sourceId, Source, _textureId, Texture, Vector4, RenderTarget, WebGLRenderTarget, DataArrayTexture, Data3DTexture, Quaternion, Vector3, _vector$b, _quaternion$4, Box3, _points, _vector$a, _box$3, _v0$2, _v1$7, _v2$4, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$2, _v1$6, _v2$3, Sphere, _vector$9, _segCenter, _segDir, _diff, _edge1, _edge2, _normal$1, Ray, Matrix4, _v1$5, _m1$2, _zero, _one, _x, _y, _z, _matrix, _quaternion$3, Euler, Layers, _object3DId, _v1$4, _q1, _m1$1, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, Object3D, _v0$1, _v1$3, _v2$2, _v3$1, _vab, _vac, _vbc, _vap, _vbp, _vcp, warnedGetUV, Triangle, _colorKeywords, _hslA, _hslB, Color, _color, _materialId, Material, MeshBasicMaterial, _vector$8, _vector2$1, BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute, Float32BufferAttribute, _id$2, _m1, _obj, _offset, _box$1, _boxMorphTargets, _vector$7, BufferGeometry, _inverseMatrix$3, _ray$3, _sphere$5, _sphereHitAt, _vA$1, _vB$1, _vC$1, _tempA, _morphA, _uvA$1, _uvB$1, _uvC$1, _normalA, _normalB, _normalC, _intersectionPoint, _intersectionPointWorld, Mesh, BoxGeometry, UniformsUtils, default_vertex, default_fragment, ShaderMaterial, Camera, PerspectiveCamera, fov, aspect, CubeCamera, CubeTexture, WebGLCubeRenderTarget, _vector1, _vector2, _normalMatrix, Plane, _sphere$4, _vector$6, Frustum, PlaneGeometry, alphahash_fragment, alphahash_pars_fragment, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, colorspace_fragment, colorspace_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, opaque_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, worldpos_vertex, vertex$h, fragment$h, vertex$g, fragment$g, vertex$f, fragment$f, vertex$e, fragment$e, vertex$d, fragment$d, vertex$c, fragment$c, vertex$b, fragment$b, vertex$a, fragment$a, vertex$9, fragment$9, vertex$8, fragment$8, vertex$7, fragment$7, vertex$6, fragment$6, vertex$5, fragment$5, vertex$4, fragment$4, vertex$3, fragment$3, vertex$2, fragment$2, vertex$1, fragment$1, ShaderChunk, UniformsLib, ShaderLib, _rgb, OrthographicCamera, LOD_MIN, EXTRA_LOD_SIGMA, MAX_SAMPLES, _flatCamera, _clearColor, _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel, PHI, INV_PHI, _axisDirections, PMREMGenerator, emptyTexture, emptyArrayTexture, empty3dTexture, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, SingleUniform, PureArrayUniform, StructuredUniform, RePathPart, WebGLUniforms, COMPLETION_STATUS_KHR, programIdCount, includePattern, shaderChunkMap, unrollLoopPattern, _id$1, WebGLShaderCache, WebGLShaderStage, nextVersion, MeshDepthMaterial, MeshDistanceMaterial, vertex, fragment, ArrayCamera, Group, _moveEvent, WebXRController, DepthTexture, WebXRManager, WebGLRenderer, WebGL1Renderer, Fog, Scene, InterleavedBuffer, _vector$5, InterleavedBufferAttribute, _basePosition, _skinIndex, _skinWeight, _vector3, _matrix4, _vertex, _sphere$3, _inverseMatrix$2, _ray$2, SkinnedMesh, Bone, DataTexture, _offsetMatrix, _identityMatrix, Skeleton, InstancedBufferAttribute, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _box3, _identity, _mesh, _sphere$2, InstancedMesh, LineBasicMaterial, _start$1, _end$1, _inverseMatrix$1, _ray$1, _sphere$1, Line, _start, _end, LineSegments, LineLoop, PointsMaterial, _inverseMatrix, _ray, _sphere, _position$2, Points, Curve, RingGeometry, MeshStandardMaterial, MeshPhysicalMaterial, MeshPhongMaterial, MeshLambertMaterial, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack, AnimationClip, Cache, LoadingManager, DefaultLoadingManager, Loader, loading, HttpError, FileLoader, ImageLoader, TextureLoader, Light, HemisphereLight, _projScreenMatrix$1, _lightPositionWorld$1, _lookTarget$1, LightShadow, SpotLightShadow, SpotLight, _projScreenMatrix, _lightPositionWorld, _lookTarget, PointLightShadow, PointLight, DirectionalLightShadow, DirectionalLight, AmbientLight, LoaderUtils, ImageBitmapLoader, Clock, PropertyMixer, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Composite, PropertyBinding, AnimationAction, _controlInterpolantsResultBuffer, AnimationMixer, Spherical, _vector$2, _boneMatrix, _matrixWorldInv, SkeletonHelper;
  var init_three_module = __esm({
    "node_modules/three/build/three.module.js"() {
      REVISION = "158";
      MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
      TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
      CullFaceNone = 0;
      CullFaceBack = 1;
      CullFaceFront = 2;
      PCFShadowMap = 1;
      PCFSoftShadowMap = 2;
      VSMShadowMap = 3;
      FrontSide = 0;
      BackSide = 1;
      DoubleSide = 2;
      NoBlending = 0;
      NormalBlending = 1;
      AdditiveBlending = 2;
      SubtractiveBlending = 3;
      MultiplyBlending = 4;
      CustomBlending = 5;
      AddEquation = 100;
      SubtractEquation = 101;
      ReverseSubtractEquation = 102;
      MinEquation = 103;
      MaxEquation = 104;
      ZeroFactor = 200;
      OneFactor = 201;
      SrcColorFactor = 202;
      OneMinusSrcColorFactor = 203;
      SrcAlphaFactor = 204;
      OneMinusSrcAlphaFactor = 205;
      DstAlphaFactor = 206;
      OneMinusDstAlphaFactor = 207;
      DstColorFactor = 208;
      OneMinusDstColorFactor = 209;
      SrcAlphaSaturateFactor = 210;
      ConstantColorFactor = 211;
      OneMinusConstantColorFactor = 212;
      ConstantAlphaFactor = 213;
      OneMinusConstantAlphaFactor = 214;
      NeverDepth = 0;
      AlwaysDepth = 1;
      LessDepth = 2;
      LessEqualDepth = 3;
      EqualDepth = 4;
      GreaterEqualDepth = 5;
      GreaterDepth = 6;
      NotEqualDepth = 7;
      MultiplyOperation = 0;
      MixOperation = 1;
      AddOperation = 2;
      NoToneMapping = 0;
      LinearToneMapping = 1;
      ReinhardToneMapping = 2;
      CineonToneMapping = 3;
      ACESFilmicToneMapping = 4;
      CustomToneMapping = 5;
      AttachedBindMode = "attached";
      DetachedBindMode = "detached";
      UVMapping = 300;
      CubeReflectionMapping = 301;
      CubeRefractionMapping = 302;
      EquirectangularReflectionMapping = 303;
      EquirectangularRefractionMapping = 304;
      CubeUVReflectionMapping = 306;
      RepeatWrapping = 1e3;
      ClampToEdgeWrapping = 1001;
      MirroredRepeatWrapping = 1002;
      NearestFilter = 1003;
      NearestMipmapNearestFilter = 1004;
      NearestMipmapLinearFilter = 1005;
      LinearFilter = 1006;
      LinearMipmapNearestFilter = 1007;
      LinearMipmapLinearFilter = 1008;
      UnsignedByteType = 1009;
      ByteType = 1010;
      ShortType = 1011;
      UnsignedShortType = 1012;
      IntType = 1013;
      UnsignedIntType = 1014;
      FloatType = 1015;
      HalfFloatType = 1016;
      UnsignedShort4444Type = 1017;
      UnsignedShort5551Type = 1018;
      UnsignedInt248Type = 1020;
      AlphaFormat = 1021;
      RGBAFormat = 1023;
      LuminanceFormat = 1024;
      LuminanceAlphaFormat = 1025;
      DepthFormat = 1026;
      DepthStencilFormat = 1027;
      RedFormat = 1028;
      RedIntegerFormat = 1029;
      RGFormat = 1030;
      RGIntegerFormat = 1031;
      RGBAIntegerFormat = 1033;
      RGB_S3TC_DXT1_Format = 33776;
      RGBA_S3TC_DXT1_Format = 33777;
      RGBA_S3TC_DXT3_Format = 33778;
      RGBA_S3TC_DXT5_Format = 33779;
      RGB_PVRTC_4BPPV1_Format = 35840;
      RGB_PVRTC_2BPPV1_Format = 35841;
      RGBA_PVRTC_4BPPV1_Format = 35842;
      RGBA_PVRTC_2BPPV1_Format = 35843;
      RGB_ETC1_Format = 36196;
      RGB_ETC2_Format = 37492;
      RGBA_ETC2_EAC_Format = 37496;
      RGBA_ASTC_4x4_Format = 37808;
      RGBA_ASTC_5x4_Format = 37809;
      RGBA_ASTC_5x5_Format = 37810;
      RGBA_ASTC_6x5_Format = 37811;
      RGBA_ASTC_6x6_Format = 37812;
      RGBA_ASTC_8x5_Format = 37813;
      RGBA_ASTC_8x6_Format = 37814;
      RGBA_ASTC_8x8_Format = 37815;
      RGBA_ASTC_10x5_Format = 37816;
      RGBA_ASTC_10x6_Format = 37817;
      RGBA_ASTC_10x8_Format = 37818;
      RGBA_ASTC_10x10_Format = 37819;
      RGBA_ASTC_12x10_Format = 37820;
      RGBA_ASTC_12x12_Format = 37821;
      RGBA_BPTC_Format = 36492;
      RGB_BPTC_SIGNED_Format = 36494;
      RGB_BPTC_UNSIGNED_Format = 36495;
      RED_RGTC1_Format = 36283;
      SIGNED_RED_RGTC1_Format = 36284;
      RED_GREEN_RGTC2_Format = 36285;
      SIGNED_RED_GREEN_RGTC2_Format = 36286;
      LoopOnce = 2200;
      LoopRepeat = 2201;
      LoopPingPong = 2202;
      InterpolateDiscrete = 2300;
      InterpolateLinear = 2301;
      InterpolateSmooth = 2302;
      ZeroCurvatureEnding = 2400;
      ZeroSlopeEnding = 2401;
      WrapAroundEnding = 2402;
      NormalAnimationBlendMode = 2500;
      AdditiveAnimationBlendMode = 2501;
      TrianglesDrawMode = 0;
      TriangleStripDrawMode = 1;
      TriangleFanDrawMode = 2;
      LinearEncoding = 3e3;
      sRGBEncoding = 3001;
      BasicDepthPacking = 3200;
      RGBADepthPacking = 3201;
      TangentSpaceNormalMap = 0;
      ObjectSpaceNormalMap = 1;
      NoColorSpace = "";
      SRGBColorSpace = "srgb";
      LinearSRGBColorSpace = "srgb-linear";
      DisplayP3ColorSpace = "display-p3";
      LinearDisplayP3ColorSpace = "display-p3-linear";
      LinearTransfer = "linear";
      SRGBTransfer = "srgb";
      Rec709Primaries = "rec709";
      P3Primaries = "p3";
      KeepStencilOp = 7680;
      AlwaysStencilFunc = 519;
      NeverCompare = 512;
      LessCompare = 513;
      EqualCompare = 514;
      LessEqualCompare = 515;
      GreaterCompare = 516;
      NotEqualCompare = 517;
      GreaterEqualCompare = 518;
      AlwaysCompare = 519;
      StaticDrawUsage = 35044;
      GLSL3 = "300 es";
      _SRGBAFormat = 1035;
      WebGLCoordinateSystem = 2e3;
      WebGPUCoordinateSystem = 2001;
      EventDispatcher = class {
        addEventListener(type, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners = this._listeners;
          if (listeners[type] === void 0) {
            listeners[type] = [];
          }
          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }
        }
        hasEventListener(type, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners = this._listeners;
          return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[type];
          if (listenerArray !== void 0) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
              listenerArray.splice(index, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i5 = 0, l4 = array.length; i5 < l4; i5++) {
              array[i5].call(this, event);
            }
            event.target = null;
          }
        }
      };
      _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
      _seed = 1234567;
      DEG2RAD = Math.PI / 180;
      RAD2DEG = 180 / Math.PI;
      MathUtils = {
        DEG2RAD,
        RAD2DEG,
        generateUUID,
        clamp,
        euclideanModulo,
        mapLinear,
        inverseLerp,
        lerp,
        damp,
        pingpong,
        smoothstep,
        smootherstep,
        randInt,
        randFloat,
        randFloatSpread,
        seededRandom,
        degToRad,
        radToDeg,
        isPowerOfTwo,
        ceilPowerOfTwo,
        floorPowerOfTwo,
        setQuaternionFromProperEuler,
        normalize,
        denormalize
      };
      Vector2 = class _Vector2 {
        constructor(x4 = 0, y3 = 0) {
          _Vector2.prototype.isVector2 = true;
          this.x = x4;
          this.y = y3;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x4, y3) {
          this.x = x4;
          this.y = y3;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x4) {
          this.x = x4;
          return this;
        }
        setY(y3) {
          this.y = y3;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v5) {
          this.x = v5.x;
          this.y = v5.y;
          return this;
        }
        add(v5) {
          this.x += v5.x;
          this.y += v5.y;
          return this;
        }
        addScalar(s4) {
          this.x += s4;
          this.y += s4;
          return this;
        }
        addVectors(a4, b3) {
          this.x = a4.x + b3.x;
          this.y = a4.y + b3.y;
          return this;
        }
        addScaledVector(v5, s4) {
          this.x += v5.x * s4;
          this.y += v5.y * s4;
          return this;
        }
        sub(v5) {
          this.x -= v5.x;
          this.y -= v5.y;
          return this;
        }
        subScalar(s4) {
          this.x -= s4;
          this.y -= s4;
          return this;
        }
        subVectors(a4, b3) {
          this.x = a4.x - b3.x;
          this.y = a4.y - b3.y;
          return this;
        }
        multiply(v5) {
          this.x *= v5.x;
          this.y *= v5.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v5) {
          this.x /= v5.x;
          this.y /= v5.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m4) {
          const x4 = this.x, y3 = this.y;
          const e4 = m4.elements;
          this.x = e4[0] * x4 + e4[3] * y3 + e4[6];
          this.y = e4[1] * x4 + e4[4] * y3 + e4[7];
          return this;
        }
        min(v5) {
          this.x = Math.min(this.x, v5.x);
          this.y = Math.min(this.y, v5.y);
          return this;
        }
        max(v5) {
          this.x = Math.max(this.x, v5.x);
          this.y = Math.max(this.y, v5.y);
          return this;
        }
        clamp(min, max2) {
          this.x = Math.max(min.x, Math.min(max2.x, this.x));
          this.y = Math.max(min.y, Math.min(max2.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max2) {
          const length3 = this.length();
          return this.divideScalar(length3 || 1).multiplyScalar(Math.max(min, Math.min(max2, length3)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = Math.trunc(this.x);
          this.y = Math.trunc(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v5) {
          return this.x * v5.x + this.y * v5.y;
        }
        cross(v5) {
          return this.x * v5.y - this.y * v5.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle2 = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle2;
        }
        angleTo(v5) {
          const denominator = Math.sqrt(this.lengthSq() * v5.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v5) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v5) {
          return Math.sqrt(this.distanceToSquared(v5));
        }
        distanceToSquared(v5) {
          const dx = this.x - v5.x, dy = this.y - v5.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v5) {
          return Math.abs(this.x - v5.x) + Math.abs(this.y - v5.y);
        }
        setLength(length3) {
          return this.normalize().multiplyScalar(length3);
        }
        lerp(v5, alpha) {
          this.x += (v5.x - this.x) * alpha;
          this.y += (v5.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v22, alpha) {
          this.x = v1.x + (v22.x - v1.x) * alpha;
          this.y = v1.y + (v22.y - v1.y) * alpha;
          return this;
        }
        equals(v5) {
          return v5.x === this.x && v5.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          return this;
        }
        rotateAround(center, angle2) {
          const c5 = Math.cos(angle2), s4 = Math.sin(angle2);
          const x4 = this.x - center.x;
          const y3 = this.y - center.y;
          this.x = x4 * c5 - y3 * s4 + center.x;
          this.y = x4 * s4 + y3 * c5 + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      };
      Matrix3 = class _Matrix3 {
        constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          _Matrix3.prototype.isMatrix3 = true;
          this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ];
          if (n11 !== void 0) {
            this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
          }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te3 = this.elements;
          te3[0] = n11;
          te3[1] = n21;
          te3[2] = n31;
          te3[3] = n12;
          te3[4] = n22;
          te3[5] = n32;
          te3[6] = n13;
          te3[7] = n23;
          te3[8] = n33;
          return this;
        }
        identity() {
          this.set(
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          );
          return this;
        }
        copy(m4) {
          const te3 = this.elements;
          const me4 = m4.elements;
          te3[0] = me4[0];
          te3[1] = me4[1];
          te3[2] = me4[2];
          te3[3] = me4[3];
          te3[4] = me4[4];
          te3[5] = me4[5];
          te3[6] = me4[6];
          te3[7] = me4[7];
          te3[8] = me4[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m4) {
          const me4 = m4.elements;
          this.set(
            me4[0],
            me4[4],
            me4[8],
            me4[1],
            me4[5],
            me4[9],
            me4[2],
            me4[6],
            me4[10]
          );
          return this;
        }
        multiply(m4) {
          return this.multiplyMatrices(this, m4);
        }
        premultiply(m4) {
          return this.multiplyMatrices(m4, this);
        }
        multiplyMatrices(a4, b3) {
          const ae4 = a4.elements;
          const be5 = b3.elements;
          const te3 = this.elements;
          const a11 = ae4[0], a12 = ae4[3], a13 = ae4[6];
          const a21 = ae4[1], a22 = ae4[4], a23 = ae4[7];
          const a31 = ae4[2], a32 = ae4[5], a33 = ae4[8];
          const b11 = be5[0], b12 = be5[3], b13 = be5[6];
          const b21 = be5[1], b22 = be5[4], b23 = be5[7];
          const b31 = be5[2], b32 = be5[5], b33 = be5[8];
          te3[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te3[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te3[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te3[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te3[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te3[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te3[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te3[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te3[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s4) {
          const te3 = this.elements;
          te3[0] *= s4;
          te3[3] *= s4;
          te3[6] *= s4;
          te3[1] *= s4;
          te3[4] *= s4;
          te3[7] *= s4;
          te3[2] *= s4;
          te3[5] *= s4;
          te3[8] *= s4;
          return this;
        }
        determinant() {
          const te3 = this.elements;
          const a4 = te3[0], b3 = te3[1], c5 = te3[2], d4 = te3[3], e4 = te3[4], f3 = te3[5], g4 = te3[6], h4 = te3[7], i5 = te3[8];
          return a4 * e4 * i5 - a4 * f3 * h4 - b3 * d4 * i5 + b3 * f3 * g4 + c5 * d4 * h4 - c5 * e4 * g4;
        }
        invert() {
          const te3 = this.elements, n11 = te3[0], n21 = te3[1], n31 = te3[2], n12 = te3[3], n22 = te3[4], n32 = te3[5], n13 = te3[6], n23 = te3[7], n33 = te3[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te3[0] = t11 * detInv;
          te3[1] = (n31 * n23 - n33 * n21) * detInv;
          te3[2] = (n32 * n21 - n31 * n22) * detInv;
          te3[3] = t12 * detInv;
          te3[4] = (n33 * n11 - n31 * n13) * detInv;
          te3[5] = (n31 * n12 - n32 * n11) * detInv;
          te3[6] = t13 * detInv;
          te3[7] = (n21 * n13 - n23 * n11) * detInv;
          te3[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp;
          const m4 = this.elements;
          tmp = m4[1];
          m4[1] = m4[3];
          m4[3] = tmp;
          tmp = m4[2];
          m4[2] = m4[6];
          m4[6] = tmp;
          tmp = m4[5];
          m4[5] = m4[7];
          m4[7] = tmp;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r4) {
          const m4 = this.elements;
          r4[0] = m4[0];
          r4[1] = m4[3];
          r4[2] = m4[6];
          r4[3] = m4[1];
          r4[4] = m4[4];
          r4[5] = m4[7];
          r4[6] = m4[2];
          r4[7] = m4[5];
          r4[8] = m4[8];
          return this;
        }
        setUvTransform(tx, ty2, sx, sy, rotation, cx, cy) {
          const c5 = Math.cos(rotation);
          const s4 = Math.sin(rotation);
          this.set(
            sx * c5,
            sx * s4,
            -sx * (c5 * cx + s4 * cy) + cx + tx,
            -sy * s4,
            sy * c5,
            -sy * (-s4 * cx + c5 * cy) + cy + ty2,
            0,
            0,
            1
          );
          return this;
        }
        //
        scale(sx, sy) {
          this.premultiply(_m3.makeScale(sx, sy));
          return this;
        }
        rotate(theta) {
          this.premultiply(_m3.makeRotation(-theta));
          return this;
        }
        translate(tx, ty2) {
          this.premultiply(_m3.makeTranslation(tx, ty2));
          return this;
        }
        // for 2D Transforms
        makeTranslation(x4, y3) {
          if (x4.isVector2) {
            this.set(
              1,
              0,
              x4.x,
              0,
              1,
              x4.y,
              0,
              0,
              1
            );
          } else {
            this.set(
              1,
              0,
              x4,
              0,
              1,
              y3,
              0,
              0,
              1
            );
          }
          return this;
        }
        makeRotation(theta) {
          const c5 = Math.cos(theta);
          const s4 = Math.sin(theta);
          this.set(
            c5,
            -s4,
            0,
            s4,
            c5,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeScale(x4, y3) {
          this.set(
            x4,
            0,
            0,
            0,
            y3,
            0,
            0,
            0,
            1
          );
          return this;
        }
        //
        equals(matrix) {
          const te3 = this.elements;
          const me4 = matrix.elements;
          for (let i5 = 0; i5 < 9; i5++) {
            if (te3[i5] !== me4[i5])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i5 = 0; i5 < 9; i5++) {
            this.elements[i5] = array[i5 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te3 = this.elements;
          array[offset] = te3[0];
          array[offset + 1] = te3[1];
          array[offset + 2] = te3[2];
          array[offset + 3] = te3[3];
          array[offset + 4] = te3[4];
          array[offset + 5] = te3[5];
          array[offset + 6] = te3[6];
          array[offset + 7] = te3[7];
          array[offset + 8] = te3[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      };
      _m3 = /* @__PURE__ */ new Matrix3();
      _cache = {};
      LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
        0.8224621,
        0.177538,
        0,
        0.0331941,
        0.9668058,
        0,
        0.0170827,
        0.0723974,
        0.9105199
      );
      LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
        1.2249401,
        -0.2249404,
        0,
        -0.0420569,
        1.0420571,
        0,
        -0.0196376,
        -0.0786361,
        1.0982735
      );
      COLOR_SPACES = {
        [LinearSRGBColorSpace]: {
          transfer: LinearTransfer,
          primaries: Rec709Primaries,
          toReference: (color) => color,
          fromReference: (color) => color
        },
        [SRGBColorSpace]: {
          transfer: SRGBTransfer,
          primaries: Rec709Primaries,
          toReference: (color) => color.convertSRGBToLinear(),
          fromReference: (color) => color.convertLinearToSRGB()
        },
        [LinearDisplayP3ColorSpace]: {
          transfer: LinearTransfer,
          primaries: P3Primaries,
          toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
          fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
        },
        [DisplayP3ColorSpace]: {
          transfer: SRGBTransfer,
          primaries: P3Primaries,
          toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
          fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
        }
      };
      SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
      ColorManagement = {
        enabled: true,
        _workingColorSpace: LinearSRGBColorSpace,
        get legacyMode() {
          console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
          return !this.enabled;
        },
        set legacyMode(legacyMode) {
          console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
          this.enabled = !legacyMode;
        },
        get workingColorSpace() {
          return this._workingColorSpace;
        },
        set workingColorSpace(colorSpace) {
          if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
            throw new Error(`Unsupported working color space, "${colorSpace}".`);
          }
          this._workingColorSpace = colorSpace;
        },
        convert: function(color, sourceColorSpace, targetColorSpace) {
          if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
            return color;
          }
          const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
          const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
          return targetFromReference(sourceToReference(color));
        },
        fromWorkingColorSpace: function(color, targetColorSpace) {
          return this.convert(color, this._workingColorSpace, targetColorSpace);
        },
        toWorkingColorSpace: function(color, sourceColorSpace) {
          return this.convert(color, sourceColorSpace, this._workingColorSpace);
        },
        getPrimaries: function(colorSpace) {
          return COLOR_SPACES[colorSpace].primaries;
        },
        getTransfer: function(colorSpace) {
          if (colorSpace === NoColorSpace)
            return LinearTransfer;
          return COLOR_SPACES[colorSpace].transfer;
        }
      };
      ImageUtils = class {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement === "undefined") {
            return image.src;
          }
          let canvas;
          if (image instanceof HTMLCanvasElement) {
            canvas = image;
          } else {
            if (_canvas === void 0)
              _canvas = createElementNS("canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas;
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas.toDataURL("image/png");
          }
        }
        static sRGBToLinear(image) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const canvas = createElementNS("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            const imageData = context.getImageData(0, 0, image.width, image.height);
            const data = imageData.data;
            for (let i5 = 0; i5 < data.length; i5++) {
              data[i5] = SRGBToLinear(data[i5] / 255) * 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
          } else if (image.data) {
            const data = image.data.slice(0);
            for (let i5 = 0; i5 < data.length; i5++) {
              if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                data[i5] = Math.floor(SRGBToLinear(data[i5] / 255) * 255);
              } else {
                data[i5] = SRGBToLinear(data[i5]);
              }
            }
            return {
              data,
              width: image.width,
              height: image.height
            };
          } else {
            console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
            return image;
          }
        }
      };
      _sourceId = 0;
      Source = class {
        constructor(data = null) {
          this.isSource = true;
          Object.defineProperty(this, "id", { value: _sourceId++ });
          this.uuid = generateUUID();
          this.data = data;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.images[this.uuid] !== void 0) {
            return meta.images[this.uuid];
          }
          const output = {
            uuid: this.uuid,
            url: ""
          };
          const data = this.data;
          if (data !== null) {
            let url;
            if (Array.isArray(data)) {
              url = [];
              for (let i5 = 0, l4 = data.length; i5 < l4; i5++) {
                if (data[i5].isDataTexture) {
                  url.push(serializeImage(data[i5].image));
                } else {
                  url.push(serializeImage(data[i5]));
                }
              }
            } else {
              url = serializeImage(data);
            }
            output.url = url;
          }
          if (!isRootObject) {
            meta.images[this.uuid] = output;
          }
          return output;
        }
      };
      _textureId = 0;
      Texture = class _Texture extends EventDispatcher {
        constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
          super();
          this.isTexture = true;
          Object.defineProperty(this, "id", { value: _textureId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.source = new Source(image);
          this.mipmaps = [];
          this.mapping = mapping;
          this.channel = 0;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format;
          this.internalFormat = null;
          this.type = type;
          this.offset = new Vector2(0, 0);
          this.repeat = new Vector2(1, 1);
          this.center = new Vector2(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix3();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          if (typeof colorSpace === "string") {
            this.colorSpace = colorSpace;
          } else {
            warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
            this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
          }
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
          this.needsPMREMUpdate = false;
        }
        get image() {
          return this.source.data;
        }
        set image(value = null) {
          this.source.data = value;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.source = source.source;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.channel = source.channel;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.colorSpace = source.colorSpace;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          this.needsUpdate = true;
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(meta).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (Object.keys(this.userData).length > 0)
            output.userData = this.userData;
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true) {
            this.version++;
            this.source.needsUpdate = true;
          }
        }
        get encoding() {
          warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
          return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
        }
        set encoding(encoding) {
          warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
          this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
        }
      };
      Texture.DEFAULT_IMAGE = null;
      Texture.DEFAULT_MAPPING = UVMapping;
      Texture.DEFAULT_ANISOTROPY = 1;
      Vector4 = class _Vector4 {
        constructor(x4 = 0, y3 = 0, z4 = 0, w3 = 1) {
          _Vector4.prototype.isVector4 = true;
          this.x = x4;
          this.y = y3;
          this.z = z4;
          this.w = w3;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x4, y3, z4, w3) {
          this.x = x4;
          this.y = y3;
          this.z = z4;
          this.w = w3;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x4) {
          this.x = x4;
          return this;
        }
        setY(y3) {
          this.y = y3;
          return this;
        }
        setZ(z4) {
          this.z = z4;
          return this;
        }
        setW(w3) {
          this.w = w3;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v5) {
          this.x = v5.x;
          this.y = v5.y;
          this.z = v5.z;
          this.w = v5.w !== void 0 ? v5.w : 1;
          return this;
        }
        add(v5) {
          this.x += v5.x;
          this.y += v5.y;
          this.z += v5.z;
          this.w += v5.w;
          return this;
        }
        addScalar(s4) {
          this.x += s4;
          this.y += s4;
          this.z += s4;
          this.w += s4;
          return this;
        }
        addVectors(a4, b3) {
          this.x = a4.x + b3.x;
          this.y = a4.y + b3.y;
          this.z = a4.z + b3.z;
          this.w = a4.w + b3.w;
          return this;
        }
        addScaledVector(v5, s4) {
          this.x += v5.x * s4;
          this.y += v5.y * s4;
          this.z += v5.z * s4;
          this.w += v5.w * s4;
          return this;
        }
        sub(v5) {
          this.x -= v5.x;
          this.y -= v5.y;
          this.z -= v5.z;
          this.w -= v5.w;
          return this;
        }
        subScalar(s4) {
          this.x -= s4;
          this.y -= s4;
          this.z -= s4;
          this.w -= s4;
          return this;
        }
        subVectors(a4, b3) {
          this.x = a4.x - b3.x;
          this.y = a4.y - b3.y;
          this.z = a4.z - b3.z;
          this.w = a4.w - b3.w;
          return this;
        }
        multiply(v5) {
          this.x *= v5.x;
          this.y *= v5.y;
          this.z *= v5.z;
          this.w *= v5.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m4) {
          const x4 = this.x, y3 = this.y, z4 = this.z, w3 = this.w;
          const e4 = m4.elements;
          this.x = e4[0] * x4 + e4[4] * y3 + e4[8] * z4 + e4[12] * w3;
          this.y = e4[1] * x4 + e4[5] * y3 + e4[9] * z4 + e4[13] * w3;
          this.z = e4[2] * x4 + e4[6] * y3 + e4[10] * z4 + e4[14] * w3;
          this.w = e4[3] * x4 + e4[7] * y3 + e4[11] * z4 + e4[15] * w3;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q4) {
          this.w = 2 * Math.acos(q4.w);
          const s4 = Math.sqrt(1 - q4.w * q4.w);
          if (s4 < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q4.x / s4;
            this.y = q4.y / s4;
            this.z = q4.z / s4;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m4) {
          let angle2, x4, y3, z4;
          const epsilon = 0.01, epsilon2 = 0.1, te3 = m4.elements, m11 = te3[0], m12 = te3[4], m13 = te3[8], m21 = te3[1], m22 = te3[5], m23 = te3[9], m31 = te3[2], m32 = te3[6], m33 = te3[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle2 = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x4 = 0;
                y3 = 0.707106781;
                z4 = 0.707106781;
              } else {
                x4 = Math.sqrt(xx);
                y3 = xy / x4;
                z4 = xz / x4;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x4 = 0.707106781;
                y3 = 0;
                z4 = 0.707106781;
              } else {
                y3 = Math.sqrt(yy);
                x4 = xy / y3;
                z4 = yz / y3;
              }
            } else {
              if (zz < epsilon) {
                x4 = 0.707106781;
                y3 = 0.707106781;
                z4 = 0;
              } else {
                z4 = Math.sqrt(zz);
                x4 = xz / z4;
                y3 = yz / z4;
              }
            }
            this.set(x4, y3, z4, angle2);
            return this;
          }
          let s4 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s4) < 1e-3)
            s4 = 1;
          this.x = (m32 - m23) / s4;
          this.y = (m13 - m31) / s4;
          this.z = (m21 - m12) / s4;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v5) {
          this.x = Math.min(this.x, v5.x);
          this.y = Math.min(this.y, v5.y);
          this.z = Math.min(this.z, v5.z);
          this.w = Math.min(this.w, v5.w);
          return this;
        }
        max(v5) {
          this.x = Math.max(this.x, v5.x);
          this.y = Math.max(this.y, v5.y);
          this.z = Math.max(this.z, v5.z);
          this.w = Math.max(this.w, v5.w);
          return this;
        }
        clamp(min, max2) {
          this.x = Math.max(min.x, Math.min(max2.x, this.x));
          this.y = Math.max(min.y, Math.min(max2.y, this.y));
          this.z = Math.max(min.z, Math.min(max2.z, this.z));
          this.w = Math.max(min.w, Math.min(max2.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max2) {
          const length3 = this.length();
          return this.divideScalar(length3 || 1).multiplyScalar(Math.max(min, Math.min(max2, length3)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = Math.trunc(this.x);
          this.y = Math.trunc(this.y);
          this.z = Math.trunc(this.z);
          this.w = Math.trunc(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v5) {
          return this.x * v5.x + this.y * v5.y + this.z * v5.z + this.w * v5.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length3) {
          return this.normalize().multiplyScalar(length3);
        }
        lerp(v5, alpha) {
          this.x += (v5.x - this.x) * alpha;
          this.y += (v5.y - this.y) * alpha;
          this.z += (v5.z - this.z) * alpha;
          this.w += (v5.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v22, alpha) {
          this.x = v1.x + (v22.x - v1.x) * alpha;
          this.y = v1.y + (v22.y - v1.y) * alpha;
          this.z = v1.z + (v22.z - v1.z) * alpha;
          this.w = v1.w + (v22.w - v1.w) * alpha;
          return this;
        }
        equals(v5) {
          return v5.x === this.x && v5.y === this.y && v5.z === this.z && v5.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      };
      RenderTarget = class extends EventDispatcher {
        constructor(width = 1, height = 1, options = {}) {
          super();
          this.isRenderTarget = true;
          this.width = width;
          this.height = height;
          this.depth = 1;
          this.scissor = new Vector4(0, 0, width, height);
          this.scissorTest = false;
          this.viewport = new Vector4(0, 0, width, height);
          const image = { width, height, depth: 1 };
          if (options.encoding !== void 0) {
            warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.");
            options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
          }
          options = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: LinearFilter,
            depthBuffer: true,
            stencilBuffer: false,
            depthTexture: null,
            samples: 0
          }, options);
          this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
          this.texture.isRenderTargetTexture = true;
          this.texture.flipY = false;
          this.texture.generateMipmaps = options.generateMipmaps;
          this.texture.internalFormat = options.internalFormat;
          this.depthBuffer = options.depthBuffer;
          this.stencilBuffer = options.stencilBuffer;
          this.depthTexture = options.depthTexture;
          this.samples = options.samples;
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.scissor.copy(source.scissor);
          this.scissorTest = source.scissorTest;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.isRenderTargetTexture = true;
          const image = Object.assign({}, source.texture.image);
          this.texture.source = new Source(image);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          if (source.depthTexture !== null)
            this.depthTexture = source.depthTexture.clone();
          this.samples = source.samples;
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      WebGLRenderTarget = class extends RenderTarget {
        constructor(width = 1, height = 1, options = {}) {
          super(width, height, options);
          this.isWebGLRenderTarget = true;
        }
      };
      DataArrayTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.isDataArrayTexture = true;
          this.image = { data, width, height, depth };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      Data3DTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.isData3DTexture = true;
          this.image = { data, width, height, depth };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      Quaternion = class {
        constructor(x4 = 0, y3 = 0, z4 = 0, w3 = 1) {
          this.isQuaternion = true;
          this._x = x4;
          this._y = y3;
          this._z = z4;
          this._w = w3;
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t4) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t4 === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t4 === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s4 = 1 - t4;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len2 = Math.atan2(sin, cos * dir);
              s4 = Math.sin(s4 * len2) / sin;
              t4 = Math.sin(t4 * len2) / sin;
            }
            const tDir = t4 * dir;
            x0 = x0 * s4 + x1 * tDir;
            y0 = y0 * s4 + y1 * tDir;
            z0 = z0 * s4 + z1 * tDir;
            w0 = w0 * s4 + w1 * tDir;
            if (s4 === 1 - t4) {
              const f3 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f3;
              y0 *= f3;
              z0 *= f3;
              w0 *= f3;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x4, y3, z4, w3) {
          this._x = x4;
          this._y = y3;
          this._z = z4;
          this._w = w3;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          const x4 = euler._x, y3 = euler._y, z4 = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x4 / 2);
          const c22 = cos(y3 / 2);
          const c32 = cos(z4 / 2);
          const s1 = sin(x4 / 2);
          const s22 = sin(y3 / 2);
          const s32 = sin(z4 / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c22 * c32 + c1 * s22 * s32;
              this._y = c1 * s22 * c32 - s1 * c22 * s32;
              this._z = c1 * c22 * s32 + s1 * s22 * c32;
              this._w = c1 * c22 * c32 - s1 * s22 * s32;
              break;
            case "YXZ":
              this._x = s1 * c22 * c32 + c1 * s22 * s32;
              this._y = c1 * s22 * c32 - s1 * c22 * s32;
              this._z = c1 * c22 * s32 - s1 * s22 * c32;
              this._w = c1 * c22 * c32 + s1 * s22 * s32;
              break;
            case "ZXY":
              this._x = s1 * c22 * c32 - c1 * s22 * s32;
              this._y = c1 * s22 * c32 + s1 * c22 * s32;
              this._z = c1 * c22 * s32 + s1 * s22 * c32;
              this._w = c1 * c22 * c32 - s1 * s22 * s32;
              break;
            case "ZYX":
              this._x = s1 * c22 * c32 - c1 * s22 * s32;
              this._y = c1 * s22 * c32 + s1 * c22 * s32;
              this._z = c1 * c22 * s32 - s1 * s22 * c32;
              this._w = c1 * c22 * c32 + s1 * s22 * s32;
              break;
            case "YZX":
              this._x = s1 * c22 * c32 + c1 * s22 * s32;
              this._y = c1 * s22 * c32 + s1 * c22 * s32;
              this._z = c1 * c22 * s32 - s1 * s22 * c32;
              this._w = c1 * c22 * c32 - s1 * s22 * s32;
              break;
            case "XZY":
              this._x = s1 * c22 * c32 - c1 * s22 * s32;
              this._y = c1 * s22 * c32 - s1 * c22 * s32;
              this._z = c1 * c22 * s32 + s1 * s22 * c32;
              this._w = c1 * c22 * c32 + s1 * s22 * s32;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle2) {
          const halfAngle = angle2 / 2, s4 = Math.sin(halfAngle);
          this._x = axis.x * s4;
          this._y = axis.y * s4;
          this._z = axis.z * s4;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m4) {
          const te3 = m4.elements, m11 = te3[0], m12 = te3[4], m13 = te3[8], m21 = te3[1], m22 = te3[5], m23 = te3[9], m31 = te3[2], m32 = te3[6], m33 = te3[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s4 = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s4;
            this._x = (m32 - m23) * s4;
            this._y = (m13 - m31) * s4;
            this._z = (m21 - m12) * s4;
          } else if (m11 > m22 && m11 > m33) {
            const s4 = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s4;
            this._x = 0.25 * s4;
            this._y = (m12 + m21) / s4;
            this._z = (m13 + m31) / s4;
          } else if (m22 > m33) {
            const s4 = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s4;
            this._x = (m12 + m21) / s4;
            this._y = 0.25 * s4;
            this._z = (m23 + m32) / s4;
          } else {
            const s4 = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s4;
            this._x = (m13 + m31) / s4;
            this._y = (m23 + m32) / s4;
            this._z = 0.25 * s4;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r4 = vFrom.dot(vTo) + 1;
          if (r4 < Number.EPSILON) {
            r4 = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r4;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r4;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r4;
          }
          return this.normalize();
        }
        angleTo(q4) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(q4), -1, 1)));
        }
        rotateTowards(q4, step) {
          const angle2 = this.angleTo(q4);
          if (angle2 === 0)
            return this;
          const t4 = Math.min(1, step / angle2);
          this.slerp(q4, t4);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v5) {
          return this._x * v5._x + this._y * v5._y + this._z * v5._z + this._w * v5._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l4 = this.length();
          if (l4 === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l4 = 1 / l4;
            this._x = this._x * l4;
            this._y = this._y * l4;
            this._z = this._z * l4;
            this._w = this._w * l4;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q4) {
          return this.multiplyQuaternions(this, q4);
        }
        premultiply(q4) {
          return this.multiplyQuaternions(q4, this);
        }
        multiplyQuaternions(a4, b3) {
          const qax = a4._x, qay = a4._y, qaz = a4._z, qaw = a4._w;
          const qbx = b3._x, qby = b3._y, qbz = b3._z, qbw = b3._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb2, t4) {
          if (t4 === 0)
            return this;
          if (t4 === 1)
            return this.copy(qb2);
          const x4 = this._x, y3 = this._y, z4 = this._z, w3 = this._w;
          let cosHalfTheta = w3 * qb2._w + x4 * qb2._x + y3 * qb2._y + z4 * qb2._z;
          if (cosHalfTheta < 0) {
            this._w = -qb2._w;
            this._x = -qb2._x;
            this._y = -qb2._y;
            this._z = -qb2._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb2);
          }
          if (cosHalfTheta >= 1) {
            this._w = w3;
            this._x = x4;
            this._y = y3;
            this._z = z4;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s4 = 1 - t4;
            this._w = s4 * w3 + t4 * this._w;
            this._x = s4 * x4 + t4 * this._x;
            this._y = s4 * y3 + t4 * this._y;
            this._z = s4 * z4 + t4 * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t4) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t4 * halfTheta) / sinHalfTheta;
          this._w = w3 * ratioA + this._w * ratioB;
          this._x = x4 * ratioA + this._x * ratioB;
          this._y = y3 * ratioA + this._y * ratioB;
          this._z = z4 * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa3, qb2, t4) {
          return this.copy(qa3).slerp(qb2, t4);
        }
        random() {
          const u1 = Math.random();
          const sqrt1u1 = Math.sqrt(1 - u1);
          const sqrtu1 = Math.sqrt(u1);
          const u22 = 2 * Math.PI * Math.random();
          const u33 = 2 * Math.PI * Math.random();
          return this.set(
            sqrt1u1 * Math.cos(u22),
            sqrtu1 * Math.sin(u33),
            sqrtu1 * Math.cos(u33),
            sqrt1u1 * Math.sin(u22)
          );
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);
          return this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x;
          yield this._y;
          yield this._z;
          yield this._w;
        }
      };
      Vector3 = class _Vector3 {
        constructor(x4 = 0, y3 = 0, z4 = 0) {
          _Vector3.prototype.isVector3 = true;
          this.x = x4;
          this.y = y3;
          this.z = z4;
        }
        set(x4, y3, z4) {
          if (z4 === void 0)
            z4 = this.z;
          this.x = x4;
          this.y = y3;
          this.z = z4;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x4) {
          this.x = x4;
          return this;
        }
        setY(y3) {
          this.y = y3;
          return this;
        }
        setZ(z4) {
          this.z = z4;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v5) {
          this.x = v5.x;
          this.y = v5.y;
          this.z = v5.z;
          return this;
        }
        add(v5) {
          this.x += v5.x;
          this.y += v5.y;
          this.z += v5.z;
          return this;
        }
        addScalar(s4) {
          this.x += s4;
          this.y += s4;
          this.z += s4;
          return this;
        }
        addVectors(a4, b3) {
          this.x = a4.x + b3.x;
          this.y = a4.y + b3.y;
          this.z = a4.z + b3.z;
          return this;
        }
        addScaledVector(v5, s4) {
          this.x += v5.x * s4;
          this.y += v5.y * s4;
          this.z += v5.z * s4;
          return this;
        }
        sub(v5) {
          this.x -= v5.x;
          this.y -= v5.y;
          this.z -= v5.z;
          return this;
        }
        subScalar(s4) {
          this.x -= s4;
          this.y -= s4;
          this.z -= s4;
          return this;
        }
        subVectors(a4, b3) {
          this.x = a4.x - b3.x;
          this.y = a4.y - b3.y;
          this.z = a4.z - b3.z;
          return this;
        }
        multiply(v5) {
          this.x *= v5.x;
          this.y *= v5.y;
          this.z *= v5.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a4, b3) {
          this.x = a4.x * b3.x;
          this.y = a4.y * b3.y;
          this.z = a4.z * b3.z;
          return this;
        }
        applyEuler(euler) {
          return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle2) {
          return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle2));
        }
        applyMatrix3(m4) {
          const x4 = this.x, y3 = this.y, z4 = this.z;
          const e4 = m4.elements;
          this.x = e4[0] * x4 + e4[3] * y3 + e4[6] * z4;
          this.y = e4[1] * x4 + e4[4] * y3 + e4[7] * z4;
          this.z = e4[2] * x4 + e4[5] * y3 + e4[8] * z4;
          return this;
        }
        applyNormalMatrix(m4) {
          return this.applyMatrix3(m4).normalize();
        }
        applyMatrix4(m4) {
          const x4 = this.x, y3 = this.y, z4 = this.z;
          const e4 = m4.elements;
          const w3 = 1 / (e4[3] * x4 + e4[7] * y3 + e4[11] * z4 + e4[15]);
          this.x = (e4[0] * x4 + e4[4] * y3 + e4[8] * z4 + e4[12]) * w3;
          this.y = (e4[1] * x4 + e4[5] * y3 + e4[9] * z4 + e4[13]) * w3;
          this.z = (e4[2] * x4 + e4[6] * y3 + e4[10] * z4 + e4[14]) * w3;
          return this;
        }
        applyQuaternion(q4) {
          const vx = this.x, vy = this.y, vz = this.z;
          const qx = q4.x, qy = q4.y, qz = q4.z, qw2 = q4.w;
          const tx = 2 * (qy * vz - qz * vy);
          const ty2 = 2 * (qz * vx - qx * vz);
          const tz = 2 * (qx * vy - qy * vx);
          this.x = vx + qw2 * tx + qy * tz - qz * ty2;
          this.y = vy + qw2 * ty2 + qz * tx - qx * tz;
          this.z = vz + qw2 * tz + qx * ty2 - qy * tx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m4) {
          const x4 = this.x, y3 = this.y, z4 = this.z;
          const e4 = m4.elements;
          this.x = e4[0] * x4 + e4[4] * y3 + e4[8] * z4;
          this.y = e4[1] * x4 + e4[5] * y3 + e4[9] * z4;
          this.z = e4[2] * x4 + e4[6] * y3 + e4[10] * z4;
          return this.normalize();
        }
        divide(v5) {
          this.x /= v5.x;
          this.y /= v5.y;
          this.z /= v5.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v5) {
          this.x = Math.min(this.x, v5.x);
          this.y = Math.min(this.y, v5.y);
          this.z = Math.min(this.z, v5.z);
          return this;
        }
        max(v5) {
          this.x = Math.max(this.x, v5.x);
          this.y = Math.max(this.y, v5.y);
          this.z = Math.max(this.z, v5.z);
          return this;
        }
        clamp(min, max2) {
          this.x = Math.max(min.x, Math.min(max2.x, this.x));
          this.y = Math.max(min.y, Math.min(max2.y, this.y));
          this.z = Math.max(min.z, Math.min(max2.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max2) {
          const length3 = this.length();
          return this.divideScalar(length3 || 1).multiplyScalar(Math.max(min, Math.min(max2, length3)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = Math.trunc(this.x);
          this.y = Math.trunc(this.y);
          this.z = Math.trunc(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v5) {
          return this.x * v5.x + this.y * v5.y + this.z * v5.z;
        }
        // TODO lengthSquared?
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length3) {
          return this.normalize().multiplyScalar(length3);
        }
        lerp(v5, alpha) {
          this.x += (v5.x - this.x) * alpha;
          this.y += (v5.y - this.y) * alpha;
          this.z += (v5.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v22, alpha) {
          this.x = v1.x + (v22.x - v1.x) * alpha;
          this.y = v1.y + (v22.y - v1.y) * alpha;
          this.z = v1.z + (v22.z - v1.z) * alpha;
          return this;
        }
        cross(v5) {
          return this.crossVectors(this, v5);
        }
        crossVectors(a4, b3) {
          const ax = a4.x, ay = a4.y, az = a4.z;
          const bx = b3.x, by = b3.y, bz = b3.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v5) {
          const denominator = v5.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v5.dot(this) / denominator;
          return this.copy(v5).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$b.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$b);
        }
        reflect(normal) {
          return this.sub(_vector$b.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v5) {
          const denominator = Math.sqrt(this.lengthSq() * v5.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v5) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v5) {
          return Math.sqrt(this.distanceToSquared(v5));
        }
        distanceToSquared(v5) {
          const dx = this.x - v5.x, dy = this.y - v5.y, dz = this.z - v5.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v5) {
          return Math.abs(this.x - v5.x) + Math.abs(this.y - v5.y) + Math.abs(this.z - v5.z);
        }
        setFromSpherical(s4) {
          return this.setFromSphericalCoords(s4.radius, s4.phi, s4.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c5) {
          return this.setFromCylindricalCoords(c5.radius, c5.theta, c5.y);
        }
        setFromCylindricalCoords(radius, theta, y3) {
          this.x = radius * Math.sin(theta);
          this.y = y3;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m4) {
          const e4 = m4.elements;
          this.x = e4[12];
          this.y = e4[13];
          this.z = e4[14];
          return this;
        }
        setFromMatrixScale(m4) {
          const sx = this.setFromMatrixColumn(m4, 0).length();
          const sy = this.setFromMatrixColumn(m4, 1).length();
          const sz = this.setFromMatrixColumn(m4, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m4, index) {
          return this.fromArray(m4.elements, index * 4);
        }
        setFromMatrix3Column(m4, index) {
          return this.fromArray(m4.elements, index * 3);
        }
        setFromEuler(e4) {
          this.x = e4._x;
          this.y = e4._y;
          this.z = e4._z;
          return this;
        }
        setFromColor(c5) {
          this.x = c5.r;
          this.y = c5.g;
          this.z = c5.b;
          return this;
        }
        equals(v5) {
          return v5.x === this.x && v5.y === this.y && v5.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const u4 = (Math.random() - 0.5) * 2;
          const t4 = Math.random() * Math.PI * 2;
          const f3 = Math.sqrt(1 - u4 ** 2);
          this.x = f3 * Math.cos(t4);
          this.y = f3 * Math.sin(t4);
          this.z = u4;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      };
      _vector$b = /* @__PURE__ */ new Vector3();
      _quaternion$4 = /* @__PURE__ */ new Quaternion();
      Box3 = class {
        constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
          this.isBox3 = true;
          this.min = min;
          this.max = max2;
        }
        set(min, max2) {
          this.min.copy(min);
          this.max.copy(max2);
          return this;
        }
        setFromArray(array) {
          this.makeEmpty();
          for (let i5 = 0, il3 = array.length; i5 < il3; i5 += 3) {
            this.expandByPoint(_vector$a.fromArray(array, i5));
          }
          return this;
        }
        setFromBufferAttribute(attribute) {
          this.makeEmpty();
          for (let i5 = 0, il3 = attribute.count; i5 < il3; i5++) {
            this.expandByPoint(_vector$a.fromBufferAttribute(attribute, i5));
          }
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i5 = 0, il3 = points.length; i5 < il3; i5++) {
            this.expandByPoint(points[i5]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$a.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object, precise = false) {
          this.makeEmpty();
          return this.expandByObject(object, precise);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object, precise = false) {
          object.updateWorldMatrix(false, false);
          const geometry = object.geometry;
          if (geometry !== void 0) {
            const positionAttribute = geometry.getAttribute("position");
            if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
              for (let i5 = 0, l4 = positionAttribute.count; i5 < l4; i5++) {
                if (object.isMesh === true) {
                  object.getVertexPosition(i5, _vector$a);
                } else {
                  _vector$a.fromBufferAttribute(positionAttribute, i5);
                }
                _vector$a.applyMatrix4(object.matrixWorld);
                this.expandByPoint(_vector$a);
              }
            } else {
              if (object.boundingBox !== void 0) {
                if (object.boundingBox === null) {
                  object.computeBoundingBox();
                }
                _box$3.copy(object.boundingBox);
              } else {
                if (geometry.boundingBox === null) {
                  geometry.computeBoundingBox();
                }
                _box$3.copy(geometry.boundingBox);
              }
              _box$3.applyMatrix4(object.matrixWorld);
              this.union(_box$3);
            }
          }
          const children = object.children;
          for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
            this.expandByObject(children[i5], precise);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set(
            (point.x - this.min.x) / (this.max.x - this.min.x),
            (point.y - this.min.y) / (this.max.y - this.min.y),
            (point.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$a);
          return _vector$a.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max2;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max2 = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max2 = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max2 += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max2 += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max2 += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max2 += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max2 >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);
          _v0$2.subVectors(triangle.a, _center);
          _v1$7.subVectors(triangle.b, _center);
          _v2$4.subVectors(triangle.c, _center);
          _f0.subVectors(_v1$7, _v0$2);
          _f1.subVectors(_v2$4, _v1$7);
          _f2.subVectors(_v0$2, _v2$4);
          let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
          ];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
            return false;
          }
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
          return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          return this.clampPoint(point, _vector$a).distanceTo(point);
        }
        getBoundingSphere(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
          } else {
            this.getCenter(target.center);
            target.radius = this.getSize(_vector$a).length() * 0.5;
          }
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      _points = [
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3()
      ];
      _vector$a = /* @__PURE__ */ new Vector3();
      _box$3 = /* @__PURE__ */ new Box3();
      _v0$2 = /* @__PURE__ */ new Vector3();
      _v1$7 = /* @__PURE__ */ new Vector3();
      _v2$4 = /* @__PURE__ */ new Vector3();
      _f0 = /* @__PURE__ */ new Vector3();
      _f1 = /* @__PURE__ */ new Vector3();
      _f2 = /* @__PURE__ */ new Vector3();
      _center = /* @__PURE__ */ new Vector3();
      _extents = /* @__PURE__ */ new Vector3();
      _triangleNormal = /* @__PURE__ */ new Vector3();
      _testAxis = /* @__PURE__ */ new Vector3();
      _box$2 = /* @__PURE__ */ new Box3();
      _v1$6 = /* @__PURE__ */ new Vector3();
      _v2$3 = /* @__PURE__ */ new Vector3();
      Sphere = class {
        constructor(center = new Vector3(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$2.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i5 = 0, il3 = points.length; i5 < il3; i5++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i5]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          if (this.isEmpty()) {
            this.center.copy(point);
            this.radius = 0;
            return this;
          }
          _v1$6.subVectors(point, this.center);
          const lengthSq = _v1$6.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length3 = Math.sqrt(lengthSq);
            const delta = (length3 - this.radius) * 0.5;
            this.center.addScaledVector(_v1$6, delta / length3);
            this.radius += delta;
          }
          return this;
        }
        union(sphere) {
          if (sphere.isEmpty()) {
            return this;
          }
          if (this.isEmpty()) {
            this.copy(sphere);
            return this;
          }
          if (this.center.equals(sphere.center) === true) {
            this.radius = Math.max(this.radius, sphere.radius);
          } else {
            _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
            this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
            this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
          }
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$9 = /* @__PURE__ */ new Vector3();
      _segCenter = /* @__PURE__ */ new Vector3();
      _segDir = /* @__PURE__ */ new Vector3();
      _diff = /* @__PURE__ */ new Vector3();
      _edge1 = /* @__PURE__ */ new Vector3();
      _edge2 = /* @__PURE__ */ new Vector3();
      _normal$1 = /* @__PURE__ */ new Vector3();
      Ray = class {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t4, target) {
          return target.copy(this.origin).addScaledVector(this.direction, t4);
        }
        lookAt(v5) {
          this.direction.copy(v5).sub(this.origin).normalize();
          return this;
        }
        recast(t4) {
          this.origin.copy(this.at(t4, _vector$9));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$9.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$9.copy(this.origin).addScaledVector(this.direction, directionDistance);
          return _vector$9.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c5 = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c5;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c5;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c5;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c5;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c5;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c5;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c5;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$9.subVectors(sphere.center, this.origin);
          const tca = _vector$9.dot(this.direction);
          const d22 = _vector$9.dot(_vector$9) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d22 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d22);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t4 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t4 >= 0 ? t4 : null;
        }
        intersectPlane(plane, target) {
          const t4 = this.distanceToPlane(plane);
          if (t4 === null) {
            return null;
          }
          return this.at(t4, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || isNaN(tmin))
            tmin = tymin;
          if (tymax < tmax || isNaN(tmax))
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$9) !== null;
        }
        intersectTriangle(a4, b3, c5, backfaceCulling, target) {
          _edge1.subVectors(b3, a4);
          _edge2.subVectors(c5, a4);
          _normal$1.crossVectors(_edge1, _edge2);
          let DdN = this.direction.dot(_normal$1);
          let sign;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign = 1;
          } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff.subVectors(this.origin, a4);
          const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign * _diff.dot(_normal$1);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Matrix4 = class _Matrix4 {
        constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          _Matrix4.prototype.isMatrix4 = true;
          this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ];
          if (n11 !== void 0) {
            this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
          }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te3 = this.elements;
          te3[0] = n11;
          te3[4] = n12;
          te3[8] = n13;
          te3[12] = n14;
          te3[1] = n21;
          te3[5] = n22;
          te3[9] = n23;
          te3[13] = n24;
          te3[2] = n31;
          te3[6] = n32;
          te3[10] = n33;
          te3[14] = n34;
          te3[3] = n41;
          te3[7] = n42;
          te3[11] = n43;
          te3[15] = n44;
          return this;
        }
        identity() {
          this.set(
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        clone() {
          return new _Matrix4().fromArray(this.elements);
        }
        copy(m4) {
          const te3 = this.elements;
          const me4 = m4.elements;
          te3[0] = me4[0];
          te3[1] = me4[1];
          te3[2] = me4[2];
          te3[3] = me4[3];
          te3[4] = me4[4];
          te3[5] = me4[5];
          te3[6] = me4[6];
          te3[7] = me4[7];
          te3[8] = me4[8];
          te3[9] = me4[9];
          te3[10] = me4[10];
          te3[11] = me4[11];
          te3[12] = me4[12];
          te3[13] = me4[13];
          te3[14] = me4[14];
          te3[15] = me4[15];
          return this;
        }
        copyPosition(m4) {
          const te3 = this.elements, me4 = m4.elements;
          te3[12] = me4[12];
          te3[13] = me4[13];
          te3[14] = me4[14];
          return this;
        }
        setFromMatrix3(m4) {
          const me4 = m4.elements;
          this.set(
            me4[0],
            me4[3],
            me4[6],
            0,
            me4[1],
            me4[4],
            me4[7],
            0,
            me4[2],
            me4[5],
            me4[8],
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(
            xAxis.x,
            yAxis.x,
            zAxis.x,
            0,
            xAxis.y,
            yAxis.y,
            zAxis.y,
            0,
            xAxis.z,
            yAxis.z,
            zAxis.z,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        extractRotation(m4) {
          const te3 = this.elements;
          const me4 = m4.elements;
          const scaleX = 1 / _v1$5.setFromMatrixColumn(m4, 0).length();
          const scaleY = 1 / _v1$5.setFromMatrixColumn(m4, 1).length();
          const scaleZ = 1 / _v1$5.setFromMatrixColumn(m4, 2).length();
          te3[0] = me4[0] * scaleX;
          te3[1] = me4[1] * scaleX;
          te3[2] = me4[2] * scaleX;
          te3[3] = 0;
          te3[4] = me4[4] * scaleY;
          te3[5] = me4[5] * scaleY;
          te3[6] = me4[6] * scaleY;
          te3[7] = 0;
          te3[8] = me4[8] * scaleZ;
          te3[9] = me4[9] * scaleZ;
          te3[10] = me4[10] * scaleZ;
          te3[11] = 0;
          te3[12] = 0;
          te3[13] = 0;
          te3[14] = 0;
          te3[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          const te3 = this.elements;
          const x4 = euler.x, y3 = euler.y, z4 = euler.z;
          const a4 = Math.cos(x4), b3 = Math.sin(x4);
          const c5 = Math.cos(y3), d4 = Math.sin(y3);
          const e4 = Math.cos(z4), f3 = Math.sin(z4);
          if (euler.order === "XYZ") {
            const ae4 = a4 * e4, af2 = a4 * f3, be5 = b3 * e4, bf2 = b3 * f3;
            te3[0] = c5 * e4;
            te3[4] = -c5 * f3;
            te3[8] = d4;
            te3[1] = af2 + be5 * d4;
            te3[5] = ae4 - bf2 * d4;
            te3[9] = -b3 * c5;
            te3[2] = bf2 - ae4 * d4;
            te3[6] = be5 + af2 * d4;
            te3[10] = a4 * c5;
          } else if (euler.order === "YXZ") {
            const ce6 = c5 * e4, cf2 = c5 * f3, de3 = d4 * e4, df2 = d4 * f3;
            te3[0] = ce6 + df2 * b3;
            te3[4] = de3 * b3 - cf2;
            te3[8] = a4 * d4;
            te3[1] = a4 * f3;
            te3[5] = a4 * e4;
            te3[9] = -b3;
            te3[2] = cf2 * b3 - de3;
            te3[6] = df2 + ce6 * b3;
            te3[10] = a4 * c5;
          } else if (euler.order === "ZXY") {
            const ce6 = c5 * e4, cf2 = c5 * f3, de3 = d4 * e4, df2 = d4 * f3;
            te3[0] = ce6 - df2 * b3;
            te3[4] = -a4 * f3;
            te3[8] = de3 + cf2 * b3;
            te3[1] = cf2 + de3 * b3;
            te3[5] = a4 * e4;
            te3[9] = df2 - ce6 * b3;
            te3[2] = -a4 * d4;
            te3[6] = b3;
            te3[10] = a4 * c5;
          } else if (euler.order === "ZYX") {
            const ae4 = a4 * e4, af2 = a4 * f3, be5 = b3 * e4, bf2 = b3 * f3;
            te3[0] = c5 * e4;
            te3[4] = be5 * d4 - af2;
            te3[8] = ae4 * d4 + bf2;
            te3[1] = c5 * f3;
            te3[5] = bf2 * d4 + ae4;
            te3[9] = af2 * d4 - be5;
            te3[2] = -d4;
            te3[6] = b3 * c5;
            te3[10] = a4 * c5;
          } else if (euler.order === "YZX") {
            const ac2 = a4 * c5, ad2 = a4 * d4, bc3 = b3 * c5, bd3 = b3 * d4;
            te3[0] = c5 * e4;
            te3[4] = bd3 - ac2 * f3;
            te3[8] = bc3 * f3 + ad2;
            te3[1] = f3;
            te3[5] = a4 * e4;
            te3[9] = -b3 * e4;
            te3[2] = -d4 * e4;
            te3[6] = ad2 * f3 + bc3;
            te3[10] = ac2 - bd3 * f3;
          } else if (euler.order === "XZY") {
            const ac2 = a4 * c5, ad2 = a4 * d4, bc3 = b3 * c5, bd3 = b3 * d4;
            te3[0] = c5 * e4;
            te3[4] = -f3;
            te3[8] = d4 * e4;
            te3[1] = ac2 * f3 + bd3;
            te3[5] = a4 * e4;
            te3[9] = ad2 * f3 - bc3;
            te3[2] = bc3 * f3 - ad2;
            te3[6] = b3 * e4;
            te3[10] = bd3 * f3 + ac2;
          }
          te3[3] = 0;
          te3[7] = 0;
          te3[11] = 0;
          te3[12] = 0;
          te3[13] = 0;
          te3[14] = 0;
          te3[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q4) {
          return this.compose(_zero, q4, _one);
        }
        lookAt(eye, target, up2) {
          const te3 = this.elements;
          _z.subVectors(eye, target);
          if (_z.lengthSq() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up2, _z);
          if (_x.lengthSq() === 0) {
            if (Math.abs(up2.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up2, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          te3[0] = _x.x;
          te3[4] = _y.x;
          te3[8] = _z.x;
          te3[1] = _x.y;
          te3[5] = _y.y;
          te3[9] = _z.y;
          te3[2] = _x.z;
          te3[6] = _y.z;
          te3[10] = _z.z;
          return this;
        }
        multiply(m4) {
          return this.multiplyMatrices(this, m4);
        }
        premultiply(m4) {
          return this.multiplyMatrices(m4, this);
        }
        multiplyMatrices(a4, b3) {
          const ae4 = a4.elements;
          const be5 = b3.elements;
          const te3 = this.elements;
          const a11 = ae4[0], a12 = ae4[4], a13 = ae4[8], a14 = ae4[12];
          const a21 = ae4[1], a22 = ae4[5], a23 = ae4[9], a24 = ae4[13];
          const a31 = ae4[2], a32 = ae4[6], a33 = ae4[10], a34 = ae4[14];
          const a41 = ae4[3], a42 = ae4[7], a43 = ae4[11], a44 = ae4[15];
          const b11 = be5[0], b12 = be5[4], b13 = be5[8], b14 = be5[12];
          const b21 = be5[1], b22 = be5[5], b23 = be5[9], b24 = be5[13];
          const b31 = be5[2], b32 = be5[6], b33 = be5[10], b34 = be5[14];
          const b41 = be5[3], b42 = be5[7], b43 = be5[11], b44 = be5[15];
          te3[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te3[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te3[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te3[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te3[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te3[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te3[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te3[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te3[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te3[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te3[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te3[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te3[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te3[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te3[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te3[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s4) {
          const te3 = this.elements;
          te3[0] *= s4;
          te3[4] *= s4;
          te3[8] *= s4;
          te3[12] *= s4;
          te3[1] *= s4;
          te3[5] *= s4;
          te3[9] *= s4;
          te3[13] *= s4;
          te3[2] *= s4;
          te3[6] *= s4;
          te3[10] *= s4;
          te3[14] *= s4;
          te3[3] *= s4;
          te3[7] *= s4;
          te3[11] *= s4;
          te3[15] *= s4;
          return this;
        }
        determinant() {
          const te3 = this.elements;
          const n11 = te3[0], n12 = te3[4], n13 = te3[8], n14 = te3[12];
          const n21 = te3[1], n22 = te3[5], n23 = te3[9], n24 = te3[13];
          const n31 = te3[2], n32 = te3[6], n33 = te3[10], n34 = te3[14];
          const n41 = te3[3], n42 = te3[7], n43 = te3[11], n44 = te3[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te3 = this.elements;
          let tmp;
          tmp = te3[1];
          te3[1] = te3[4];
          te3[4] = tmp;
          tmp = te3[2];
          te3[2] = te3[8];
          te3[8] = tmp;
          tmp = te3[6];
          te3[6] = te3[9];
          te3[9] = tmp;
          tmp = te3[3];
          te3[3] = te3[12];
          te3[12] = tmp;
          tmp = te3[7];
          te3[7] = te3[13];
          te3[13] = tmp;
          tmp = te3[11];
          te3[11] = te3[14];
          te3[14] = tmp;
          return this;
        }
        setPosition(x4, y3, z4) {
          const te3 = this.elements;
          if (x4.isVector3) {
            te3[12] = x4.x;
            te3[13] = x4.y;
            te3[14] = x4.z;
          } else {
            te3[12] = x4;
            te3[13] = y3;
            te3[14] = z4;
          }
          return this;
        }
        invert() {
          const te3 = this.elements, n11 = te3[0], n21 = te3[1], n31 = te3[2], n41 = te3[3], n12 = te3[4], n22 = te3[5], n32 = te3[6], n42 = te3[7], n13 = te3[8], n23 = te3[9], n33 = te3[10], n43 = te3[11], n14 = te3[12], n24 = te3[13], n34 = te3[14], n44 = te3[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te3[0] = t11 * detInv;
          te3[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te3[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te3[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te3[4] = t12 * detInv;
          te3[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te3[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te3[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te3[8] = t13 * detInv;
          te3[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te3[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te3[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te3[12] = t14 * detInv;
          te3[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te3[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te3[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v5) {
          const te3 = this.elements;
          const x4 = v5.x, y3 = v5.y, z4 = v5.z;
          te3[0] *= x4;
          te3[4] *= y3;
          te3[8] *= z4;
          te3[1] *= x4;
          te3[5] *= y3;
          te3[9] *= z4;
          te3[2] *= x4;
          te3[6] *= y3;
          te3[10] *= z4;
          te3[3] *= x4;
          te3[7] *= y3;
          te3[11] *= z4;
          return this;
        }
        getMaxScaleOnAxis() {
          const te3 = this.elements;
          const scaleXSq = te3[0] * te3[0] + te3[1] * te3[1] + te3[2] * te3[2];
          const scaleYSq = te3[4] * te3[4] + te3[5] * te3[5] + te3[6] * te3[6];
          const scaleZSq = te3[8] * te3[8] + te3[9] * te3[9] + te3[10] * te3[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x4, y3, z4) {
          if (x4.isVector3) {
            this.set(
              1,
              0,
              0,
              x4.x,
              0,
              1,
              0,
              x4.y,
              0,
              0,
              1,
              x4.z,
              0,
              0,
              0,
              1
            );
          } else {
            this.set(
              1,
              0,
              0,
              x4,
              0,
              1,
              0,
              y3,
              0,
              0,
              1,
              z4,
              0,
              0,
              0,
              1
            );
          }
          return this;
        }
        makeRotationX(theta) {
          const c5 = Math.cos(theta), s4 = Math.sin(theta);
          this.set(
            1,
            0,
            0,
            0,
            0,
            c5,
            -s4,
            0,
            0,
            s4,
            c5,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationY(theta) {
          const c5 = Math.cos(theta), s4 = Math.sin(theta);
          this.set(
            c5,
            0,
            s4,
            0,
            0,
            1,
            0,
            0,
            -s4,
            0,
            c5,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationZ(theta) {
          const c5 = Math.cos(theta), s4 = Math.sin(theta);
          this.set(
            c5,
            -s4,
            0,
            0,
            s4,
            c5,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationAxis(axis, angle2) {
          const c5 = Math.cos(angle2);
          const s4 = Math.sin(angle2);
          const t4 = 1 - c5;
          const x4 = axis.x, y3 = axis.y, z4 = axis.z;
          const tx = t4 * x4, ty2 = t4 * y3;
          this.set(
            tx * x4 + c5,
            tx * y3 - s4 * z4,
            tx * z4 + s4 * y3,
            0,
            tx * y3 + s4 * z4,
            ty2 * y3 + c5,
            ty2 * z4 - s4 * x4,
            0,
            tx * z4 - s4 * y3,
            ty2 * z4 + s4 * x4,
            t4 * z4 * z4 + c5,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeScale(x4, y3, z4) {
          this.set(
            x4,
            0,
            0,
            0,
            0,
            y3,
            0,
            0,
            0,
            0,
            z4,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(
            1,
            yx,
            zx,
            0,
            xy,
            1,
            zy,
            0,
            xz,
            yz,
            1,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        compose(position, quaternion, scale4) {
          const te3 = this.elements;
          const x4 = quaternion._x, y3 = quaternion._y, z4 = quaternion._z, w3 = quaternion._w;
          const x22 = x4 + x4, y22 = y3 + y3, z22 = z4 + z4;
          const xx = x4 * x22, xy = x4 * y22, xz = x4 * z22;
          const yy = y3 * y22, yz = y3 * z22, zz = z4 * z22;
          const wx2 = w3 * x22, wy = w3 * y22, wz = w3 * z22;
          const sx = scale4.x, sy = scale4.y, sz = scale4.z;
          te3[0] = (1 - (yy + zz)) * sx;
          te3[1] = (xy + wz) * sx;
          te3[2] = (xz - wy) * sx;
          te3[3] = 0;
          te3[4] = (xy - wz) * sy;
          te3[5] = (1 - (xx + zz)) * sy;
          te3[6] = (yz + wx2) * sy;
          te3[7] = 0;
          te3[8] = (xz + wy) * sz;
          te3[9] = (yz - wx2) * sz;
          te3[10] = (1 - (xx + yy)) * sz;
          te3[11] = 0;
          te3[12] = position.x;
          te3[13] = position.y;
          te3[14] = position.z;
          te3[15] = 1;
          return this;
        }
        decompose(position, quaternion, scale4) {
          const te3 = this.elements;
          let sx = _v1$5.set(te3[0], te3[1], te3[2]).length();
          const sy = _v1$5.set(te3[4], te3[5], te3[6]).length();
          const sz = _v1$5.set(te3[8], te3[9], te3[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position.x = te3[12];
          position.y = te3[13];
          position.z = te3[14];
          _m1$2.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$2.elements[0] *= invSX;
          _m1$2.elements[1] *= invSX;
          _m1$2.elements[2] *= invSX;
          _m1$2.elements[4] *= invSY;
          _m1$2.elements[5] *= invSY;
          _m1$2.elements[6] *= invSY;
          _m1$2.elements[8] *= invSZ;
          _m1$2.elements[9] *= invSZ;
          _m1$2.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$2);
          scale4.x = sx;
          scale4.y = sy;
          scale4.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
          const te3 = this.elements;
          const x4 = 2 * near / (right - left);
          const y3 = 2 * near / (top - bottom);
          const a4 = (right + left) / (right - left);
          const b3 = (top + bottom) / (top - bottom);
          let c5, d4;
          if (coordinateSystem === WebGLCoordinateSystem) {
            c5 = -(far + near) / (far - near);
            d4 = -2 * far * near / (far - near);
          } else if (coordinateSystem === WebGPUCoordinateSystem) {
            c5 = -far / (far - near);
            d4 = -far * near / (far - near);
          } else {
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
          }
          te3[0] = x4;
          te3[4] = 0;
          te3[8] = a4;
          te3[12] = 0;
          te3[1] = 0;
          te3[5] = y3;
          te3[9] = b3;
          te3[13] = 0;
          te3[2] = 0;
          te3[6] = 0;
          te3[10] = c5;
          te3[14] = d4;
          te3[3] = 0;
          te3[7] = 0;
          te3[11] = -1;
          te3[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
          const te3 = this.elements;
          const w3 = 1 / (right - left);
          const h4 = 1 / (top - bottom);
          const p4 = 1 / (far - near);
          const x4 = (right + left) * w3;
          const y3 = (top + bottom) * h4;
          let z4, zInv;
          if (coordinateSystem === WebGLCoordinateSystem) {
            z4 = (far + near) * p4;
            zInv = -2 * p4;
          } else if (coordinateSystem === WebGPUCoordinateSystem) {
            z4 = near * p4;
            zInv = -1 * p4;
          } else {
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
          }
          te3[0] = 2 * w3;
          te3[4] = 0;
          te3[8] = 0;
          te3[12] = -x4;
          te3[1] = 0;
          te3[5] = 2 * h4;
          te3[9] = 0;
          te3[13] = -y3;
          te3[2] = 0;
          te3[6] = 0;
          te3[10] = zInv;
          te3[14] = -z4;
          te3[3] = 0;
          te3[7] = 0;
          te3[11] = 0;
          te3[15] = 1;
          return this;
        }
        equals(matrix) {
          const te3 = this.elements;
          const me4 = matrix.elements;
          for (let i5 = 0; i5 < 16; i5++) {
            if (te3[i5] !== me4[i5])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i5 = 0; i5 < 16; i5++) {
            this.elements[i5] = array[i5 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te3 = this.elements;
          array[offset] = te3[0];
          array[offset + 1] = te3[1];
          array[offset + 2] = te3[2];
          array[offset + 3] = te3[3];
          array[offset + 4] = te3[4];
          array[offset + 5] = te3[5];
          array[offset + 6] = te3[6];
          array[offset + 7] = te3[7];
          array[offset + 8] = te3[8];
          array[offset + 9] = te3[9];
          array[offset + 10] = te3[10];
          array[offset + 11] = te3[11];
          array[offset + 12] = te3[12];
          array[offset + 13] = te3[13];
          array[offset + 14] = te3[14];
          array[offset + 15] = te3[15];
          return array;
        }
      };
      _v1$5 = /* @__PURE__ */ new Vector3();
      _m1$2 = /* @__PURE__ */ new Matrix4();
      _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
      _one = /* @__PURE__ */ new Vector3(1, 1, 1);
      _x = /* @__PURE__ */ new Vector3();
      _y = /* @__PURE__ */ new Vector3();
      _z = /* @__PURE__ */ new Vector3();
      _matrix = /* @__PURE__ */ new Matrix4();
      _quaternion$3 = /* @__PURE__ */ new Quaternion();
      Euler = class _Euler {
        constructor(x4 = 0, y3 = 0, z4 = 0, order = _Euler.DEFAULT_ORDER) {
          this.isEuler = true;
          this._x = x4;
          this._y = y3;
          this._z = z4;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x4, y3, z4, order = this._order) {
          this._x = x4;
          this._y = y3;
          this._z = z4;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m4, order = this._order, update = true) {
          const te3 = m4.elements;
          const m11 = te3[0], m12 = te3[4], m13 = te3[8];
          const m21 = te3[1], m22 = te3[5], m23 = te3[9];
          const m31 = te3[2], m32 = te3[6], m33 = te3[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q4, order, update) {
          _matrix.makeRotationFromQuaternion(q4);
          return this.setFromRotationMatrix(_matrix, order, update);
        }
        setFromVector3(v5, order = this._order) {
          return this.set(v5.x, v5.y, v5.z, order);
        }
        reorder(newOrder) {
          _quaternion$3.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x;
          yield this._y;
          yield this._z;
          yield this._order;
        }
      };
      Euler.DEFAULT_ORDER = "XYZ";
      Layers = class {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = (1 << channel | 0) >>> 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
        isEnabled(channel) {
          return (this.mask & (1 << channel | 0)) !== 0;
        }
      };
      _object3DId = 0;
      _v1$4 = /* @__PURE__ */ new Vector3();
      _q1 = /* @__PURE__ */ new Quaternion();
      _m1$1 = /* @__PURE__ */ new Matrix4();
      _target = /* @__PURE__ */ new Vector3();
      _position$3 = /* @__PURE__ */ new Vector3();
      _scale$2 = /* @__PURE__ */ new Vector3();
      _quaternion$2 = /* @__PURE__ */ new Quaternion();
      _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
      _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
      _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
      _addedEvent = { type: "added" };
      _removedEvent = { type: "removed" };
      Object3D = class _Object3D extends EventDispatcher {
        constructor() {
          super();
          this.isObject3D = true;
          Object.defineProperty(this, "id", { value: _object3DId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = _Object3D.DEFAULT_UP.clone();
          const position = new Vector3();
          const rotation = new Euler();
          const quaternion = new Quaternion();
          const scale4 = new Vector3(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
          }
          function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, false);
          }
          rotation._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale4
            },
            modelViewMatrix: {
              value: new Matrix4()
            },
            normalMatrix: {
              value: new Matrix3()
            }
          });
          this.matrix = new Matrix4();
          this.matrixWorld = new Matrix4();
          this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
          this.matrixWorldNeedsUpdate = false;
          this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
          this.layers = new Layers();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q4) {
          this.quaternion.premultiply(q4);
          return this;
        }
        setRotationFromAxisAngle(axis, angle2) {
          this.quaternion.setFromAxisAngle(axis, angle2);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m4) {
          this.quaternion.setFromRotationMatrix(m4);
        }
        setRotationFromQuaternion(q4) {
          this.quaternion.copy(q4);
        }
        rotateOnAxis(axis, angle2) {
          _q1.setFromAxisAngle(axis, angle2);
          this.quaternion.multiply(_q1);
          return this;
        }
        rotateOnWorldAxis(axis, angle2) {
          _q1.setFromAxisAngle(axis, angle2);
          this.quaternion.premultiply(_q1);
          return this;
        }
        rotateX(angle2) {
          return this.rotateOnAxis(_xAxis, angle2);
        }
        rotateY(angle2) {
          return this.rotateOnAxis(_yAxis, angle2);
        }
        rotateZ(angle2) {
          return this.rotateOnAxis(_zAxis, angle2);
        }
        translateOnAxis(axis, distance) {
          _v1$4.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$4.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
          this.updateWorldMatrix(true, false);
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          this.updateWorldMatrix(true, false);
          return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x4, y3, z4) {
          if (x4.isVector3) {
            _target.copy(x4);
          } else {
            _target.set(x4, y3, z4);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$3.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$1.lookAt(_position$3, _target, this.up);
          } else {
            _m1$1.lookAt(_target, _position$3, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$1);
          if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i5 = 0; i5 < arguments.length; i5++) {
              this.add(arguments[i5]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i5 = 0; i5 < arguments.length; i5++) {
              this.remove(arguments[i5]);
            }
            return this;
          }
          const index = this.children.indexOf(object);
          if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$1.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$1);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id2) {
          return this.getObjectByProperty("id", id2);
        }
        getObjectByName(name2) {
          return this.getObjectByProperty("name", name2);
        }
        getObjectByProperty(name2, value) {
          if (this[name2] === value)
            return this;
          for (let i5 = 0, l4 = this.children.length; i5 < l4; i5++) {
            const child = this.children[i5];
            const object = child.getObjectByProperty(name2, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getObjectsByProperty(name2, value) {
          let result = [];
          if (this[name2] === value)
            result.push(this);
          for (let i5 = 0, l4 = this.children.length; i5 < l4; i5++) {
            const childResult = this.children[i5].getObjectsByProperty(name2, value);
            if (childResult.length > 0) {
              result = result.concat(childResult);
            }
          }
          return result;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, target, _scale$2);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, _quaternion$2, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e4 = this.matrixWorld.elements;
          return target.set(e4[8], e4[9], e4[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
            children[i5].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
            children[i5].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
            const child = children[i5];
            if (child.matrixWorldAutoUpdate === true || force === true) {
              child.updateMatrixWorld(force);
            }
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
              const child = children[i5];
              if (child.matrixWorldAutoUpdate === true) {
                child.updateWorldMatrix(false, true);
              }
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {}
            };
            output.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (Object.keys(this.userData).length > 0)
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          object.up = this.up.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i5 = 0, l4 = shapes.length; i5 < l4; i5++) {
                  const shape = shapes[i5];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i5 = 0, l4 = this.material.length; i5 < l4; i5++) {
                uuids.push(serialize(meta.materials, this.material[i5]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i5 = 0; i5 < this.children.length; i5++) {
              object.children.push(this.children[i5].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i5 = 0; i5 < this.animations.length; i5++) {
              const animation = this.animations[i5];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            const nodes = extractFromCache(meta.nodes);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
            if (nodes.length > 0)
              output.nodes = nodes;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values.push(data);
            }
            return values;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.animations = source.animations.slice();
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i5 = 0; i5 < source.children.length; i5++) {
              const child = source.children[i5];
              this.add(child.clone());
            }
          }
          return this;
        }
      };
      Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
      Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
      Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      _v0$1 = /* @__PURE__ */ new Vector3();
      _v1$3 = /* @__PURE__ */ new Vector3();
      _v2$2 = /* @__PURE__ */ new Vector3();
      _v3$1 = /* @__PURE__ */ new Vector3();
      _vab = /* @__PURE__ */ new Vector3();
      _vac = /* @__PURE__ */ new Vector3();
      _vbc = /* @__PURE__ */ new Vector3();
      _vap = /* @__PURE__ */ new Vector3();
      _vbp = /* @__PURE__ */ new Vector3();
      _vcp = /* @__PURE__ */ new Vector3();
      warnedGetUV = false;
      Triangle = class _Triangle {
        constructor(a4 = new Vector3(), b3 = new Vector3(), c5 = new Vector3()) {
          this.a = a4;
          this.b = b3;
          this.c = c5;
        }
        static getNormal(a4, b3, c5, target) {
          target.subVectors(c5, b3);
          _v0$1.subVectors(a4, b3);
          target.cross(_v0$1);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        // static/instance method to calculate barycentric coordinates
        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
        static getBarycoord(point, a4, b3, c5, target) {
          _v0$1.subVectors(c5, a4);
          _v1$3.subVectors(b3, a4);
          _v2$2.subVectors(point, a4);
          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$2);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$2);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u4 = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v5 = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u4 - v5, v5, u4);
        }
        static containsPoint(point, a4, b3, c5) {
          this.getBarycoord(point, a4, b3, c5, _v3$1);
          return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
        }
        static getUV(point, p1, p22, p32, uv1, uv2, uv3, target) {
          if (warnedGetUV === false) {
            console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
            warnedGetUV = true;
          }
          return this.getInterpolation(point, p1, p22, p32, uv1, uv2, uv3, target);
        }
        static getInterpolation(point, p1, p22, p32, v1, v22, v32, target) {
          this.getBarycoord(point, p1, p22, p32, _v3$1);
          target.setScalar(0);
          target.addScaledVector(v1, _v3$1.x);
          target.addScaledVector(v22, _v3$1.y);
          target.addScaledVector(v32, _v3$1.z);
          return target;
        }
        static isFrontFacing(a4, b3, c5, direction) {
          _v0$1.subVectors(c5, b3);
          _v1$3.subVectors(a4, b3);
          return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        }
        set(a4, b3, c5) {
          this.a.copy(a4);
          this.b.copy(b3);
          this.c.copy(c5);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i22) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i22]);
          return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i22) {
          this.a.fromBufferAttribute(attribute, i0);
          this.b.fromBufferAttribute(attribute, i1);
          this.c.fromBufferAttribute(attribute, i22);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);
          return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return _Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return _Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          if (warnedGetUV === false) {
            console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
            warnedGetUV = true;
          }
          return _Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        getInterpolation(point, v1, v22, v32, target) {
          return _Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v22, v32, target);
        }
        containsPoint(point) {
          return _Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p4, target) {
          const a4 = this.a, b3 = this.b, c5 = this.c;
          let v5, w3;
          _vab.subVectors(b3, a4);
          _vac.subVectors(c5, a4);
          _vap.subVectors(p4, a4);
          const d1 = _vab.dot(_vap);
          const d22 = _vac.dot(_vap);
          if (d1 <= 0 && d22 <= 0) {
            return target.copy(a4);
          }
          _vbp.subVectors(p4, b3);
          const d32 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d32 >= 0 && d4 <= d32) {
            return target.copy(b3);
          }
          const vc3 = d1 * d4 - d32 * d22;
          if (vc3 <= 0 && d1 >= 0 && d32 <= 0) {
            v5 = d1 / (d1 - d32);
            return target.copy(a4).addScaledVector(_vab, v5);
          }
          _vcp.subVectors(p4, c5);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c5);
          }
          const vb2 = d5 * d22 - d1 * d6;
          if (vb2 <= 0 && d22 >= 0 && d6 <= 0) {
            w3 = d22 / (d22 - d6);
            return target.copy(a4).addScaledVector(_vac, w3);
          }
          const va3 = d32 * d6 - d5 * d4;
          if (va3 <= 0 && d4 - d32 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c5, b3);
            w3 = (d4 - d32) / (d4 - d32 + (d5 - d6));
            return target.copy(b3).addScaledVector(_vbc, w3);
          }
          const denom = 1 / (va3 + vb2 + vc3);
          v5 = vb2 * denom;
          w3 = vc3 * denom;
          return target.copy(a4).addScaledVector(_vab, v5).addScaledVector(_vac, w3);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      };
      _colorKeywords = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      _hslA = { h: 0, s: 0, l: 0 };
      _hslB = { h: 0, s: 0, l: 0 };
      Color = class {
        constructor(r4, g4, b3) {
          this.isColor = true;
          this.r = 1;
          this.g = 1;
          this.b = 1;
          return this.set(r4, g4, b3);
        }
        set(r4, g4, b3) {
          if (g4 === void 0 && b3 === void 0) {
            const value = r4;
            if (value && value.isColor) {
              this.copy(value);
            } else if (typeof value === "number") {
              this.setHex(value);
            } else if (typeof value === "string") {
              this.setStyle(value);
            }
          } else {
            this.setRGB(r4, g4, b3);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex, colorSpace = SRGBColorSpace) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
        setRGB(r4, g4, b3, colorSpace = ColorManagement.workingColorSpace) {
          this.r = r4;
          this.g = g4;
          this.b = b3;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
        setHSL(h4, s4, l4, colorSpace = ColorManagement.workingColorSpace) {
          h4 = euclideanModulo(h4, 1);
          s4 = clamp(s4, 0, 1);
          l4 = clamp(l4, 0, 1);
          if (s4 === 0) {
            this.r = this.g = this.b = l4;
          } else {
            const p4 = l4 <= 0.5 ? l4 * (1 + s4) : l4 + s4 - l4 * s4;
            const q4 = 2 * l4 - p4;
            this.r = hue2rgb(q4, p4, h4 + 1 / 3);
            this.g = hue2rgb(q4, p4, h4);
            this.b = hue2rgb(q4, p4, h4 - 1 / 3);
          }
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
        setStyle(style, colorSpace = SRGBColorSpace) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m4;
          if (m4 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name2 = m4[1];
            const components = m4[2];
            switch (name2) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  handleAlpha(color[4]);
                  return this.setRGB(
                    Math.min(255, parseInt(color[1], 10)) / 255,
                    Math.min(255, parseInt(color[2], 10)) / 255,
                    Math.min(255, parseInt(color[3], 10)) / 255,
                    colorSpace
                  );
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  handleAlpha(color[4]);
                  return this.setRGB(
                    Math.min(100, parseInt(color[1], 10)) / 100,
                    Math.min(100, parseInt(color[2], 10)) / 100,
                    Math.min(100, parseInt(color[3], 10)) / 100,
                    colorSpace
                  );
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  handleAlpha(color[4]);
                  return this.setHSL(
                    parseFloat(color[1]) / 360,
                    parseFloat(color[2]) / 100,
                    parseFloat(color[3]) / 100,
                    colorSpace
                  );
                }
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + style);
            }
          } else if (m4 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m4[1];
            const size = hex.length;
            if (size === 3) {
              return this.setRGB(
                parseInt(hex.charAt(0), 16) / 15,
                parseInt(hex.charAt(1), 16) / 15,
                parseInt(hex.charAt(2), 16) / 15,
                colorSpace
              );
            } else if (size === 6) {
              return this.setHex(parseInt(hex, 16), colorSpace);
            } else {
              console.warn("THREE.Color: Invalid hex color " + style);
            }
          } else if (style && style.length > 0) {
            return this.setColorName(style, colorSpace);
          }
          return this;
        }
        setColorName(style, colorSpace = SRGBColorSpace) {
          const hex = _colorKeywords[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex, colorSpace);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex(colorSpace = SRGBColorSpace) {
          ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
          return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
        }
        getHexString(colorSpace = SRGBColorSpace) {
          return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
        }
        getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
          ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
          const r4 = _color.r, g4 = _color.g, b3 = _color.b;
          const max2 = Math.max(r4, g4, b3);
          const min = Math.min(r4, g4, b3);
          let hue, saturation;
          const lightness = (min + max2) / 2;
          if (min === max2) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max2 - min;
            saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);
            switch (max2) {
              case r4:
                hue = (g4 - b3) / delta + (g4 < b3 ? 6 : 0);
                break;
              case g4:
                hue = (b3 - r4) / delta + 2;
                break;
              case b3:
                hue = (r4 - g4) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
          ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
          target.r = _color.r;
          target.g = _color.g;
          target.b = _color.b;
          return target;
        }
        getStyle(colorSpace = SRGBColorSpace) {
          ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
          const r4 = _color.r, g4 = _color.g, b3 = _color.b;
          if (colorSpace !== SRGBColorSpace) {
            return `color(${colorSpace} ${r4.toFixed(3)} ${g4.toFixed(3)} ${b3.toFixed(3)})`;
          }
          return `rgb(${Math.round(r4 * 255)},${Math.round(g4 * 255)},${Math.round(b3 * 255)})`;
        }
        offsetHSL(h4, s4, l4) {
          this.getHSL(_hslA);
          return this.setHSL(_hslA.h + h4, _hslA.s + s4, _hslA.l + l4);
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s4) {
          this.r += s4;
          this.g += s4;
          this.b += s4;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s4) {
          this.r *= s4;
          this.g *= s4;
          this.b *= s4;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA);
          color.getHSL(_hslB);
          const h4 = lerp(_hslA.h, _hslB.h, alpha);
          const s4 = lerp(_hslA.s, _hslB.s, alpha);
          const l4 = lerp(_hslA.l, _hslB.l, alpha);
          this.setHSL(h4, s4, l4);
          return this;
        }
        setFromVector3(v5) {
          this.r = v5.x;
          this.g = v5.y;
          this.b = v5.z;
          return this;
        }
        applyMatrix3(m4) {
          const r4 = this.r, g4 = this.g, b3 = this.b;
          const e4 = m4.elements;
          this.r = e4[0] * r4 + e4[3] * g4 + e4[6] * b3;
          this.g = e4[1] * r4 + e4[4] * g4 + e4[7] * b3;
          this.b = e4[2] * r4 + e4[5] * g4 + e4[8] * b3;
          return this;
        }
        equals(c5) {
          return c5.r === this.r && c5.g === this.g && c5.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);
          return this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r;
          yield this.g;
          yield this.b;
        }
      };
      _color = /* @__PURE__ */ new Color();
      Color.NAMES = _colorKeywords;
      _materialId = 0;
      Material = class extends EventDispatcher {
        constructor() {
          super();
          this.isMaterial = true;
          Object.defineProperty(this, "id", { value: _materialId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Material";
          this.blending = NormalBlending;
          this.side = FrontSide;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.alphaHash = false;
          this.blendSrc = SrcAlphaFactor;
          this.blendDst = OneMinusSrcAlphaFactor;
          this.blendEquation = AddEquation;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.blendColor = new Color(0, 0, 0);
          this.blendAlpha = 0;
          this.depthFunc = LessEqualDepth;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp;
          this.stencilZFail = KeepStencilOp;
          this.stencilZPass = KeepStencilOp;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.forceSinglePass = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(value) {
          if (this._alphaTest > 0 !== value > 0) {
            this.version++;
          }
          this._alphaTest = value;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values) {
          if (values === void 0)
            return;
          for (const key in values) {
            const newValue = values[key];
            if (newValue === void 0) {
              console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (isRootObject) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen !== void 0)
            data.sheen = this.sheen;
          if (this.sheenColor && this.sheenColor.isColor)
            data.sheenColor = this.sheenColor.getHex();
          if (this.sheenRoughness !== void 0)
            data.sheenRoughness = this.sheenRoughness;
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.specularIntensity !== void 0)
            data.specularIntensity = this.specularIntensity;
          if (this.specularColor && this.specularColor.isColor)
            data.specularColor = this.specularColor.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.iridescence !== void 0)
            data.iridescence = this.iridescence;
          if (this.iridescenceIOR !== void 0)
            data.iridescenceIOR = this.iridescenceIOR;
          if (this.iridescenceThicknessRange !== void 0)
            data.iridescenceThicknessRange = this.iridescenceThicknessRange;
          if (this.iridescenceMap && this.iridescenceMap.isTexture) {
            data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
          }
          if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
            data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
          }
          if (this.anisotropy !== void 0)
            data.anisotropy = this.anisotropy;
          if (this.anisotropyRotation !== void 0)
            data.anisotropyRotation = this.anisotropyRotation;
          if (this.anisotropyMap && this.anisotropyMap.isTexture) {
            data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
          if (this.specularColorMap && this.specularColorMap.isTexture)
            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending)
            data.blending = this.blending;
          if (this.side !== FrontSide)
            data.side = this.side;
          if (this.vertexColors === true)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.transparent === true)
            data.transparent = true;
          if (this.blendSrc !== SrcAlphaFactor)
            data.blendSrc = this.blendSrc;
          if (this.blendDst !== OneMinusSrcAlphaFactor)
            data.blendDst = this.blendDst;
          if (this.blendEquation !== AddEquation)
            data.blendEquation = this.blendEquation;
          if (this.blendSrcAlpha !== null)
            data.blendSrcAlpha = this.blendSrcAlpha;
          if (this.blendDstAlpha !== null)
            data.blendDstAlpha = this.blendDstAlpha;
          if (this.blendEquationAlpha !== null)
            data.blendEquationAlpha = this.blendEquationAlpha;
          if (this.blendColor && this.blendColor.isColor)
            data.blendColor = this.blendColor.getHex();
          if (this.blendAlpha !== 0)
            data.blendAlpha = this.blendAlpha;
          if (this.depthFunc !== LessEqualDepth)
            data.depthFunc = this.depthFunc;
          if (this.depthTest === false)
            data.depthTest = this.depthTest;
          if (this.depthWrite === false)
            data.depthWrite = this.depthWrite;
          if (this.colorWrite === false)
            data.colorWrite = this.colorWrite;
          if (this.stencilWriteMask !== 255)
            data.stencilWriteMask = this.stencilWriteMask;
          if (this.stencilFunc !== AlwaysStencilFunc)
            data.stencilFunc = this.stencilFunc;
          if (this.stencilRef !== 0)
            data.stencilRef = this.stencilRef;
          if (this.stencilFuncMask !== 255)
            data.stencilFuncMask = this.stencilFuncMask;
          if (this.stencilFail !== KeepStencilOp)
            data.stencilFail = this.stencilFail;
          if (this.stencilZFail !== KeepStencilOp)
            data.stencilZFail = this.stencilZFail;
          if (this.stencilZPass !== KeepStencilOp)
            data.stencilZPass = this.stencilZPass;
          if (this.stencilWrite === true)
            data.stencilWrite = this.stencilWrite;
          if (this.rotation !== void 0 && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth !== void 0 && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaHash === true)
            data.alphaHash = true;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = true;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = true;
          if (this.forceSinglePass === true)
            data.forceSinglePass = true;
          if (this.wireframe === true)
            data.wireframe = true;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.flatShading === true)
            data.flatShading = true;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (this.fog === false)
            data.fog = false;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values.push(data2);
            }
            return values;
          }
          if (isRootObject) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.blendColor.copy(source.blendColor);
          this.blendAlpha = source.blendAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n4 = srcPlanes.length;
            dstPlanes = new Array(n4);
            for (let i5 = 0; i5 !== n4; ++i5) {
              dstPlanes[i5] = srcPlanes[i5].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaHash = source.alphaHash;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.forceSinglePass = source.forceSinglePass;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      MeshBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshBasicMaterial = true;
          this.type = "MeshBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.fog = source.fog;
          return this;
        }
      };
      _vector$8 = /* @__PURE__ */ new Vector3();
      _vector2$1 = /* @__PURE__ */ new Vector2();
      BufferAttribute = class {
        constructor(array, itemSize, normalized = false) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.isBufferAttribute = true;
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized;
          this.usage = StaticDrawUsage;
          this.updateRange = { offset: 0, count: -1 };
          this.gpuType = FloatType;
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          this.gpuType = source.gpuType;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i5 = 0, l4 = this.itemSize; i5 < l4; i5++) {
            this.array[index1 + i5] = attribute.array[index2 + i5];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        applyMatrix3(m4) {
          if (this.itemSize === 2) {
            for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
              _vector2$1.fromBufferAttribute(this, i5);
              _vector2$1.applyMatrix3(m4);
              this.setXY(i5, _vector2$1.x, _vector2$1.y);
            }
          } else if (this.itemSize === 3) {
            for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
              _vector$8.fromBufferAttribute(this, i5);
              _vector$8.applyMatrix3(m4);
              this.setXYZ(i5, _vector$8.x, _vector$8.y, _vector$8.z);
            }
          }
          return this;
        }
        applyMatrix4(m4) {
          for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
            _vector$8.fromBufferAttribute(this, i5);
            _vector$8.applyMatrix4(m4);
            this.setXYZ(i5, _vector$8.x, _vector$8.y, _vector$8.z);
          }
          return this;
        }
        applyNormalMatrix(m4) {
          for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
            _vector$8.fromBufferAttribute(this, i5);
            _vector$8.applyNormalMatrix(m4);
            this.setXYZ(i5, _vector$8.x, _vector$8.y, _vector$8.z);
          }
          return this;
        }
        transformDirection(m4) {
          for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
            _vector$8.fromBufferAttribute(this, i5);
            _vector$8.transformDirection(m4);
            this.setXYZ(i5, _vector$8.x, _vector$8.y, _vector$8.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getComponent(index, component) {
          let value = this.array[index * this.itemSize + component];
          if (this.normalized)
            value = denormalize(value, this.array);
          return value;
        }
        setComponent(index, component, value) {
          if (this.normalized)
            value = normalize(value, this.array);
          this.array[index * this.itemSize + component] = value;
          return this;
        }
        getX(index) {
          let x4 = this.array[index * this.itemSize];
          if (this.normalized)
            x4 = denormalize(x4, this.array);
          return x4;
        }
        setX(index, x4) {
          if (this.normalized)
            x4 = normalize(x4, this.array);
          this.array[index * this.itemSize] = x4;
          return this;
        }
        getY(index) {
          let y3 = this.array[index * this.itemSize + 1];
          if (this.normalized)
            y3 = denormalize(y3, this.array);
          return y3;
        }
        setY(index, y3) {
          if (this.normalized)
            y3 = normalize(y3, this.array);
          this.array[index * this.itemSize + 1] = y3;
          return this;
        }
        getZ(index) {
          let z4 = this.array[index * this.itemSize + 2];
          if (this.normalized)
            z4 = denormalize(z4, this.array);
          return z4;
        }
        setZ(index, z4) {
          if (this.normalized)
            z4 = normalize(z4, this.array);
          this.array[index * this.itemSize + 2] = z4;
          return this;
        }
        getW(index) {
          let w3 = this.array[index * this.itemSize + 3];
          if (this.normalized)
            w3 = denormalize(w3, this.array);
          return w3;
        }
        setW(index, w3) {
          if (this.normalized)
            w3 = normalize(w3, this.array);
          this.array[index * this.itemSize + 3] = w3;
          return this;
        }
        setXY(index, x4, y3) {
          index *= this.itemSize;
          if (this.normalized) {
            x4 = normalize(x4, this.array);
            y3 = normalize(y3, this.array);
          }
          this.array[index + 0] = x4;
          this.array[index + 1] = y3;
          return this;
        }
        setXYZ(index, x4, y3, z4) {
          index *= this.itemSize;
          if (this.normalized) {
            x4 = normalize(x4, this.array);
            y3 = normalize(y3, this.array);
            z4 = normalize(z4, this.array);
          }
          this.array[index + 0] = x4;
          this.array[index + 1] = y3;
          this.array[index + 2] = z4;
          return this;
        }
        setXYZW(index, x4, y3, z4, w3) {
          index *= this.itemSize;
          if (this.normalized) {
            x4 = normalize(x4, this.array);
            y3 = normalize(y3, this.array);
            z4 = normalize(z4, this.array);
            w3 = normalize(w3, this.array);
          }
          this.array[index + 0] = x4;
          this.array[index + 1] = y3;
          this.array[index + 2] = z4;
          this.array[index + 3] = w3;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
      };
      Uint16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      Uint32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      };
      Float32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      };
      _id$2 = 0;
      _m1 = /* @__PURE__ */ new Matrix4();
      _obj = /* @__PURE__ */ new Object3D();
      _offset = /* @__PURE__ */ new Vector3();
      _box$1 = /* @__PURE__ */ new Box3();
      _boxMorphTargets = /* @__PURE__ */ new Box3();
      _vector$7 = /* @__PURE__ */ new Vector3();
      BufferGeometry = class _BufferGeometry extends EventDispatcher {
        constructor() {
          super();
          this.isBufferGeometry = true;
          Object.defineProperty(this, "id", { value: _id$2++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = { start: 0, count: Infinity };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (Array.isArray(index)) {
            this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
          } else {
            this.index = index;
          }
          return this;
        }
        getAttribute(name2) {
          return this.attributes[name2];
        }
        setAttribute(name2, attribute) {
          this.attributes[name2] = attribute;
          return this;
        }
        deleteAttribute(name2) {
          delete this.attributes[name2];
          return this;
        }
        hasAttribute(name2) {
          return this.attributes[name2] !== void 0;
        }
        addGroup(start, count, materialIndex = 0) {
          this.groups.push({
            start,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start, count) {
          this.drawRange.start = start;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position = this.attributes.position;
          if (position !== void 0) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q4) {
          _m1.makeRotationFromQuaternion(q4);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateX(angle2) {
          _m1.makeRotationX(angle2);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateY(angle2) {
          _m1.makeRotationY(angle2);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateZ(angle2) {
          _m1.makeRotationZ(angle2);
          this.applyMatrix4(_m1);
          return this;
        }
        translate(x4, y3, z4) {
          _m1.makeTranslation(x4, y3, z4);
          this.applyMatrix4(_m1);
          return this;
        }
        scale(x4, y3, z4) {
          _m1.makeScale(x4, y3, z4);
          this.applyMatrix4(_m1);
          return this;
        }
        lookAt(vector) {
          _obj.lookAt(vector);
          _obj.updateMatrix();
          this.applyMatrix4(_obj.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset).negate();
          this.translate(_offset.x, _offset.y, _offset.z);
          return this;
        }
        setFromPoints(points) {
          const position = [];
          for (let i5 = 0, l4 = points.length; i5 < l4; i5++) {
            const point = points[i5];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute(position, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(
              new Vector3(-Infinity, -Infinity, -Infinity),
              new Vector3(Infinity, Infinity, Infinity)
            );
            return;
          }
          if (position !== void 0) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i5 = 0, il3 = morphAttributesPosition.length; i5 < il3; i5++) {
                const morphAttribute = morphAttributesPosition[i5];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$7.addVectors(this.boundingBox.min, _box$1.min);
                  this.boundingBox.expandByPoint(_vector$7);
                  _vector$7.addVectors(this.boundingBox.max, _box$1.max);
                  this.boundingBox.expandByPoint(_vector$7);
                } else {
                  this.boundingBox.expandByPoint(_box$1.min);
                  this.boundingBox.expandByPoint(_box$1.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
          }
          if (position) {
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i5 = 0, il3 = morphAttributesPosition.length; i5 < il3; i5++) {
                const morphAttribute = morphAttributesPosition[i5];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$7.addVectors(_box$1.min, _boxMorphTargets.min);
                  _box$1.expandByPoint(_vector$7);
                  _vector$7.addVectors(_box$1.max, _boxMorphTargets.max);
                  _box$1.expandByPoint(_vector$7);
                } else {
                  _box$1.expandByPoint(_boxMorphTargets.min);
                  _box$1.expandByPoint(_boxMorphTargets.max);
                }
              }
            }
            _box$1.getCenter(center);
            let maxRadiusSq = 0;
            for (let i5 = 0, il3 = position.count; i5 < il3; i5++) {
              _vector$7.fromBufferAttribute(position, i5);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
            }
            if (morphAttributesPosition) {
              for (let i5 = 0, il3 = morphAttributesPosition.length; i5 < il3; i5++) {
                const morphAttribute = morphAttributesPosition[i5];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j4 = 0, jl3 = morphAttribute.count; j4 < jl3; j4++) {
                  _vector$7.fromBufferAttribute(morphAttribute, j4);
                  if (morphTargetsRelative) {
                    _offset.fromBufferAttribute(position, j4);
                    _vector$7.add(_offset);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeTangents() {
          const index = this.index;
          const attributes = this.attributes;
          if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (this.hasAttribute("tangent") === false) {
            this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
          }
          const tangents = this.getAttribute("tangent").array;
          const tan1 = [], tan2 = [];
          for (let i5 = 0; i5 < nVertices; i5++) {
            tan1[i5] = new Vector3();
            tan2[i5] = new Vector3();
          }
          const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
          function handleTriangle(a4, b3, c5) {
            vA.fromArray(positions, a4 * 3);
            vB.fromArray(positions, b3 * 3);
            vC.fromArray(positions, c5 * 3);
            uvA.fromArray(uvs, a4 * 2);
            uvB.fromArray(uvs, b3 * 2);
            uvC.fromArray(uvs, c5 * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r4 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r4))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r4);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r4);
            tan1[a4].add(sdir);
            tan1[b3].add(sdir);
            tan1[c5].add(sdir);
            tan2[a4].add(tdir);
            tan2[b3].add(tdir);
            tan2[c5].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i5 = 0, il3 = groups.length; i5 < il3; ++i5) {
            const group = groups[i5];
            const start = group.start;
            const count = group.count;
            for (let j4 = start, jl3 = start + count; j4 < jl3; j4 += 3) {
              handleTriangle(
                indices[j4 + 0],
                indices[j4 + 1],
                indices[j4 + 2]
              );
            }
          }
          const tmp = new Vector3(), tmp2 = new Vector3();
          const n4 = new Vector3(), n22 = new Vector3();
          function handleVertex(v5) {
            n4.fromArray(normals, v5 * 3);
            n22.copy(n4);
            const t4 = tan1[v5];
            tmp.copy(t4);
            tmp.sub(n4.multiplyScalar(n4.dot(t4))).normalize();
            tmp2.crossVectors(n22, t4);
            const test = tmp2.dot(tan2[v5]);
            const w3 = test < 0 ? -1 : 1;
            tangents[v5 * 4] = tmp.x;
            tangents[v5 * 4 + 1] = tmp.y;
            tangents[v5 * 4 + 2] = tmp.z;
            tangents[v5 * 4 + 3] = w3;
          }
          for (let i5 = 0, il3 = groups.length; i5 < il3; ++i5) {
            const group = groups[i5];
            const start = group.start;
            const count = group.count;
            for (let j4 = start, jl3 = start + count; j4 < jl3; j4 += 3) {
              handleVertex(indices[j4 + 0]);
              handleVertex(indices[j4 + 1]);
              handleVertex(indices[j4 + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i5 = 0, il3 = normalAttribute.count; i5 < il3; i5++) {
                normalAttribute.setXYZ(i5, 0, 0, 0);
              }
            }
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb2 = new Vector3(), ab2 = new Vector3();
            if (index) {
              for (let i5 = 0, il3 = index.count; i5 < il3; i5 += 3) {
                const vA = index.getX(i5 + 0);
                const vB = index.getX(i5 + 1);
                const vC = index.getX(i5 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb2.subVectors(pC, pB);
                ab2.subVectors(pA, pB);
                cb2.cross(ab2);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb2);
                nB.add(cb2);
                nC.add(cb2);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i5 = 0, il3 = positionAttribute.count; i5 < il3; i5 += 3) {
                pA.fromBufferAttribute(positionAttribute, i5 + 0);
                pB.fromBufferAttribute(positionAttribute, i5 + 1);
                pC.fromBufferAttribute(positionAttribute, i5 + 2);
                cb2.subVectors(pC, pB);
                ab2.subVectors(pA, pB);
                cb2.cross(ab2);
                normalAttribute.setXYZ(i5 + 0, cb2.x, cb2.y, cb2.z);
                normalAttribute.setXYZ(i5 + 1, cb2.x, cb2.y, cb2.z);
                normalAttribute.setXYZ(i5 + 2, cb2.x, cb2.y, cb2.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i5 = 0, il3 = normals.count; i5 < il3; i5++) {
            _vector$7.fromBufferAttribute(normals, i5);
            _vector$7.normalize();
            normals.setXYZ(i5, _vector$7.x, _vector$7.y, _vector$7.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for (let i5 = 0, l4 = indices2.length; i5 < l4; i5++) {
              if (attribute.isInterleavedBufferAttribute) {
                index = indices2[i5] * attribute.data.stride + attribute.offset;
              } else {
                index = indices2[i5] * itemSize;
              }
              for (let j4 = 0; j4 < itemSize; j4++) {
                array2[index2++] = array[index++];
              }
            }
            return new BufferAttribute(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new _BufferGeometry();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name2 in attributes) {
            const attribute = attributes[name2];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name2, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name2 in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name2];
            for (let i5 = 0, il3 = morphAttribute.length; i5 < il3; i5++) {
              const attribute = morphAttribute[i5];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name2] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i5 = 0, l4 = groups.length; i5 < l4; i5++) {
            const group = groups[i5];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = { attributes: {} };
          const index = this.index;
          if (index !== null) {
            data.data.index = {
              type: index.array.constructor.name,
              array: Array.prototype.slice.call(index.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i5 = 0, il3 = attributeArray.length; i5 < il3; i5++) {
              const attribute = attributeArray[i5];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index = source.index;
          if (index !== null) {
            this.setIndex(index.clone(data));
          }
          const attributes = source.attributes;
          for (const name2 in attributes) {
            const attribute = attributes[name2];
            this.setAttribute(name2, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name2 in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name2];
            for (let i5 = 0, l4 = morphAttribute.length; i5 < l4; i5++) {
              array.push(morphAttribute[i5].clone(data));
            }
            this.morphAttributes[name2] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i5 = 0, l4 = groups.length; i5 < l4; i5++) {
            const group = groups[i5];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
      _ray$3 = /* @__PURE__ */ new Ray();
      _sphere$5 = /* @__PURE__ */ new Sphere();
      _sphereHitAt = /* @__PURE__ */ new Vector3();
      _vA$1 = /* @__PURE__ */ new Vector3();
      _vB$1 = /* @__PURE__ */ new Vector3();
      _vC$1 = /* @__PURE__ */ new Vector3();
      _tempA = /* @__PURE__ */ new Vector3();
      _morphA = /* @__PURE__ */ new Vector3();
      _uvA$1 = /* @__PURE__ */ new Vector2();
      _uvB$1 = /* @__PURE__ */ new Vector2();
      _uvC$1 = /* @__PURE__ */ new Vector2();
      _normalA = /* @__PURE__ */ new Vector3();
      _normalB = /* @__PURE__ */ new Vector3();
      _normalC = /* @__PURE__ */ new Vector3();
      _intersectionPoint = /* @__PURE__ */ new Vector3();
      _intersectionPointWorld = /* @__PURE__ */ new Vector3();
      Mesh = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
          super();
          this.isMesh = true;
          this.type = "Mesh";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m4 = 0, ml3 = morphAttribute.length; m4 < ml3; m4++) {
                const name2 = morphAttribute[m4].name || String(m4);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name2] = m4;
              }
            }
          }
        }
        getVertexPosition(index, target) {
          const geometry = this.geometry;
          const position = geometry.attributes.position;
          const morphPosition = geometry.morphAttributes.position;
          const morphTargetsRelative = geometry.morphTargetsRelative;
          target.fromBufferAttribute(position, index);
          const morphInfluences = this.morphTargetInfluences;
          if (morphPosition && morphInfluences) {
            _morphA.set(0, 0, 0);
            for (let i5 = 0, il3 = morphPosition.length; i5 < il3; i5++) {
              const influence = morphInfluences[i5];
              const morphAttribute = morphPosition[i5];
              if (influence === 0)
                continue;
              _tempA.fromBufferAttribute(morphAttribute, index);
              if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
              } else {
                _morphA.addScaledVector(_tempA.sub(target), influence);
              }
            }
            target.add(_morphA);
          }
          return target;
        }
        raycast(raycaster, intersects) {
          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$5.copy(geometry.boundingSphere);
          _sphere$5.applyMatrix4(matrixWorld);
          _ray$3.copy(raycaster.ray).recast(raycaster.near);
          if (_sphere$5.containsPoint(_ray$3.origin) === false) {
            if (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null)
              return;
            if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2)
              return;
          }
          _inverseMatrix$3.copy(matrixWorld).invert();
          _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
          if (geometry.boundingBox !== null) {
            if (_ray$3.intersectsBox(geometry.boundingBox) === false)
              return;
          }
          this._computeIntersections(raycaster, intersects, _ray$3);
        }
        _computeIntersections(raycaster, intersects, rayLocalSpace) {
          let intersection;
          const geometry = this.geometry;
          const material = this.material;
          const index = geometry.index;
          const position = geometry.attributes.position;
          const uv = geometry.attributes.uv;
          const uv1 = geometry.attributes.uv1;
          const normal = geometry.attributes.normal;
          const groups = geometry.groups;
          const drawRange = geometry.drawRange;
          if (index !== null) {
            if (Array.isArray(material)) {
              for (let i5 = 0, il3 = groups.length; i5 < il3; i5++) {
                const group = groups[i5];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j4 = start, jl3 = end; j4 < jl3; j4 += 3) {
                  const a4 = index.getX(j4);
                  const b3 = index.getX(j4 + 1);
                  const c5 = index.getX(j4 + 2);
                  intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a4, b3, c5);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j4 / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i5 = start, il3 = end; i5 < il3; i5 += 3) {
                const a4 = index.getX(i5);
                const b3 = index.getX(i5 + 1);
                const c5 = index.getX(i5 + 2);
                intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a4, b3, c5);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i5 / 3);
                  intersects.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (let i5 = 0, il3 = groups.length; i5 < il3; i5++) {
                const group = groups[i5];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j4 = start, jl3 = end; j4 < jl3; j4 += 3) {
                  const a4 = j4;
                  const b3 = j4 + 1;
                  const c5 = j4 + 2;
                  intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a4, b3, c5);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j4 / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(position.count, drawRange.start + drawRange.count);
              for (let i5 = start, il3 = end; i5 < il3; i5 += 3) {
                const a4 = i5;
                const b3 = i5 + 1;
                const c5 = i5 + 2;
                intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a4, b3, c5);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i5 / 3);
                  intersects.push(intersection);
                }
              }
            }
          }
        }
      };
      BoxGeometry = class _BoxGeometry extends BufferGeometry {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function buildPlane(u4, v5, w3, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width2 / gridX;
            const segmentHeight = height2 / gridY;
            const widthHalf = width2 / 2;
            const heightHalf = height2 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            for (let iy = 0; iy < gridY1; iy++) {
              const y3 = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x4 = ix * segmentWidth - widthHalf;
                vector[u4] = x4 * udir;
                vector[v5] = y3 * vdir;
                vector[w3] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u4] = 0;
                vector[v5] = 0;
                vector[w3] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a4 = numberOfVertices + ix + gridX1 * iy;
                const b3 = numberOfVertices + ix + gridX1 * (iy + 1);
                const c5 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d4 = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a4, b3, d4);
                indices.push(b3, c5, d4);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        copy(source) {
          super.copy(source);
          this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        static fromJSON(data) {
          return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      };
      UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
      default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      ShaderMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isShaderMaterial = true;
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.uniformsGroups = [];
          this.vertexShader = default_vertex;
          this.fragmentShader = default_fragment;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.forceSinglePass = true;
          this.extensions = {
            derivatives: false,
            // set to use derivatives
            fragDepth: false,
            // set to use fragment depth values
            drawBuffers: false,
            // set to use draw buffers
            shaderTextureLOD: false
            // set to use shader texture LOD
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv1": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms(source.uniforms);
          this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.fog = source.fog;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name2 in this.uniforms) {
            const uniform = this.uniforms[name2];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name2] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name2] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name2] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name2] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name2] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name2] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name2] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name2] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          data.lights = this.lights;
          data.clipping = this.clipping;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      };
      Camera = class extends Object3D {
        constructor() {
          super();
          this.isCamera = true;
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix4();
          this.projectionMatrix = new Matrix4();
          this.projectionMatrixInverse = new Matrix4();
          this.coordinateSystem = WebGLCoordinateSystem;
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          this.coordinateSystem = source.coordinateSystem;
          return this;
        }
        getWorldDirection(target) {
          return super.getWorldDirection(target).negate();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      PerspectiveCamera = class extends Camera {
        constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
          super();
          this.isPerspectiveCamera = true;
          this.type = "PerspectiveCamera";
          this.fov = fov2;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect2;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        /**
         * Sets the FOV by focal length in respect to the current .filmGauge.
         *
         * The default film gauge is 35, so that the focal length can be specified for
         * a 35mm (full frame) camera.
         *
         * Values for focal length and film gauge must have the same unit.
         */
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        /**
         * Calculates the focal length from the current .fov and .filmGauge.
         */
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG * 2 * Math.atan(
            Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
          );
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        /**
         * Sets an offset in a larger frustum. This is useful for multi-window or
         * multi-monitor/multi-machine setups.
         *
         * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
         * the monitors are in grid like this
         *
         *   +---+---+---+
         *   | A | B | C |
         *   +---+---+---+
         *   | D | E | F |
         *   +---+---+---+
         *
         * then for each monitor you would call it like this
         *
         *   const w = 1920;
         *   const h = 1080;
         *   const fullWidth = w * 3;
         *   const fullHeight = h * 2;
         *
         *   --A--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
         *   --B--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
         *   --C--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
         *   --D--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
         *   --E--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
         *   --F--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
         *
         *   Note there is no reason monitors have to be the same size or in a grid.
         */
        setViewOffset(fullWidth, fullHeight, x4, y3, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x4;
          this.view.offsetY = y3;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
          let height = 2 * top;
          let width = this.aspect * height;
          let left = -0.5 * width;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      };
      fov = -90;
      aspect = 1;
      CubeCamera = class extends Object3D {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          this.renderTarget = renderTarget;
          this.coordinateSystem = null;
          this.activeMipmapLevel = 0;
          const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
          cameraPX.layers = this.layers;
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
          cameraNX.layers = this.layers;
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
          cameraPY.layers = this.layers;
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
          cameraNY.layers = this.layers;
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraPZ.layers = this.layers;
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraNZ.layers = this.layers;
          this.add(cameraNZ);
        }
        updateCoordinateSystem() {
          const coordinateSystem = this.coordinateSystem;
          const cameras = this.children.concat();
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
          for (const camera of cameras)
            this.remove(camera);
          if (coordinateSystem === WebGLCoordinateSystem) {
            cameraPX.up.set(0, 1, 0);
            cameraPX.lookAt(1, 0, 0);
            cameraNX.up.set(0, 1, 0);
            cameraNX.lookAt(-1, 0, 0);
            cameraPY.up.set(0, 0, -1);
            cameraPY.lookAt(0, 1, 0);
            cameraNY.up.set(0, 0, 1);
            cameraNY.lookAt(0, -1, 0);
            cameraPZ.up.set(0, 1, 0);
            cameraPZ.lookAt(0, 0, 1);
            cameraNZ.up.set(0, 1, 0);
            cameraNZ.lookAt(0, 0, -1);
          } else if (coordinateSystem === WebGPUCoordinateSystem) {
            cameraPX.up.set(0, -1, 0);
            cameraPX.lookAt(-1, 0, 0);
            cameraNX.up.set(0, -1, 0);
            cameraNX.lookAt(1, 0, 0);
            cameraPY.up.set(0, 0, 1);
            cameraPY.lookAt(0, 1, 0);
            cameraNY.up.set(0, 0, -1);
            cameraNY.lookAt(0, -1, 0);
            cameraPZ.up.set(0, -1, 0);
            cameraPZ.lookAt(0, 0, 1);
            cameraNZ.up.set(0, -1, 0);
            cameraNZ.lookAt(0, 0, -1);
          } else {
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
          }
          for (const camera of cameras) {
            this.add(camera);
            camera.updateMatrixWorld();
          }
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const { renderTarget, activeMipmapLevel } = this;
          if (this.coordinateSystem !== renderer.coordinateSystem) {
            this.coordinateSystem = renderer.coordinateSystem;
            this.updateCoordinateSystem();
          }
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentRenderTarget = renderer.getRenderTarget();
          const currentActiveCubeFace = renderer.getActiveCubeFace();
          const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
          const currentXrEnabled = renderer.xr.enabled;
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
          renderer.xr.enabled = currentXrEnabled;
          renderTarget.texture.needsPMREMUpdate = true;
        }
      };
      CubeTexture = class extends Texture {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
          this.isCubeTexture = true;
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      };
      WebGLCubeRenderTarget = class extends WebGLRenderTarget {
        constructor(size = 1, options = {}) {
          super(size, size, options);
          this.isWebGLCubeRenderTarget = true;
          const image = { width: size, height: size, depth: 1 };
          const images = [image, image, image, image, image, image];
          if (options.encoding !== void 0) {
            warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.");
            options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
          }
          this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.colorSpace = texture.colorSpace;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: { value: null }
            },
            vertexShader: (
              /* glsl */
              `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
            ),
            fragmentShader: (
              /* glsl */
              `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            )
          };
          const geometry = new BoxGeometry(5, 5, 5);
          const material = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
          });
          material.uniforms.tEquirect.value = texture;
          const mesh = new Mesh(geometry, material);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter)
            texture.minFilter = LinearFilter;
          const camera = new CubeCamera(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i5 = 0; i5 < 6; i5++) {
            renderer.setRenderTarget(this, i5);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      };
      _vector1 = /* @__PURE__ */ new Vector3();
      _vector2 = /* @__PURE__ */ new Vector3();
      _normalMatrix = /* @__PURE__ */ new Matrix3();
      Plane = class {
        constructor(normal = new Vector3(1, 0, 0), constant = 0) {
          this.isPlane = true;
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x4, y3, z4, w3) {
          this.normal.set(x4, y3, z4);
          this.constant = w3;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a4, b3, c5) {
          const normal = _vector1.subVectors(c5, b3).cross(_vector2.subVectors(a4, b3)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a4);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector1);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t4 = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t4 < 0 || t4 > 1) {
            return null;
          }
          return target.copy(line.start).addScaledVector(direction, t4);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _sphere$4 = /* @__PURE__ */ new Sphere();
      _vector$6 = /* @__PURE__ */ new Vector3();
      Frustum = class {
        constructor(p0 = new Plane(), p1 = new Plane(), p22 = new Plane(), p32 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
          this.planes = [p0, p1, p22, p32, p4, p5];
        }
        set(p0, p1, p22, p32, p4, p5) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p22);
          planes[3].copy(p32);
          planes[4].copy(p4);
          planes[5].copy(p5);
          return this;
        }
        copy(frustum2) {
          const planes = this.planes;
          for (let i5 = 0; i5 < 6; i5++) {
            planes[i5].copy(frustum2.planes[i5]);
          }
          return this;
        }
        setFromProjectionMatrix(m4, coordinateSystem = WebGLCoordinateSystem) {
          const planes = this.planes;
          const me4 = m4.elements;
          const me0 = me4[0], me1 = me4[1], me22 = me4[2], me32 = me4[3];
          const me42 = me4[4], me5 = me4[5], me6 = me4[6], me7 = me4[7];
          const me8 = me4[8], me9 = me4[9], me10 = me4[10], me11 = me4[11];
          const me12 = me4[12], me13 = me4[13], me14 = me4[14], me15 = me4[15];
          planes[0].setComponents(me32 - me0, me7 - me42, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me32 + me0, me7 + me42, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me32 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me32 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me32 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
          if (coordinateSystem === WebGLCoordinateSystem) {
            planes[5].setComponents(me32 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
          } else if (coordinateSystem === WebGPUCoordinateSystem) {
            planes[5].setComponents(me22, me6, me10, me14).normalize();
          } else {
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
          }
          return this;
        }
        intersectsObject(object) {
          if (object.boundingSphere !== void 0) {
            if (object.boundingSphere === null)
              object.computeBoundingSphere();
            _sphere$4.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
          } else {
            const geometry = object.geometry;
            if (geometry.boundingSphere === null)
              geometry.computeBoundingSphere();
            _sphere$4.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
          }
          return this.intersectsSphere(_sphere$4);
        }
        intersectsSprite(sprite) {
          _sphere$4.center.set(0, 0, 0);
          _sphere$4.radius = 0.7071067811865476;
          _sphere$4.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$4);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i5 = 0; i5 < 6; i5++) {
            const distance = planes[i5].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i5 = 0; i5 < 6; i5++) {
            const plane = planes[i5];
            _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$6) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i5 = 0; i5 < 6; i5++) {
            if (planes[i5].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width,
            height,
            widthSegments,
            heightSegments
          };
          const width_half = width / 2;
          const height_half = height / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width / gridX;
          const segment_height = height / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y3 = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x4 = ix * segment_width - width_half;
              vertices.push(x4, -y3, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a4 = ix + gridX1 * iy;
              const b3 = ix + gridX1 * (iy + 1);
              const c5 = ix + 1 + gridX1 * (iy + 1);
              const d4 = ix + 1 + gridX1 * iy;
              indices.push(a4, b3, d4);
              indices.push(b3, c5, d4);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
          super.copy(source);
          this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        static fromJSON(data) {
          return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      };
      alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
      alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
      alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
      alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
      alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
      aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
      aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
      beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
      iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
      bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
      cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
      emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}";
      envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
      fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
      fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
      lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
      lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
      lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
      lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
      envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
      lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
      lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
      lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	anisotropyV /= material.anisotropy;\n	material.anisotropy = saturate( material.anisotropy );\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";
      lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
      lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
      logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
      map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
      morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
      morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
      morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
      normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
      normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
      normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
      clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
      clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
      clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
      iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
      opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
      packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
      premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
      shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
      skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
      transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
      uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
      uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
      uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
      worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
      vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
      vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
      vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
      vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
      vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
      fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
      vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
      ShaderChunk = {
        alphahash_fragment,
        alphahash_pars_fragment,
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        alphatest_pars_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        iridescence_fragment,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        colorspace_fragment,
        colorspace_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_fragment,
        lightmap_pars_fragment,
        lights_lambert_fragment,
        lights_lambert_pars_fragment,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphcolor_vertex,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normal_pars_fragment,
        normal_pars_vertex,
        normal_vertex,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        iridescence_pars_fragment,
        opaque_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        worldpos_vertex,
        background_vert: vertex$h,
        background_frag: fragment$h,
        backgroundCube_vert: vertex$g,
        backgroundCube_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
      };
      UniformsLib = {
        common: {
          diffuse: { value: /* @__PURE__ */ new Color(16777215) },
          opacity: { value: 1 },
          map: { value: null },
          mapTransform: { value: /* @__PURE__ */ new Matrix3() },
          alphaMap: { value: null },
          alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          alphaTest: { value: 0 }
        },
        specularmap: {
          specularMap: { value: null },
          specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          // basic, lambert, phong
          ior: { value: 1.5 },
          // physical
          refractionRatio: { value: 0.98 }
          // basic, lambert, phong
        },
        aomap: {
          aoMap: { value: null },
          aoMapIntensity: { value: 1 },
          aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
          lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        bumpmap: {
          bumpMap: { value: null },
          bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          bumpScale: { value: 1 }
        },
        normalmap: {
          normalMap: { value: null },
          normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 }
        },
        emissivemap: {
          emissiveMap: { value: null },
          emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        metalnessmap: {
          metalnessMap: { value: null },
          metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        roughnessmap: {
          roughnessMap: { value: null },
          roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        gradientmap: {
          gradientMap: { value: null }
        },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: /* @__PURE__ */ new Color(16777215) }
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: { value: [], properties: {
            direction: {},
            color: {}
          } },
          directionalLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          } },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: { value: [], properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          } },
          spotLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          } },
          spotLightMap: { value: [] },
          spotShadowMap: { value: [] },
          spotLightMatrix: { value: [] },
          pointLights: { value: [], properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          } },
          pointLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          } },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: { value: [], properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          } },
          // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
          rectAreaLights: { value: [], properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          } },
          ltc_1: { value: null },
          ltc_2: { value: null }
        },
        points: {
          diffuse: { value: /* @__PURE__ */ new Color(16777215) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          alphaTest: { value: 0 },
          uvTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        sprite: {
          diffuse: { value: /* @__PURE__ */ new Color(16777215) },
          opacity: { value: 1 },
          center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          mapTransform: { value: /* @__PURE__ */ new Matrix3() },
          alphaMap: { value: null },
          alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
          alphaTest: { value: 0 }
        }
      };
      ShaderLib = {
        basic: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) }
            }
          ]),
          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) },
              specular: { value: /* @__PURE__ */ new Color(1118481) },
              shininess: { value: 30 }
            }
          ]),
          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 }
              // temporary
            }
          ]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) }
            }
          ]),
          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
              matcap: { value: null }
            }
          ]),
          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 }
            }
          ]),
          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
          ]),
          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.meshnormal_vert,
          fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: { value: /* @__PURE__ */ new Matrix3() },
            t2D: { value: null },
            backgroundIntensity: { value: 1 }
          },
          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            backgroundBlurriness: { value: 0 },
            backgroundIntensity: { value: 1 }
          },
          vertexShader: ShaderChunk.backgroundCube_vert,
          fragmentShader: ShaderChunk.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: { value: null },
            tFlip: { value: -1 },
            opacity: { value: 1 }
          },
          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: { value: null }
          },
          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
              referencePosition: { value: /* @__PURE__ */ new Vector3() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 }
            }
          ]),
          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
              color: { value: /* @__PURE__ */ new Color(0) },
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag
        }
      };
      ShaderLib.physical = {
        uniforms: /* @__PURE__ */ mergeUniforms([
          ShaderLib.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            sheen: { value: 0 },
            sheenColor: { value: /* @__PURE__ */ new Color(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: /* @__PURE__ */ new Color(0) },
            specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
            anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      };
      _rgb = { r: 0, b: 0, g: 0 };
      OrthographicCamera = class extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.isOrthographicCamera = true;
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x4, y3, width, height) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x4;
          this.view.offsetY = y3;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      };
      LOD_MIN = 4;
      EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      MAX_SAMPLES = 20;
      _flatCamera = /* @__PURE__ */ new OrthographicCamera();
      _clearColor = /* @__PURE__ */ new Color();
      _oldTarget = null;
      _oldActiveCubeFace = 0;
      _oldActiveMipmapLevel = 0;
      PHI = (1 + Math.sqrt(5)) / 2;
      INV_PHI = 1 / PHI;
      _axisDirections = [
        /* @__PURE__ */ new Vector3(1, 1, 1),
        /* @__PURE__ */ new Vector3(-1, 1, 1),
        /* @__PURE__ */ new Vector3(1, 1, -1),
        /* @__PURE__ */ new Vector3(-1, 1, -1),
        /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
        /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
        /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
        /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
        /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
        /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
      ];
      PMREMGenerator = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._lodMax = 0;
          this._cubeSize = 0;
          this._lodPlanes = [];
          this._sizeLods = [];
          this._sigmas = [];
          this._blurMaterial = null;
          this._cubemapMaterial = null;
          this._equirectMaterial = null;
          this._compileMaterial(this._blurMaterial);
        }
        /**
         * Generates a PMREM from a supplied Scene, which can be faster than using an
         * image if networking bandwidth is low. Optional sigma specifies a blur radius
         * in radians to be applied to the scene before PMREM generation. Optional near
         * and far planes ensure the scene is rendered in its entirety (the cubeCamera
         * is placed at the origin).
         */
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget = this._renderer.getRenderTarget();
          _oldActiveCubeFace = this._renderer.getActiveCubeFace();
          _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
          this._setSize(256);
          const cubeUVRenderTarget = this._allocateTargets();
          cubeUVRenderTarget.depthBuffer = true;
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        /**
         * Generates a PMREM from an equirectangular texture, which can be either LDR
         * or HDR. The ideal input image size is 1k (1024 x 512),
         * as this matches best with the 256 x 256 cubemap output.
         */
        fromEquirectangular(equirectangular, renderTarget = null) {
          return this._fromTexture(equirectangular, renderTarget);
        }
        /**
         * Generates a PMREM from an cubemap texture, which can be either LDR
         * or HDR. The ideal input cube size is 256 x 256,
         * as this matches best with the 256 x 256 cubemap output.
         */
        fromCubemap(cubemap, renderTarget = null) {
          return this._fromTexture(cubemap, renderTarget);
        }
        /**
         * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
         * your texture's network fetch for increased concurrency.
         */
        compileCubemapShader() {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial();
            this._compileMaterial(this._cubemapMaterial);
          }
        }
        /**
         * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
         * your texture's network fetch for increased concurrency.
         */
        compileEquirectangularShader() {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial();
            this._compileMaterial(this._equirectMaterial);
          }
        }
        /**
         * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
         * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
         * one of them will cause any others to also become unusable.
         */
        dispose() {
          this._dispose();
          if (this._cubemapMaterial !== null)
            this._cubemapMaterial.dispose();
          if (this._equirectMaterial !== null)
            this._equirectMaterial.dispose();
        }
        // private interface
        _setSize(cubeSize) {
          this._lodMax = Math.floor(Math.log2(cubeSize));
          this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          if (this._blurMaterial !== null)
            this._blurMaterial.dispose();
          if (this._pingPongRenderTarget !== null)
            this._pingPongRenderTarget.dispose();
          for (let i5 = 0; i5 < this._lodPlanes.length; i5++) {
            this._lodPlanes[i5].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture, renderTarget) {
          if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
            this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
          } else {
            this._setSize(texture.image.width / 4);
          }
          _oldTarget = this._renderer.getRenderTarget();
          _oldActiveCubeFace = this._renderer.getActiveCubeFace();
          _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
          const cubeUVRenderTarget = renderTarget || this._allocateTargets();
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets() {
          const width = 3 * Math.max(this._cubeSize, 16 * 7);
          const height = 4 * this._cubeSize;
          const params = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            colorSpace: LinearSRGBColorSpace,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget(width, height, params);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
            if (this._pingPongRenderTarget !== null) {
              this._dispose();
            }
            this._pingPongRenderTarget = _createRenderTarget(width, height, params);
            const { _lodMax } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
            this._blurMaterial = _getBlurShader(_lodMax, width, height);
          }
          return cubeUVRenderTarget;
        }
        _compileMaterial(material) {
          const tmpMesh = new Mesh(this._lodPlanes[0], material);
          this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov2 = 90;
          const aspect2 = 1;
          const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor);
          renderer.toneMapping = NoToneMapping;
          renderer.autoClear = false;
          const backgroundMaterial = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: false,
            depthTest: false
          });
          const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background);
              scene.background = null;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor);
            useSolidColor = true;
          }
          for (let i5 = 0; i5 < 6; i5++) {
            const col = i5 % 3;
            if (col === 0) {
              cubeCamera.up.set(0, upSign[i5], 0);
              cubeCamera.lookAt(forwardSign[i5], 0, 0);
            } else if (col === 1) {
              cubeCamera.up.set(0, 0, upSign[i5]);
              cubeCamera.lookAt(0, forwardSign[i5], 0);
            } else {
              cubeCamera.up.set(0, upSign[i5], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i5]);
            }
            const size = this._cubeSize;
            _setViewport(cubeUVRenderTarget, col * size, i5 > 2 ? size : 0, size, size);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          backgroundBox.geometry.dispose();
          backgroundBox.material.dispose();
          renderer.toneMapping = toneMapping;
          renderer.autoClear = originalAutoClear;
          scene.background = background;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
          if (isCubeTexture) {
            if (this._cubemapMaterial === null) {
              this._cubemapMaterial = _getCubemapMaterial();
            }
            this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
          } else {
            if (this._equirectMaterial === null) {
              this._equirectMaterial = _getEquirectMaterial();
            }
          }
          const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
          const mesh = new Mesh(this._lodPlanes[0], material);
          const uniforms = material.uniforms;
          uniforms["envMap"].value = texture;
          const size = this._cubeSize;
          _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i5 = 1; i5 < this._lodPlanes.length; i5++) {
            const sigma = Math.sqrt(this._sigmas[i5] * this._sigmas[i5] - this._sigmas[i5 - 1] * this._sigmas[i5 - 1]);
            const poleAxis = _axisDirections[(i5 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i5 - 1, i5, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        /**
         * This is a two-pass Gaussian blur for a cubemap. Normally this is done
         * vertically and horizontally, but this breaks down on a cube. Here we apply
         * the blur latitudinally (around the poles), and then longitudinally (towards
         * the poles) to approximate the orthogonally-separable blur. It is least
         * accurate at the poles, but still does a decent job.
         */
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(
            cubeUVRenderTarget,
            pingPongRenderTarget,
            lodIn,
            lodOut,
            sigma,
            "latitudinal",
            poleAxis
          );
          this._halfBlur(
            pingPongRenderTarget,
            cubeUVRenderTarget,
            lodOut,
            lodOut,
            sigma,
            "longitudinal",
            poleAxis
          );
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = this._sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
          if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
          }
          const weights = [];
          let sum = 0;
          for (let i5 = 0; i5 < MAX_SAMPLES; ++i5) {
            const x5 = i5 / sigmaPixels;
            const weight = Math.exp(-x5 * x5 / 2);
            weights.push(weight);
            if (i5 === 0) {
              sum += weight;
            } else if (i5 < samples) {
              sum += 2 * weight;
            }
          }
          for (let i5 = 0; i5 < weights.length; i5++) {
            weights[i5] = weights[i5] / sum;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          const { _lodMax } = this;
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = _lodMax - lodIn;
          const outputSize = this._sizeLods[lodOut];
          const x4 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
          const y3 = 4 * (this._cubeSize - outputSize);
          _setViewport(targetOut, x4, y3, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);
        }
      };
      emptyTexture = /* @__PURE__ */ new Texture();
      emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
      empty3dTexture = /* @__PURE__ */ new Data3DTexture();
      emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
      arrayCacheF32 = [];
      arrayCacheI32 = [];
      mat4array = new Float32Array(16);
      mat3array = new Float32Array(9);
      mat2array = new Float32Array(4);
      SingleUniform = class {
        constructor(id2, activeInfo, addr) {
          this.id = id2;
          this.addr = addr;
          this.cache = [];
          this.setValue = getSingularSetter(activeInfo.type);
        }
      };
      PureArrayUniform = class {
        constructor(id2, activeInfo, addr) {
          this.id = id2;
          this.addr = addr;
          this.cache = [];
          this.size = activeInfo.size;
          this.setValue = getPureArraySetter(activeInfo.type);
        }
      };
      StructuredUniform = class {
        constructor(id2) {
          this.id = id2;
          this.seq = [];
          this.map = {};
        }
        setValue(gl3, value, textures) {
          const seq = this.seq;
          for (let i5 = 0, n4 = seq.length; i5 !== n4; ++i5) {
            const u4 = seq[i5];
            u4.setValue(gl3, value[u4.id], textures);
          }
        }
      };
      RePathPart = /(\w+)(\])?(\[|\.)?/g;
      WebGLUniforms = class {
        constructor(gl3, program) {
          this.seq = [];
          this.map = {};
          const n4 = gl3.getProgramParameter(program, gl3.ACTIVE_UNIFORMS);
          for (let i5 = 0; i5 < n4; ++i5) {
            const info = gl3.getActiveUniform(program, i5), addr = gl3.getUniformLocation(program, info.name);
            parseUniform(info, addr, this);
          }
        }
        setValue(gl3, name2, value, textures) {
          const u4 = this.map[name2];
          if (u4 !== void 0)
            u4.setValue(gl3, value, textures);
        }
        setOptional(gl3, object, name2) {
          const v5 = object[name2];
          if (v5 !== void 0)
            this.setValue(gl3, name2, v5);
        }
        static upload(gl3, seq, values, textures) {
          for (let i5 = 0, n4 = seq.length; i5 !== n4; ++i5) {
            const u4 = seq[i5], v5 = values[u4.id];
            if (v5.needsUpdate !== false) {
              u4.setValue(gl3, v5.value, textures);
            }
          }
        }
        static seqWithValue(seq, values) {
          const r4 = [];
          for (let i5 = 0, n4 = seq.length; i5 !== n4; ++i5) {
            const u4 = seq[i5];
            if (u4.id in values)
              r4.push(u4);
          }
          return r4;
        }
      };
      COMPLETION_STATUS_KHR = 37297;
      programIdCount = 0;
      includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
      shaderChunkMap = /* @__PURE__ */ new Map([
        ["encodings_fragment", "colorspace_fragment"],
        // @deprecated, r154
        ["encodings_pars_fragment", "colorspace_pars_fragment"],
        // @deprecated, r154
        ["output_fragment", "opaque_fragment"]
        // @deprecated, r154
      ]);
      unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      _id$1 = 0;
      WebGLShaderCache = class {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map();
          this.materialCache = /* @__PURE__ */ new Map();
        }
        update(material) {
          const vertexShader = material.vertexShader;
          const fragmentShader = material.fragmentShader;
          const vertexShaderStage = this._getShaderStage(vertexShader);
          const fragmentShaderStage = this._getShaderStage(fragmentShader);
          const materialShaders = this._getShaderCacheForMaterial(material);
          if (materialShaders.has(vertexShaderStage) === false) {
            materialShaders.add(vertexShaderStage);
            vertexShaderStage.usedTimes++;
          }
          if (materialShaders.has(fragmentShaderStage) === false) {
            materialShaders.add(fragmentShaderStage);
            fragmentShaderStage.usedTimes++;
          }
          return this;
        }
        remove(material) {
          const materialShaders = this.materialCache.get(material);
          for (const shaderStage of materialShaders) {
            shaderStage.usedTimes--;
            if (shaderStage.usedTimes === 0)
              this.shaderCache.delete(shaderStage.code);
          }
          this.materialCache.delete(material);
          return this;
        }
        getVertexShaderID(material) {
          return this._getShaderStage(material.vertexShader).id;
        }
        getFragmentShaderID(material) {
          return this._getShaderStage(material.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear();
          this.materialCache.clear();
        }
        _getShaderCacheForMaterial(material) {
          const cache = this.materialCache;
          let set3 = cache.get(material);
          if (set3 === void 0) {
            set3 = /* @__PURE__ */ new Set();
            cache.set(material, set3);
          }
          return set3;
        }
        _getShaderStage(code) {
          const cache = this.shaderCache;
          let stage = cache.get(code);
          if (stage === void 0) {
            stage = new WebGLShaderStage(code);
            cache.set(code, stage);
          }
          return stage;
        }
      };
      WebGLShaderStage = class {
        constructor(code) {
          this.id = _id$1++;
          this.code = code;
          this.usedTimes = 0;
        }
      };
      nextVersion = 0;
      MeshDepthMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshDepthMaterial = true;
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      };
      MeshDistanceMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshDistanceMaterial = true;
          this.type = "MeshDistanceMaterial";
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      };
      vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      ArrayCamera = class extends PerspectiveCamera {
        constructor(array = []) {
          super();
          this.isArrayCamera = true;
          this.cameras = array;
        }
      };
      Group = class extends Object3D {
        constructor() {
          super();
          this.isGroup = true;
          this.type = "Group";
        }
      };
      _moveEvent = { type: "move" };
      WebXRController = class {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = { pinching: false };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector3();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector3();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector3();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector3();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        connect(inputSource) {
          if (inputSource && inputSource.hand) {
            const hand = this._hand;
            if (hand) {
              for (const inputjoint of inputSource.hand.values()) {
                this._getHandJoint(hand, inputjoint);
              }
            }
          }
          this.dispatchEvent({ type: "connected", data: inputSource });
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({ type: "disconnected", data: inputSource });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                const joint = this._getHandJoint(hand, inputjoint);
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.matrixWorldNeedsUpdate = true;
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  grip.matrixWorldNeedsUpdate = true;
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose === null && gripPose !== null) {
                inputPose = gripPose;
              }
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                targetRay.matrixWorldNeedsUpdate = true;
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent);
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
        // private method
        _getHandJoint(hand, inputjoint) {
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint = new Group();
            joint.matrixAutoUpdate = false;
            joint.visible = false;
            hand.joints[inputjoint.jointName] = joint;
            hand.add(joint);
          }
          return hand.joints[inputjoint.jointName];
        }
      };
      DepthTexture = class extends Texture {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
          format = format !== void 0 ? format : DepthFormat;
          if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type === void 0 && format === DepthFormat)
            type = UnsignedIntType;
          if (type === void 0 && format === DepthStencilFormat)
            type = UnsignedInt248Type;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.isDepthTexture = true;
          this.image = { width, height };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
          this.flipY = false;
          this.generateMipmaps = false;
          this.compareFunction = null;
        }
        copy(source) {
          super.copy(source);
          this.compareFunction = source.compareFunction;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.compareFunction !== null)
            data.compareFunction = this.compareFunction;
          return data;
        }
      };
      WebXRManager = class extends EventDispatcher {
        constructor(renderer, gl3) {
          super();
          const scope = this;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          let foveation = 1;
          let customReferenceSpace = null;
          let pose = null;
          let glBinding = null;
          let glProjLayer = null;
          let glBaseLayer = null;
          let xrFrame = null;
          const attributes = gl3.getContextAttributes();
          let initialRenderTarget = null;
          let newRenderTarget = null;
          const controllers = [];
          const controllerInputSources = [];
          const cameraL = new PerspectiveCamera();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector4();
          const cameraR = new PerspectiveCamera();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector4();
          const cameras = [cameraL, cameraR];
          const cameraXR = new ArrayCamera();
          cameraXR.layers.enable(1);
          cameraXR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controllerIndex = controllerInputSources.indexOf(event.inputSource);
            if (controllerIndex === -1) {
              return;
            }
            const controller = controllers[controllerIndex];
            if (controller !== void 0) {
              controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
              controller.dispatchEvent({ type: event.type, data: event.inputSource });
            }
          }
          function onSessionEnd() {
            session.removeEventListener("select", onSessionEvent);
            session.removeEventListener("selectstart", onSessionEvent);
            session.removeEventListener("selectend", onSessionEvent);
            session.removeEventListener("squeeze", onSessionEvent);
            session.removeEventListener("squeezestart", onSessionEvent);
            session.removeEventListener("squeezeend", onSessionEvent);
            session.removeEventListener("end", onSessionEnd);
            session.removeEventListener("inputsourceschange", onInputSourcesChange);
            for (let i5 = 0; i5 < controllers.length; i5++) {
              const inputSource = controllerInputSources[i5];
              if (inputSource === null)
                continue;
              controllerInputSources[i5] = null;
              controllers[i5].disconnect(inputSource);
            }
            _currentDepthNear = null;
            _currentDepthFar = null;
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({ type: "sessionend" });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return customReferenceSpace || referenceSpace;
          };
          this.setReferenceSpace = function(space) {
            customReferenceSpace = space;
          };
          this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
          };
          this.getBinding = function() {
            return glBinding;
          };
          this.getFrame = function() {
            return xrFrame;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                await gl3.makeXRCompatible();
              }
              if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
                const layerInit = {
                  antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                  alpha: true,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl3, layerInit);
                session.updateRenderState({ baseLayer: glBaseLayer });
                newRenderTarget = new WebGLRenderTarget(
                  glBaseLayer.framebufferWidth,
                  glBaseLayer.framebufferHeight,
                  {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    colorSpace: renderer.outputColorSpace,
                    stencilBuffer: attributes.stencil
                  }
                );
              } else {
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? gl3.DEPTH24_STENCIL8 : gl3.DEPTH_COMPONENT24;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
                }
                const projectionlayerInit = {
                  colorFormat: gl3.RGBA8,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl3);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({ layers: [glProjLayer] });
                newRenderTarget = new WebGLRenderTarget(
                  glProjLayer.textureWidth,
                  glProjLayer.textureHeight,
                  {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    colorSpace: renderer.outputColorSpace,
                    samples: attributes.antialias ? 4 : 0
                  }
                );
                const renderTargetProperties = renderer.properties.get(newRenderTarget);
                renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
              }
              newRenderTarget.isXRRenderTarget = true;
              this.setFoveation(foveation);
              customReferenceSpace = null;
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({ type: "sessionstart" });
            }
          };
          this.getEnvironmentBlendMode = function() {
            if (session !== null) {
              return session.environmentBlendMode;
            }
          };
          function onInputSourcesChange(event) {
            for (let i5 = 0; i5 < event.removed.length; i5++) {
              const inputSource = event.removed[i5];
              const index = controllerInputSources.indexOf(inputSource);
              if (index >= 0) {
                controllerInputSources[index] = null;
                controllers[index].disconnect(inputSource);
              }
            }
            for (let i5 = 0; i5 < event.added.length; i5++) {
              const inputSource = event.added[i5];
              let controllerIndex = controllerInputSources.indexOf(inputSource);
              if (controllerIndex === -1) {
                for (let i6 = 0; i6 < controllers.length; i6++) {
                  if (i6 >= controllerInputSources.length) {
                    controllerInputSources.push(inputSource);
                    controllerIndex = i6;
                    break;
                  } else if (controllerInputSources[i6] === null) {
                    controllerInputSources[i6] = inputSource;
                    controllerIndex = i6;
                    break;
                  }
                }
                if (controllerIndex === -1)
                  break;
              }
              const controller = controllers[controllerIndex];
              if (controller) {
                controller.connect(inputSource);
              }
            }
          }
          const cameraLPos = new Vector3();
          const cameraRPos = new Vector3();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraXR.near = cameraR.near = cameraL.near = camera.near;
            cameraXR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
              session.updateRenderState({
                depthNear: cameraXR.near,
                depthFar: cameraXR.far
              });
              _currentDepthNear = cameraXR.near;
              _currentDepthFar = cameraXR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraXR.cameras;
            updateCamera(cameraXR, parent);
            for (let i5 = 0; i5 < cameras2.length; i5++) {
              updateCamera(cameras2[i5], parent);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraXR, cameraL, cameraR);
            } else {
              cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
            updateUserCamera(camera, cameraXR, parent);
          };
          function updateUserCamera(camera, cameraXR2, parent) {
            if (parent === null) {
              camera.matrix.copy(cameraXR2.matrixWorld);
            } else {
              camera.matrix.copy(parent.matrixWorld);
              camera.matrix.invert();
              camera.matrix.multiply(cameraXR2.matrixWorld);
            }
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            camera.updateMatrixWorld(true);
            camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
            camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
            if (camera.isPerspectiveCamera) {
              camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
              camera.zoom = 1;
            }
          }
          this.getCamera = function() {
            return cameraXR;
          };
          this.getFoveation = function() {
            if (glProjLayer === null && glBaseLayer === null) {
              return void 0;
            }
            return foveation;
          };
          this.setFoveation = function(value) {
            foveation = value;
            if (glProjLayer !== null) {
              glProjLayer.fixedFoveation = value;
            }
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
              glBaseLayer.fixedFoveation = value;
            }
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
              const views = pose.views;
              if (glBaseLayer !== null) {
                renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                renderer.setRenderTarget(newRenderTarget);
              }
              let cameraXRNeedsUpdate = false;
              if (views.length !== cameraXR.cameras.length) {
                cameraXR.cameras.length = 0;
                cameraXRNeedsUpdate = true;
              }
              for (let i5 = 0; i5 < views.length; i5++) {
                const view = views[i5];
                let viewport = null;
                if (glBaseLayer !== null) {
                  viewport = glBaseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  viewport = glSubImage.viewport;
                  if (i5 === 0) {
                    renderer.setRenderTargetTextures(
                      newRenderTarget,
                      glSubImage.colorTexture,
                      glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
                    );
                    renderer.setRenderTarget(newRenderTarget);
                  }
                }
                let camera = cameras[i5];
                if (camera === void 0) {
                  camera = new PerspectiveCamera();
                  camera.layers.enable(i5);
                  camera.viewport = new Vector4();
                  cameras[i5] = camera;
                }
                camera.matrix.fromArray(view.transform.matrix);
                camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i5 === 0) {
                  cameraXR.matrix.copy(camera.matrix);
                  cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
                }
                if (cameraXRNeedsUpdate === true) {
                  cameraXR.cameras.push(camera);
                }
              }
            }
            for (let i5 = 0; i5 < controllers.length; i5++) {
              const inputSource = controllerInputSources[i5];
              const controller = controllers[i5];
              if (inputSource !== null && controller !== void 0) {
                controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
              }
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time, frame);
            if (frame.detectedPlanes) {
              scope.dispatchEvent({ type: "planesdetected", data: frame });
            }
            xrFrame = null;
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      };
      WebGLRenderer = class {
        constructor(parameters = {}) {
          const {
            canvas = createCanvasElement(),
            context = null,
            depth = true,
            stencil = true,
            alpha = false,
            antialias = false,
            premultipliedAlpha = true,
            preserveDrawingBuffer = false,
            powerPreference = "default",
            failIfMajorPerformanceCaveat = false
          } = parameters;
          this.isWebGLRenderer = true;
          let _alpha;
          if (context !== null) {
            _alpha = context.getContextAttributes().alpha;
          } else {
            _alpha = alpha;
          }
          const uintClearColor = new Uint32Array(4);
          const intClearColor = new Int32Array(4);
          let currentRenderList = null;
          let currentRenderState = null;
          const renderListStack = [];
          const renderStateStack = [];
          this.domElement = canvas;
          this.debug = {
            /**
             * Enables error checking and reporting when shader programs are being compiled
             * @type {boolean}
             */
            checkShaderErrors: true,
            /**
             * Callback for custom error reporting.
             * @type {?Function}
             */
            onShaderError: null
          };
          this.autoClear = true;
          this.autoClearColor = true;
          this.autoClearDepth = true;
          this.autoClearStencil = true;
          this.sortObjects = true;
          this.clippingPlanes = [];
          this.localClippingEnabled = false;
          this._outputColorSpace = SRGBColorSpace;
          this._useLegacyLights = false;
          this.toneMapping = NoToneMapping;
          this.toneMappingExposure = 1;
          const _this = this;
          let _isContextLost = false;
          let _currentActiveCubeFace = 0;
          let _currentActiveMipmapLevel = 0;
          let _currentRenderTarget = null;
          let _currentMaterialId = -1;
          let _currentCamera = null;
          const _currentViewport = new Vector4();
          const _currentScissor = new Vector4();
          let _currentScissorTest = null;
          const _currentClearColor = new Color(0);
          let _currentClearAlpha = 0;
          let _width = canvas.width;
          let _height = canvas.height;
          let _pixelRatio = 1;
          let _opaqueSort = null;
          let _transparentSort = null;
          const _viewport = new Vector4(0, 0, _width, _height);
          const _scissor = new Vector4(0, 0, _width, _height);
          let _scissorTest = false;
          const _frustum = new Frustum();
          let _clippingEnabled = false;
          let _localClippingEnabled = false;
          let _transmissionRenderTarget = null;
          const _projScreenMatrix2 = new Matrix4();
          const _vector22 = new Vector2();
          const _vector32 = new Vector3();
          const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
          function getTargetPixelRatio() {
            return _currentRenderTarget === null ? _pixelRatio : 1;
          }
          let _gl = context;
          function getContext(contextNames, contextAttributes) {
            for (let i5 = 0; i5 < contextNames.length; i5++) {
              const contextName = contextNames[i5];
              const context2 = canvas.getContext(contextName, contextAttributes);
              if (context2 !== null)
                return context2;
            }
            return null;
          }
          try {
            const contextAttributes = {
              alpha: true,
              depth,
              stencil,
              antialias,
              premultipliedAlpha,
              preserveDrawingBuffer,
              powerPreference,
              failIfMajorPerformanceCaveat
            };
            if ("setAttribute" in canvas)
              canvas.setAttribute("data-engine", `three.js r${REVISION}`);
            canvas.addEventListener("webglcontextlost", onContextLost, false);
            canvas.addEventListener("webglcontextrestored", onContextRestore, false);
            canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
            if (_gl === null) {
              const contextNames = ["webgl2", "webgl", "experimental-webgl"];
              if (_this.isWebGL1Renderer === true) {
                contextNames.shift();
              }
              _gl = getContext(contextNames, contextAttributes);
              if (_gl === null) {
                if (getContext(contextNames)) {
                  throw new Error("Error creating WebGL context with your selected attributes.");
                } else {
                  throw new Error("Error creating WebGL context.");
                }
              }
            }
            if (typeof WebGLRenderingContext !== "undefined" && _gl instanceof WebGLRenderingContext) {
              console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.");
            }
            if (_gl.getShaderPrecisionFormat === void 0) {
              _gl.getShaderPrecisionFormat = function() {
                return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
              };
            }
          } catch (error) {
            console.error("THREE.WebGLRenderer: " + error.message);
            throw error;
          }
          let extensions, capabilities, state, info;
          let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
          let programCache, materials, renderLists, renderStates, clipping, shadowMap;
          let background, morphtargets, bufferRenderer, indexedBufferRenderer;
          let utils, bindingStates, uniformsGroups;
          function initGLContext() {
            extensions = new WebGLExtensions(_gl);
            capabilities = new WebGLCapabilities(_gl, extensions, parameters);
            extensions.init(capabilities);
            utils = new WebGLUtils(_gl, extensions, capabilities);
            state = new WebGLState(_gl, extensions, capabilities);
            info = new WebGLInfo(_gl);
            properties = new WebGLProperties();
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
            cubemaps = new WebGLCubeMaps(_this);
            cubeuvmaps = new WebGLCubeUVMaps(_this);
            attributes = new WebGLAttributes(_gl, capabilities);
            bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
            geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
            objects = new WebGLObjects(_gl, geometries, attributes, info);
            morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
            clipping = new WebGLClipping(properties);
            programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
            materials = new WebGLMaterials(_this, properties);
            renderLists = new WebGLRenderLists();
            renderStates = new WebGLRenderStates(extensions, capabilities);
            background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
            shadowMap = new WebGLShadowMap(_this, objects, capabilities);
            uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
            indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
            info.programs = programCache.programs;
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.shadowMap = shadowMap;
            _this.state = state;
            _this.info = info;
          }
          initGLContext();
          const xr5 = new WebXRManager(_this, _gl);
          this.xr = xr5;
          this.getContext = function() {
            return _gl;
          };
          this.getContextAttributes = function() {
            return _gl.getContextAttributes();
          };
          this.forceContextLoss = function() {
            const extension = extensions.get("WEBGL_lose_context");
            if (extension)
              extension.loseContext();
          };
          this.forceContextRestore = function() {
            const extension = extensions.get("WEBGL_lose_context");
            if (extension)
              extension.restoreContext();
          };
          this.getPixelRatio = function() {
            return _pixelRatio;
          };
          this.setPixelRatio = function(value) {
            if (value === void 0)
              return;
            _pixelRatio = value;
            this.setSize(_width, _height, false);
          };
          this.getSize = function(target) {
            return target.set(_width, _height);
          };
          this.setSize = function(width, height, updateStyle = true) {
            if (xr5.isPresenting) {
              console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
              return;
            }
            _width = width;
            _height = height;
            canvas.width = Math.floor(width * _pixelRatio);
            canvas.height = Math.floor(height * _pixelRatio);
            if (updateStyle === true) {
              canvas.style.width = width + "px";
              canvas.style.height = height + "px";
            }
            this.setViewport(0, 0, width, height);
          };
          this.getDrawingBufferSize = function(target) {
            return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
          };
          this.setDrawingBufferSize = function(width, height, pixelRatio) {
            _width = width;
            _height = height;
            _pixelRatio = pixelRatio;
            canvas.width = Math.floor(width * pixelRatio);
            canvas.height = Math.floor(height * pixelRatio);
            this.setViewport(0, 0, width, height);
          };
          this.getCurrentViewport = function(target) {
            return target.copy(_currentViewport);
          };
          this.getViewport = function(target) {
            return target.copy(_viewport);
          };
          this.setViewport = function(x4, y3, width, height) {
            if (x4.isVector4) {
              _viewport.set(x4.x, x4.y, x4.z, x4.w);
            } else {
              _viewport.set(x4, y3, width, height);
            }
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
          };
          this.getScissor = function(target) {
            return target.copy(_scissor);
          };
          this.setScissor = function(x4, y3, width, height) {
            if (x4.isVector4) {
              _scissor.set(x4.x, x4.y, x4.z, x4.w);
            } else {
              _scissor.set(x4, y3, width, height);
            }
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
          };
          this.getScissorTest = function() {
            return _scissorTest;
          };
          this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
          };
          this.setOpaqueSort = function(method2) {
            _opaqueSort = method2;
          };
          this.setTransparentSort = function(method2) {
            _transparentSort = method2;
          };
          this.getClearColor = function(target) {
            return target.copy(background.getClearColor());
          };
          this.setClearColor = function() {
            background.setClearColor.apply(background, arguments);
          };
          this.getClearAlpha = function() {
            return background.getClearAlpha();
          };
          this.setClearAlpha = function() {
            background.setClearAlpha.apply(background, arguments);
          };
          this.clear = function(color = true, depth2 = true, stencil2 = true) {
            let bits2 = 0;
            if (color) {
              let isIntegerFormat = false;
              if (_currentRenderTarget !== null) {
                const targetFormat = _currentRenderTarget.texture.format;
                isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
              }
              if (isIntegerFormat) {
                const targetType = _currentRenderTarget.texture.type;
                const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
                const clearColor = background.getClearColor();
                const a4 = background.getClearAlpha();
                const r4 = clearColor.r;
                const g4 = clearColor.g;
                const b3 = clearColor.b;
                if (isUnsignedType) {
                  uintClearColor[0] = r4;
                  uintClearColor[1] = g4;
                  uintClearColor[2] = b3;
                  uintClearColor[3] = a4;
                  _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
                } else {
                  intClearColor[0] = r4;
                  intClearColor[1] = g4;
                  intClearColor[2] = b3;
                  intClearColor[3] = a4;
                  _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
                }
              } else {
                bits2 |= _gl.COLOR_BUFFER_BIT;
              }
            }
            if (depth2)
              bits2 |= _gl.DEPTH_BUFFER_BIT;
            if (stencil2) {
              bits2 |= _gl.STENCIL_BUFFER_BIT;
              this.state.buffers.stencil.setMask(4294967295);
            }
            _gl.clear(bits2);
          };
          this.clearColor = function() {
            this.clear(true, false, false);
          };
          this.clearDepth = function() {
            this.clear(false, true, false);
          };
          this.clearStencil = function() {
            this.clear(false, false, true);
          };
          this.dispose = function() {
            canvas.removeEventListener("webglcontextlost", onContextLost, false);
            canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
            canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
            renderLists.dispose();
            renderStates.dispose();
            properties.dispose();
            cubemaps.dispose();
            cubeuvmaps.dispose();
            objects.dispose();
            bindingStates.dispose();
            uniformsGroups.dispose();
            programCache.dispose();
            xr5.dispose();
            xr5.removeEventListener("sessionstart", onXRSessionStart);
            xr5.removeEventListener("sessionend", onXRSessionEnd);
            if (_transmissionRenderTarget) {
              _transmissionRenderTarget.dispose();
              _transmissionRenderTarget = null;
            }
            animation.stop();
          };
          function onContextLost(event) {
            event.preventDefault();
            console.log("THREE.WebGLRenderer: Context Lost.");
            _isContextLost = true;
          }
          function onContextRestore() {
            console.log("THREE.WebGLRenderer: Context Restored.");
            _isContextLost = false;
            const infoAutoReset = info.autoReset;
            const shadowMapEnabled = shadowMap.enabled;
            const shadowMapAutoUpdate = shadowMap.autoUpdate;
            const shadowMapNeedsUpdate = shadowMap.needsUpdate;
            const shadowMapType = shadowMap.type;
            initGLContext();
            info.autoReset = infoAutoReset;
            shadowMap.enabled = shadowMapEnabled;
            shadowMap.autoUpdate = shadowMapAutoUpdate;
            shadowMap.needsUpdate = shadowMapNeedsUpdate;
            shadowMap.type = shadowMapType;
          }
          function onContextCreationError(event) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
          }
          function onMaterialDispose(event) {
            const material = event.target;
            material.removeEventListener("dispose", onMaterialDispose);
            deallocateMaterial(material);
          }
          function deallocateMaterial(material) {
            releaseMaterialProgramReferences(material);
            properties.remove(material);
          }
          function releaseMaterialProgramReferences(material) {
            const programs = properties.get(material).programs;
            if (programs !== void 0) {
              programs.forEach(function(program) {
                programCache.releaseProgram(program);
              });
              if (material.isShaderMaterial) {
                programCache.releaseShaderCache(material);
              }
            }
          }
          this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
            if (scene === null)
              scene = _emptyScene;
            const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
            const program = setProgram(camera, scene, geometry, material, object);
            state.setMaterial(material, frontFaceCW);
            let index = geometry.index;
            let rangeFactor = 1;
            if (material.wireframe === true) {
              index = geometries.getWireframeAttribute(geometry);
              if (index === void 0)
                return;
              rangeFactor = 2;
            }
            const drawRange = geometry.drawRange;
            const position = geometry.attributes.position;
            let drawStart = drawRange.start * rangeFactor;
            let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
            if (group !== null) {
              drawStart = Math.max(drawStart, group.start * rangeFactor);
              drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
            }
            if (index !== null) {
              drawStart = Math.max(drawStart, 0);
              drawEnd = Math.min(drawEnd, index.count);
            } else if (position !== void 0 && position !== null) {
              drawStart = Math.max(drawStart, 0);
              drawEnd = Math.min(drawEnd, position.count);
            }
            const drawCount = drawEnd - drawStart;
            if (drawCount < 0 || drawCount === Infinity)
              return;
            bindingStates.setup(object, material, program, geometry, index);
            let attribute;
            let renderer = bufferRenderer;
            if (index !== null) {
              attribute = attributes.get(index);
              renderer = indexedBufferRenderer;
              renderer.setIndex(attribute);
            }
            if (object.isMesh) {
              if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(_gl.LINES);
              } else {
                renderer.setMode(_gl.TRIANGLES);
              }
            } else if (object.isLine) {
              let lineWidth = material.linewidth;
              if (lineWidth === void 0)
                lineWidth = 1;
              state.setLineWidth(lineWidth * getTargetPixelRatio());
              if (object.isLineSegments) {
                renderer.setMode(_gl.LINES);
              } else if (object.isLineLoop) {
                renderer.setMode(_gl.LINE_LOOP);
              } else {
                renderer.setMode(_gl.LINE_STRIP);
              }
            } else if (object.isPoints) {
              renderer.setMode(_gl.POINTS);
            } else if (object.isSprite) {
              renderer.setMode(_gl.TRIANGLES);
            }
            if (object.isInstancedMesh) {
              renderer.renderInstances(drawStart, drawCount, object.count);
            } else if (geometry.isInstancedBufferGeometry) {
              const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
              const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
              renderer.renderInstances(drawStart, drawCount, instanceCount);
            } else {
              renderer.render(drawStart, drawCount);
            }
          };
          function prepareMaterial(material, scene, object) {
            if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
              material.side = BackSide;
              material.needsUpdate = true;
              getProgram(material, scene, object);
              material.side = FrontSide;
              material.needsUpdate = true;
              getProgram(material, scene, object);
              material.side = DoubleSide;
            } else {
              getProgram(material, scene, object);
            }
          }
          this.compile = function(scene, camera, targetScene = null) {
            if (targetScene === null)
              targetScene = scene;
            currentRenderState = renderStates.get(targetScene);
            currentRenderState.init();
            renderStateStack.push(currentRenderState);
            targetScene.traverseVisible(function(object) {
              if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) {
                  currentRenderState.pushShadow(object);
                }
              }
            });
            if (scene !== targetScene) {
              scene.traverseVisible(function(object) {
                if (object.isLight && object.layers.test(camera.layers)) {
                  currentRenderState.pushLight(object);
                  if (object.castShadow) {
                    currentRenderState.pushShadow(object);
                  }
                }
              });
            }
            currentRenderState.setupLights(_this._useLegacyLights);
            const materials2 = /* @__PURE__ */ new Set();
            scene.traverse(function(object) {
              const material = object.material;
              if (material) {
                if (Array.isArray(material)) {
                  for (let i5 = 0; i5 < material.length; i5++) {
                    const material2 = material[i5];
                    prepareMaterial(material2, targetScene, object);
                    materials2.add(material2);
                  }
                } else {
                  prepareMaterial(material, targetScene, object);
                  materials2.add(material);
                }
              }
            });
            renderStateStack.pop();
            currentRenderState = null;
            return materials2;
          };
          this.compileAsync = function(scene, camera, targetScene = null) {
            const materials2 = this.compile(scene, camera, targetScene);
            return new Promise((resolve) => {
              function checkMaterialsReady() {
                materials2.forEach(function(material) {
                  const materialProperties = properties.get(material);
                  const program = materialProperties.currentProgram;
                  if (program.isReady()) {
                    materials2.delete(material);
                  }
                });
                if (materials2.size === 0) {
                  resolve(scene);
                  return;
                }
                setTimeout(checkMaterialsReady, 10);
              }
              if (extensions.get("KHR_parallel_shader_compile") !== null) {
                checkMaterialsReady();
              } else {
                setTimeout(checkMaterialsReady, 10);
              }
            });
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time) {
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time);
          }
          function onXRSessionStart() {
            animation.stop();
          }
          function onXRSessionEnd() {
            animation.start();
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          if (typeof self !== "undefined")
            animation.setContext(self);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
            xr5.setAnimationLoop(callback);
            callback === null ? animation.stop() : animation.start();
          };
          xr5.addEventListener("sessionstart", onXRSessionStart);
          xr5.addEventListener("sessionend", onXRSessionEnd);
          this.render = function(scene, camera) {
            if (camera !== void 0 && camera.isCamera !== true) {
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              return;
            }
            if (_isContextLost === true)
              return;
            if (scene.matrixWorldAutoUpdate === true)
              scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
              camera.updateMatrixWorld();
            if (xr5.enabled === true && xr5.isPresenting === true) {
              if (xr5.cameraAutoUpdate === true)
                xr5.updateCamera(camera);
              camera = xr5.getCamera();
            }
            if (scene.isScene === true)
              scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
            currentRenderState = renderStates.get(scene, renderStateStack.length);
            currentRenderState.init();
            renderStateStack.push(currentRenderState);
            _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromProjectionMatrix(_projScreenMatrix2);
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
            currentRenderList = renderLists.get(scene, renderListStack.length);
            currentRenderList.init();
            renderListStack.push(currentRenderList);
            projectObject(scene, camera, 0, _this.sortObjects);
            currentRenderList.finish();
            if (_this.sortObjects === true) {
              currentRenderList.sort(_opaqueSort, _transparentSort);
            }
            this.info.render.frame++;
            if (_clippingEnabled === true)
              clipping.beginShadows();
            const shadowsArray = currentRenderState.state.shadowsArray;
            shadowMap.render(shadowsArray, scene, camera);
            if (_clippingEnabled === true)
              clipping.endShadows();
            if (this.info.autoReset === true)
              this.info.reset();
            background.render(currentRenderList, scene);
            currentRenderState.setupLights(_this._useLegacyLights);
            if (camera.isArrayCamera) {
              const cameras = camera.cameras;
              for (let i5 = 0, l4 = cameras.length; i5 < l4; i5++) {
                const camera2 = cameras[i5];
                renderScene(currentRenderList, scene, camera2, camera2.viewport);
              }
            } else {
              renderScene(currentRenderList, scene, camera);
            }
            if (_currentRenderTarget !== null) {
              textures.updateMultisampleRenderTarget(_currentRenderTarget);
              textures.updateRenderTargetMipmap(_currentRenderTarget);
            }
            if (scene.isScene === true)
              scene.onAfterRender(_this, scene, camera);
            bindingStates.resetDefaultState();
            _currentMaterialId = -1;
            _currentCamera = null;
            renderStateStack.pop();
            if (renderStateStack.length > 0) {
              currentRenderState = renderStateStack[renderStateStack.length - 1];
            } else {
              currentRenderState = null;
            }
            renderListStack.pop();
            if (renderListStack.length > 0) {
              currentRenderList = renderListStack[renderListStack.length - 1];
            } else {
              currentRenderList = null;
            }
          };
          function projectObject(object, camera, groupOrder, sortObjects) {
            if (object.visible === false)
              return;
            const visible = object.layers.test(camera.layers);
            if (visible) {
              if (object.isGroup) {
                groupOrder = object.renderOrder;
              } else if (object.isLOD) {
                if (object.autoUpdate === true)
                  object.update(camera);
              } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) {
                  currentRenderState.pushShadow(object);
                }
              } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                  if (sortObjects) {
                    _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                  }
                  const geometry = objects.update(object);
                  const material = object.material;
                  if (material.visible) {
                    currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
                  }
                }
              } else if (object.isMesh || object.isLine || object.isPoints) {
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                  const geometry = objects.update(object);
                  const material = object.material;
                  if (sortObjects) {
                    if (object.boundingSphere !== void 0) {
                      if (object.boundingSphere === null)
                        object.computeBoundingSphere();
                      _vector32.copy(object.boundingSphere.center);
                    } else {
                      if (geometry.boundingSphere === null)
                        geometry.computeBoundingSphere();
                      _vector32.copy(geometry.boundingSphere.center);
                    }
                    _vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                  }
                  if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for (let i5 = 0, l4 = groups.length; i5 < l4; i5++) {
                      const group = groups[i5];
                      const groupMaterial = material[group.materialIndex];
                      if (groupMaterial && groupMaterial.visible) {
                        currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector32.z, group);
                      }
                    }
                  } else if (material.visible) {
                    currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
                  }
                }
              }
            }
            const children = object.children;
            for (let i5 = 0, l4 = children.length; i5 < l4; i5++) {
              projectObject(children[i5], camera, groupOrder, sortObjects);
            }
          }
          function renderScene(currentRenderList2, scene, camera, viewport) {
            const opaqueObjects = currentRenderList2.opaque;
            const transmissiveObjects = currentRenderList2.transmissive;
            const transparentObjects = currentRenderList2.transparent;
            currentRenderState.setupLightsView(camera);
            if (_clippingEnabled === true)
              clipping.setGlobalState(_this.clippingPlanes, camera);
            if (transmissiveObjects.length > 0)
              renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
            if (viewport)
              state.viewport(_currentViewport.copy(viewport));
            if (opaqueObjects.length > 0)
              renderObjects(opaqueObjects, scene, camera);
            if (transmissiveObjects.length > 0)
              renderObjects(transmissiveObjects, scene, camera);
            if (transparentObjects.length > 0)
              renderObjects(transparentObjects, scene, camera);
            state.buffers.depth.setTest(true);
            state.buffers.depth.setMask(true);
            state.buffers.color.setMask(true);
            state.setPolygonOffset(false);
          }
          function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
            const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
            if (overrideMaterial !== null) {
              return;
            }
            const isWebGL2 = capabilities.isWebGL2;
            if (_transmissionRenderTarget === null) {
              _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
                generateMipmaps: true,
                type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
                minFilter: LinearMipmapLinearFilter,
                samples: isWebGL2 ? 4 : 0
              });
            }
            _this.getDrawingBufferSize(_vector22);
            if (isWebGL2) {
              _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
            } else {
              _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
            }
            const currentRenderTarget = _this.getRenderTarget();
            _this.setRenderTarget(_transmissionRenderTarget);
            _this.getClearColor(_currentClearColor);
            _currentClearAlpha = _this.getClearAlpha();
            if (_currentClearAlpha < 1)
              _this.setClearColor(16777215, 0.5);
            _this.clear();
            const currentToneMapping = _this.toneMapping;
            _this.toneMapping = NoToneMapping;
            renderObjects(opaqueObjects, scene, camera);
            textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
            textures.updateRenderTargetMipmap(_transmissionRenderTarget);
            let renderTargetNeedsUpdate = false;
            for (let i5 = 0, l4 = transmissiveObjects.length; i5 < l4; i5++) {
              const renderItem = transmissiveObjects[i5];
              const object = renderItem.object;
              const geometry = renderItem.geometry;
              const material = renderItem.material;
              const group = renderItem.group;
              if (material.side === DoubleSide && object.layers.test(camera.layers)) {
                const currentSide = material.side;
                material.side = BackSide;
                material.needsUpdate = true;
                renderObject(object, scene, camera, geometry, material, group);
                material.side = currentSide;
                material.needsUpdate = true;
                renderTargetNeedsUpdate = true;
              }
            }
            if (renderTargetNeedsUpdate === true) {
              textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
              textures.updateRenderTargetMipmap(_transmissionRenderTarget);
            }
            _this.setRenderTarget(currentRenderTarget);
            _this.setClearColor(_currentClearColor, _currentClearAlpha);
            _this.toneMapping = currentToneMapping;
          }
          function renderObjects(renderList, scene, camera) {
            const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
            for (let i5 = 0, l4 = renderList.length; i5 < l4; i5++) {
              const renderItem = renderList[i5];
              const object = renderItem.object;
              const geometry = renderItem.geometry;
              const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
              const group = renderItem.group;
              if (object.layers.test(camera.layers)) {
                renderObject(object, scene, camera, geometry, material, group);
              }
            }
          }
          function renderObject(object, scene, camera, geometry, material, group) {
            object.onBeforeRender(_this, scene, camera, geometry, material, group);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            material.onBeforeRender(_this, scene, camera, geometry, object, group);
            if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
              material.side = BackSide;
              material.needsUpdate = true;
              _this.renderBufferDirect(camera, scene, geometry, material, object, group);
              material.side = FrontSide;
              material.needsUpdate = true;
              _this.renderBufferDirect(camera, scene, geometry, material, object, group);
              material.side = DoubleSide;
            } else {
              _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            }
            object.onAfterRender(_this, scene, camera, geometry, material, group);
          }
          function getProgram(material, scene, object) {
            if (scene.isScene !== true)
              scene = _emptyScene;
            const materialProperties = properties.get(material);
            const lights = currentRenderState.state.lights;
            const shadowsArray = currentRenderState.state.shadowsArray;
            const lightsStateVersion = lights.state.version;
            const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
            const programCacheKey = programCache.getProgramCacheKey(parameters2);
            let programs = materialProperties.programs;
            materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
            materialProperties.fog = scene.fog;
            materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
            if (programs === void 0) {
              material.addEventListener("dispose", onMaterialDispose);
              programs = /* @__PURE__ */ new Map();
              materialProperties.programs = programs;
            }
            let program = programs.get(programCacheKey);
            if (program !== void 0) {
              if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                updateCommonMaterialProperties(material, parameters2);
                return program;
              }
            } else {
              parameters2.uniforms = programCache.getUniforms(material);
              material.onBuild(object, parameters2, _this);
              material.onBeforeCompile(parameters2, _this);
              program = programCache.acquireProgram(parameters2, programCacheKey);
              programs.set(programCacheKey, program);
              materialProperties.uniforms = parameters2.uniforms;
            }
            const uniforms = materialProperties.uniforms;
            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
              uniforms.clippingPlanes = clipping.uniform;
            }
            updateCommonMaterialProperties(material, parameters2);
            materialProperties.needsLights = materialNeedsLights(material);
            materialProperties.lightsStateVersion = lightsStateVersion;
            if (materialProperties.needsLights) {
              uniforms.ambientLightColor.value = lights.state.ambient;
              uniforms.lightProbe.value = lights.state.probe;
              uniforms.directionalLights.value = lights.state.directional;
              uniforms.directionalLightShadows.value = lights.state.directionalShadow;
              uniforms.spotLights.value = lights.state.spot;
              uniforms.spotLightShadows.value = lights.state.spotShadow;
              uniforms.rectAreaLights.value = lights.state.rectArea;
              uniforms.ltc_1.value = lights.state.rectAreaLTC1;
              uniforms.ltc_2.value = lights.state.rectAreaLTC2;
              uniforms.pointLights.value = lights.state.point;
              uniforms.pointLightShadows.value = lights.state.pointShadow;
              uniforms.hemisphereLights.value = lights.state.hemi;
              uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
              uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
              uniforms.spotShadowMap.value = lights.state.spotShadowMap;
              uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
              uniforms.spotLightMap.value = lights.state.spotLightMap;
              uniforms.pointShadowMap.value = lights.state.pointShadowMap;
              uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
            }
            materialProperties.currentProgram = program;
            materialProperties.uniformsList = null;
            return program;
          }
          function getUniformList(materialProperties) {
            if (materialProperties.uniformsList === null) {
              const progUniforms = materialProperties.currentProgram.getUniforms();
              materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
            }
            return materialProperties.uniformsList;
          }
          function updateCommonMaterialProperties(material, parameters2) {
            const materialProperties = properties.get(material);
            materialProperties.outputColorSpace = parameters2.outputColorSpace;
            materialProperties.instancing = parameters2.instancing;
            materialProperties.instancingColor = parameters2.instancingColor;
            materialProperties.skinning = parameters2.skinning;
            materialProperties.morphTargets = parameters2.morphTargets;
            materialProperties.morphNormals = parameters2.morphNormals;
            materialProperties.morphColors = parameters2.morphColors;
            materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
            materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
            materialProperties.numIntersection = parameters2.numClipIntersection;
            materialProperties.vertexAlphas = parameters2.vertexAlphas;
            materialProperties.vertexTangents = parameters2.vertexTangents;
            materialProperties.toneMapping = parameters2.toneMapping;
          }
          function setProgram(camera, scene, geometry, material, object) {
            if (scene.isScene !== true)
              scene = _emptyScene;
            textures.resetTextureUnits();
            const fog = scene.fog;
            const environment = material.isMeshStandardMaterial ? scene.environment : null;
            const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
            const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
            const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
            const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
            const morphTargets = !!geometry.morphAttributes.position;
            const morphNormals = !!geometry.morphAttributes.normal;
            const morphColors = !!geometry.morphAttributes.color;
            let toneMapping = NoToneMapping;
            if (material.toneMapped) {
              if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
                toneMapping = _this.toneMapping;
              }
            }
            const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
            const materialProperties = properties.get(material);
            const lights = currentRenderState.state.lights;
            if (_clippingEnabled === true) {
              if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                clipping.setState(material, camera, useCache);
              }
            }
            let needsProgramChange = false;
            if (material.version === materialProperties.__version) {
              if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
                needsProgramChange = true;
              } else if (materialProperties.outputColorSpace !== colorSpace) {
                needsProgramChange = true;
              } else if (object.isInstancedMesh && materialProperties.instancing === false) {
                needsProgramChange = true;
              } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
                needsProgramChange = true;
              } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
                needsProgramChange = true;
              } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
                needsProgramChange = true;
              } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
                needsProgramChange = true;
              } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
                needsProgramChange = true;
              } else if (materialProperties.envMap !== envMap) {
                needsProgramChange = true;
              } else if (material.fog === true && materialProperties.fog !== fog) {
                needsProgramChange = true;
              } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
                needsProgramChange = true;
              } else if (materialProperties.vertexAlphas !== vertexAlphas) {
                needsProgramChange = true;
              } else if (materialProperties.vertexTangents !== vertexTangents) {
                needsProgramChange = true;
              } else if (materialProperties.morphTargets !== morphTargets) {
                needsProgramChange = true;
              } else if (materialProperties.morphNormals !== morphNormals) {
                needsProgramChange = true;
              } else if (materialProperties.morphColors !== morphColors) {
                needsProgramChange = true;
              } else if (materialProperties.toneMapping !== toneMapping) {
                needsProgramChange = true;
              } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
                needsProgramChange = true;
              }
            } else {
              needsProgramChange = true;
              materialProperties.__version = material.version;
            }
            let program = materialProperties.currentProgram;
            if (needsProgramChange === true) {
              program = getProgram(material, scene, object);
            }
            let refreshProgram = false;
            let refreshMaterial = false;
            let refreshLights = false;
            const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
            if (state.useProgram(program.program)) {
              refreshProgram = true;
              refreshMaterial = true;
              refreshLights = true;
            }
            if (material.id !== _currentMaterialId) {
              _currentMaterialId = material.id;
              refreshMaterial = true;
            }
            if (refreshProgram || _currentCamera !== camera) {
              p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
              p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
              const uCamPos = p_uniforms.map.cameraPosition;
              if (uCamPos !== void 0) {
                uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
              }
              if (capabilities.logarithmicDepthBuffer) {
                p_uniforms.setValue(
                  _gl,
                  "logDepthBufFC",
                  2 / (Math.log(camera.far + 1) / Math.LN2)
                );
              }
              if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
                p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
              }
              if (_currentCamera !== camera) {
                _currentCamera = camera;
                refreshMaterial = true;
                refreshLights = true;
              }
            }
            if (object.isSkinnedMesh) {
              p_uniforms.setOptional(_gl, object, "bindMatrix");
              p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
              const skeleton = object.skeleton;
              if (skeleton) {
                if (capabilities.floatVertexTextures) {
                  if (skeleton.boneTexture === null)
                    skeleton.computeBoneTexture();
                  p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                  p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
                } else {
                  console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
                }
              }
            }
            const morphAttributes = geometry.morphAttributes;
            if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
              morphtargets.update(object, geometry, program);
            }
            if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
              materialProperties.receiveShadow = object.receiveShadow;
              p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
            }
            if (material.isMeshGouraudMaterial && material.envMap !== null) {
              m_uniforms.envMap.value = envMap;
              m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
            }
            if (refreshMaterial) {
              p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
              if (materialProperties.needsLights) {
                markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
              }
              if (fog && material.fog === true) {
                materials.refreshFogUniforms(m_uniforms, fog);
              }
              materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
              WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
            }
            if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
              WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
              material.uniformsNeedUpdate = false;
            }
            if (material.isSpriteMaterial) {
              p_uniforms.setValue(_gl, "center", object.center);
            }
            p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
            p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
            p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
            if (material.isShaderMaterial || material.isRawShaderMaterial) {
              const groups = material.uniformsGroups;
              for (let i5 = 0, l4 = groups.length; i5 < l4; i5++) {
                if (capabilities.isWebGL2) {
                  const group = groups[i5];
                  uniformsGroups.update(group, program);
                  uniformsGroups.bind(group, program);
                } else {
                  console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
                }
              }
            }
            return program;
          }
          function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.lightProbe.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.directionalLightShadows.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.pointLightShadows.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.spotLightShadows.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
          }
          function materialNeedsLights(material) {
            return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
          }
          this.getActiveCubeFace = function() {
            return _currentActiveCubeFace;
          };
          this.getActiveMipmapLevel = function() {
            return _currentActiveMipmapLevel;
          };
          this.getRenderTarget = function() {
            return _currentRenderTarget;
          };
          this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
            properties.get(renderTarget.texture).__webglTexture = colorTexture;
            properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
            const renderTargetProperties = properties.get(renderTarget);
            renderTargetProperties.__hasExternalTextures = true;
            if (renderTargetProperties.__hasExternalTextures) {
              renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
              if (!renderTargetProperties.__autoAllocateDepthBuffer) {
                if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
                  console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
                  renderTargetProperties.__useRenderToTexture = false;
                }
              }
            }
          };
          this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
            const renderTargetProperties = properties.get(renderTarget);
            renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
            renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
          };
          this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
            _currentRenderTarget = renderTarget;
            _currentActiveCubeFace = activeCubeFace;
            _currentActiveMipmapLevel = activeMipmapLevel;
            let useDefaultFramebuffer = true;
            let framebuffer = null;
            let isCube = false;
            let isRenderTarget3D = false;
            if (renderTarget) {
              const renderTargetProperties = properties.get(renderTarget);
              if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
                state.bindFramebuffer(_gl.FRAMEBUFFER, null);
                useDefaultFramebuffer = false;
              } else if (renderTargetProperties.__webglFramebuffer === void 0) {
                textures.setupRenderTarget(renderTarget);
              } else if (renderTargetProperties.__hasExternalTextures) {
                textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
              }
              const texture = renderTarget.texture;
              if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
                isRenderTarget3D = true;
              }
              const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
              if (renderTarget.isWebGLCubeRenderTarget) {
                if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
                  framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
                } else {
                  framebuffer = __webglFramebuffer[activeCubeFace];
                }
                isCube = true;
              } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
                framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
              } else {
                if (Array.isArray(__webglFramebuffer)) {
                  framebuffer = __webglFramebuffer[activeMipmapLevel];
                } else {
                  framebuffer = __webglFramebuffer;
                }
              }
              _currentViewport.copy(renderTarget.viewport);
              _currentScissor.copy(renderTarget.scissor);
              _currentScissorTest = renderTarget.scissorTest;
            } else {
              _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
              _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
              _currentScissorTest = _scissorTest;
            }
            const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
              state.drawBuffers(renderTarget, framebuffer);
            }
            state.viewport(_currentViewport);
            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);
            if (isCube) {
              const textureProperties = properties.get(renderTarget.texture);
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
            } else if (isRenderTarget3D) {
              const textureProperties = properties.get(renderTarget.texture);
              const layer = activeCubeFace || 0;
              _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
            }
            _currentMaterialId = -1;
          };
          this.readRenderTargetPixels = function(renderTarget, x4, y3, width, height, buffer, activeCubeFaceIndex) {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              return;
            }
            let framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
              framebuffer = framebuffer[activeCubeFaceIndex];
            }
            if (framebuffer) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
              try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return;
                }
                const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
                !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
                !halfFloatSupportedByExt) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return;
                }
                if (x4 >= 0 && x4 <= renderTarget.width - width && (y3 >= 0 && y3 <= renderTarget.height - height)) {
                  _gl.readPixels(x4, y3, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                }
              } finally {
                const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
              }
            }
          };
          this.copyFramebufferToTexture = function(position, texture, level = 0) {
            const levelScale = Math.pow(2, -level);
            const width = Math.floor(texture.image.width * levelScale);
            const height = Math.floor(texture.image.height * levelScale);
            textures.setTexture2D(texture, 0);
            _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
            state.unbindTexture();
          };
          this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
            const width = srcTexture.image.width;
            const height = srcTexture.image.height;
            const glFormat = utils.convert(dstTexture.format);
            const glType = utils.convert(dstTexture.type);
            textures.setTexture2D(dstTexture, 0);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
            if (srcTexture.isDataTexture) {
              _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
            } else {
              if (srcTexture.isCompressedTexture) {
                _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
              } else {
                _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
              }
            }
            if (level === 0 && dstTexture.generateMipmaps)
              _gl.generateMipmap(_gl.TEXTURE_2D);
            state.unbindTexture();
          };
          this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
            if (_this.isWebGL1Renderer) {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
              return;
            }
            const width = sourceBox.max.x - sourceBox.min.x + 1;
            const height = sourceBox.max.y - sourceBox.min.y + 1;
            const depth2 = sourceBox.max.z - sourceBox.min.z + 1;
            const glFormat = utils.convert(dstTexture.format);
            const glType = utils.convert(dstTexture.type);
            let glTarget;
            if (dstTexture.isData3DTexture) {
              textures.setTexture3D(dstTexture, 0);
              glTarget = _gl.TEXTURE_3D;
            } else if (dstTexture.isDataArrayTexture) {
              textures.setTexture2DArray(dstTexture, 0);
              glTarget = _gl.TEXTURE_2D_ARRAY;
            } else {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
              return;
            }
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
            const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
            const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
            const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
            const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
            const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
            const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
            if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
              _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image.data);
            } else {
              if (srcTexture.isCompressedArrayTexture) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
                _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, image.data);
              } else {
                _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image);
              }
            }
            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
            if (level === 0 && dstTexture.generateMipmaps)
              _gl.generateMipmap(glTarget);
            state.unbindTexture();
          };
          this.initTexture = function(texture) {
            if (texture.isCubeTexture) {
              textures.setTextureCube(texture, 0);
            } else if (texture.isData3DTexture) {
              textures.setTexture3D(texture, 0);
            } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
              textures.setTexture2DArray(texture, 0);
            } else {
              textures.setTexture2D(texture, 0);
            }
            state.unbindTexture();
          };
          this.resetState = function() {
            _currentActiveCubeFace = 0;
            _currentActiveMipmapLevel = 0;
            _currentRenderTarget = null;
            state.reset();
            bindingStates.reset();
          };
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
        }
        get coordinateSystem() {
          return WebGLCoordinateSystem;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(colorSpace) {
          this._outputColorSpace = colorSpace;
          const gl3 = this.getContext();
          gl3.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
          gl3.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
        }
        get physicallyCorrectLights() {
          console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
          return !this.useLegacyLights;
        }
        set physicallyCorrectLights(value) {
          console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
          this.useLegacyLights = !value;
        }
        get outputEncoding() {
          console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
          return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
        }
        set outputEncoding(encoding) {
          console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
          this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
        }
        get useLegacyLights() {
          console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
          return this._useLegacyLights;
        }
        set useLegacyLights(value) {
          console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
          this._useLegacyLights = value;
        }
      };
      WebGL1Renderer = class extends WebGLRenderer {
      };
      WebGL1Renderer.prototype.isWebGL1Renderer = true;
      Fog = class _Fog {
        constructor(color, near = 1, far = 1e3) {
          this.isFog = true;
          this.name = "";
          this.color = new Color(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new _Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      };
      Scene = class extends Object3D {
        constructor() {
          super();
          this.isScene = true;
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.backgroundBlurriness = 0;
          this.backgroundIntensity = 1;
          this.overrideMaterial = null;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          this.backgroundBlurriness = source.backgroundBlurriness;
          this.backgroundIntensity = source.backgroundIntensity;
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          if (this.backgroundBlurriness > 0)
            data.object.backgroundBlurriness = this.backgroundBlurriness;
          if (this.backgroundIntensity !== 1)
            data.object.backgroundIntensity = this.backgroundIntensity;
          return data;
        }
      };
      InterleavedBuffer = class {
        constructor(array, stride) {
          this.isInterleavedBuffer = true;
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
          this.uuid = generateUUID();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i5 = 0, l4 = this.stride; i5 < l4; i5++) {
            this.array[index1 + i5] = attribute.array[index2 + i5];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib2 = new this.constructor(array, this.stride);
          ib2.setUsage(this.usage);
          return ib2;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      };
      _vector$5 = /* @__PURE__ */ new Vector3();
      InterleavedBufferAttribute = class _InterleavedBufferAttribute {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.isInterleavedBufferAttribute = true;
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m4) {
          for (let i5 = 0, l4 = this.data.count; i5 < l4; i5++) {
            _vector$5.fromBufferAttribute(this, i5);
            _vector$5.applyMatrix4(m4);
            this.setXYZ(i5, _vector$5.x, _vector$5.y, _vector$5.z);
          }
          return this;
        }
        applyNormalMatrix(m4) {
          for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
            _vector$5.fromBufferAttribute(this, i5);
            _vector$5.applyNormalMatrix(m4);
            this.setXYZ(i5, _vector$5.x, _vector$5.y, _vector$5.z);
          }
          return this;
        }
        transformDirection(m4) {
          for (let i5 = 0, l4 = this.count; i5 < l4; i5++) {
            _vector$5.fromBufferAttribute(this, i5);
            _vector$5.transformDirection(m4);
            this.setXYZ(i5, _vector$5.x, _vector$5.y, _vector$5.z);
          }
          return this;
        }
        setX(index, x4) {
          if (this.normalized)
            x4 = normalize(x4, this.array);
          this.data.array[index * this.data.stride + this.offset] = x4;
          return this;
        }
        setY(index, y3) {
          if (this.normalized)
            y3 = normalize(y3, this.array);
          this.data.array[index * this.data.stride + this.offset + 1] = y3;
          return this;
        }
        setZ(index, z4) {
          if (this.normalized)
            z4 = normalize(z4, this.array);
          this.data.array[index * this.data.stride + this.offset + 2] = z4;
          return this;
        }
        setW(index, w3) {
          if (this.normalized)
            w3 = normalize(w3, this.array);
          this.data.array[index * this.data.stride + this.offset + 3] = w3;
          return this;
        }
        getX(index) {
          let x4 = this.data.array[index * this.data.stride + this.offset];
          if (this.normalized)
            x4 = denormalize(x4, this.array);
          return x4;
        }
        getY(index) {
          let y3 = this.data.array[index * this.data.stride + this.offset + 1];
          if (this.normalized)
            y3 = denormalize(y3, this.array);
          return y3;
        }
        getZ(index) {
          let z4 = this.data.array[index * this.data.stride + this.offset + 2];
          if (this.normalized)
            z4 = denormalize(z4, this.array);
          return z4;
        }
        getW(index) {
          let w3 = this.data.array[index * this.data.stride + this.offset + 3];
          if (this.normalized)
            w3 = denormalize(w3, this.array);
          return w3;
        }
        setXY(index, x4, y3) {
          index = index * this.data.stride + this.offset;
          if (this.normalized) {
            x4 = normalize(x4, this.array);
            y3 = normalize(y3, this.array);
          }
          this.data.array[index + 0] = x4;
          this.data.array[index + 1] = y3;
          return this;
        }
        setXYZ(index, x4, y3, z4) {
          index = index * this.data.stride + this.offset;
          if (this.normalized) {
            x4 = normalize(x4, this.array);
            y3 = normalize(y3, this.array);
            z4 = normalize(z4, this.array);
          }
          this.data.array[index + 0] = x4;
          this.data.array[index + 1] = y3;
          this.data.array[index + 2] = z4;
          return this;
        }
        setXYZW(index, x4, y3, z4, w3) {
          index = index * this.data.stride + this.offset;
          if (this.normalized) {
            x4 = normalize(x4, this.array);
            y3 = normalize(y3, this.array);
            z4 = normalize(z4, this.array);
            w3 = normalize(w3, this.array);
          }
          this.data.array[index + 0] = x4;
          this.data.array[index + 1] = y3;
          this.data.array[index + 2] = z4;
          this.data.array[index + 3] = w3;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const array = [];
            for (let i5 = 0; i5 < this.count; i5++) {
              const index = i5 * this.data.stride + this.offset;
              for (let j4 = 0; j4 < this.itemSize; j4++) {
                array.push(this.data.array[index + j4]);
              }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new _InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const array = [];
            for (let i5 = 0; i5 < this.count; i5++) {
              const index = i5 * this.data.stride + this.offset;
              for (let j4 = 0; j4 < this.itemSize; j4++) {
                array.push(this.data.array[index + j4]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      };
      _basePosition = /* @__PURE__ */ new Vector3();
      _skinIndex = /* @__PURE__ */ new Vector4();
      _skinWeight = /* @__PURE__ */ new Vector4();
      _vector3 = /* @__PURE__ */ new Vector3();
      _matrix4 = /* @__PURE__ */ new Matrix4();
      _vertex = /* @__PURE__ */ new Vector3();
      _sphere$3 = /* @__PURE__ */ new Sphere();
      _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
      _ray$2 = /* @__PURE__ */ new Ray();
      SkinnedMesh = class extends Mesh {
        constructor(geometry, material) {
          super(geometry, material);
          this.isSkinnedMesh = true;
          this.type = "SkinnedMesh";
          this.bindMode = AttachedBindMode;
          this.bindMatrix = new Matrix4();
          this.bindMatrixInverse = new Matrix4();
          this.boundingBox = null;
          this.boundingSphere = null;
        }
        computeBoundingBox() {
          const geometry = this.geometry;
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          this.boundingBox.makeEmpty();
          const positionAttribute = geometry.getAttribute("position");
          for (let i5 = 0; i5 < positionAttribute.count; i5++) {
            this.getVertexPosition(i5, _vertex);
            this.boundingBox.expandByPoint(_vertex);
          }
        }
        computeBoundingSphere() {
          const geometry = this.geometry;
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          this.boundingSphere.makeEmpty();
          const positionAttribute = geometry.getAttribute("position");
          for (let i5 = 0; i5 < positionAttribute.count; i5++) {
            this.getVertexPosition(i5, _vertex);
            this.boundingSphere.expandByPoint(_vertex);
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          if (source.boundingBox !== null)
            this.boundingBox = source.boundingBox.clone();
          if (source.boundingSphere !== null)
            this.boundingSphere = source.boundingSphere.clone();
          return this;
        }
        raycast(raycaster, intersects) {
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (this.boundingSphere === null)
            this.computeBoundingSphere();
          _sphere$3.copy(this.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$3) === false)
            return;
          _inverseMatrix$2.copy(matrixWorld).invert();
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
          if (this.boundingBox !== null) {
            if (_ray$2.intersectsBox(this.boundingBox) === false)
              return;
          }
          this._computeIntersections(raycaster, intersects, _ray$2);
        }
        getVertexPosition(index, target) {
          super.getVertexPosition(index, target);
          this.applyBoneTransform(index, target);
          return target;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector4();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i5 = 0, l4 = skinWeight.count; i5 < l4; i5++) {
            vector.fromBufferAttribute(skinWeight, i5);
            const scale4 = 1 / vector.manhattanLength();
            if (scale4 !== Infinity) {
              vector.multiplyScalar(scale4);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i5, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === AttachedBindMode) {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === DetachedBindMode) {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        applyBoneTransform(index, vector) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
          _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
          _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
          vector.set(0, 0, 0);
          for (let i5 = 0; i5 < 4; i5++) {
            const weight = _skinWeight.getComponent(i5);
            if (weight !== 0) {
              const boneIndex = _skinIndex.getComponent(i5);
              _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
            }
          }
          return vector.applyMatrix4(this.bindMatrixInverse);
        }
        boneTransform(index, vector) {
          console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.");
          return this.applyBoneTransform(index, vector);
        }
      };
      Bone = class extends Object3D {
        constructor() {
          super();
          this.isBone = true;
          this.type = "Bone";
        }
      };
      DataTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
          this.isDataTexture = true;
          this.image = { data, width, height };
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      _offsetMatrix = /* @__PURE__ */ new Matrix4();
      _identityMatrix = /* @__PURE__ */ new Matrix4();
      Skeleton = class _Skeleton {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i5 = 0, il3 = this.bones.length; i5 < il3; i5++) {
                this.boneInverses.push(new Matrix4());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i5 = 0, il3 = this.bones.length; i5 < il3; i5++) {
            const inverse = new Matrix4();
            if (this.bones[i5]) {
              inverse.copy(this.bones[i5].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i5 = 0, il3 = this.bones.length; i5 < il3; i5++) {
            const bone = this.bones[i5];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i5]).invert();
            }
          }
          for (let i5 = 0, il3 = this.bones.length; i5 < il3; i5++) {
            const bone = this.bones[i5];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i5 = 0, il3 = bones.length; i5 < il3; i5++) {
            const matrix = bones[i5] ? bones[i5].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i5]);
            _offsetMatrix.toArray(boneMatrices, i5 * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new _Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
          boneTexture.needsUpdate = true;
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name2) {
          for (let i5 = 0, il3 = this.bones.length; i5 < il3; i5++) {
            const bone = this.bones[i5];
            if (bone.name === name2) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i5 = 0, l4 = json.bones.length; i5 < l4; i5++) {
            const uuid = json.bones[i5];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i5]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i5 = 0, l4 = bones.length; i5 < l4; i5++) {
            const bone = bones[i5];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i5];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      };
      InstancedBufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          super(array, itemSize, normalized);
          this.isInstancedBufferAttribute = true;
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      };
      _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
      _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
      _instanceIntersects = [];
      _box3 = /* @__PURE__ */ new Box3();
      _identity = /* @__PURE__ */ new Matrix4();
      _mesh = /* @__PURE__ */ new Mesh();
      _sphere$2 = /* @__PURE__ */ new Sphere();
      InstancedMesh = class extends Mesh {
        constructor(geometry, material, count) {
          super(geometry, material);
          this.isInstancedMesh = true;
          this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.boundingBox = null;
          this.boundingSphere = null;
          for (let i5 = 0; i5 < count; i5++) {
            this.setMatrixAt(i5, _identity);
          }
        }
        computeBoundingBox() {
          const geometry = this.geometry;
          const count = this.count;
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          this.boundingBox.makeEmpty();
          for (let i5 = 0; i5 < count; i5++) {
            this.getMatrixAt(i5, _instanceLocalMatrix);
            _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
            this.boundingBox.union(_box3);
          }
        }
        computeBoundingSphere() {
          const geometry = this.geometry;
          const count = this.count;
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          if (geometry.boundingSphere === null) {
            geometry.computeBoundingSphere();
          }
          this.boundingSphere.makeEmpty();
          for (let i5 = 0; i5 < count; i5++) {
            this.getMatrixAt(i5, _instanceLocalMatrix);
            _sphere$2.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
            this.boundingSphere.union(_sphere$2);
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          if (source.boundingBox !== null)
            this.boundingBox = source.boundingBox.clone();
          if (source.boundingSphere !== null)
            this.boundingSphere = source.boundingSphere.clone();
          return this;
        }
        getColorAt(index, color) {
          color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        raycast(raycaster, intersects) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh.geometry = this.geometry;
          _mesh.material = this.material;
          if (_mesh.material === void 0)
            return;
          if (this.boundingSphere === null)
            this.computeBoundingSphere();
          _sphere$2.copy(this.boundingSphere);
          _sphere$2.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$2) === false)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for (let i5 = 0, l4 = _instanceIntersects.length; i5 < l4; i5++) {
              const intersect = _instanceIntersects[i5];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects.push(intersect);
            }
            _instanceIntersects.length = 0;
          }
        }
        setColorAt(index, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
          matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      LineBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isLineBasicMaterial = true;
          this.type = "LineBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          this.fog = source.fog;
          return this;
        }
      };
      _start$1 = /* @__PURE__ */ new Vector3();
      _end$1 = /* @__PURE__ */ new Vector3();
      _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
      _ray$1 = /* @__PURE__ */ new Ray();
      _sphere$1 = /* @__PURE__ */ new Sphere();
      Line = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
          super();
          this.isLine = true;
          this.type = "Line";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [0];
            for (let i5 = 1, l4 = positionAttribute.count; i5 < l4; i5++) {
              _start$1.fromBufferAttribute(positionAttribute, i5 - 1);
              _end$1.fromBufferAttribute(positionAttribute, i5);
              lineDistances[i5] = lineDistances[i5 - 1];
              lineDistances[i5] += _start$1.distanceTo(_end$1);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
          return this;
        }
        raycast(raycaster, intersects) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$1.copy(geometry.boundingSphere);
          _sphere$1.applyMatrix4(matrixWorld);
          _sphere$1.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$1) === false)
            return;
          _inverseMatrix$1.copy(matrixWorld).invert();
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector3();
          const vEnd = new Vector3();
          const interSegment = new Vector3();
          const interRay = new Vector3();
          const step = this.isLineSegments ? 2 : 1;
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i5 = start, l4 = end - 1; i5 < l4; i5 += step) {
              const a4 = index.getX(i5);
              const b3 = index.getX(i5 + 1);
              vStart.fromBufferAttribute(positionAttribute, a4);
              vEnd.fromBufferAttribute(positionAttribute, b3);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i5,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i5 = start, l4 = end - 1; i5 < l4; i5 += step) {
              vStart.fromBufferAttribute(positionAttribute, i5);
              vEnd.fromBufferAttribute(positionAttribute, i5 + 1);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i5,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m4 = 0, ml3 = morphAttribute.length; m4 < ml3; m4++) {
                const name2 = morphAttribute[m4].name || String(m4);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name2] = m4;
              }
            }
          }
        }
      };
      _start = /* @__PURE__ */ new Vector3();
      _end = /* @__PURE__ */ new Vector3();
      LineSegments = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.isLineSegments = true;
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [];
            for (let i5 = 0, l4 = positionAttribute.count; i5 < l4; i5 += 2) {
              _start.fromBufferAttribute(positionAttribute, i5);
              _end.fromBufferAttribute(positionAttribute, i5 + 1);
              lineDistances[i5] = i5 === 0 ? 0 : lineDistances[i5 - 1];
              lineDistances[i5 + 1] = lineDistances[i5] + _start.distanceTo(_end);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
          return this;
        }
      };
      LineLoop = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.isLineLoop = true;
          this.type = "LineLoop";
        }
      };
      PointsMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isPointsMaterial = true;
          this.type = "PointsMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          this.fog = source.fog;
          return this;
        }
      };
      _inverseMatrix = /* @__PURE__ */ new Matrix4();
      _ray = /* @__PURE__ */ new Ray();
      _sphere = /* @__PURE__ */ new Sphere();
      _position$2 = /* @__PURE__ */ new Vector3();
      Points = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
          super();
          this.isPoints = true;
          this.type = "Points";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere.copy(geometry.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);
          _sphere.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere) === false)
            return;
          _inverseMatrix.copy(matrixWorld).invert();
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i5 = start, il3 = end; i5 < il3; i5++) {
              const a4 = index.getX(i5);
              _position$2.fromBufferAttribute(positionAttribute, a4);
              testPoint(_position$2, a4, localThresholdSq, matrixWorld, raycaster, intersects, this);
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i5 = start, l4 = end; i5 < l4; i5++) {
              _position$2.fromBufferAttribute(positionAttribute, i5);
              testPoint(_position$2, i5, localThresholdSq, matrixWorld, raycaster, intersects, this);
            }
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m4 = 0, ml3 = morphAttribute.length; m4 < ml3; m4++) {
                const name2 = morphAttribute[m4].name || String(m4);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name2] = m4;
              }
            }
          }
        }
      };
      Curve = class {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        // Virtual base class method to overwrite and implement in subclasses
        //	- t [0 .. 1]
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        // Get point at relative position in curve according to arc length
        // - u [0 .. 1]
        getPointAt(u4, optionalTarget) {
          const t4 = this.getUtoTmapping(u4);
          return this.getPoint(t4, optionalTarget);
        }
        // Get sequence of points using getPoint( t )
        getPoints(divisions = 5) {
          const points = [];
          for (let d4 = 0; d4 <= divisions; d4++) {
            points.push(this.getPoint(d4 / divisions));
          }
          return points;
        }
        // Get sequence of points using getPointAt( u )
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d4 = 0; d4 <= divisions; d4++) {
            points.push(this.getPointAt(d4 / divisions));
          }
          return points;
        }
        // Get total curve arc length
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        // Get list of cumulative segment lengths
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;
          cache.push(0);
          for (let p4 = 1; p4 <= divisions; p4++) {
            current = this.getPoint(p4 / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
        getUtoTmapping(u4, distance) {
          const arcLengths = this.getLengths();
          let i5 = 0;
          const il3 = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u4 * arcLengths[il3 - 1];
          }
          let low = 0, high = il3 - 1, comparison;
          while (low <= high) {
            i5 = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i5] - targetArcLength;
            if (comparison < 0) {
              low = i5 + 1;
            } else if (comparison > 0) {
              high = i5 - 1;
            } else {
              high = i5;
              break;
            }
          }
          i5 = high;
          if (arcLengths[i5] === targetArcLength) {
            return i5 / (il3 - 1);
          }
          const lengthBefore = arcLengths[i5];
          const lengthAfter = arcLengths[i5 + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t4 = (i5 + segmentFraction) / (il3 - 1);
          return t4;
        }
        // Returns a unit vector tangent at t
        // In case any sub curve does not implement its tangent derivation,
        // 2 points a small delta apart will be used to find its gradient
        // which seems to give a reasonable approximation
        getTangent(t4, optionalTarget) {
          const delta = 1e-4;
          let t1 = t4 - delta;
          let t22 = t4 + delta;
          if (t1 < 0)
            t1 = 0;
          if (t22 > 1)
            t22 = 1;
          const pt1 = this.getPoint(t1);
          const pt22 = this.getPoint(t22);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
          tangent.copy(pt22).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u4, optionalTarget) {
          const t4 = this.getUtoTmapping(u4);
          return this.getTangent(t4, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector3();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector3();
          const mat = new Matrix4();
          for (let i5 = 0; i5 <= segments; i5++) {
            const u4 = i5 / segments;
            tangents[i5] = this.getTangentAt(u4, new Vector3());
          }
          normals[0] = new Vector3();
          binormals[0] = new Vector3();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty2 = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty2 <= min) {
            min = ty2;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i5 = 1; i5 <= segments; i5++) {
            normals[i5] = normals[i5 - 1].clone();
            binormals[i5] = binormals[i5 - 1].clone();
            vec.crossVectors(tangents[i5 - 1], tangents[i5]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp(tangents[i5 - 1].dot(tangents[i5]), -1, 1));
              normals[i5].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i5].crossVectors(tangents[i5], normals[i5]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i5 = 1; i5 <= segments; i5++) {
              normals[i5].applyMatrix4(mat.makeRotationAxis(tangents[i5], theta * i5));
              binormals[i5].crossVectors(tangents[i5], normals[i5]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      };
      RingGeometry = class _RingGeometry extends BufferGeometry {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius,
            outerRadius,
            thetaSegments,
            phiSegments,
            thetaStart,
            thetaLength
          };
          thetaSegments = Math.max(3, thetaSegments);
          phiSegments = Math.max(1, phiSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let radius = innerRadius;
          const radiusStep = (outerRadius - innerRadius) / phiSegments;
          const vertex2 = new Vector3();
          const uv = new Vector2();
          for (let j4 = 0; j4 <= phiSegments; j4++) {
            for (let i5 = 0; i5 <= thetaSegments; i5++) {
              const segment = thetaStart + i5 / thetaSegments * thetaLength;
              vertex2.x = radius * Math.cos(segment);
              vertex2.y = radius * Math.sin(segment);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, 0, 1);
              uv.x = (vertex2.x / outerRadius + 1) / 2;
              uv.y = (vertex2.y / outerRadius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
          }
          for (let j4 = 0; j4 < phiSegments; j4++) {
            const thetaSegmentLevel = j4 * (thetaSegments + 1);
            for (let i5 = 0; i5 < thetaSegments; i5++) {
              const segment = i5 + thetaSegmentLevel;
              const a4 = segment;
              const b3 = segment + thetaSegments + 1;
              const c5 = segment + thetaSegments + 2;
              const d4 = segment + 1;
              indices.push(a4, b3, d4);
              indices.push(b3, c5, d4);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
          super.copy(source);
          this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        static fromJSON(data) {
          return new _RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
      };
      MeshStandardMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshStandardMaterial = true;
          this.defines = { "STANDARD": "" };
          this.type = "MeshStandardMaterial";
          this.color = new Color(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = { "STANDARD": "" };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      MeshPhysicalMaterial = class extends MeshStandardMaterial {
        constructor(parameters) {
          super();
          this.isMeshPhysicalMaterial = true;
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.anisotropyRotation = 0;
          this.anisotropyMap = null;
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector2(1, 1);
          this.clearcoatNormalMap = null;
          this.ior = 1.5;
          Object.defineProperty(this, "reflectivity", {
            get: function() {
              return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
              this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
          });
          this.iridescenceMap = null;
          this.iridescenceIOR = 1.3;
          this.iridescenceThicknessRange = [100, 400];
          this.iridescenceThicknessMap = null;
          this.sheenColor = new Color(0);
          this.sheenColorMap = null;
          this.sheenRoughness = 1;
          this.sheenRoughnessMap = null;
          this.transmissionMap = null;
          this.thickness = 0;
          this.thicknessMap = null;
          this.attenuationDistance = Infinity;
          this.attenuationColor = new Color(1, 1, 1);
          this.specularIntensity = 1;
          this.specularIntensityMap = null;
          this.specularColor = new Color(1, 1, 1);
          this.specularColorMap = null;
          this._anisotropy = 0;
          this._clearcoat = 0;
          this._iridescence = 0;
          this._sheen = 0;
          this._transmission = 0;
          this.setValues(parameters);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(value) {
          if (this._anisotropy > 0 !== value > 0) {
            this.version++;
          }
          this._anisotropy = value;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(value) {
          if (this._clearcoat > 0 !== value > 0) {
            this.version++;
          }
          this._clearcoat = value;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(value) {
          if (this._iridescence > 0 !== value > 0) {
            this.version++;
          }
          this._iridescence = value;
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(value) {
          if (this._sheen > 0 !== value > 0) {
            this.version++;
          }
          this._sheen = value;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(value) {
          if (this._transmission > 0 !== value > 0) {
            this.version++;
          }
          this._transmission = value;
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.anisotropy = source.anisotropy;
          this.anisotropyRotation = source.anisotropyRotation;
          this.anisotropyMap = source.anisotropyMap;
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.ior = source.ior;
          this.iridescence = source.iridescence;
          this.iridescenceMap = source.iridescenceMap;
          this.iridescenceIOR = source.iridescenceIOR;
          this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
          this.iridescenceThicknessMap = source.iridescenceThicknessMap;
          this.sheen = source.sheen;
          this.sheenColor.copy(source.sheenColor);
          this.sheenColorMap = source.sheenColorMap;
          this.sheenRoughness = source.sheenRoughness;
          this.sheenRoughnessMap = source.sheenRoughnessMap;
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          this.specularIntensity = source.specularIntensity;
          this.specularIntensityMap = source.specularIntensityMap;
          this.specularColor.copy(source.specularColor);
          this.specularColorMap = source.specularColorMap;
          return this;
        }
      };
      MeshPhongMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshPhongMaterial = true;
          this.type = "MeshPhongMaterial";
          this.color = new Color(16777215);
          this.specular = new Color(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      MeshLambertMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshLambertMaterial = true;
          this.type = "MeshLambertMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      Interpolant = class {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t4) {
          const pp2 = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp2[i1], t0 = pp2[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t4 < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t4 < t0)
                          break forward_scan;
                        i1 = pp2.length;
                        this._cachedIndex = i1;
                        return this.copySampleValue_(i1 - 1);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp2[++i1];
                      if (t4 < t1) {
                        break seek;
                      }
                    }
                    right = pp2.length;
                    break linear_scan;
                  }
                if (!(t4 >= t0)) {
                  const t1global = pp2[1];
                  if (t4 < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.copySampleValue_(0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp2[--i1 - 1];
                    if (t4 >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t4 < pp2[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp2[i1];
              t0 = pp2[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (t1 === void 0) {
                i1 = pp2.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t4, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
          for (let i5 = 0; i5 !== stride; ++i5) {
            result[i5] = values[offset + i5];
          }
          return result;
        }
        // Template methods for derived classes:
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      };
      CubicInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp2 = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp2[iPrev], tNext = pp2[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding:
                iPrev = pp2.length - 2;
                tPrev = t0 + pp2[iPrev] - pp2[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp2[1] - pp2[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t4, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p4 = (t4 - t0) / (t1 - t0), pp2 = p4 * p4, ppp = pp2 * p4;
          const sP = -wP * ppp + 2 * wP * pp2 - wP * p4;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp2 + (-0.5 + wP) * p4 + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp2 + 0.5 * p4;
          const sN = wN * ppp - wN * pp2;
          for (let i5 = 0; i5 !== stride; ++i5) {
            result[i5] = sP * values[oP + i5] + s0 * values[o0 + i5] + s1 * values[o1 + i5] + sN * values[oN + i5];
          }
          return result;
        }
      };
      LinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t4, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t4 - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i5 = 0; i5 !== stride; ++i5) {
            result[i5] = values[offset0 + i5] * weight0 + values[offset1 + i5] * weight1;
          }
          return result;
        }
      };
      DiscreteInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      };
      KeyframeTrack = class {
        constructor(name2, times, values, interpolation) {
          if (name2 === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
          this.name = name2;
          this.times = convertArray(times, this.TimeBufferType);
          this.values = convertArray(values, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        // Serialization (in static context, because of constructor invocation
        // and automatic invocation of .toJSON):
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": convertArray(track.times, Array),
              "values": convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        // move all keyframes either forwards or backwards in time
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i5 = 0, n4 = times.length; i5 !== n4; ++i5) {
              times[i5] += timeOffset;
            }
          }
          return this;
        }
        // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i5 = 0, n4 = times.length; i5 !== n4; ++i5) {
              times[i5] *= timeScale;
            }
          }
          return this;
        }
        // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
        // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to4 = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to4 !== -1 && times[to4] > endTime) {
            --to4;
          }
          ++to4;
          if (from !== 0 || to4 !== nKeys) {
            if (from >= to4) {
              to4 = Math.max(to4, 1);
              from = to4 - 1;
            }
            const stride = this.getValueSize();
            this.times = times.slice(from, to4);
            this.values = this.values.slice(from * stride, to4 * stride);
          }
          return this;
        }
        // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i5 = 0; i5 !== nKeys; i5++) {
            const currTime = times[i5];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i5, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i5, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values !== void 0) {
            if (isTypedArray2(values)) {
              for (let i5 = 0, n4 = values.length; i5 !== n4; ++i5) {
                const value = values[i5];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i5, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        // removes equivalent sequential keys as common in morph target sequences
        // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        optimize() {
          const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i5 = 1; i5 < lastIndex; ++i5) {
            let keep = false;
            const time = times[i5];
            const timeNext = times[i5 + 1];
            if (time !== timeNext && (i5 !== 1 || time !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i5 * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j4 = 0; j4 !== stride; ++j4) {
                  const value = values[offset + j4];
                  if (value !== values[offsetP + j4] || value !== values[offsetN + j4]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i5 !== writeIndex) {
                times[writeIndex] = times[i5];
                const readOffset = i5 * stride, writeOffset = writeIndex * stride;
                for (let j4 = 0; j4 !== stride; ++j4) {
                  values[writeOffset + j4] = values[readOffset + j4];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j4 = 0; j4 !== stride; ++j4) {
              values[writeOffset + j4] = values[readOffset + j4];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = times.slice(0, writeIndex);
            this.values = values.slice(0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values;
          }
          return this;
        }
        clone() {
          const times = this.times.slice();
          const values = this.values.slice();
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      };
      KeyframeTrack.prototype.TimeBufferType = Float32Array;
      KeyframeTrack.prototype.ValueBufferType = Float32Array;
      KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      BooleanKeyframeTrack = class extends KeyframeTrack {
      };
      BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      ColorKeyframeTrack = class extends KeyframeTrack {
      };
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      NumberKeyframeTrack = class extends KeyframeTrack {
      };
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      QuaternionLinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t4, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t4 - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
          }
          return result;
        }
      };
      QuaternionKeyframeTrack = class extends KeyframeTrack {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
      };
      QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      StringKeyframeTrack = class extends KeyframeTrack {
      };
      StringKeyframeTrack.prototype.ValueTypeName = "string";
      StringKeyframeTrack.prototype.ValueBufferType = Array;
      StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      VectorKeyframeTrack = class extends KeyframeTrack {
      };
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      AnimationClip = class {
        constructor(name2, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
          this.name = name2;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i5 = 0, n4 = jsonTracks.length; i5 !== n4; ++i5) {
            tracks.push(parseKeyframeTrack(jsonTracks[i5]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i5 = 0, n4 = clipTracks.length; i5 !== n4; ++i5) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i5]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i5 = 0; i5 < numMorphTargets; i5++) {
            let times = [];
            let values = [];
            times.push(
              (i5 + numMorphTargets - 1) % numMorphTargets,
              i5,
              (i5 + 1) % numMorphTargets
            );
            values.push(0, 1, 0);
            const order = getKeyframeOrder(times);
            times = sortedArray(times, 1, order);
            values = sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values.push(values[0]);
            }
            tracks.push(
              new NumberKeyframeTrack(
                ".morphTargetInfluences[" + morphTargetSequence[i5].name + "]",
                times,
                values
              ).scale(1 / fps)
            );
          }
          return new this(name2, -1, tracks);
        }
        static findByName(objectOrClipArray, name2) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o4 = objectOrClipArray;
            clipArray = o4.geometry && o4.geometry.animations || o4.animations;
          }
          for (let i5 = 0; i5 < clipArray.length; i5++) {
            if (clipArray[i5].name === name2) {
              return clipArray[i5];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i5 = 0, il3 = morphTargets.length; i5 < il3; i5++) {
            const morphTarget = morphTargets[i5];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name2 = parts[1];
              let animationMorphTargets = animationToMorphTargets[name2];
              if (!animationMorphTargets) {
                animationToMorphTargets[name2] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name2 in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
          }
          return clips;
        }
        // parse the animation.hierarchy format
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values = [];
              flattenJSON(animationKeys, times, values, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h4 = 0; h4 < hierarchyTracks.length; h4++) {
            const animationKeys = hierarchyTracks[h4].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k4;
              for (k4 = 0; k4 < animationKeys.length; k4++) {
                if (animationKeys[k4].morphTargets) {
                  for (let m4 = 0; m4 < animationKeys[k4].morphTargets.length; m4++) {
                    morphTargetNames[animationKeys[k4].morphTargets[m4]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values = [];
                for (let m4 = 0; m4 !== animationKeys[k4].morphTargets.length; ++m4) {
                  const animationKey = animationKeys[k4];
                  times.push(animationKey.time);
                  values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
              }
              duration = morphTargetNames.length * fps;
            } else {
              const boneName = ".bones[" + bones[h4].name + "]";
              addNonemptyTrack(
                VectorKeyframeTrack,
                boneName + ".position",
                animationKeys,
                "pos",
                tracks
              );
              addNonemptyTrack(
                QuaternionKeyframeTrack,
                boneName + ".quaternion",
                animationKeys,
                "rot",
                tracks
              );
              addNonemptyTrack(
                VectorKeyframeTrack,
                boneName + ".scale",
                animationKeys,
                "scl",
                tracks
              );
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i5 = 0, n4 = tracks.length; i5 !== n4; ++i5) {
            const track = this.tracks[i5];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i5 = 0; i5 < this.tracks.length; i5++) {
            this.tracks[i5].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i5 = 0; i5 < this.tracks.length; i5++) {
            valid = valid && this.tracks[i5].validate();
          }
          return valid;
        }
        optimize() {
          for (let i5 = 0; i5 < this.tracks.length; i5++) {
            this.tracks[i5].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i5 = 0; i5 < this.tracks.length; i5++) {
            tracks.push(this.tracks[i5].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      };
      Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      LoadingManager = class {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
          };
          this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i5 = 0, l4 = handlers.length; i5 < l4; i5 += 2) {
              const regex = handlers[i5];
              const loader = handlers[i5 + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader;
              }
            }
            return null;
          };
        }
      };
      DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
      Loader = class {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      };
      Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      loading = {};
      HttpError = class extends Error {
        constructor(message, response) {
          super(message);
          this.response = response;
        }
      };
      FileLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const cached = Cache.get(url);
          if (cached !== void 0) {
            this.manager.itemStart(url);
            setTimeout(() => {
              if (onLoad)
                onLoad(cached);
              this.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading[url] !== void 0) {
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          loading[url] = [];
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
            // An abort controller could be added within a future PR
          });
          const mimeType = this.mimeType;
          const responseType = this.responseType;
          fetch(req).then((response) => {
            if (response.status === 200 || response.status === 0) {
              if (response.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
                return response;
              }
              const callbacks = loading[url];
              const reader = response.body.getReader();
              const contentLength = response.headers.get("Content-Length") || response.headers.get("X-File-Size");
              const total = contentLength ? parseInt(contentLength) : 0;
              const lengthComputable = total !== 0;
              let loaded = 0;
              const stream = new ReadableStream({
                start(controller) {
                  readData();
                  function readData() {
                    reader.read().then(({ done, value }) => {
                      if (done) {
                        controller.close();
                      } else {
                        loaded += value.byteLength;
                        const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                        for (let i5 = 0, il3 = callbacks.length; i5 < il3; i5++) {
                          const callback = callbacks[i5];
                          if (callback.onProgress)
                            callback.onProgress(event);
                        }
                        controller.enqueue(value);
                        readData();
                      }
                    });
                  }
                }
              });
              return new Response(stream);
            } else {
              throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
            }
          }).then((response) => {
            switch (responseType) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "document":
                return response.text().then((text) => {
                  const parser = new DOMParser();
                  return parser.parseFromString(text, mimeType);
                });
              case "json":
                return response.json();
              default:
                if (mimeType === void 0) {
                  return response.text();
                } else {
                  const re6 = /charset="?([^;"\s]*)"?/i;
                  const exec = re6.exec(mimeType);
                  const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                  const decoder = new TextDecoder(label);
                  return response.arrayBuffer().then((ab2) => decoder.decode(ab2));
                }
            }
          }).then((data) => {
            Cache.add(url, data);
            const callbacks = loading[url];
            delete loading[url];
            for (let i5 = 0, il3 = callbacks.length; i5 < il3; i5++) {
              const callback = callbacks[i5];
              if (callback.onLoad)
                callback.onLoad(data);
            }
          }).catch((err) => {
            const callbacks = loading[url];
            if (callbacks === void 0) {
              this.manager.itemError(url);
              throw err;
            }
            delete loading[url];
            for (let i5 = 0, il3 = callbacks.length; i5 < il3; i5++) {
              const callback = callbacks[i5];
              if (callback.onError)
                callback.onError(err);
            }
            this.manager.itemError(url);
          }).finally(() => {
            this.manager.itemEnd(url);
          });
          this.manager.itemStart(url);
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      };
      ImageLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = createElementNS("img");
          function onImageLoad() {
            removeEventListeners();
            Cache.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            removeEventListeners();
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.slice(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      };
      TextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          loader.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      };
      Light = class extends Object3D {
        constructor(color, intensity = 1) {
          super();
          this.isLight = true;
          this.type = "Light";
          this.color = new Color(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      };
      HemisphereLight = class extends Light {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.isHemisphereLight = true;
          this.type = "HemisphereLight";
          this.position.copy(Object3D.DEFAULT_UP);
          this.updateMatrix();
          this.groundColor = new Color(groundColor);
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      };
      _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
      _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
      _lookTarget$1 = /* @__PURE__ */ new Vector3();
      LightShadow = class {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.blurSamples = 8;
          this.mapSize = new Vector2(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix4();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum();
          this._frameExtents = new Vector2(1, 1);
          this._viewportCount = 1;
          this._viewports = [
            new Vector4(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$1);
          _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$1);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
          shadowMatrix.set(
            0.5,
            0,
            0,
            0.5,
            0,
            0.5,
            0,
            0.5,
            0,
            0,
            0.5,
            0.5,
            0,
            0,
            0,
            1
          );
          shadowMatrix.multiply(_projScreenMatrix$1);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      };
      SpotLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(50, 1, 0.5, 500));
          this.isSpotLightShadow = true;
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov2 = RAD2DEG * 2 * light.angle * this.focus;
          const aspect2 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      };
      SpotLight = class extends Light {
        constructor(color, intensity, distance = 0, angle2 = Math.PI / 3, penumbra = 0, decay = 2) {
          super(color, intensity);
          this.isSpotLight = true;
          this.type = "SpotLight";
          this.position.copy(Object3D.DEFAULT_UP);
          this.updateMatrix();
          this.target = new Object3D();
          this.distance = distance;
          this.angle = angle2;
          this.penumbra = penumbra;
          this.decay = decay;
          this.map = null;
          this.shadow = new SpotLightShadow();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      _projScreenMatrix = /* @__PURE__ */ new Matrix4();
      _lightPositionWorld = /* @__PURE__ */ new Vector3();
      _lookTarget = /* @__PURE__ */ new Vector3();
      PointLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(90, 1, 0.5, 500));
          this.isPointLightShadow = true;
          this._frameExtents = new Vector2(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            new Vector4(2, 1, 1, 1),
            // negative X
            new Vector4(0, 1, 1, 1),
            // positive Z
            new Vector4(3, 1, 1, 1),
            // negative Z
            new Vector4(1, 1, 1, 1),
            // positive Y
            new Vector4(3, 0, 1, 1),
            // negative Y
            new Vector4(1, 0, 1, 1)
          ];
          this._cubeDirections = [
            new Vector3(1, 0, 0),
            new Vector3(-1, 0, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1),
            new Vector3(0, 1, 0),
            new Vector3(0, -1, 0)
          ];
          this._cubeUps = [
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1)
          ];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld);
          _lookTarget.copy(camera.position);
          _lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix);
        }
      };
      PointLight = class extends Light {
        constructor(color, intensity, distance = 0, decay = 2) {
          super(color, intensity);
          this.isPointLight = true;
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      DirectionalLightShadow = class extends LightShadow {
        constructor() {
          super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
          this.isDirectionalLightShadow = true;
        }
      };
      DirectionalLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.isDirectionalLight = true;
          this.type = "DirectionalLight";
          this.position.copy(Object3D.DEFAULT_UP);
          this.updateMatrix();
          this.target = new Object3D();
          this.shadow = new DirectionalLightShadow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      AmbientLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.isAmbientLight = true;
          this.type = "AmbientLight";
        }
      };
      LoaderUtils = class {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s4 = "";
          for (let i5 = 0, il3 = array.length; i5 < il3; i5++) {
            s4 += String.fromCharCode(array[i5]);
          }
          try {
            return decodeURIComponent(escape(s4));
          } catch (e4) {
            return s4;
          }
        }
        static extractUrlBase(url) {
          const index = url.lastIndexOf("/");
          if (index === -1)
            return "./";
          return url.slice(0, index + 1);
        }
        static resolveURL(url, path) {
          if (typeof url !== "string" || url === "")
            return "";
          if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
            path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
          }
          if (/^(https?:)?\/\//i.test(url))
            return url;
          if (/^data:.*,.*$/i.test(url))
            return url;
          if (/^blob:.*$/i.test(url))
            return url;
          return path + url;
        }
      };
      ImageBitmapLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.isImageBitmapLoader = true;
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = { premultiplyAlpha: "none" };
        }
        setOptions(options) {
          this.options = options;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
          }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e4) {
            if (onError)
              onError(e4);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      };
      Clock = class {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      };
      PropertyMixer = class {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        // accumulate data in the 'incoming' region into 'accu<i>'
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i5 = 0; i5 !== stride; ++i5) {
              buffer[offset + i5] = buffer[i5];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        // accumulate data in the 'incoming' region into 'add'
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        // apply the state of 'accu<i>' to the binding when accus differ
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(
              buffer,
              offset,
              originalValueOffset,
              1 - weight,
              stride
            );
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i5 = stride, e4 = stride + stride; i5 !== e4; ++i5) {
            if (buffer[i5] !== buffer[i5 + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        // remember the state of the bound property and copy it to both accus
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i5 = stride, e4 = originalValueOffset; i5 !== e4; ++i5) {
            buffer[i5] = buffer[originalValueOffset + i5 % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        // apply the state previously taken via 'saveOriginalState' to the binding
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i5 = startIndex; i5 < endIndex; i5++) {
            this.buffer[i5] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i5 = 0; i5 < this.valueSize; i5++) {
            this.buffer[targetIndex + i5] = this.buffer[startIndex + i5];
          }
        }
        // mix functions
        _select(buffer, dstOffset, srcOffset, t4, stride) {
          if (t4 >= 0.5) {
            for (let i5 = 0; i5 !== stride; ++i5) {
              buffer[dstOffset + i5] = buffer[srcOffset + i5];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t4) {
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t4);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t4, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t4);
        }
        _lerp(buffer, dstOffset, srcOffset, t4, stride) {
          const s4 = 1 - t4;
          for (let i5 = 0; i5 !== stride; ++i5) {
            const j4 = dstOffset + i5;
            buffer[j4] = buffer[j4] * s4 + buffer[srcOffset + i5] * t4;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t4, stride) {
          for (let i5 = 0; i5 !== stride; ++i5) {
            const j4 = dstOffset + i5;
            buffer[j4] = buffer[j4] + buffer[srcOffset + i5] * t4;
          }
        }
      };
      _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
      _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
      _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
      _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
      _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
      _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
      _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
      _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
      _trackRe = new RegExp(
        "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
      );
      _supportedObjectNames = ["material", "materials", "bones", "map"];
      Composite = class {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i5 = this._targetGroup.nCachedObjects_, n4 = bindings.length; i5 !== n4; ++i5) {
            bindings[i5].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i5 = this._targetGroup.nCachedObjects_, n4 = bindings.length; i5 !== n4; ++i5) {
            bindings[i5].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i5 = this._targetGroup.nCachedObjects_, n4 = bindings.length; i5 !== n4; ++i5) {
            bindings[i5].unbind();
          }
        }
      };
      PropertyBinding = class _PropertyBinding {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
          this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root2, path, parsedPath) {
          if (!(root2 && root2.isAnimationObjectGroup)) {
            return new _PropertyBinding(root2, path, parsedPath);
          } else {
            return new _PropertyBinding.Composite(root2, path, parsedPath);
          }
        }
        /**
         * Replaces spaces with underscores and removes unsupported characters from
         * node names, to ensure compatibility with parseTrackName().
         *
         * @param {string} name Node name to be sanitized.
         * @return {string}
         */
        static sanitizeNodeName(name2) {
          return name2.replace(/\s/g, "_").replace(_reservedRe, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe.exec(trackName);
          if (matches === null) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            // required
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root2, nodeName) {
          if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root2.name || nodeName === root2.uuid) {
            return root2;
          }
          if (root2.skeleton) {
            const bone = root2.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root2.children) {
            const searchNodeSubtree = function(children) {
              for (let i5 = 0; i5 < children.length; i5++) {
                const childNode = children[i5];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root2.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        // these are used to "bind" a nonexistent property
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        // Getters
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i5 = 0, n4 = source.length; i5 !== n4; ++i5) {
            buffer[offset++] = source[i5];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        // Direct
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        // EntireArray
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i5 = 0, n4 = dest.length; i5 !== n4; ++i5) {
            dest[i5] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i5 = 0, n4 = dest.length; i5 !== n4; ++i5) {
            dest[i5] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i5 = 0, n4 = dest.length; i5 !== n4; ++i5) {
            dest[i5] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        // ArrayElement
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        // HasToFromArray
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        // create getter / setter pair for a property in the scene graph
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i5 = 0; i5 < targetObject.length; i5++) {
                  if (targetObject[i5].name === objectIndex) {
                    objectIndex = i5;
                    break;
                  }
                }
                break;
              case "map":
                if ("map" in targetObject) {
                  targetObject = targetObject.map;
                  break;
                }
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                targetObject = targetObject.material.map;
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      };
      PropertyBinding.Composite = Composite;
      PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding.prototype.GetterByBindingType = [
        PropertyBinding.prototype._getValue_direct,
        PropertyBinding.prototype._getValue_array,
        PropertyBinding.prototype._getValue_arrayElement,
        PropertyBinding.prototype._getValue_toArray
      ];
      PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
        [
          // Direct
          PropertyBinding.prototype._setValue_direct,
          PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
          PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
          // EntireArray
          PropertyBinding.prototype._setValue_array,
          PropertyBinding.prototype._setValue_array_setNeedsUpdate,
          PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
          // ArrayElement
          PropertyBinding.prototype._setValue_arrayElement,
          PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
          PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
          // HasToFromArray
          PropertyBinding.prototype._setValue_fromArray,
          PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
          PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
      ];
      AnimationAction = class {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
          for (let i5 = 0; i5 !== nTracks; ++i5) {
            const interpolant = tracks[i5].createInterpolant(null);
            interpolants[i5] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        // State & Scheduling
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        // return true when play has been called
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time) {
          this._startTime = time;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        // Weight
        // set the weight stopping any scheduled fading
        // although .enabled = false yields an effective weight of zero, this
        // method does *not* change .enabled, because it would be confusing
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        // return the weight considering fading and .enabled
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        // Time Scale Control
        // set the time scale stopping any scheduled warping
        // although .paused = true yields an effective time scale of zero, this
        // method does *not* change .paused, because it would be confusing
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        // return the time scale considering warping and .paused
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now3;
          times[1] = now3 + duration;
          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        // Object Accessors
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        // Interna
        _update(time, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              deltaTime = 0;
            } else {
              this._startTime = null;
              deltaTime = timeDirection * timeRunning;
            }
          }
          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode:
                for (let j4 = 0, m4 = interpolants.length; j4 !== m4; ++j4) {
                  interpolants[j4].evaluate(clipTime);
                  propertyMixers[j4].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode:
              default:
                for (let j4 = 0, m4 = interpolants.length; j4 !== m4; ++j4) {
                  interpolants[j4].evaluate(clipTime);
                  propertyMixers[j4].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              weight *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              timeScale *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop = this.loop;
          let time = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop === LoopPingPong;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
          }
          if (loop === LoopOnce) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time >= duration) {
                time = duration;
              } else if (time < 0) {
                time = 0;
              } else {
                this.time = time;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time >= duration || time < 0) {
              const loopDelta = Math.floor(time / duration);
              time -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time = deltaTime > 0 ? duration : 0;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time;
            }
          }
          return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingEnd = WrapAroundEnding;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now3 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now3;
          values[0] = weightNow;
          times[1] = now3 + duration;
          values[1] = weightThen;
          return this;
        }
      };
      _controlInterpolantsResultBuffer = new Float32Array(1);
      AnimationMixer = class extends EventDispatcher {
        constructor(root2) {
          super();
          this._root = root2;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root2 = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root2.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i5 = 0; i5 !== nTracks; ++i5) {
            const track = tracks[i5], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              ++binding.referenceCount;
              bindings[i5] = binding;
            } else {
              binding = bindings[i5];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i5].binding.parsedPath;
              binding = new PropertyMixer(
                PropertyBinding.create(root2, trackName, path),
                track.ValueTypeName,
                track.getValueSize()
              );
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i5] = binding;
            }
            interpolants[i5].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(
                action,
                actionsForClip && actionsForClip.knownActions[0]
              );
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i5 = 0, n4 = bindings.length; i5 !== n4; ++i5) {
              const binding = bindings[i5];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i5 = 0, n4 = bindings.length; i5 !== n4; ++i5) {
              const binding = bindings[i5];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        // Memory manager
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        // Memory management for AnimationAction objects
        _isActiveAction(action) {
          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i5 = 0, n4 = bindings.length; i5 !== n4; ++i5) {
            const binding = bindings[i5];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        // Memory management for PropertyMixer objects
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        // Memory management of Interpolants for weight and time scale
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant(
              new Float32Array(2),
              new Float32Array(2),
              1,
              _controlInterpolantsResultBuffer
            );
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        // return an action for a clip optionally using a custom root target
        // object (this method allocates a lot of dynamic memory in case a
        // previously unknown clip/root combination is specified)
        clipAction(clip, optionalRoot, blendMode) {
          const root2 = optionalRoot || this._root, rootUuid = root2.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip.findByName(root2, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        // get an existing action
        existingAction(clip, optionalRoot) {
          const root2 = optionalRoot || this._root, rootUuid = root2.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root2, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        // deactivates all previously scheduled actions
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i5 = nActions - 1; i5 >= 0; --i5) {
            actions[i5].stop();
          }
          return this;
        }
        // advance the time and update apply the animation
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i5 = 0; i5 !== nActions; ++i5) {
            const action = actions[i5];
            action._update(time, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i5 = 0; i5 !== nBindings; ++i5) {
            bindings[i5].apply(accuIndex);
          }
          return this;
        }
        // Allows you to seek to a specific time in an animation.
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i5 = 0; i5 < this._actions.length; i5++) {
            this._actions[i5].time = 0;
          }
          return this.update(timeInSeconds);
        }
        // return this mixer's root target object
        getRoot() {
          return this._root;
        }
        // free all resources specific to a particular clip
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i5 = 0, n4 = actionsToRemove.length; i5 !== n4; ++i5) {
              const action = actionsToRemove[i5];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        // free all resources specific to a particular root target object
        uncacheRoot(root2) {
          const rootUuid = root2.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        // remove a targeted clip from the cache
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      };
      Spherical = class {
        constructor(radius = 1, phi = 0, theta = 0) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        set(radius, phi, theta) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;
          return this;
        }
        // restrict phi to be between EPS and PI-EPS
        makeSafe() {
          const EPS = 1e-6;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
          return this;
        }
        setFromVector3(v5) {
          return this.setFromCartesianCoords(v5.x, v5.y, v5.z);
        }
        setFromCartesianCoords(x4, y3, z4) {
          this.radius = Math.sqrt(x4 * x4 + y3 * y3 + z4 * z4);
          if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
          } else {
            this.theta = Math.atan2(x4, z4);
            this.phi = Math.acos(clamp(y3 / this.radius, -1, 1));
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$2 = /* @__PURE__ */ new Vector3();
      _boneMatrix = /* @__PURE__ */ new Matrix4();
      _matrixWorldInv = /* @__PURE__ */ new Matrix4();
      SkeletonHelper = class extends LineSegments {
        constructor(object) {
          const bones = getBoneList(object);
          const geometry = new BufferGeometry();
          const vertices = [];
          const colors = [];
          const color1 = new Color(0, 0, 1);
          const color2 = new Color(0, 1, 0);
          for (let i5 = 0; i5 < bones.length; i5++) {
            const bone = bones[i5];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
          super(geometry, material);
          this.isSkeletonHelper = true;
          this.type = "SkeletonHelper";
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry = this.geometry;
          const position = geometry.getAttribute("position");
          _matrixWorldInv.copy(this.root.matrixWorld).invert();
          for (let i5 = 0, j4 = 0; i5 < bones.length; i5++) {
            const bone = bones[i5];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j4, _vector$2.x, _vector$2.y, _vector$2.z);
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j4 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
              j4 += 2;
            }
          }
          geometry.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
          revision: REVISION
        } }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION;
        }
      }
    }
  });

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var _changeEvent, _startEvent, _endEvent, _ray2, _plane, TILT_LIMIT, OrbitControls;
  var init_OrbitControls = __esm({
    "node_modules/three/examples/jsm/controls/OrbitControls.js"() {
      init_three_module();
      _changeEvent = { type: "change" };
      _startEvent = { type: "start" };
      _endEvent = { type: "end" };
      _ray2 = new Ray();
      _plane = new Plane();
      TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
      OrbitControls = class extends EventDispatcher {
        constructor(object, domElement) {
          super();
          this.object = object;
          this.domElement = domElement;
          this.domElement.style.touchAction = "none";
          this.enabled = true;
          this.target = new Vector3();
          this.cursor = new Vector3();
          this.minDistance = 0;
          this.maxDistance = Infinity;
          this.minZoom = 0;
          this.maxZoom = Infinity;
          this.minTargetRadius = 0;
          this.maxTargetRadius = Infinity;
          this.minPolarAngle = 0;
          this.maxPolarAngle = Math.PI;
          this.minAzimuthAngle = -Infinity;
          this.maxAzimuthAngle = Infinity;
          this.enableDamping = false;
          this.dampingFactor = 0.05;
          this.enableZoom = true;
          this.zoomSpeed = 1;
          this.enableRotate = true;
          this.rotateSpeed = 1;
          this.enablePan = true;
          this.panSpeed = 1;
          this.screenSpacePanning = true;
          this.keyPanSpeed = 7;
          this.zoomToCursor = false;
          this.autoRotate = false;
          this.autoRotateSpeed = 2;
          this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
          this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
          this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
          this.target0 = this.target.clone();
          this.position0 = this.object.position.clone();
          this.zoom0 = this.object.zoom;
          this._domElementKeyEvents = null;
          this.getPolarAngle = function() {
            return spherical.phi;
          };
          this.getAzimuthalAngle = function() {
            return spherical.theta;
          };
          this.getDistance = function() {
            return this.object.position.distanceTo(this.target);
          };
          this.listenToKeyEvents = function(domElement2) {
            domElement2.addEventListener("keydown", onKeyDown);
            this._domElementKeyEvents = domElement2;
          };
          this.stopListenToKeyEvents = function() {
            this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
            this._domElementKeyEvents = null;
          };
          this.saveState = function() {
            scope.target0.copy(scope.target);
            scope.position0.copy(scope.object.position);
            scope.zoom0 = scope.object.zoom;
          };
          this.reset = function() {
            scope.target.copy(scope.target0);
            scope.object.position.copy(scope.position0);
            scope.object.zoom = scope.zoom0;
            scope.object.updateProjectionMatrix();
            scope.dispatchEvent(_changeEvent);
            scope.update();
            state = STATE.NONE;
          };
          this.update = function() {
            const offset = new Vector3();
            const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
            const quatInverse = quat.clone().invert();
            const lastPosition = new Vector3();
            const lastQuaternion = new Quaternion();
            const lastTargetPosition = new Vector3();
            const twoPI = 2 * Math.PI;
            return function update(deltaTime = null) {
              const position = scope.object.position;
              offset.copy(position).sub(scope.target);
              offset.applyQuaternion(quat);
              spherical.setFromVector3(offset);
              if (scope.autoRotate && state === STATE.NONE) {
                rotateLeft(getAutoRotationAngle(deltaTime));
              }
              if (scope.enableDamping) {
                spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                spherical.phi += sphericalDelta.phi * scope.dampingFactor;
              } else {
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
              }
              let min = scope.minAzimuthAngle;
              let max2 = scope.maxAzimuthAngle;
              if (isFinite(min) && isFinite(max2)) {
                if (min < -Math.PI)
                  min += twoPI;
                else if (min > Math.PI)
                  min -= twoPI;
                if (max2 < -Math.PI)
                  max2 += twoPI;
                else if (max2 > Math.PI)
                  max2 -= twoPI;
                if (min <= max2) {
                  spherical.theta = Math.max(min, Math.min(max2, spherical.theta));
                } else {
                  spherical.theta = spherical.theta > (min + max2) / 2 ? Math.max(min, spherical.theta) : Math.min(max2, spherical.theta);
                }
              }
              spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
              spherical.makeSafe();
              if (scope.enableDamping === true) {
                scope.target.addScaledVector(panOffset, scope.dampingFactor);
              } else {
                scope.target.add(panOffset);
              }
              scope.target.sub(scope.cursor);
              scope.target.clampLength(scope.minTargetRadius, scope.maxTargetRadius);
              scope.target.add(scope.cursor);
              if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {
                spherical.radius = clampDistance(spherical.radius);
              } else {
                spherical.radius = clampDistance(spherical.radius * scale4);
              }
              offset.setFromSpherical(spherical);
              offset.applyQuaternion(quatInverse);
              position.copy(scope.target).add(offset);
              scope.object.lookAt(scope.target);
              if (scope.enableDamping === true) {
                sphericalDelta.theta *= 1 - scope.dampingFactor;
                sphericalDelta.phi *= 1 - scope.dampingFactor;
                panOffset.multiplyScalar(1 - scope.dampingFactor);
              } else {
                sphericalDelta.set(0, 0, 0);
                panOffset.set(0, 0, 0);
              }
              let zoomChanged = false;
              if (scope.zoomToCursor && performCursorZoom) {
                let newRadius = null;
                if (scope.object.isPerspectiveCamera) {
                  const prevRadius = offset.length();
                  newRadius = clampDistance(prevRadius * scale4);
                  const radiusDelta = prevRadius - newRadius;
                  scope.object.position.addScaledVector(dollyDirection, radiusDelta);
                  scope.object.updateMatrixWorld();
                } else if (scope.object.isOrthographicCamera) {
                  const mouseBefore = new Vector3(mouse.x, mouse.y, 0);
                  mouseBefore.unproject(scope.object);
                  scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale4));
                  scope.object.updateProjectionMatrix();
                  zoomChanged = true;
                  const mouseAfter = new Vector3(mouse.x, mouse.y, 0);
                  mouseAfter.unproject(scope.object);
                  scope.object.position.sub(mouseAfter).add(mouseBefore);
                  scope.object.updateMatrixWorld();
                  newRadius = offset.length();
                } else {
                  console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
                  scope.zoomToCursor = false;
                }
                if (newRadius !== null) {
                  if (this.screenSpacePanning) {
                    scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);
                  } else {
                    _ray2.origin.copy(scope.object.position);
                    _ray2.direction.set(0, 0, -1).transformDirection(scope.object.matrix);
                    if (Math.abs(scope.object.up.dot(_ray2.direction)) < TILT_LIMIT) {
                      object.lookAt(scope.target);
                    } else {
                      _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);
                      _ray2.intersectPlane(_plane, scope.target);
                    }
                  }
                }
              } else if (scope.object.isOrthographicCamera) {
                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale4));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
              }
              scale4 = 1;
              performCursorZoom = false;
              if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > 0) {
                scope.dispatchEvent(_changeEvent);
                lastPosition.copy(scope.object.position);
                lastQuaternion.copy(scope.object.quaternion);
                lastTargetPosition.copy(scope.target);
                zoomChanged = false;
                return true;
              }
              return false;
            };
          }();
          this.dispose = function() {
            scope.domElement.removeEventListener("contextmenu", onContextMenu);
            scope.domElement.removeEventListener("pointerdown", onPointerDown);
            scope.domElement.removeEventListener("pointercancel", onPointerUp);
            scope.domElement.removeEventListener("wheel", onMouseWheel);
            scope.domElement.removeEventListener("pointermove", onPointerMove);
            scope.domElement.removeEventListener("pointerup", onPointerUp);
            if (scope._domElementKeyEvents !== null) {
              scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
              scope._domElementKeyEvents = null;
            }
          };
          const scope = this;
          const STATE = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
          };
          let state = STATE.NONE;
          const EPS = 1e-6;
          const spherical = new Spherical();
          const sphericalDelta = new Spherical();
          let scale4 = 1;
          const panOffset = new Vector3();
          const rotateStart = new Vector2();
          const rotateEnd = new Vector2();
          const rotateDelta = new Vector2();
          const panStart = new Vector2();
          const panEnd = new Vector2();
          const panDelta = new Vector2();
          const dollyStart = new Vector2();
          const dollyEnd = new Vector2();
          const dollyDelta = new Vector2();
          const dollyDirection = new Vector3();
          const mouse = new Vector2();
          let performCursorZoom = false;
          const pointers = [];
          const pointerPositions = {};
          function getAutoRotationAngle(deltaTime) {
            if (deltaTime !== null) {
              return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;
            } else {
              return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }
          }
          function getZoomScale() {
            return Math.pow(0.95, scope.zoomSpeed);
          }
          function rotateLeft(angle2) {
            sphericalDelta.theta -= angle2;
          }
          function rotateUp(angle2) {
            sphericalDelta.phi -= angle2;
          }
          const panLeft = function() {
            const v5 = new Vector3();
            return function panLeft2(distance, objectMatrix) {
              v5.setFromMatrixColumn(objectMatrix, 0);
              v5.multiplyScalar(-distance);
              panOffset.add(v5);
            };
          }();
          const panUp = function() {
            const v5 = new Vector3();
            return function panUp2(distance, objectMatrix) {
              if (scope.screenSpacePanning === true) {
                v5.setFromMatrixColumn(objectMatrix, 1);
              } else {
                v5.setFromMatrixColumn(objectMatrix, 0);
                v5.crossVectors(scope.object.up, v5);
              }
              v5.multiplyScalar(distance);
              panOffset.add(v5);
            };
          }();
          const pan = function() {
            const offset = new Vector3();
            return function pan2(deltaX, deltaY) {
              const element = scope.domElement;
              if (scope.object.isPerspectiveCamera) {
                const position = scope.object.position;
                offset.copy(position).sub(scope.target);
                let targetDistance = offset.length();
                targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
                panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
              } else if (scope.object.isOrthographicCamera) {
                panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
                panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
              } else {
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
                scope.enablePan = false;
              }
            };
          }();
          function dollyOut(dollyScale) {
            if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
              scale4 /= dollyScale;
            } else {
              console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
              scope.enableZoom = false;
            }
          }
          function dollyIn(dollyScale) {
            if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
              scale4 *= dollyScale;
            } else {
              console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
              scope.enableZoom = false;
            }
          }
          function updateMouseParameters(event) {
            if (!scope.zoomToCursor) {
              return;
            }
            performCursorZoom = true;
            const rect = scope.domElement.getBoundingClientRect();
            const x4 = event.clientX - rect.left;
            const y3 = event.clientY - rect.top;
            const w3 = rect.width;
            const h4 = rect.height;
            mouse.x = x4 / w3 * 2 - 1;
            mouse.y = -(y3 / h4) * 2 + 1;
            dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();
          }
          function clampDistance(dist) {
            return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));
          }
          function handleMouseDownRotate(event) {
            rotateStart.set(event.clientX, event.clientY);
          }
          function handleMouseDownDolly(event) {
            updateMouseParameters(event);
            dollyStart.set(event.clientX, event.clientY);
          }
          function handleMouseDownPan(event) {
            panStart.set(event.clientX, event.clientY);
          }
          function handleMouseMoveRotate(event) {
            rotateEnd.set(event.clientX, event.clientY);
            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
            rotateStart.copy(rotateEnd);
            scope.update();
          }
          function handleMouseMoveDolly(event) {
            dollyEnd.set(event.clientX, event.clientY);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) {
              dollyOut(getZoomScale());
            } else if (dollyDelta.y < 0) {
              dollyIn(getZoomScale());
            }
            dollyStart.copy(dollyEnd);
            scope.update();
          }
          function handleMouseMovePan(event) {
            panEnd.set(event.clientX, event.clientY);
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
            scope.update();
          }
          function handleMouseWheel(event) {
            updateMouseParameters(event);
            if (event.deltaY < 0) {
              dollyIn(getZoomScale());
            } else if (event.deltaY > 0) {
              dollyOut(getZoomScale());
            }
            scope.update();
          }
          function handleKeyDown(event) {
            let needsUpdate = false;
            switch (event.code) {
              case scope.keys.UP:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                  rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
                } else {
                  pan(0, scope.keyPanSpeed);
                }
                needsUpdate = true;
                break;
              case scope.keys.BOTTOM:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                  rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
                } else {
                  pan(0, -scope.keyPanSpeed);
                }
                needsUpdate = true;
                break;
              case scope.keys.LEFT:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                  rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
                } else {
                  pan(scope.keyPanSpeed, 0);
                }
                needsUpdate = true;
                break;
              case scope.keys.RIGHT:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                  rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
                } else {
                  pan(-scope.keyPanSpeed, 0);
                }
                needsUpdate = true;
                break;
            }
            if (needsUpdate) {
              event.preventDefault();
              scope.update();
            }
          }
          function handleTouchStartRotate() {
            if (pointers.length === 1) {
              rotateStart.set(pointers[0].pageX, pointers[0].pageY);
            } else {
              const x4 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
              const y3 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
              rotateStart.set(x4, y3);
            }
          }
          function handleTouchStartPan() {
            if (pointers.length === 1) {
              panStart.set(pointers[0].pageX, pointers[0].pageY);
            } else {
              const x4 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
              const y3 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
              panStart.set(x4, y3);
            }
          }
          function handleTouchStartDolly() {
            const dx = pointers[0].pageX - pointers[1].pageX;
            const dy = pointers[0].pageY - pointers[1].pageY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
          }
          function handleTouchStartDollyPan() {
            if (scope.enableZoom)
              handleTouchStartDolly();
            if (scope.enablePan)
              handleTouchStartPan();
          }
          function handleTouchStartDollyRotate() {
            if (scope.enableZoom)
              handleTouchStartDolly();
            if (scope.enableRotate)
              handleTouchStartRotate();
          }
          function handleTouchMoveRotate(event) {
            if (pointers.length == 1) {
              rotateEnd.set(event.pageX, event.pageY);
            } else {
              const position = getSecondPointerPosition(event);
              const x4 = 0.5 * (event.pageX + position.x);
              const y3 = 0.5 * (event.pageY + position.y);
              rotateEnd.set(x4, y3);
            }
            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
            rotateStart.copy(rotateEnd);
          }
          function handleTouchMovePan(event) {
            if (pointers.length === 1) {
              panEnd.set(event.pageX, event.pageY);
            } else {
              const position = getSecondPointerPosition(event);
              const x4 = 0.5 * (event.pageX + position.x);
              const y3 = 0.5 * (event.pageY + position.y);
              panEnd.set(x4, y3);
            }
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
          }
          function handleTouchMoveDolly(event) {
            const position = getSecondPointerPosition(event);
            const dx = event.pageX - position.x;
            const dy = event.pageY - position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
            dollyOut(dollyDelta.y);
            dollyStart.copy(dollyEnd);
          }
          function handleTouchMoveDollyPan(event) {
            if (scope.enableZoom)
              handleTouchMoveDolly(event);
            if (scope.enablePan)
              handleTouchMovePan(event);
          }
          function handleTouchMoveDollyRotate(event) {
            if (scope.enableZoom)
              handleTouchMoveDolly(event);
            if (scope.enableRotate)
              handleTouchMoveRotate(event);
          }
          function onPointerDown(event) {
            if (scope.enabled === false)
              return;
            if (pointers.length === 0) {
              scope.domElement.setPointerCapture(event.pointerId);
              scope.domElement.addEventListener("pointermove", onPointerMove);
              scope.domElement.addEventListener("pointerup", onPointerUp);
            }
            addPointer(event);
            if (event.pointerType === "touch") {
              onTouchStart(event);
            } else {
              onMouseDown(event);
            }
          }
          function onPointerMove(event) {
            if (scope.enabled === false)
              return;
            if (event.pointerType === "touch") {
              onTouchMove(event);
            } else {
              onMouseMove(event);
            }
          }
          function onPointerUp(event) {
            removePointer(event);
            if (pointers.length === 0) {
              scope.domElement.releasePointerCapture(event.pointerId);
              scope.domElement.removeEventListener("pointermove", onPointerMove);
              scope.domElement.removeEventListener("pointerup", onPointerUp);
            }
            scope.dispatchEvent(_endEvent);
            state = STATE.NONE;
          }
          function onMouseDown(event) {
            let mouseAction;
            switch (event.button) {
              case 0:
                mouseAction = scope.mouseButtons.LEFT;
                break;
              case 1:
                mouseAction = scope.mouseButtons.MIDDLE;
                break;
              case 2:
                mouseAction = scope.mouseButtons.RIGHT;
                break;
              default:
                mouseAction = -1;
            }
            switch (mouseAction) {
              case MOUSE.DOLLY:
                if (scope.enableZoom === false)
                  return;
                handleMouseDownDolly(event);
                state = STATE.DOLLY;
                break;
              case MOUSE.ROTATE:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                  if (scope.enablePan === false)
                    return;
                  handleMouseDownPan(event);
                  state = STATE.PAN;
                } else {
                  if (scope.enableRotate === false)
                    return;
                  handleMouseDownRotate(event);
                  state = STATE.ROTATE;
                }
                break;
              case MOUSE.PAN:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                  if (scope.enableRotate === false)
                    return;
                  handleMouseDownRotate(event);
                  state = STATE.ROTATE;
                } else {
                  if (scope.enablePan === false)
                    return;
                  handleMouseDownPan(event);
                  state = STATE.PAN;
                }
                break;
              default:
                state = STATE.NONE;
            }
            if (state !== STATE.NONE) {
              scope.dispatchEvent(_startEvent);
            }
          }
          function onMouseMove(event) {
            switch (state) {
              case STATE.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleMouseMoveRotate(event);
                break;
              case STATE.DOLLY:
                if (scope.enableZoom === false)
                  return;
                handleMouseMoveDolly(event);
                break;
              case STATE.PAN:
                if (scope.enablePan === false)
                  return;
                handleMouseMovePan(event);
                break;
            }
          }
          function onMouseWheel(event) {
            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
              return;
            event.preventDefault();
            scope.dispatchEvent(_startEvent);
            handleMouseWheel(event);
            scope.dispatchEvent(_endEvent);
          }
          function onKeyDown(event) {
            if (scope.enabled === false || scope.enablePan === false)
              return;
            handleKeyDown(event);
          }
          function onTouchStart(event) {
            trackPointer(event);
            switch (pointers.length) {
              case 1:
                switch (scope.touches.ONE) {
                  case TOUCH.ROTATE:
                    if (scope.enableRotate === false)
                      return;
                    handleTouchStartRotate();
                    state = STATE.TOUCH_ROTATE;
                    break;
                  case TOUCH.PAN:
                    if (scope.enablePan === false)
                      return;
                    handleTouchStartPan();
                    state = STATE.TOUCH_PAN;
                    break;
                  default:
                    state = STATE.NONE;
                }
                break;
              case 2:
                switch (scope.touches.TWO) {
                  case TOUCH.DOLLY_PAN:
                    if (scope.enableZoom === false && scope.enablePan === false)
                      return;
                    handleTouchStartDollyPan();
                    state = STATE.TOUCH_DOLLY_PAN;
                    break;
                  case TOUCH.DOLLY_ROTATE:
                    if (scope.enableZoom === false && scope.enableRotate === false)
                      return;
                    handleTouchStartDollyRotate();
                    state = STATE.TOUCH_DOLLY_ROTATE;
                    break;
                  default:
                    state = STATE.NONE;
                }
                break;
              default:
                state = STATE.NONE;
            }
            if (state !== STATE.NONE) {
              scope.dispatchEvent(_startEvent);
            }
          }
          function onTouchMove(event) {
            trackPointer(event);
            switch (state) {
              case STATE.TOUCH_ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleTouchMoveRotate(event);
                scope.update();
                break;
              case STATE.TOUCH_PAN:
                if (scope.enablePan === false)
                  return;
                handleTouchMovePan(event);
                scope.update();
                break;
              case STATE.TOUCH_DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false)
                  return;
                handleTouchMoveDollyPan(event);
                scope.update();
                break;
              case STATE.TOUCH_DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false)
                  return;
                handleTouchMoveDollyRotate(event);
                scope.update();
                break;
              default:
                state = STATE.NONE;
            }
          }
          function onContextMenu(event) {
            if (scope.enabled === false)
              return;
            event.preventDefault();
          }
          function addPointer(event) {
            pointers.push(event);
          }
          function removePointer(event) {
            delete pointerPositions[event.pointerId];
            for (let i5 = 0; i5 < pointers.length; i5++) {
              if (pointers[i5].pointerId == event.pointerId) {
                pointers.splice(i5, 1);
                return;
              }
            }
          }
          function trackPointer(event) {
            let position = pointerPositions[event.pointerId];
            if (position === void 0) {
              position = new Vector2();
              pointerPositions[event.pointerId] = position;
            }
            position.set(event.pageX, event.pageY);
          }
          function getSecondPointerPosition(event) {
            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
            return pointerPositions[pointer.pointerId];
          }
          scope.domElement.addEventListener("contextmenu", onContextMenu);
          scope.domElement.addEventListener("pointerdown", onPointerDown);
          scope.domElement.addEventListener("pointercancel", onPointerUp);
          scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
          this.update();
        }
      };
    }
  });

  // node_modules/three/examples/jsm/libs/stats.module.js
  var Stats, stats_module_default;
  var init_stats_module = __esm({
    "node_modules/three/examples/jsm/libs/stats.module.js"() {
      Stats = function() {
        var mode = 0;
        var container = document.createElement("div");
        container.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
        container.addEventListener("click", function(event) {
          event.preventDefault();
          showPanel(++mode % container.children.length);
        }, false);
        function addPanel(panel) {
          container.appendChild(panel.dom);
          return panel;
        }
        function showPanel(id2) {
          for (var i5 = 0; i5 < container.children.length; i5++) {
            container.children[i5].style.display = i5 === id2 ? "block" : "none";
          }
          mode = id2;
        }
        var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
        var fpsPanel = addPanel(new Stats.Panel("FPS", "#0ff", "#002"));
        var msPanel = addPanel(new Stats.Panel("MS", "#0f0", "#020"));
        if (self.performance && self.performance.memory) {
          var memPanel = addPanel(new Stats.Panel("MB", "#f08", "#201"));
        }
        showPanel(0);
        return {
          REVISION: 16,
          dom: container,
          addPanel,
          showPanel,
          begin: function() {
            beginTime = (performance || Date).now();
          },
          end: function() {
            frames++;
            var time = (performance || Date).now();
            msPanel.update(time - beginTime, 200);
            if (time >= prevTime + 1e3) {
              fpsPanel.update(frames * 1e3 / (time - prevTime), 100);
              prevTime = time;
              frames = 0;
              if (memPanel) {
                var memory = performance.memory;
                memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
              }
            }
            return time;
          },
          update: function() {
            beginTime = this.end();
          },
          // Backwards Compatibility
          domElement: container,
          setMode: showPanel
        };
      };
      Stats.Panel = function(name2, fg3, bg3) {
        var min = Infinity, max2 = 0, round = Math.round;
        var PR = round(window.devicePixelRatio || 1);
        var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;
        var canvas = document.createElement("canvas");
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        canvas.style.cssText = "width:80px;height:48px";
        var context = canvas.getContext("2d");
        context.font = "bold " + 9 * PR + "px Helvetica,Arial,sans-serif";
        context.textBaseline = "top";
        context.fillStyle = bg3;
        context.fillRect(0, 0, WIDTH, HEIGHT);
        context.fillStyle = fg3;
        context.fillText(name2, TEXT_X, TEXT_Y);
        context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
        context.fillStyle = bg3;
        context.globalAlpha = 0.9;
        context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
        return {
          dom: canvas,
          update: function(value, maxValue) {
            min = Math.min(min, value);
            max2 = Math.max(max2, value);
            context.fillStyle = bg3;
            context.globalAlpha = 1;
            context.fillRect(0, 0, WIDTH, GRAPH_Y);
            context.fillStyle = fg3;
            context.fillText(round(value) + " " + name2 + " (" + round(min) + "-" + round(max2) + ")", TEXT_X, TEXT_Y);
            context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
            context.fillStyle = bg3;
            context.globalAlpha = 0.9;
            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));
          }
        };
      };
      stats_module_default = Stats;
    }
  });

  // node_modules/three/examples/jsm/libs/fflate.module.js
  function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
  }
  var durl, cwk, u8, u16, u32, fleb, fdeb, clim, freb, _a, fl2, revfl, _b2, fd2, revfd, rev, x4, i5, hMap, flt, i5, i5, i5, i5, fdt, i5, flrm, fdrm, max, bits, bits16, shft, slc, inflt, et, zlv, td2, tds;
  var init_fflate_module = __esm({
    "node_modules/three/examples/jsm/libs/fflate.module.js"() {
      durl = function(c5) {
        return URL.createObjectURL(new Blob([c5], { type: "text/javascript" }));
      };
      cwk = function(u4) {
        return new Worker(u4);
      };
      try {
        URL.revokeObjectURL(durl(""));
      } catch (e4) {
        durl = function(c5) {
          return "data:application/javascript;charset=UTF-8," + encodeURI(c5);
        };
        cwk = function(u4) {
          return new Worker(u4, { type: "module" });
        };
      }
      u8 = Uint8Array;
      u16 = Uint16Array;
      u32 = Uint32Array;
      fleb = new u8([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        /* unused */
        0,
        0,
        /* impossible */
        0
      ]);
      fdeb = new u8([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        /* unused */
        0,
        0
      ]);
      clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      freb = function(eb2, start) {
        var b3 = new u16(31);
        for (var i5 = 0; i5 < 31; ++i5) {
          b3[i5] = start += 1 << eb2[i5 - 1];
        }
        var r4 = new u32(b3[30]);
        for (var i5 = 1; i5 < 30; ++i5) {
          for (var j4 = b3[i5]; j4 < b3[i5 + 1]; ++j4) {
            r4[j4] = j4 - b3[i5] << 5 | i5;
          }
        }
        return [b3, r4];
      };
      _a = freb(fleb, 2);
      fl2 = _a[0];
      revfl = _a[1];
      fl2[28] = 258, revfl[258] = 28;
      _b2 = freb(fdeb, 0);
      fd2 = _b2[0];
      revfd = _b2[1];
      rev = new u16(32768);
      for (i5 = 0; i5 < 32768; ++i5) {
        x4 = (i5 & 43690) >>> 1 | (i5 & 21845) << 1;
        x4 = (x4 & 52428) >>> 2 | (x4 & 13107) << 2;
        x4 = (x4 & 61680) >>> 4 | (x4 & 3855) << 4;
        rev[i5] = ((x4 & 65280) >>> 8 | (x4 & 255) << 8) >>> 1;
      }
      hMap = function(cd2, mb2, r4) {
        var s4 = cd2.length;
        var i5 = 0;
        var l4 = new u16(mb2);
        for (; i5 < s4; ++i5)
          ++l4[cd2[i5] - 1];
        var le4 = new u16(mb2);
        for (i5 = 0; i5 < mb2; ++i5) {
          le4[i5] = le4[i5 - 1] + l4[i5 - 1] << 1;
        }
        var co4;
        if (r4) {
          co4 = new u16(1 << mb2);
          var rvb = 15 - mb2;
          for (i5 = 0; i5 < s4; ++i5) {
            if (cd2[i5]) {
              var sv = i5 << 4 | cd2[i5];
              var r_1 = mb2 - cd2[i5];
              var v5 = le4[cd2[i5] - 1]++ << r_1;
              for (var m4 = v5 | (1 << r_1) - 1; v5 <= m4; ++v5) {
                co4[rev[v5] >>> rvb] = sv;
              }
            }
          }
        } else {
          co4 = new u16(s4);
          for (i5 = 0; i5 < s4; ++i5) {
            if (cd2[i5]) {
              co4[i5] = rev[le4[cd2[i5] - 1]++] >>> 15 - cd2[i5];
            }
          }
        }
        return co4;
      };
      flt = new u8(288);
      for (i5 = 0; i5 < 144; ++i5)
        flt[i5] = 8;
      for (i5 = 144; i5 < 256; ++i5)
        flt[i5] = 9;
      for (i5 = 256; i5 < 280; ++i5)
        flt[i5] = 7;
      for (i5 = 280; i5 < 288; ++i5)
        flt[i5] = 8;
      fdt = new u8(32);
      for (i5 = 0; i5 < 32; ++i5)
        fdt[i5] = 5;
      flrm = /* @__PURE__ */ hMap(flt, 9, 1);
      fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
      max = function(a4) {
        var m4 = a4[0];
        for (var i5 = 1; i5 < a4.length; ++i5) {
          if (a4[i5] > m4)
            m4 = a4[i5];
        }
        return m4;
      };
      bits = function(d4, p4, m4) {
        var o4 = p4 / 8 | 0;
        return (d4[o4] | d4[o4 + 1] << 8) >> (p4 & 7) & m4;
      };
      bits16 = function(d4, p4) {
        var o4 = p4 / 8 | 0;
        return (d4[o4] | d4[o4 + 1] << 8 | d4[o4 + 2] << 16) >> (p4 & 7);
      };
      shft = function(p4) {
        return (p4 / 8 | 0) + (p4 & 7 && 1);
      };
      slc = function(v5, s4, e4) {
        if (s4 == null || s4 < 0)
          s4 = 0;
        if (e4 == null || e4 > v5.length)
          e4 = v5.length;
        var n4 = new (v5 instanceof u16 ? u16 : v5 instanceof u32 ? u32 : u8)(e4 - s4);
        n4.set(v5.subarray(s4, e4));
        return n4;
      };
      inflt = function(dat, buf, st4) {
        var sl3 = dat.length;
        if (!sl3 || st4 && !st4.l && sl3 < 5)
          return buf || new u8(0);
        var noBuf = !buf || st4;
        var noSt = !st4 || st4.i;
        if (!st4)
          st4 = {};
        if (!buf)
          buf = new u8(sl3 * 3);
        var cbuf = function(l5) {
          var bl2 = buf.length;
          if (l5 > bl2) {
            var nbuf = new u8(Math.max(bl2 * 2, l5));
            nbuf.set(buf);
            buf = nbuf;
          }
        };
        var final = st4.f || 0, pos = st4.p || 0, bt4 = st4.b || 0, lm2 = st4.l, dm2 = st4.d, lbt = st4.m, dbt = st4.n;
        var tbts = sl3 * 8;
        do {
          if (!lm2) {
            st4.f = final = bits(dat, pos, 1);
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
              var s4 = shft(pos) + 4, l4 = dat[s4 - 4] | dat[s4 - 3] << 8, t4 = s4 + l4;
              if (t4 > sl3) {
                if (noSt)
                  throw "unexpected EOF";
                break;
              }
              if (noBuf)
                cbuf(bt4 + l4);
              buf.set(dat.subarray(s4, t4), bt4);
              st4.b = bt4 += l4, st4.p = pos = t4 * 8;
              continue;
            } else if (type == 1)
              lm2 = flrm, dm2 = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
              var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
              var tl3 = hLit + bits(dat, pos + 5, 31) + 1;
              pos += 14;
              var ldt = new u8(tl3);
              var clt = new u8(19);
              for (var i5 = 0; i5 < hcLen; ++i5) {
                clt[clim[i5]] = bits(dat, pos + i5 * 3, 7);
              }
              pos += hcLen * 3;
              var clb = max(clt), clbmsk = (1 << clb) - 1;
              var clm = hMap(clt, clb, 1);
              for (var i5 = 0; i5 < tl3; ) {
                var r4 = clm[bits(dat, pos, clbmsk)];
                pos += r4 & 15;
                var s4 = r4 >>> 4;
                if (s4 < 16) {
                  ldt[i5++] = s4;
                } else {
                  var c5 = 0, n4 = 0;
                  if (s4 == 16)
                    n4 = 3 + bits(dat, pos, 3), pos += 2, c5 = ldt[i5 - 1];
                  else if (s4 == 17)
                    n4 = 3 + bits(dat, pos, 7), pos += 3;
                  else if (s4 == 18)
                    n4 = 11 + bits(dat, pos, 127), pos += 7;
                  while (n4--)
                    ldt[i5++] = c5;
                }
              }
              var lt4 = ldt.subarray(0, hLit), dt5 = ldt.subarray(hLit);
              lbt = max(lt4);
              dbt = max(dt5);
              lm2 = hMap(lt4, lbt, 1);
              dm2 = hMap(dt5, dbt, 1);
            } else
              throw "invalid block type";
            if (pos > tbts) {
              if (noSt)
                throw "unexpected EOF";
              break;
            }
          }
          if (noBuf)
            cbuf(bt4 + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var lpos = pos;
          for (; ; lpos = pos) {
            var c5 = lm2[bits16(dat, pos) & lms], sym = c5 >>> 4;
            pos += c5 & 15;
            if (pos > tbts) {
              if (noSt)
                throw "unexpected EOF";
              break;
            }
            if (!c5)
              throw "invalid length/literal";
            if (sym < 256)
              buf[bt4++] = sym;
            else if (sym == 256) {
              lpos = pos, lm2 = null;
              break;
            } else {
              var add4 = sym - 254;
              if (sym > 264) {
                var i5 = sym - 257, b3 = fleb[i5];
                add4 = bits(dat, pos, (1 << b3) - 1) + fl2[i5];
                pos += b3;
              }
              var d4 = dm2[bits16(dat, pos) & dms], dsym = d4 >>> 4;
              if (!d4)
                throw "invalid distance";
              pos += d4 & 15;
              var dt5 = fd2[dsym];
              if (dsym > 3) {
                var b3 = fdeb[dsym];
                dt5 += bits16(dat, pos) & (1 << b3) - 1, pos += b3;
              }
              if (pos > tbts) {
                if (noSt)
                  throw "unexpected EOF";
                break;
              }
              if (noBuf)
                cbuf(bt4 + 131072);
              var end = bt4 + add4;
              for (; bt4 < end; bt4 += 4) {
                buf[bt4] = buf[bt4 - dt5];
                buf[bt4 + 1] = buf[bt4 + 1 - dt5];
                buf[bt4 + 2] = buf[bt4 + 2 - dt5];
                buf[bt4 + 3] = buf[bt4 + 3 - dt5];
              }
              bt4 = end;
            }
          }
          st4.l = lm2, st4.p = lpos, st4.b = bt4;
          if (lm2)
            final = 1, st4.m = lbt, st4.d = dm2, st4.n = dbt;
        } while (!final);
        return bt4 == buf.length ? buf : slc(buf, 0, bt4);
      };
      et = /* @__PURE__ */ new u8(0);
      zlv = function(d4) {
        if ((d4[0] & 15) != 8 || d4[0] >>> 4 > 7 || (d4[0] << 8 | d4[1]) % 31)
          throw "invalid zlib data";
        if (d4[1] & 32)
          throw "invalid zlib data: preset dictionaries not supported";
      };
      td2 = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
      tds = 0;
      try {
        td2.decode(et, { stream: true });
        tds = 1;
      } catch (e4) {
      }
    }
  });

  // node_modules/three/examples/jsm/curves/NURBSUtils.js
  function findSpan(p4, u4, U5) {
    const n4 = U5.length - p4 - 1;
    if (u4 >= U5[n4]) {
      return n4 - 1;
    }
    if (u4 <= U5[p4]) {
      return p4;
    }
    let low = p4;
    let high = n4;
    let mid = Math.floor((low + high) / 2);
    while (u4 < U5[mid] || u4 >= U5[mid + 1]) {
      if (u4 < U5[mid]) {
        high = mid;
      } else {
        low = mid;
      }
      mid = Math.floor((low + high) / 2);
    }
    return mid;
  }
  function calcBasisFunctions(span, u4, p4, U5) {
    const N4 = [];
    const left = [];
    const right = [];
    N4[0] = 1;
    for (let j4 = 1; j4 <= p4; ++j4) {
      left[j4] = u4 - U5[span + 1 - j4];
      right[j4] = U5[span + j4] - u4;
      let saved = 0;
      for (let r4 = 0; r4 < j4; ++r4) {
        const rv = right[r4 + 1];
        const lv = left[j4 - r4];
        const temp = N4[r4] / (rv + lv);
        N4[r4] = saved + rv * temp;
        saved = lv * temp;
      }
      N4[j4] = saved;
    }
    return N4;
  }
  function calcBSplinePoint(p4, U5, P4, u4) {
    const span = findSpan(p4, u4, U5);
    const N4 = calcBasisFunctions(span, u4, p4, U5);
    const C3 = new Vector4(0, 0, 0, 0);
    for (let j4 = 0; j4 <= p4; ++j4) {
      const point = P4[span - p4 + j4];
      const Nj = N4[j4];
      const wNj = point.w * Nj;
      C3.x += point.x * wNj;
      C3.y += point.y * wNj;
      C3.z += point.z * wNj;
      C3.w += point.w * Nj;
    }
    return C3;
  }
  function calcBasisFunctionDerivatives(span, u4, p4, n4, U5) {
    const zeroArr = [];
    for (let i5 = 0; i5 <= p4; ++i5)
      zeroArr[i5] = 0;
    const ders = [];
    for (let i5 = 0; i5 <= n4; ++i5)
      ders[i5] = zeroArr.slice(0);
    const ndu = [];
    for (let i5 = 0; i5 <= p4; ++i5)
      ndu[i5] = zeroArr.slice(0);
    ndu[0][0] = 1;
    const left = zeroArr.slice(0);
    const right = zeroArr.slice(0);
    for (let j4 = 1; j4 <= p4; ++j4) {
      left[j4] = u4 - U5[span + 1 - j4];
      right[j4] = U5[span + j4] - u4;
      let saved = 0;
      for (let r5 = 0; r5 < j4; ++r5) {
        const rv = right[r5 + 1];
        const lv = left[j4 - r5];
        ndu[j4][r5] = rv + lv;
        const temp = ndu[r5][j4 - 1] / ndu[j4][r5];
        ndu[r5][j4] = saved + rv * temp;
        saved = lv * temp;
      }
      ndu[j4][j4] = saved;
    }
    for (let j4 = 0; j4 <= p4; ++j4) {
      ders[0][j4] = ndu[j4][p4];
    }
    for (let r5 = 0; r5 <= p4; ++r5) {
      let s1 = 0;
      let s22 = 1;
      const a4 = [];
      for (let i5 = 0; i5 <= p4; ++i5) {
        a4[i5] = zeroArr.slice(0);
      }
      a4[0][0] = 1;
      for (let k4 = 1; k4 <= n4; ++k4) {
        let d4 = 0;
        const rk = r5 - k4;
        const pk = p4 - k4;
        if (r5 >= k4) {
          a4[s22][0] = a4[s1][0] / ndu[pk + 1][rk];
          d4 = a4[s22][0] * ndu[rk][pk];
        }
        const j1 = rk >= -1 ? 1 : -rk;
        const j22 = r5 - 1 <= pk ? k4 - 1 : p4 - r5;
        for (let j5 = j1; j5 <= j22; ++j5) {
          a4[s22][j5] = (a4[s1][j5] - a4[s1][j5 - 1]) / ndu[pk + 1][rk + j5];
          d4 += a4[s22][j5] * ndu[rk + j5][pk];
        }
        if (r5 <= pk) {
          a4[s22][k4] = -a4[s1][k4 - 1] / ndu[pk + 1][r5];
          d4 += a4[s22][k4] * ndu[r5][pk];
        }
        ders[k4][r5] = d4;
        const j4 = s1;
        s1 = s22;
        s22 = j4;
      }
    }
    let r4 = p4;
    for (let k4 = 1; k4 <= n4; ++k4) {
      for (let j4 = 0; j4 <= p4; ++j4) {
        ders[k4][j4] *= r4;
      }
      r4 *= p4 - k4;
    }
    return ders;
  }
  function calcBSplineDerivatives(p4, U5, P4, u4, nd2) {
    const du2 = nd2 < p4 ? nd2 : p4;
    const CK = [];
    const span = findSpan(p4, u4, U5);
    const nders = calcBasisFunctionDerivatives(span, u4, p4, du2, U5);
    const Pw2 = [];
    for (let i5 = 0; i5 < P4.length; ++i5) {
      const point = P4[i5].clone();
      const w3 = point.w;
      point.x *= w3;
      point.y *= w3;
      point.z *= w3;
      Pw2[i5] = point;
    }
    for (let k4 = 0; k4 <= du2; ++k4) {
      const point = Pw2[span - p4].clone().multiplyScalar(nders[k4][0]);
      for (let j4 = 1; j4 <= p4; ++j4) {
        point.add(Pw2[span - p4 + j4].clone().multiplyScalar(nders[k4][j4]));
      }
      CK[k4] = point;
    }
    for (let k4 = du2 + 1; k4 <= nd2 + 1; ++k4) {
      CK[k4] = new Vector4(0, 0, 0);
    }
    return CK;
  }
  function calcKoverI(k4, i5) {
    let nom = 1;
    for (let j4 = 2; j4 <= k4; ++j4) {
      nom *= j4;
    }
    let denom = 1;
    for (let j4 = 2; j4 <= i5; ++j4) {
      denom *= j4;
    }
    for (let j4 = 2; j4 <= k4 - i5; ++j4) {
      denom *= j4;
    }
    return nom / denom;
  }
  function calcRationalCurveDerivatives(Pders) {
    const nd2 = Pders.length;
    const Aders = [];
    const wders = [];
    for (let i5 = 0; i5 < nd2; ++i5) {
      const point = Pders[i5];
      Aders[i5] = new Vector3(point.x, point.y, point.z);
      wders[i5] = point.w;
    }
    const CK = [];
    for (let k4 = 0; k4 < nd2; ++k4) {
      const v5 = Aders[k4].clone();
      for (let i5 = 1; i5 <= k4; ++i5) {
        v5.sub(CK[k4 - i5].clone().multiplyScalar(calcKoverI(k4, i5) * wders[i5]));
      }
      CK[k4] = v5.divideScalar(wders[0]);
    }
    return CK;
  }
  function calcNURBSDerivatives(p4, U5, P4, u4, nd2) {
    const Pders = calcBSplineDerivatives(p4, U5, P4, u4, nd2);
    return calcRationalCurveDerivatives(Pders);
  }
  var init_NURBSUtils = __esm({
    "node_modules/three/examples/jsm/curves/NURBSUtils.js"() {
      init_three_module();
    }
  });

  // node_modules/three/examples/jsm/curves/NURBSCurve.js
  var NURBSCurve;
  var init_NURBSCurve = __esm({
    "node_modules/three/examples/jsm/curves/NURBSCurve.js"() {
      init_three_module();
      init_NURBSUtils();
      NURBSCurve = class extends Curve {
        constructor(degree3, knots, controlPoints, startKnot, endKnot) {
          super();
          this.degree = degree3;
          this.knots = knots;
          this.controlPoints = [];
          this.startKnot = startKnot || 0;
          this.endKnot = endKnot || this.knots.length - 1;
          for (let i5 = 0; i5 < controlPoints.length; ++i5) {
            const point = controlPoints[i5];
            this.controlPoints[i5] = new Vector4(point.x, point.y, point.z, point.w);
          }
        }
        getPoint(t4, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const u4 = this.knots[this.startKnot] + t4 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
          const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u4);
          if (hpoint.w !== 1) {
            hpoint.divideScalar(hpoint.w);
          }
          return point.set(hpoint.x, hpoint.y, hpoint.z);
        }
        getTangent(t4, optionalTarget = new Vector3()) {
          const tangent = optionalTarget;
          const u4 = this.knots[0] + t4 * (this.knots[this.knots.length - 1] - this.knots[0]);
          const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u4, 1);
          tangent.copy(ders[1]).normalize();
          return tangent;
        }
      };
    }
  });

  // node_modules/three/examples/jsm/loaders/FBXLoader.js
  function isFbxFormatBinary(buffer) {
    const CORRECT = "Kaydara FBX Binary  \0";
    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
  }
  function isFbxFormatASCII(text) {
    const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
    let cursor = 0;
    function read(offset) {
      const result = text[offset - 1];
      text = text.slice(cursor + offset);
      cursor++;
      return result;
    }
    for (let i5 = 0; i5 < CORRECT.length; ++i5) {
      const num = read(1);
      if (num === CORRECT[i5]) {
        return false;
      }
    }
    return true;
  }
  function getFbxVersion(text) {
    const versionRegExp = /FBXVersion: (\d+)/;
    const match = text.match(versionRegExp);
    if (match) {
      const version = parseInt(match[1]);
      return version;
    }
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
  }
  function convertFBXTimeToSeconds(time) {
    return time / 46186158e3;
  }
  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
    let index;
    switch (infoObject.mappingType) {
      case "ByPolygonVertex":
        index = polygonVertexIndex;
        break;
      case "ByPolygon":
        index = polygonIndex;
        break;
      case "ByVertice":
        index = vertexIndex;
        break;
      case "AllSame":
        index = infoObject.indices[0];
        break;
      default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
    }
    if (infoObject.referenceType === "IndexToDirect")
      index = infoObject.indices[index];
    const from = index * infoObject.dataSize;
    const to4 = from + infoObject.dataSize;
    return slice(dataArray, infoObject.buffer, from, to4);
  }
  function generateTransform(transformData2) {
    const lTranslationM = new Matrix4();
    const lPreRotationM = new Matrix4();
    const lRotationM = new Matrix4();
    const lPostRotationM = new Matrix4();
    const lScalingM = new Matrix4();
    const lScalingPivotM = new Matrix4();
    const lScalingOffsetM = new Matrix4();
    const lRotationOffsetM = new Matrix4();
    const lRotationPivotM = new Matrix4();
    const lParentGX = new Matrix4();
    const lParentLX = new Matrix4();
    const lGlobalT = new Matrix4();
    const inheritType = transformData2.inheritType ? transformData2.inheritType : 0;
    if (transformData2.translation)
      lTranslationM.setPosition(tempVec.fromArray(transformData2.translation));
    if (transformData2.preRotation) {
      const array = transformData2.preRotation.map(MathUtils.degToRad);
      array.push(transformData2.eulerOrder || Euler.DEFAULT_ORDER);
      lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    }
    if (transformData2.rotation) {
      const array = transformData2.rotation.map(MathUtils.degToRad);
      array.push(transformData2.eulerOrder || Euler.DEFAULT_ORDER);
      lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    }
    if (transformData2.postRotation) {
      const array = transformData2.postRotation.map(MathUtils.degToRad);
      array.push(transformData2.eulerOrder || Euler.DEFAULT_ORDER);
      lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
      lPostRotationM.invert();
    }
    if (transformData2.scale)
      lScalingM.scale(tempVec.fromArray(transformData2.scale));
    if (transformData2.scalingOffset)
      lScalingOffsetM.setPosition(tempVec.fromArray(transformData2.scalingOffset));
    if (transformData2.scalingPivot)
      lScalingPivotM.setPosition(tempVec.fromArray(transformData2.scalingPivot));
    if (transformData2.rotationOffset)
      lRotationOffsetM.setPosition(tempVec.fromArray(transformData2.rotationOffset));
    if (transformData2.rotationPivot)
      lRotationPivotM.setPosition(tempVec.fromArray(transformData2.rotationPivot));
    if (transformData2.parentMatrixWorld) {
      lParentLX.copy(transformData2.parentMatrix);
      lParentGX.copy(transformData2.parentMatrixWorld);
    }
    const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
    const lParentGRM = new Matrix4();
    lParentGRM.extractRotation(lParentGX);
    const lParentTM = new Matrix4();
    lParentTM.copyPosition(lParentGX);
    const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
    const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
    const lLSM = lScalingM;
    const lGlobalRS = new Matrix4();
    if (inheritType === 0) {
      lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
    } else if (inheritType === 1) {
      lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
    } else {
      const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
      const lParentLSM_inv = lParentLSM.clone().invert();
      const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
      lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
    }
    const lRotationPivotM_inv = lRotationPivotM.clone().invert();
    const lScalingPivotM_inv = lScalingPivotM.clone().invert();
    let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
    const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
    const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
    lGlobalT.copyPosition(lGlobalTranslation);
    lTransform = lGlobalT.clone().multiply(lGlobalRS);
    lTransform.premultiply(lParentGX.invert());
    return lTransform;
  }
  function getEulerOrder(order) {
    order = order || 0;
    const enums = [
      "ZYX",
      // -> XYZ extrinsic
      "YZX",
      // -> XZY extrinsic
      "XZY",
      // -> YZX extrinsic
      "ZXY",
      // -> YXZ extrinsic
      "YXZ",
      // -> ZXY extrinsic
      "XYZ"
      // -> ZYX extrinsic
      //'SphericXYZ', // not possible to support
    ];
    if (order === 6) {
      console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
      return enums[0];
    }
    return enums[order];
  }
  function parseNumberArray(value) {
    const array = value.split(",").map(function(val) {
      return parseFloat(val);
    });
    return array;
  }
  function convertArrayBufferToString(buffer, from, to4) {
    if (from === void 0)
      from = 0;
    if (to4 === void 0)
      to4 = buffer.byteLength;
    return new TextDecoder().decode(new Uint8Array(buffer, from, to4));
  }
  function append2(a4, b3) {
    for (let i5 = 0, j4 = a4.length, l4 = b3.length; i5 < l4; i5++, j4++) {
      a4[j4] = b3[i5];
    }
  }
  function slice(a4, b3, from, to4) {
    for (let i5 = from, j4 = 0; i5 < to4; i5++, j4++) {
      a4[j4] = b3[i5];
    }
    return a4;
  }
  function inject(a1, index, a22) {
    return a1.slice(0, index).concat(a22).concat(a1.slice(index));
  }
  var fbxTree, connections, sceneGraph, FBXLoader, FBXTreeParser, GeometryParser, AnimationParser, TextParser, BinaryParser, BinaryReader, FBXTree, dataArray, tempEuler, tempVec;
  var init_FBXLoader = __esm({
    "node_modules/three/examples/jsm/loaders/FBXLoader.js"() {
      init_three_module();
      init_fflate_module();
      init_NURBSCurve();
      FBXLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
          const loader = new FileLoader(this.manager);
          loader.setPath(scope.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(buffer) {
            try {
              onLoad(scope.parse(buffer, path));
            } catch (e4) {
              if (onError) {
                onError(e4);
              } else {
                console.error(e4);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(FBXBuffer, path) {
          if (isFbxFormatBinary(FBXBuffer)) {
            fbxTree = new BinaryParser().parse(FBXBuffer);
          } else {
            const FBXText = convertArrayBufferToString(FBXBuffer);
            if (!isFbxFormatASCII(FBXText)) {
              throw new Error("THREE.FBXLoader: Unknown format.");
            }
            if (getFbxVersion(FBXText) < 7e3) {
              throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
            }
            fbxTree = new TextParser().parse(FBXText);
          }
          const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
          return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
        }
      };
      FBXTreeParser = class {
        constructor(textureLoader, manager) {
          this.textureLoader = textureLoader;
          this.manager = manager;
        }
        parse() {
          connections = this.parseConnections();
          const images = this.parseImages();
          const textures = this.parseTextures(images);
          const materials = this.parseMaterials(textures);
          const deformers = this.parseDeformers();
          const geometryMap = new GeometryParser().parse(deformers);
          this.parseScene(deformers, geometryMap, materials);
          return sceneGraph;
        }
        // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
        // and details the connection type
        parseConnections() {
          const connectionMap = /* @__PURE__ */ new Map();
          if ("Connections" in fbxTree) {
            const rawConnections = fbxTree.Connections.connections;
            rawConnections.forEach(function(rawConnection) {
              const fromID = rawConnection[0];
              const toID = rawConnection[1];
              const relationship = rawConnection[2];
              if (!connectionMap.has(fromID)) {
                connectionMap.set(fromID, {
                  parents: [],
                  children: []
                });
              }
              const parentRelationship = { ID: toID, relationship };
              connectionMap.get(fromID).parents.push(parentRelationship);
              if (!connectionMap.has(toID)) {
                connectionMap.set(toID, {
                  parents: [],
                  children: []
                });
              }
              const childRelationship = { ID: fromID, relationship };
              connectionMap.get(toID).children.push(childRelationship);
            });
          }
          return connectionMap;
        }
        // Parse FBXTree.Objects.Video for embedded image data
        // These images are connected to textures in FBXTree.Objects.Textures
        // via FBXTree.Connections.
        parseImages() {
          const images = {};
          const blobs = {};
          if ("Video" in fbxTree.Objects) {
            const videoNodes = fbxTree.Objects.Video;
            for (const nodeID in videoNodes) {
              const videoNode = videoNodes[nodeID];
              const id2 = parseInt(nodeID);
              images[id2] = videoNode.RelativeFilename || videoNode.Filename;
              if ("Content" in videoNode) {
                const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
                const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
                if (arrayBufferContent || base64Content) {
                  const image = this.parseImage(videoNodes[nodeID]);
                  blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
                }
              }
            }
          }
          for (const id2 in images) {
            const filename = images[id2];
            if (blobs[filename] !== void 0)
              images[id2] = blobs[filename];
            else
              images[id2] = images[id2].split("\\").pop();
          }
          return images;
        }
        // Parse embedded image data in FBXTree.Video.Content
        parseImage(videoNode) {
          const content = videoNode.Content;
          const fileName = videoNode.RelativeFilename || videoNode.Filename;
          const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
          let type;
          switch (extension) {
            case "bmp":
              type = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              type = "image/jpeg";
              break;
            case "png":
              type = "image/png";
              break;
            case "tif":
              type = "image/tiff";
              break;
            case "tga":
              if (this.manager.getHandler(".tga") === null) {
                console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
              }
              type = "image/tga";
              break;
            default:
              console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
              return;
          }
          if (typeof content === "string") {
            return "data:" + type + ";base64," + content;
          } else {
            const array = new Uint8Array(content);
            return window.URL.createObjectURL(new Blob([array], { type }));
          }
        }
        // Parse nodes in FBXTree.Objects.Texture
        // These contain details such as UV scaling, cropping, rotation etc and are connected
        // to images in FBXTree.Objects.Video
        parseTextures(images) {
          const textureMap = /* @__PURE__ */ new Map();
          if ("Texture" in fbxTree.Objects) {
            const textureNodes = fbxTree.Objects.Texture;
            for (const nodeID in textureNodes) {
              const texture = this.parseTexture(textureNodes[nodeID], images);
              textureMap.set(parseInt(nodeID), texture);
            }
          }
          return textureMap;
        }
        // Parse individual node in FBXTree.Objects.Texture
        parseTexture(textureNode, images) {
          const texture = this.loadTexture(textureNode, images);
          texture.ID = textureNode.id;
          texture.name = textureNode.attrName;
          const wrapModeU = textureNode.WrapModeU;
          const wrapModeV = textureNode.WrapModeV;
          const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
          const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
          texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
          texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
          if ("Scaling" in textureNode) {
            const values = textureNode.Scaling.value;
            texture.repeat.x = values[0];
            texture.repeat.y = values[1];
          }
          if ("Translation" in textureNode) {
            const values = textureNode.Translation.value;
            texture.offset.x = values[0];
            texture.offset.y = values[1];
          }
          return texture;
        }
        // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
        loadTexture(textureNode, images) {
          let fileName;
          const currentPath = this.textureLoader.path;
          const children = connections.get(textureNode.id).children;
          if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
            fileName = images[children[0].ID];
            if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
              this.textureLoader.setPath(void 0);
            }
          }
          let texture;
          const extension = textureNode.FileName.slice(-3).toLowerCase();
          if (extension === "tga") {
            const loader = this.manager.getHandler(".tga");
            if (loader === null) {
              console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
              texture = new Texture();
            } else {
              loader.setPath(this.textureLoader.path);
              texture = loader.load(fileName);
            }
          } else if (extension === "psd") {
            console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new Texture();
          } else {
            texture = this.textureLoader.load(fileName);
          }
          this.textureLoader.setPath(currentPath);
          return texture;
        }
        // Parse nodes in FBXTree.Objects.Material
        parseMaterials(textureMap) {
          const materialMap = /* @__PURE__ */ new Map();
          if ("Material" in fbxTree.Objects) {
            const materialNodes = fbxTree.Objects.Material;
            for (const nodeID in materialNodes) {
              const material = this.parseMaterial(materialNodes[nodeID], textureMap);
              if (material !== null)
                materialMap.set(parseInt(nodeID), material);
            }
          }
          return materialMap;
        }
        // Parse single node in FBXTree.Objects.Material
        // Materials are connected to texture maps in FBXTree.Objects.Textures
        // FBX format currently only supports Lambert and Phong shading models
        parseMaterial(materialNode, textureMap) {
          const ID = materialNode.id;
          const name2 = materialNode.attrName;
          let type = materialNode.ShadingModel;
          if (typeof type === "object") {
            type = type.value;
          }
          if (!connections.has(ID))
            return null;
          const parameters = this.parseParameters(materialNode, textureMap, ID);
          let material;
          switch (type.toLowerCase()) {
            case "phong":
              material = new MeshPhongMaterial();
              break;
            case "lambert":
              material = new MeshLambertMaterial();
              break;
            default:
              console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
              material = new MeshPhongMaterial();
              break;
          }
          material.setValues(parameters);
          material.name = name2;
          return material;
        }
        // Parse FBX material and return parameters suitable for a three.js material
        // Also parse the texture map and return any textures associated with the material
        parseParameters(materialNode, textureMap, ID) {
          const parameters = {};
          if (materialNode.BumpFactor) {
            parameters.bumpScale = materialNode.BumpFactor.value;
          }
          if (materialNode.Diffuse) {
            parameters.color = new Color().fromArray(materialNode.Diffuse.value).convertSRGBToLinear();
          } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
            parameters.color = new Color().fromArray(materialNode.DiffuseColor.value).convertSRGBToLinear();
          }
          if (materialNode.DisplacementFactor) {
            parameters.displacementScale = materialNode.DisplacementFactor.value;
          }
          if (materialNode.Emissive) {
            parameters.emissive = new Color().fromArray(materialNode.Emissive.value).convertSRGBToLinear();
          } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
            parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value).convertSRGBToLinear();
          }
          if (materialNode.EmissiveFactor) {
            parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
          }
          if (materialNode.Opacity) {
            parameters.opacity = parseFloat(materialNode.Opacity.value);
          }
          if (parameters.opacity < 1) {
            parameters.transparent = true;
          }
          if (materialNode.ReflectionFactor) {
            parameters.reflectivity = materialNode.ReflectionFactor.value;
          }
          if (materialNode.Shininess) {
            parameters.shininess = materialNode.Shininess.value;
          }
          if (materialNode.Specular) {
            parameters.specular = new Color().fromArray(materialNode.Specular.value).convertSRGBToLinear();
          } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
            parameters.specular = new Color().fromArray(materialNode.SpecularColor.value).convertSRGBToLinear();
          }
          const scope = this;
          connections.get(ID).children.forEach(function(child) {
            const type = child.relationship;
            switch (type) {
              case "Bump":
                parameters.bumpMap = scope.getTexture(textureMap, child.ID);
                break;
              case "Maya|TEX_ao_map":
                parameters.aoMap = scope.getTexture(textureMap, child.ID);
                break;
              case "DiffuseColor":
              case "Maya|TEX_color_map":
                parameters.map = scope.getTexture(textureMap, child.ID);
                if (parameters.map !== void 0) {
                  parameters.map.colorSpace = SRGBColorSpace;
                }
                break;
              case "DisplacementColor":
                parameters.displacementMap = scope.getTexture(textureMap, child.ID);
                break;
              case "EmissiveColor":
                parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
                if (parameters.emissiveMap !== void 0) {
                  parameters.emissiveMap.colorSpace = SRGBColorSpace;
                }
                break;
              case "NormalMap":
              case "Maya|TEX_normal_map":
                parameters.normalMap = scope.getTexture(textureMap, child.ID);
                break;
              case "ReflectionColor":
                parameters.envMap = scope.getTexture(textureMap, child.ID);
                if (parameters.envMap !== void 0) {
                  parameters.envMap.mapping = EquirectangularReflectionMapping;
                  parameters.envMap.colorSpace = SRGBColorSpace;
                }
                break;
              case "SpecularColor":
                parameters.specularMap = scope.getTexture(textureMap, child.ID);
                if (parameters.specularMap !== void 0) {
                  parameters.specularMap.colorSpace = SRGBColorSpace;
                }
                break;
              case "TransparentColor":
              case "TransparencyFactor":
                parameters.alphaMap = scope.getTexture(textureMap, child.ID);
                parameters.transparent = true;
                break;
              case "AmbientColor":
              case "ShininessExponent":
              case "SpecularFactor":
              case "VectorDisplacementColor":
              default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
                break;
            }
          });
          return parameters;
        }
        // get a texture from the textureMap for use by a material.
        getTexture(textureMap, id2) {
          if ("LayeredTexture" in fbxTree.Objects && id2 in fbxTree.Objects.LayeredTexture) {
            console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
            id2 = connections.get(id2).children[0].ID;
          }
          return textureMap.get(id2);
        }
        // Parse nodes in FBXTree.Objects.Deformer
        // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
        // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
        parseDeformers() {
          const skeletons = {};
          const morphTargets = {};
          if ("Deformer" in fbxTree.Objects) {
            const DeformerNodes = fbxTree.Objects.Deformer;
            for (const nodeID in DeformerNodes) {
              const deformerNode = DeformerNodes[nodeID];
              const relationships = connections.get(parseInt(nodeID));
              if (deformerNode.attrType === "Skin") {
                const skeleton = this.parseSkeleton(relationships, DeformerNodes);
                skeleton.ID = nodeID;
                if (relationships.parents.length > 1)
                  console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
                skeleton.geometryID = relationships.parents[0].ID;
                skeletons[nodeID] = skeleton;
              } else if (deformerNode.attrType === "BlendShape") {
                const morphTarget = {
                  id: nodeID
                };
                morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
                morphTarget.id = nodeID;
                if (relationships.parents.length > 1)
                  console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
                morphTargets[nodeID] = morphTarget;
              }
            }
          }
          return {
            skeletons,
            morphTargets
          };
        }
        // Parse single nodes in FBXTree.Objects.Deformer
        // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
        // Each skin node represents a skeleton and each cluster node represents a bone
        parseSkeleton(relationships, deformerNodes) {
          const rawBones = [];
          relationships.children.forEach(function(child) {
            const boneNode = deformerNodes[child.ID];
            if (boneNode.attrType !== "Cluster")
              return;
            const rawBone = {
              ID: child.ID,
              indices: [],
              weights: [],
              transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
              // transform: new Matrix4().fromArray( boneNode.Transform.a ),
              // linkMode: boneNode.Mode,
            };
            if ("Indexes" in boneNode) {
              rawBone.indices = boneNode.Indexes.a;
              rawBone.weights = boneNode.Weights.a;
            }
            rawBones.push(rawBone);
          });
          return {
            rawBones,
            bones: []
          };
        }
        // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
        parseMorphTargets(relationships, deformerNodes) {
          const rawMorphTargets = [];
          for (let i5 = 0; i5 < relationships.children.length; i5++) {
            const child = relationships.children[i5];
            const morphTargetNode = deformerNodes[child.ID];
            const rawMorphTarget = {
              name: morphTargetNode.attrName,
              initialWeight: morphTargetNode.DeformPercent,
              id: morphTargetNode.id,
              fullWeights: morphTargetNode.FullWeights.a
            };
            if (morphTargetNode.attrType !== "BlendShapeChannel")
              return;
            rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
              return child2.relationship === void 0;
            })[0].ID;
            rawMorphTargets.push(rawMorphTarget);
          }
          return rawMorphTargets;
        }
        // create the main Group() to be returned by the loader
        parseScene(deformers, geometryMap, materialMap) {
          sceneGraph = new Group();
          const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
          const modelNodes = fbxTree.Objects.Model;
          const scope = this;
          modelMap.forEach(function(model) {
            const modelNode = modelNodes[model.ID];
            scope.setLookAtProperties(model, modelNode);
            const parentConnections = connections.get(model.ID).parents;
            parentConnections.forEach(function(connection) {
              const parent = modelMap.get(connection.ID);
              if (parent !== void 0)
                parent.add(model);
            });
            if (model.parent === null) {
              sceneGraph.add(model);
            }
          });
          this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
          this.createAmbientLight();
          sceneGraph.traverse(function(node) {
            if (node.userData.transformData) {
              if (node.parent) {
                node.userData.transformData.parentMatrix = node.parent.matrix;
                node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
              }
              const transform = generateTransform(node.userData.transformData);
              node.applyMatrix4(transform);
              node.updateWorldMatrix();
            }
          });
          const animations = new AnimationParser().parse();
          if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
            sceneGraph.children[0].animations = animations;
            sceneGraph = sceneGraph.children[0];
          }
          sceneGraph.animations = animations;
        }
        // parse nodes in FBXTree.Objects.Model
        parseModels(skeletons, geometryMap, materialMap) {
          const modelMap = /* @__PURE__ */ new Map();
          const modelNodes = fbxTree.Objects.Model;
          for (const nodeID in modelNodes) {
            const id2 = parseInt(nodeID);
            const node = modelNodes[nodeID];
            const relationships = connections.get(id2);
            let model = this.buildSkeleton(relationships, skeletons, id2, node.attrName);
            if (!model) {
              switch (node.attrType) {
                case "Camera":
                  model = this.createCamera(relationships);
                  break;
                case "Light":
                  model = this.createLight(relationships);
                  break;
                case "Mesh":
                  model = this.createMesh(relationships, geometryMap, materialMap);
                  break;
                case "NurbsCurve":
                  model = this.createCurve(relationships, geometryMap);
                  break;
                case "LimbNode":
                case "Root":
                  model = new Bone();
                  break;
                case "Null":
                default:
                  model = new Group();
                  break;
              }
              model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
              model.userData.originalName = node.attrName;
              model.ID = id2;
            }
            this.getTransformData(model, node);
            modelMap.set(id2, model);
          }
          return modelMap;
        }
        buildSkeleton(relationships, skeletons, id2, name2) {
          let bone = null;
          relationships.parents.forEach(function(parent) {
            for (const ID in skeletons) {
              const skeleton = skeletons[ID];
              skeleton.rawBones.forEach(function(rawBone, i5) {
                if (rawBone.ID === parent.ID) {
                  const subBone = bone;
                  bone = new Bone();
                  bone.matrixWorld.copy(rawBone.transformLink);
                  bone.name = name2 ? PropertyBinding.sanitizeNodeName(name2) : "";
                  bone.userData.originalName = name2;
                  bone.ID = id2;
                  skeleton.bones[i5] = bone;
                  if (subBone !== null) {
                    bone.add(subBone);
                  }
                }
              });
            }
          });
          return bone;
        }
        // create a PerspectiveCamera or OrthographicCamera
        createCamera(relationships) {
          let model;
          let cameraAttribute;
          relationships.children.forEach(function(child) {
            const attr = fbxTree.Objects.NodeAttribute[child.ID];
            if (attr !== void 0) {
              cameraAttribute = attr;
            }
          });
          if (cameraAttribute === void 0) {
            model = new Object3D();
          } else {
            let type = 0;
            if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
              type = 1;
            }
            let nearClippingPlane = 1;
            if (cameraAttribute.NearPlane !== void 0) {
              nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
            }
            let farClippingPlane = 1e3;
            if (cameraAttribute.FarPlane !== void 0) {
              farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
            }
            let width = window.innerWidth;
            let height = window.innerHeight;
            if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
              width = cameraAttribute.AspectWidth.value;
              height = cameraAttribute.AspectHeight.value;
            }
            const aspect2 = width / height;
            let fov2 = 45;
            if (cameraAttribute.FieldOfView !== void 0) {
              fov2 = cameraAttribute.FieldOfView.value;
            }
            const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
            switch (type) {
              case 0:
                model = new PerspectiveCamera(fov2, aspect2, nearClippingPlane, farClippingPlane);
                if (focalLength !== null)
                  model.setFocalLength(focalLength);
                break;
              case 1:
                model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
                model = new Object3D();
                break;
            }
          }
          return model;
        }
        // Create a DirectionalLight, PointLight or SpotLight
        createLight(relationships) {
          let model;
          let lightAttribute;
          relationships.children.forEach(function(child) {
            const attr = fbxTree.Objects.NodeAttribute[child.ID];
            if (attr !== void 0) {
              lightAttribute = attr;
            }
          });
          if (lightAttribute === void 0) {
            model = new Object3D();
          } else {
            let type;
            if (lightAttribute.LightType === void 0) {
              type = 0;
            } else {
              type = lightAttribute.LightType.value;
            }
            let color = 16777215;
            if (lightAttribute.Color !== void 0) {
              color = new Color().fromArray(lightAttribute.Color.value).convertSRGBToLinear();
            }
            let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
            if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
              intensity = 0;
            }
            let distance = 0;
            if (lightAttribute.FarAttenuationEnd !== void 0) {
              if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
                distance = 0;
              } else {
                distance = lightAttribute.FarAttenuationEnd.value;
              }
            }
            const decay = 1;
            switch (type) {
              case 0:
                model = new PointLight(color, intensity, distance, decay);
                break;
              case 1:
                model = new DirectionalLight(color, intensity);
                break;
              case 2:
                let angle2 = Math.PI / 3;
                if (lightAttribute.InnerAngle !== void 0) {
                  angle2 = MathUtils.degToRad(lightAttribute.InnerAngle.value);
                }
                let penumbra = 0;
                if (lightAttribute.OuterAngle !== void 0) {
                  penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
                  penumbra = Math.max(penumbra, 1);
                }
                model = new SpotLight(color, intensity, distance, angle2, penumbra, decay);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
                model = new PointLight(color, intensity);
                break;
            }
            if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
              model.castShadow = true;
            }
          }
          return model;
        }
        createMesh(relationships, geometryMap, materialMap) {
          let model;
          let geometry = null;
          let material = null;
          const materials = [];
          relationships.children.forEach(function(child) {
            if (geometryMap.has(child.ID)) {
              geometry = geometryMap.get(child.ID);
            }
            if (materialMap.has(child.ID)) {
              materials.push(materialMap.get(child.ID));
            }
          });
          if (materials.length > 1) {
            material = materials;
          } else if (materials.length > 0) {
            material = materials[0];
          } else {
            material = new MeshPhongMaterial({
              name: Loader.DEFAULT_MATERIAL_NAME,
              color: 13421772
            });
            materials.push(material);
          }
          if ("color" in geometry.attributes) {
            materials.forEach(function(material2) {
              material2.vertexColors = true;
            });
          }
          if (geometry.FBX_Deformer) {
            model = new SkinnedMesh(geometry, material);
            model.normalizeSkinWeights();
          } else {
            model = new Mesh(geometry, material);
          }
          return model;
        }
        createCurve(relationships, geometryMap) {
          const geometry = relationships.children.reduce(function(geo, child) {
            if (geometryMap.has(child.ID))
              geo = geometryMap.get(child.ID);
            return geo;
          }, null);
          const material = new LineBasicMaterial({
            name: Loader.DEFAULT_MATERIAL_NAME,
            color: 3342591,
            linewidth: 1
          });
          return new Line(geometry, material);
        }
        // parse the model node for transform data
        getTransformData(model, modelNode) {
          const transformData2 = {};
          if ("InheritType" in modelNode)
            transformData2.inheritType = parseInt(modelNode.InheritType.value);
          if ("RotationOrder" in modelNode)
            transformData2.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
          else
            transformData2.eulerOrder = "ZYX";
          if ("Lcl_Translation" in modelNode)
            transformData2.translation = modelNode.Lcl_Translation.value;
          if ("PreRotation" in modelNode)
            transformData2.preRotation = modelNode.PreRotation.value;
          if ("Lcl_Rotation" in modelNode)
            transformData2.rotation = modelNode.Lcl_Rotation.value;
          if ("PostRotation" in modelNode)
            transformData2.postRotation = modelNode.PostRotation.value;
          if ("Lcl_Scaling" in modelNode)
            transformData2.scale = modelNode.Lcl_Scaling.value;
          if ("ScalingOffset" in modelNode)
            transformData2.scalingOffset = modelNode.ScalingOffset.value;
          if ("ScalingPivot" in modelNode)
            transformData2.scalingPivot = modelNode.ScalingPivot.value;
          if ("RotationOffset" in modelNode)
            transformData2.rotationOffset = modelNode.RotationOffset.value;
          if ("RotationPivot" in modelNode)
            transformData2.rotationPivot = modelNode.RotationPivot.value;
          model.userData.transformData = transformData2;
        }
        setLookAtProperties(model, modelNode) {
          if ("LookAtProperty" in modelNode) {
            const children = connections.get(model.ID).children;
            children.forEach(function(child) {
              if (child.relationship === "LookAtProperty") {
                const lookAtTarget = fbxTree.Objects.Model[child.ID];
                if ("Lcl_Translation" in lookAtTarget) {
                  const pos = lookAtTarget.Lcl_Translation.value;
                  if (model.target !== void 0) {
                    model.target.position.fromArray(pos);
                    sceneGraph.add(model.target);
                  } else {
                    model.lookAt(new Vector3().fromArray(pos));
                  }
                }
              }
            });
          }
        }
        bindSkeleton(skeletons, geometryMap, modelMap) {
          const bindMatrices = this.parsePoseNodes();
          for (const ID in skeletons) {
            const skeleton = skeletons[ID];
            const parents = connections.get(parseInt(skeleton.ID)).parents;
            parents.forEach(function(parent) {
              if (geometryMap.has(parent.ID)) {
                const geoID = parent.ID;
                const geoRelationships = connections.get(geoID);
                geoRelationships.parents.forEach(function(geoConnParent) {
                  if (modelMap.has(geoConnParent.ID)) {
                    const model = modelMap.get(geoConnParent.ID);
                    model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
                  }
                });
              }
            });
          }
        }
        parsePoseNodes() {
          const bindMatrices = {};
          if ("Pose" in fbxTree.Objects) {
            const BindPoseNode = fbxTree.Objects.Pose;
            for (const nodeID in BindPoseNode) {
              if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
                const poseNodes = BindPoseNode[nodeID].PoseNode;
                if (Array.isArray(poseNodes)) {
                  poseNodes.forEach(function(poseNode) {
                    bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
                  });
                } else {
                  bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
                }
              }
            }
          }
          return bindMatrices;
        }
        // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
        createAmbientLight() {
          if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
            const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
            const r4 = ambientColor[0];
            const g4 = ambientColor[1];
            const b3 = ambientColor[2];
            if (r4 !== 0 || g4 !== 0 || b3 !== 0) {
              const color = new Color(r4, g4, b3).convertSRGBToLinear();
              sceneGraph.add(new AmbientLight(color, 1));
            }
          }
        }
      };
      GeometryParser = class {
        constructor() {
          this.negativeMaterialIndices = false;
        }
        // Parse nodes in FBXTree.Objects.Geometry
        parse(deformers) {
          const geometryMap = /* @__PURE__ */ new Map();
          if ("Geometry" in fbxTree.Objects) {
            const geoNodes = fbxTree.Objects.Geometry;
            for (const nodeID in geoNodes) {
              const relationships = connections.get(parseInt(nodeID));
              const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
              geometryMap.set(parseInt(nodeID), geo);
            }
          }
          if (this.negativeMaterialIndices === true) {
            console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
          }
          return geometryMap;
        }
        // Parse single node in FBXTree.Objects.Geometry
        parseGeometry(relationships, geoNode, deformers) {
          switch (geoNode.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(relationships, geoNode, deformers);
              break;
            case "NurbsCurve":
              return this.parseNurbsGeometry(geoNode);
              break;
          }
        }
        // Parse single node mesh geometry in FBXTree.Objects.Geometry
        parseMeshGeometry(relationships, geoNode, deformers) {
          const skeletons = deformers.skeletons;
          const morphTargets = [];
          const modelNodes = relationships.parents.map(function(parent) {
            return fbxTree.Objects.Model[parent.ID];
          });
          if (modelNodes.length === 0)
            return;
          const skeleton = relationships.children.reduce(function(skeleton2, child) {
            if (skeletons[child.ID] !== void 0)
              skeleton2 = skeletons[child.ID];
            return skeleton2;
          }, null);
          relationships.children.forEach(function(child) {
            if (deformers.morphTargets[child.ID] !== void 0) {
              morphTargets.push(deformers.morphTargets[child.ID]);
            }
          });
          const modelNode = modelNodes[0];
          const transformData2 = {};
          if ("RotationOrder" in modelNode)
            transformData2.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
          if ("InheritType" in modelNode)
            transformData2.inheritType = parseInt(modelNode.InheritType.value);
          if ("GeometricTranslation" in modelNode)
            transformData2.translation = modelNode.GeometricTranslation.value;
          if ("GeometricRotation" in modelNode)
            transformData2.rotation = modelNode.GeometricRotation.value;
          if ("GeometricScaling" in modelNode)
            transformData2.scale = modelNode.GeometricScaling.value;
          const transform = generateTransform(transformData2);
          return this.genGeometry(geoNode, skeleton, morphTargets, transform);
        }
        // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
        genGeometry(geoNode, skeleton, morphTargets, preTransform) {
          const geo = new BufferGeometry();
          if (geoNode.attrName)
            geo.name = geoNode.attrName;
          const geoInfo = this.parseGeoNode(geoNode, skeleton);
          const buffers = this.genBuffers(geoInfo);
          const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
          positionAttribute.applyMatrix4(preTransform);
          geo.setAttribute("position", positionAttribute);
          if (buffers.colors.length > 0) {
            geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
          }
          if (skeleton) {
            geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
            geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
            geo.FBX_Deformer = skeleton;
          }
          if (buffers.normal.length > 0) {
            const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
            const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
            normalAttribute.applyNormalMatrix(normalMatrix);
            geo.setAttribute("normal", normalAttribute);
          }
          buffers.uvs.forEach(function(uvBuffer, i5) {
            const name2 = i5 === 0 ? "uv" : `uv${i5}`;
            geo.setAttribute(name2, new Float32BufferAttribute(buffers.uvs[i5], 2));
          });
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            let prevMaterialIndex = buffers.materialIndex[0];
            let startIndex = 0;
            buffers.materialIndex.forEach(function(currentIndex, i5) {
              if (currentIndex !== prevMaterialIndex) {
                geo.addGroup(startIndex, i5 - startIndex, prevMaterialIndex);
                prevMaterialIndex = currentIndex;
                startIndex = i5;
              }
            });
            if (geo.groups.length > 0) {
              const lastGroup = geo.groups[geo.groups.length - 1];
              const lastIndex = lastGroup.start + lastGroup.count;
              if (lastIndex !== buffers.materialIndex.length) {
                geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
              }
            }
            if (geo.groups.length === 0) {
              geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
            }
          }
          this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
          return geo;
        }
        parseGeoNode(geoNode, skeleton) {
          const geoInfo = {};
          geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
          geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
          if (geoNode.LayerElementColor) {
            geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
          }
          if (geoNode.LayerElementMaterial) {
            geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
          }
          if (geoNode.LayerElementNormal) {
            geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
          }
          if (geoNode.LayerElementUV) {
            geoInfo.uv = [];
            let i5 = 0;
            while (geoNode.LayerElementUV[i5]) {
              if (geoNode.LayerElementUV[i5].UV) {
                geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i5]));
              }
              i5++;
            }
          }
          geoInfo.weightTable = {};
          if (skeleton !== null) {
            geoInfo.skeleton = skeleton;
            skeleton.rawBones.forEach(function(rawBone, i5) {
              rawBone.indices.forEach(function(index, j4) {
                if (geoInfo.weightTable[index] === void 0)
                  geoInfo.weightTable[index] = [];
                geoInfo.weightTable[index].push({
                  id: i5,
                  weight: rawBone.weights[j4]
                });
              });
            });
          }
          return geoInfo;
        }
        genBuffers(geoInfo) {
          const buffers = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
          };
          let polygonIndex = 0;
          let faceLength = 0;
          let displayedWeightsWarning = false;
          let facePositionIndexes = [];
          let faceNormals = [];
          let faceColors = [];
          let faceUVs = [];
          let faceWeights = [];
          let faceWeightIndices = [];
          const scope = this;
          geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
            let materialIndex;
            let endOfFace = false;
            if (vertexIndex < 0) {
              vertexIndex = vertexIndex ^ -1;
              endOfFace = true;
            }
            let weightIndices = [];
            let weights = [];
            facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
            if (geoInfo.color) {
              const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
              faceColors.push(data[0], data[1], data[2]);
            }
            if (geoInfo.skeleton) {
              if (geoInfo.weightTable[vertexIndex] !== void 0) {
                geoInfo.weightTable[vertexIndex].forEach(function(wt5) {
                  weights.push(wt5.weight);
                  weightIndices.push(wt5.id);
                });
              }
              if (weights.length > 4) {
                if (!displayedWeightsWarning) {
                  console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
                  displayedWeightsWarning = true;
                }
                const wIndex = [0, 0, 0, 0];
                const Weight = [0, 0, 0, 0];
                weights.forEach(function(weight, weightIndex) {
                  let currentWeight = weight;
                  let currentIndex = weightIndices[weightIndex];
                  Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
                    if (currentWeight > comparedWeight) {
                      comparedWeightArray[comparedWeightIndex] = currentWeight;
                      currentWeight = comparedWeight;
                      const tmp = wIndex[comparedWeightIndex];
                      wIndex[comparedWeightIndex] = currentIndex;
                      currentIndex = tmp;
                    }
                  });
                });
                weightIndices = wIndex;
                weights = Weight;
              }
              while (weights.length < 4) {
                weights.push(0);
                weightIndices.push(0);
              }
              for (let i5 = 0; i5 < 4; ++i5) {
                faceWeights.push(weights[i5]);
                faceWeightIndices.push(weightIndices[i5]);
              }
            }
            if (geoInfo.normal) {
              const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
              faceNormals.push(data[0], data[1], data[2]);
            }
            if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
              materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
              if (materialIndex < 0) {
                scope.negativeMaterialIndices = true;
                materialIndex = 0;
              }
            }
            if (geoInfo.uv) {
              geoInfo.uv.forEach(function(uv, i5) {
                const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
                if (faceUVs[i5] === void 0) {
                  faceUVs[i5] = [];
                }
                faceUVs[i5].push(data[0]);
                faceUVs[i5].push(data[1]);
              });
            }
            faceLength++;
            if (endOfFace) {
              if (faceLength > 4)
                console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.");
              scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
              polygonIndex++;
              faceLength = 0;
              facePositionIndexes = [];
              faceNormals = [];
              faceColors = [];
              faceUVs = [];
              faceWeights = [];
              faceWeightIndices = [];
            }
          });
          return buffers;
        }
        // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
        genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
          for (let i5 = 2; i5 < faceLength; i5++) {
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i5 - 1) * 3]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i5 - 1) * 3 + 1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i5 - 1) * 3 + 2]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i5 * 3]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i5 * 3 + 1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i5 * 3 + 2]]);
            if (geoInfo.skeleton) {
              buffers.vertexWeights.push(faceWeights[0]);
              buffers.vertexWeights.push(faceWeights[1]);
              buffers.vertexWeights.push(faceWeights[2]);
              buffers.vertexWeights.push(faceWeights[3]);
              buffers.vertexWeights.push(faceWeights[(i5 - 1) * 4]);
              buffers.vertexWeights.push(faceWeights[(i5 - 1) * 4 + 1]);
              buffers.vertexWeights.push(faceWeights[(i5 - 1) * 4 + 2]);
              buffers.vertexWeights.push(faceWeights[(i5 - 1) * 4 + 3]);
              buffers.vertexWeights.push(faceWeights[i5 * 4]);
              buffers.vertexWeights.push(faceWeights[i5 * 4 + 1]);
              buffers.vertexWeights.push(faceWeights[i5 * 4 + 2]);
              buffers.vertexWeights.push(faceWeights[i5 * 4 + 3]);
              buffers.weightsIndices.push(faceWeightIndices[0]);
              buffers.weightsIndices.push(faceWeightIndices[1]);
              buffers.weightsIndices.push(faceWeightIndices[2]);
              buffers.weightsIndices.push(faceWeightIndices[3]);
              buffers.weightsIndices.push(faceWeightIndices[(i5 - 1) * 4]);
              buffers.weightsIndices.push(faceWeightIndices[(i5 - 1) * 4 + 1]);
              buffers.weightsIndices.push(faceWeightIndices[(i5 - 1) * 4 + 2]);
              buffers.weightsIndices.push(faceWeightIndices[(i5 - 1) * 4 + 3]);
              buffers.weightsIndices.push(faceWeightIndices[i5 * 4]);
              buffers.weightsIndices.push(faceWeightIndices[i5 * 4 + 1]);
              buffers.weightsIndices.push(faceWeightIndices[i5 * 4 + 2]);
              buffers.weightsIndices.push(faceWeightIndices[i5 * 4 + 3]);
            }
            if (geoInfo.color) {
              buffers.colors.push(faceColors[0]);
              buffers.colors.push(faceColors[1]);
              buffers.colors.push(faceColors[2]);
              buffers.colors.push(faceColors[(i5 - 1) * 3]);
              buffers.colors.push(faceColors[(i5 - 1) * 3 + 1]);
              buffers.colors.push(faceColors[(i5 - 1) * 3 + 2]);
              buffers.colors.push(faceColors[i5 * 3]);
              buffers.colors.push(faceColors[i5 * 3 + 1]);
              buffers.colors.push(faceColors[i5 * 3 + 2]);
            }
            if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
              buffers.materialIndex.push(materialIndex);
              buffers.materialIndex.push(materialIndex);
              buffers.materialIndex.push(materialIndex);
            }
            if (geoInfo.normal) {
              buffers.normal.push(faceNormals[0]);
              buffers.normal.push(faceNormals[1]);
              buffers.normal.push(faceNormals[2]);
              buffers.normal.push(faceNormals[(i5 - 1) * 3]);
              buffers.normal.push(faceNormals[(i5 - 1) * 3 + 1]);
              buffers.normal.push(faceNormals[(i5 - 1) * 3 + 2]);
              buffers.normal.push(faceNormals[i5 * 3]);
              buffers.normal.push(faceNormals[i5 * 3 + 1]);
              buffers.normal.push(faceNormals[i5 * 3 + 2]);
            }
            if (geoInfo.uv) {
              geoInfo.uv.forEach(function(uv, j4) {
                if (buffers.uvs[j4] === void 0)
                  buffers.uvs[j4] = [];
                buffers.uvs[j4].push(faceUVs[j4][0]);
                buffers.uvs[j4].push(faceUVs[j4][1]);
                buffers.uvs[j4].push(faceUVs[j4][(i5 - 1) * 2]);
                buffers.uvs[j4].push(faceUVs[j4][(i5 - 1) * 2 + 1]);
                buffers.uvs[j4].push(faceUVs[j4][i5 * 2]);
                buffers.uvs[j4].push(faceUVs[j4][i5 * 2 + 1]);
              });
            }
          }
        }
        addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
          if (morphTargets.length === 0)
            return;
          parentGeo.morphTargetsRelative = true;
          parentGeo.morphAttributes.position = [];
          const scope = this;
          morphTargets.forEach(function(morphTarget) {
            morphTarget.rawTargets.forEach(function(rawTarget) {
              const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
              if (morphGeoNode !== void 0) {
                scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
              }
            });
          });
        }
        // a morph geometry node is similar to a standard  node, and the node is also contained
        // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
        // and a special attribute Index defining which vertices of the original geometry are affected
        // Normal and position attributes only have data for the vertices that are affected by the morph
        genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name2) {
          const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
          const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
          const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
          const length3 = parentGeo.attributes.position.count * 3;
          const morphPositions = new Float32Array(length3);
          for (let i5 = 0; i5 < indices.length; i5++) {
            const morphIndex = indices[i5] * 3;
            morphPositions[morphIndex] = morphPositionsSparse[i5 * 3];
            morphPositions[morphIndex + 1] = morphPositionsSparse[i5 * 3 + 1];
            morphPositions[morphIndex + 2] = morphPositionsSparse[i5 * 3 + 2];
          }
          const morphGeoInfo = {
            vertexIndices,
            vertexPositions: morphPositions
          };
          const morphBuffers = this.genBuffers(morphGeoInfo);
          const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
          positionAttribute.name = name2 || morphGeoNode.attrName;
          positionAttribute.applyMatrix4(preTransform);
          parentGeo.morphAttributes.position.push(positionAttribute);
        }
        // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
        parseNormals(NormalNode) {
          const mappingType = NormalNode.MappingInformationType;
          const referenceType = NormalNode.ReferenceInformationType;
          const buffer = NormalNode.Normals.a;
          let indexBuffer = [];
          if (referenceType === "IndexToDirect") {
            if ("NormalIndex" in NormalNode) {
              indexBuffer = NormalNode.NormalIndex.a;
            } else if ("NormalsIndex" in NormalNode) {
              indexBuffer = NormalNode.NormalsIndex.a;
            }
          }
          return {
            dataSize: 3,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
          };
        }
        // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
        parseUVs(UVNode) {
          const mappingType = UVNode.MappingInformationType;
          const referenceType = UVNode.ReferenceInformationType;
          const buffer = UVNode.UV.a;
          let indexBuffer = [];
          if (referenceType === "IndexToDirect") {
            indexBuffer = UVNode.UVIndex.a;
          }
          return {
            dataSize: 2,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
          };
        }
        // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
        parseVertexColors(ColorNode) {
          const mappingType = ColorNode.MappingInformationType;
          const referenceType = ColorNode.ReferenceInformationType;
          const buffer = ColorNode.Colors.a;
          let indexBuffer = [];
          if (referenceType === "IndexToDirect") {
            indexBuffer = ColorNode.ColorIndex.a;
          }
          for (let i5 = 0, c5 = new Color(); i5 < buffer.length; i5 += 4) {
            c5.fromArray(buffer, i5).convertSRGBToLinear().toArray(buffer, i5);
          }
          return {
            dataSize: 4,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
          };
        }
        // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
        parseMaterialIndices(MaterialNode) {
          const mappingType = MaterialNode.MappingInformationType;
          const referenceType = MaterialNode.ReferenceInformationType;
          if (mappingType === "NoMappingInformation") {
            return {
              dataSize: 1,
              buffer: [0],
              indices: [0],
              mappingType: "AllSame",
              referenceType
            };
          }
          const materialIndexBuffer = MaterialNode.Materials.a;
          const materialIndices = [];
          for (let i5 = 0; i5 < materialIndexBuffer.length; ++i5) {
            materialIndices.push(i5);
          }
          return {
            dataSize: 1,
            buffer: materialIndexBuffer,
            indices: materialIndices,
            mappingType,
            referenceType
          };
        }
        // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
        parseNurbsGeometry(geoNode) {
          const order = parseInt(geoNode.Order);
          if (isNaN(order)) {
            console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
            return new BufferGeometry();
          }
          const degree3 = order - 1;
          const knots = geoNode.KnotVector.a;
          const controlPoints = [];
          const pointsValues = geoNode.Points.a;
          for (let i5 = 0, l4 = pointsValues.length; i5 < l4; i5 += 4) {
            controlPoints.push(new Vector4().fromArray(pointsValues, i5));
          }
          let startKnot, endKnot;
          if (geoNode.Form === "Closed") {
            controlPoints.push(controlPoints[0]);
          } else if (geoNode.Form === "Periodic") {
            startKnot = degree3;
            endKnot = knots.length - 1 - startKnot;
            for (let i5 = 0; i5 < degree3; ++i5) {
              controlPoints.push(controlPoints[i5]);
            }
          }
          const curve = new NURBSCurve(degree3, knots, controlPoints, startKnot, endKnot);
          const points = curve.getPoints(controlPoints.length * 12);
          return new BufferGeometry().setFromPoints(points);
        }
      };
      AnimationParser = class {
        // take raw animation clips and turn them into three.js animation clips
        parse() {
          const animationClips = [];
          const rawClips = this.parseClips();
          if (rawClips !== void 0) {
            for (const key in rawClips) {
              const rawClip = rawClips[key];
              const clip = this.addClip(rawClip);
              animationClips.push(clip);
            }
          }
          return animationClips;
        }
        parseClips() {
          if (fbxTree.Objects.AnimationCurve === void 0)
            return void 0;
          const curveNodesMap = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(curveNodesMap);
          const layersMap = this.parseAnimationLayers(curveNodesMap);
          const rawClips = this.parseAnimStacks(layersMap);
          return rawClips;
        }
        // parse nodes in FBXTree.Objects.AnimationCurveNode
        // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
        // and is referenced by an AnimationLayer
        parseAnimationCurveNodes() {
          const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
          const curveNodesMap = /* @__PURE__ */ new Map();
          for (const nodeID in rawCurveNodes) {
            const rawCurveNode = rawCurveNodes[nodeID];
            if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
              const curveNode = {
                id: rawCurveNode.id,
                attr: rawCurveNode.attrName,
                curves: {}
              };
              curveNodesMap.set(curveNode.id, curveNode);
            }
          }
          return curveNodesMap;
        }
        // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
        // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
        // axis ( e.g. times and values of x rotation)
        parseAnimationCurves(curveNodesMap) {
          const rawCurves = fbxTree.Objects.AnimationCurve;
          for (const nodeID in rawCurves) {
            const animationCurve = {
              id: rawCurves[nodeID].id,
              times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
              values: rawCurves[nodeID].KeyValueFloat.a
            };
            const relationships = connections.get(animationCurve.id);
            if (relationships !== void 0) {
              const animationCurveID = relationships.parents[0].ID;
              const animationCurveRelationship = relationships.parents[0].relationship;
              if (animationCurveRelationship.match(/X/)) {
                curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
              } else if (animationCurveRelationship.match(/Y/)) {
                curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
              } else if (animationCurveRelationship.match(/Z/)) {
                curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
              } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
                curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
              }
            }
          }
        }
        // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
        // to various AnimationCurveNodes and is referenced by an AnimationStack node
        // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
        parseAnimationLayers(curveNodesMap) {
          const rawLayers = fbxTree.Objects.AnimationLayer;
          const layersMap = /* @__PURE__ */ new Map();
          for (const nodeID in rawLayers) {
            const layerCurveNodes = [];
            const connection = connections.get(parseInt(nodeID));
            if (connection !== void 0) {
              const children = connection.children;
              children.forEach(function(child, i5) {
                if (curveNodesMap.has(child.ID)) {
                  const curveNode = curveNodesMap.get(child.ID);
                  if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
                    if (layerCurveNodes[i5] === void 0) {
                      const modelID = connections.get(child.ID).parents.filter(function(parent) {
                        return parent.relationship !== void 0;
                      })[0].ID;
                      if (modelID !== void 0) {
                        const rawModel = fbxTree.Objects.Model[modelID.toString()];
                        if (rawModel === void 0) {
                          console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                          return;
                        }
                        const node = {
                          modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                          ID: rawModel.id,
                          initialPosition: [0, 0, 0],
                          initialRotation: [0, 0, 0],
                          initialScale: [1, 1, 1]
                        };
                        sceneGraph.traverse(function(child2) {
                          if (child2.ID === rawModel.id) {
                            node.transform = child2.matrix;
                            if (child2.userData.transformData)
                              node.eulerOrder = child2.userData.transformData.eulerOrder;
                          }
                        });
                        if (!node.transform)
                          node.transform = new Matrix4();
                        if ("PreRotation" in rawModel)
                          node.preRotation = rawModel.PreRotation.value;
                        if ("PostRotation" in rawModel)
                          node.postRotation = rawModel.PostRotation.value;
                        layerCurveNodes[i5] = node;
                      }
                    }
                    if (layerCurveNodes[i5])
                      layerCurveNodes[i5][curveNode.attr] = curveNode;
                  } else if (curveNode.curves.morph !== void 0) {
                    if (layerCurveNodes[i5] === void 0) {
                      const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                        return parent.relationship !== void 0;
                      })[0].ID;
                      const morpherID = connections.get(deformerID).parents[0].ID;
                      const geoID = connections.get(morpherID).parents[0].ID;
                      const modelID = connections.get(geoID).parents[0].ID;
                      const rawModel = fbxTree.Objects.Model[modelID];
                      const node = {
                        modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                        morphName: fbxTree.Objects.Deformer[deformerID].attrName
                      };
                      layerCurveNodes[i5] = node;
                    }
                    layerCurveNodes[i5][curveNode.attr] = curveNode;
                  }
                }
              });
              layersMap.set(parseInt(nodeID), layerCurveNodes);
            }
          }
          return layersMap;
        }
        // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
        // hierarchy. Each Stack node will be used to create a AnimationClip
        parseAnimStacks(layersMap) {
          const rawStacks = fbxTree.Objects.AnimationStack;
          const rawClips = {};
          for (const nodeID in rawStacks) {
            const children = connections.get(parseInt(nodeID)).children;
            if (children.length > 1) {
              console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            }
            const layer = layersMap.get(children[0].ID);
            rawClips[nodeID] = {
              name: rawStacks[nodeID].attrName,
              layer
            };
          }
          return rawClips;
        }
        addClip(rawClip) {
          let tracks = [];
          const scope = this;
          rawClip.layer.forEach(function(rawTracks) {
            tracks = tracks.concat(scope.generateTracks(rawTracks));
          });
          return new AnimationClip(rawClip.name, -1, tracks);
        }
        generateTracks(rawTracks) {
          const tracks = [];
          let initialPosition = new Vector3();
          let initialRotation = new Quaternion();
          let initialScale = new Vector3();
          if (rawTracks.transform)
            rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
          initialPosition = initialPosition.toArray();
          initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
          initialScale = initialScale.toArray();
          if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
            const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
            if (positionTrack !== void 0)
              tracks.push(positionTrack);
          }
          if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
            const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
            if (rotationTrack !== void 0)
              tracks.push(rotationTrack);
          }
          if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
            const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
            if (scaleTrack !== void 0)
              tracks.push(scaleTrack);
          }
          if (rawTracks.DeformPercent !== void 0) {
            const morphTrack = this.generateMorphTrack(rawTracks);
            if (morphTrack !== void 0)
              tracks.push(morphTrack);
          }
          return tracks;
        }
        generateVectorTrack(modelName, curves, initialValue, type) {
          const times = this.getTimesForAllAxes(curves);
          const values = this.getKeyframeTrackValues(times, curves, initialValue);
          return new VectorKeyframeTrack(modelName + "." + type, times, values);
        }
        generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
          if (curves.x !== void 0) {
            this.interpolateRotations(curves.x);
            curves.x.values = curves.x.values.map(MathUtils.degToRad);
          }
          if (curves.y !== void 0) {
            this.interpolateRotations(curves.y);
            curves.y.values = curves.y.values.map(MathUtils.degToRad);
          }
          if (curves.z !== void 0) {
            this.interpolateRotations(curves.z);
            curves.z.values = curves.z.values.map(MathUtils.degToRad);
          }
          const times = this.getTimesForAllAxes(curves);
          const values = this.getKeyframeTrackValues(times, curves, initialValue);
          if (preRotation !== void 0) {
            preRotation = preRotation.map(MathUtils.degToRad);
            preRotation.push(eulerOrder);
            preRotation = new Euler().fromArray(preRotation);
            preRotation = new Quaternion().setFromEuler(preRotation);
          }
          if (postRotation !== void 0) {
            postRotation = postRotation.map(MathUtils.degToRad);
            postRotation.push(eulerOrder);
            postRotation = new Euler().fromArray(postRotation);
            postRotation = new Quaternion().setFromEuler(postRotation).invert();
          }
          const quaternion = new Quaternion();
          const euler = new Euler();
          const quaternionValues = [];
          for (let i5 = 0; i5 < values.length; i5 += 3) {
            euler.set(values[i5], values[i5 + 1], values[i5 + 2], eulerOrder);
            quaternion.setFromEuler(euler);
            if (preRotation !== void 0)
              quaternion.premultiply(preRotation);
            if (postRotation !== void 0)
              quaternion.multiply(postRotation);
            quaternion.toArray(quaternionValues, i5 / 3 * 4);
          }
          return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
        }
        generateMorphTrack(rawTracks) {
          const curves = rawTracks.DeformPercent.curves.morph;
          const values = curves.values.map(function(val) {
            return val / 100;
          });
          const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
          return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
        }
        // For all animated objects, times are defined separately for each axis
        // Here we'll combine the times into one sorted array without duplicates
        getTimesForAllAxes(curves) {
          let times = [];
          if (curves.x !== void 0)
            times = times.concat(curves.x.times);
          if (curves.y !== void 0)
            times = times.concat(curves.y.times);
          if (curves.z !== void 0)
            times = times.concat(curves.z.times);
          times = times.sort(function(a4, b3) {
            return a4 - b3;
          });
          if (times.length > 1) {
            let targetIndex = 1;
            let lastValue = times[0];
            for (let i5 = 1; i5 < times.length; i5++) {
              const currentValue = times[i5];
              if (currentValue !== lastValue) {
                times[targetIndex] = currentValue;
                lastValue = currentValue;
                targetIndex++;
              }
            }
            times = times.slice(0, targetIndex);
          }
          return times;
        }
        getKeyframeTrackValues(times, curves, initialValue) {
          const prevValue = initialValue;
          const values = [];
          let xIndex = -1;
          let yIndex = -1;
          let zIndex = -1;
          times.forEach(function(time) {
            if (curves.x)
              xIndex = curves.x.times.indexOf(time);
            if (curves.y)
              yIndex = curves.y.times.indexOf(time);
            if (curves.z)
              zIndex = curves.z.times.indexOf(time);
            if (xIndex !== -1) {
              const xValue = curves.x.values[xIndex];
              values.push(xValue);
              prevValue[0] = xValue;
            } else {
              values.push(prevValue[0]);
            }
            if (yIndex !== -1) {
              const yValue = curves.y.values[yIndex];
              values.push(yValue);
              prevValue[1] = yValue;
            } else {
              values.push(prevValue[1]);
            }
            if (zIndex !== -1) {
              const zValue = curves.z.values[zIndex];
              values.push(zValue);
              prevValue[2] = zValue;
            } else {
              values.push(prevValue[2]);
            }
          });
          return values;
        }
        // Rotations are defined as Euler angles which can have values  of any size
        // These will be converted to quaternions which don't support values greater than
        // PI, so we'll interpolate large rotations
        interpolateRotations(curve) {
          for (let i5 = 1; i5 < curve.values.length; i5++) {
            const initialValue = curve.values[i5 - 1];
            const valuesSpan = curve.values[i5] - initialValue;
            const absoluteSpan = Math.abs(valuesSpan);
            if (absoluteSpan >= 180) {
              const numSubIntervals = absoluteSpan / 180;
              const step = valuesSpan / numSubIntervals;
              let nextValue = initialValue + step;
              const initialTime = curve.times[i5 - 1];
              const timeSpan = curve.times[i5] - initialTime;
              const interval = timeSpan / numSubIntervals;
              let nextTime = initialTime + interval;
              const interpolatedTimes = [];
              const interpolatedValues = [];
              while (nextTime < curve.times[i5]) {
                interpolatedTimes.push(nextTime);
                nextTime += interval;
                interpolatedValues.push(nextValue);
                nextValue += step;
              }
              curve.times = inject(curve.times, i5, interpolatedTimes);
              curve.values = inject(curve.values, i5, interpolatedValues);
            }
          }
        }
      };
      TextParser = class {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(node) {
          this.nodeStack.push(node);
          this.currentIndent += 1;
        }
        popStack() {
          this.nodeStack.pop();
          this.currentIndent -= 1;
        }
        setCurrentProp(val, name2) {
          this.currentProp = val;
          this.currentPropName = name2;
        }
        parse(text) {
          this.currentIndent = 0;
          this.allNodes = new FBXTree();
          this.nodeStack = [];
          this.currentProp = [];
          this.currentPropName = "";
          const scope = this;
          const split = text.split(/[\r\n]+/);
          split.forEach(function(line, i5) {
            const matchComment = line.match(/^[\s\t]*;/);
            const matchEmpty = line.match(/^[\s\t]*$/);
            if (matchComment || matchEmpty)
              return;
            const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
            const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
            const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
            if (matchBeginning) {
              scope.parseNodeBegin(line, matchBeginning);
            } else if (matchProperty) {
              scope.parseNodeProperty(line, matchProperty, split[++i5]);
            } else if (matchEnd) {
              scope.popStack();
            } else if (line.match(/^[^\s\t}]/)) {
              scope.parseNodePropertyContinued(line);
            }
          });
          return this.allNodes;
        }
        parseNodeBegin(line, property) {
          const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
          const nodeAttrs = property[2].split(",").map(function(attr) {
            return attr.trim().replace(/^"/, "").replace(/"$/, "");
          });
          const node = { name: nodeName };
          const attrs = this.parseNodeAttr(nodeAttrs);
          const currentNode = this.getCurrentNode();
          if (this.currentIndent === 0) {
            this.allNodes.add(nodeName, node);
          } else {
            if (nodeName in currentNode) {
              if (nodeName === "PoseNode") {
                currentNode.PoseNode.push(node);
              } else if (currentNode[nodeName].id !== void 0) {
                currentNode[nodeName] = {};
                currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
              }
              if (attrs.id !== "")
                currentNode[nodeName][attrs.id] = node;
            } else if (typeof attrs.id === "number") {
              currentNode[nodeName] = {};
              currentNode[nodeName][attrs.id] = node;
            } else if (nodeName !== "Properties70") {
              if (nodeName === "PoseNode")
                currentNode[nodeName] = [node];
              else
                currentNode[nodeName] = node;
            }
          }
          if (typeof attrs.id === "number")
            node.id = attrs.id;
          if (attrs.name !== "")
            node.attrName = attrs.name;
          if (attrs.type !== "")
            node.attrType = attrs.type;
          this.pushStack(node);
        }
        parseNodeAttr(attrs) {
          let id2 = attrs[0];
          if (attrs[0] !== "") {
            id2 = parseInt(attrs[0]);
            if (isNaN(id2)) {
              id2 = attrs[0];
            }
          }
          let name2 = "", type = "";
          if (attrs.length > 1) {
            name2 = attrs[1].replace(/^(\w+)::/, "");
            type = attrs[2];
          }
          return { id: id2, name: name2, type };
        }
        parseNodeProperty(line, property, contentLine) {
          let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
          let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
          if (propName === "Content" && propValue === ",") {
            propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
          }
          const currentNode = this.getCurrentNode();
          const parentName = currentNode.name;
          if (parentName === "Properties70") {
            this.parseNodeSpecialProperty(line, propName, propValue);
            return;
          }
          if (propName === "C") {
            const connProps = propValue.split(",").slice(1);
            const from = parseInt(connProps[0]);
            const to4 = parseInt(connProps[1]);
            let rest = propValue.split(",").slice(3);
            rest = rest.map(function(elem) {
              return elem.trim().replace(/^"/, "");
            });
            propName = "connections";
            propValue = [from, to4];
            append2(propValue, rest);
            if (currentNode[propName] === void 0) {
              currentNode[propName] = [];
            }
          }
          if (propName === "Node")
            currentNode.id = propValue;
          if (propName in currentNode && Array.isArray(currentNode[propName])) {
            currentNode[propName].push(propValue);
          } else {
            if (propName !== "a")
              currentNode[propName] = propValue;
            else
              currentNode.a = propValue;
          }
          this.setCurrentProp(currentNode, propName);
          if (propName === "a" && propValue.slice(-1) !== ",") {
            currentNode.a = parseNumberArray(propValue);
          }
        }
        parseNodePropertyContinued(line) {
          const currentNode = this.getCurrentNode();
          currentNode.a += line;
          if (line.slice(-1) !== ",") {
            currentNode.a = parseNumberArray(currentNode.a);
          }
        }
        // parse "Property70"
        parseNodeSpecialProperty(line, propName, propValue) {
          const props = propValue.split('",').map(function(prop) {
            return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
          });
          const innerPropName = props[0];
          const innerPropType1 = props[1];
          const innerPropType2 = props[2];
          const innerPropFlag = props[3];
          let innerPropValue = props[4];
          switch (innerPropType1) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              innerPropValue = parseFloat(innerPropValue);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              innerPropValue = parseNumberArray(innerPropValue);
              break;
          }
          this.getPrevNode()[innerPropName] = {
            "type": innerPropType1,
            "type2": innerPropType2,
            "flag": innerPropFlag,
            "value": innerPropValue
          };
          this.setCurrentProp(this.getPrevNode(), innerPropName);
        }
      };
      BinaryParser = class {
        parse(buffer) {
          const reader = new BinaryReader(buffer);
          reader.skip(23);
          const version = reader.getUint32();
          if (version < 6400) {
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
          }
          const allNodes = new FBXTree();
          while (!this.endOfContent(reader)) {
            const node = this.parseNode(reader, version);
            if (node !== null)
              allNodes.add(node.name, node);
          }
          return allNodes;
        }
        // Check if reader has reached the end of content.
        endOfContent(reader) {
          if (reader.size() % 16 === 0) {
            return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
          } else {
            return reader.getOffset() + 160 + 16 >= reader.size();
          }
        }
        // recursively parse nodes until the end of the file is reached
        parseNode(reader, version) {
          const node = {};
          const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
          const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
          version >= 7500 ? reader.getUint64() : reader.getUint32();
          const nameLen = reader.getUint8();
          const name2 = reader.getString(nameLen);
          if (endOffset === 0)
            return null;
          const propertyList = [];
          for (let i5 = 0; i5 < numProperties; i5++) {
            propertyList.push(this.parseProperty(reader));
          }
          const id2 = propertyList.length > 0 ? propertyList[0] : "";
          const attrName = propertyList.length > 1 ? propertyList[1] : "";
          const attrType = propertyList.length > 2 ? propertyList[2] : "";
          node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
          while (endOffset > reader.getOffset()) {
            const subNode = this.parseNode(reader, version);
            if (subNode !== null)
              this.parseSubNode(name2, node, subNode);
          }
          node.propertyList = propertyList;
          if (typeof id2 === "number")
            node.id = id2;
          if (attrName !== "")
            node.attrName = attrName;
          if (attrType !== "")
            node.attrType = attrType;
          if (name2 !== "")
            node.name = name2;
          return node;
        }
        parseSubNode(name2, node, subNode) {
          if (subNode.singleProperty === true) {
            const value = subNode.propertyList[0];
            if (Array.isArray(value)) {
              node[subNode.name] = subNode;
              subNode.a = value;
            } else {
              node[subNode.name] = value;
            }
          } else if (name2 === "Connections" && subNode.name === "C") {
            const array = [];
            subNode.propertyList.forEach(function(property, i5) {
              if (i5 !== 0)
                array.push(property);
            });
            if (node.connections === void 0) {
              node.connections = [];
            }
            node.connections.push(array);
          } else if (subNode.name === "Properties70") {
            const keys = Object.keys(subNode);
            keys.forEach(function(key) {
              node[key] = subNode[key];
            });
          } else if (name2 === "Properties70" && subNode.name === "P") {
            let innerPropName = subNode.propertyList[0];
            let innerPropType1 = subNode.propertyList[1];
            const innerPropType2 = subNode.propertyList[2];
            const innerPropFlag = subNode.propertyList[3];
            let innerPropValue;
            if (innerPropName.indexOf("Lcl ") === 0)
              innerPropName = innerPropName.replace("Lcl ", "Lcl_");
            if (innerPropType1.indexOf("Lcl ") === 0)
              innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
            if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
              innerPropValue = [
                subNode.propertyList[4],
                subNode.propertyList[5],
                subNode.propertyList[6]
              ];
            } else {
              innerPropValue = subNode.propertyList[4];
            }
            node[innerPropName] = {
              "type": innerPropType1,
              "type2": innerPropType2,
              "flag": innerPropFlag,
              "value": innerPropValue
            };
          } else if (node[subNode.name] === void 0) {
            if (typeof subNode.id === "number") {
              node[subNode.name] = {};
              node[subNode.name][subNode.id] = subNode;
            } else {
              node[subNode.name] = subNode;
            }
          } else {
            if (subNode.name === "PoseNode") {
              if (!Array.isArray(node[subNode.name])) {
                node[subNode.name] = [node[subNode.name]];
              }
              node[subNode.name].push(subNode);
            } else if (node[subNode.name][subNode.id] === void 0) {
              node[subNode.name][subNode.id] = subNode;
            }
          }
        }
        parseProperty(reader) {
          const type = reader.getString(1);
          let length3;
          switch (type) {
            case "C":
              return reader.getBoolean();
            case "D":
              return reader.getFloat64();
            case "F":
              return reader.getFloat32();
            case "I":
              return reader.getInt32();
            case "L":
              return reader.getInt64();
            case "R":
              length3 = reader.getUint32();
              return reader.getArrayBuffer(length3);
            case "S":
              length3 = reader.getUint32();
              return reader.getString(length3);
            case "Y":
              return reader.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const arrayLength = reader.getUint32();
              const encoding = reader.getUint32();
              const compressedLength = reader.getUint32();
              if (encoding === 0) {
                switch (type) {
                  case "b":
                  case "c":
                    return reader.getBooleanArray(arrayLength);
                  case "d":
                    return reader.getFloat64Array(arrayLength);
                  case "f":
                    return reader.getFloat32Array(arrayLength);
                  case "i":
                    return reader.getInt32Array(arrayLength);
                  case "l":
                    return reader.getInt64Array(arrayLength);
                }
              }
              const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
              const reader2 = new BinaryReader(data.buffer);
              switch (type) {
                case "b":
                case "c":
                  return reader2.getBooleanArray(arrayLength);
                case "d":
                  return reader2.getFloat64Array(arrayLength);
                case "f":
                  return reader2.getFloat32Array(arrayLength);
                case "i":
                  return reader2.getInt32Array(arrayLength);
                case "l":
                  return reader2.getInt64Array(arrayLength);
              }
              break;
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + type);
          }
        }
      };
      BinaryReader = class {
        constructor(buffer, littleEndian) {
          this.dv = new DataView(buffer);
          this.offset = 0;
          this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
          this._textDecoder = new TextDecoder();
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(length3) {
          this.offset += length3;
        }
        // seems like true/false representation depends on exporter.
        // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
        // then sees LSB.
        getBoolean() {
          return (this.getUint8() & 1) === 1;
        }
        getBooleanArray(size) {
          const a4 = [];
          for (let i5 = 0; i5 < size; i5++) {
            a4.push(this.getBoolean());
          }
          return a4;
        }
        getUint8() {
          const value = this.dv.getUint8(this.offset);
          this.offset += 1;
          return value;
        }
        getInt16() {
          const value = this.dv.getInt16(this.offset, this.littleEndian);
          this.offset += 2;
          return value;
        }
        getInt32() {
          const value = this.dv.getInt32(this.offset, this.littleEndian);
          this.offset += 4;
          return value;
        }
        getInt32Array(size) {
          const a4 = [];
          for (let i5 = 0; i5 < size; i5++) {
            a4.push(this.getInt32());
          }
          return a4;
        }
        getUint32() {
          const value = this.dv.getUint32(this.offset, this.littleEndian);
          this.offset += 4;
          return value;
        }
        // JavaScript doesn't support 64-bit integer so calculate this here
        // 1 << 32 will return 1 so using multiply operation instead here.
        // There's a possibility that this method returns wrong value if the value
        // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
        // TODO: safely handle 64-bit integer
        getInt64() {
          let low, high;
          if (this.littleEndian) {
            low = this.getUint32();
            high = this.getUint32();
          } else {
            high = this.getUint32();
            low = this.getUint32();
          }
          if (high & 2147483648) {
            high = ~high & 4294967295;
            low = ~low & 4294967295;
            if (low === 4294967295)
              high = high + 1 & 4294967295;
            low = low + 1 & 4294967295;
            return -(high * 4294967296 + low);
          }
          return high * 4294967296 + low;
        }
        getInt64Array(size) {
          const a4 = [];
          for (let i5 = 0; i5 < size; i5++) {
            a4.push(this.getInt64());
          }
          return a4;
        }
        // Note: see getInt64() comment
        getUint64() {
          let low, high;
          if (this.littleEndian) {
            low = this.getUint32();
            high = this.getUint32();
          } else {
            high = this.getUint32();
            low = this.getUint32();
          }
          return high * 4294967296 + low;
        }
        getFloat32() {
          const value = this.dv.getFloat32(this.offset, this.littleEndian);
          this.offset += 4;
          return value;
        }
        getFloat32Array(size) {
          const a4 = [];
          for (let i5 = 0; i5 < size; i5++) {
            a4.push(this.getFloat32());
          }
          return a4;
        }
        getFloat64() {
          const value = this.dv.getFloat64(this.offset, this.littleEndian);
          this.offset += 8;
          return value;
        }
        getFloat64Array(size) {
          const a4 = [];
          for (let i5 = 0; i5 < size; i5++) {
            a4.push(this.getFloat64());
          }
          return a4;
        }
        getArrayBuffer(size) {
          const value = this.dv.buffer.slice(this.offset, this.offset + size);
          this.offset += size;
          return value;
        }
        getString(size) {
          const start = this.offset;
          let a4 = new Uint8Array(this.dv.buffer, start, size);
          this.skip(size);
          const nullByte = a4.indexOf(0);
          if (nullByte >= 0)
            a4 = new Uint8Array(this.dv.buffer, start, nullByte);
          return this._textDecoder.decode(a4);
        }
      };
      FBXTree = class {
        add(key, val) {
          this[key] = val;
        }
      };
      dataArray = [];
      tempEuler = new Euler();
      tempVec = new Vector3();
    }
  });

  // node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
  function toTrianglesDrawMode(geometry, drawMode) {
    if (drawMode === TrianglesDrawMode) {
      console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
      return geometry;
    }
    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
      let index = geometry.getIndex();
      if (index === null) {
        const indices = [];
        const position = geometry.getAttribute("position");
        if (position !== void 0) {
          for (let i5 = 0; i5 < position.count; i5++) {
            indices.push(i5);
          }
          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
          return geometry;
        }
      }
      const numberOfTriangles = index.count - 2;
      const newIndices = [];
      if (drawMode === TriangleFanDrawMode) {
        for (let i5 = 1; i5 <= numberOfTriangles; i5++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i5));
          newIndices.push(index.getX(i5 + 1));
        }
      } else {
        for (let i5 = 0; i5 < numberOfTriangles; i5++) {
          if (i5 % 2 === 0) {
            newIndices.push(index.getX(i5));
            newIndices.push(index.getX(i5 + 1));
            newIndices.push(index.getX(i5 + 2));
          } else {
            newIndices.push(index.getX(i5 + 2));
            newIndices.push(index.getX(i5 + 1));
            newIndices.push(index.getX(i5));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      }
      const newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      newGeometry.clearGroups();
      return newGeometry;
    } else {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
      return geometry;
    }
  }
  var init_BufferGeometryUtils = __esm({
    "node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"() {
      init_three_module();
    }
  });

  // node_modules/three/examples/jsm/loaders/GLTFLoader.js
  function GLTFRegistry() {
    let objects = {};
    return {
      get: function(key) {
        return objects[key];
      },
      add: function(key, object) {
        objects[key] = object;
      },
      remove: function(key) {
        delete objects[key];
      },
      removeAll: function() {
        objects = {};
      }
    };
  }
  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
      cache["DefaultMaterial"] = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache["DefaultMaterial"];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for (const name2 in objectDef.extensions) {
      if (knownExtensions[name2] === void 0) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name2] = objectDef.extensions[name2];
      }
    }
  }
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  function addMorphTargets(geometry, targets, parser) {
    let hasMorphPosition = false;
    let hasMorphNormal = false;
    let hasMorphColor = false;
    for (let i5 = 0, il3 = targets.length; i5 < il3; i5++) {
      const target = targets[i5];
      if (target.POSITION !== void 0)
        hasMorphPosition = true;
      if (target.NORMAL !== void 0)
        hasMorphNormal = true;
      if (target.COLOR_0 !== void 0)
        hasMorphColor = true;
      if (hasMorphPosition && hasMorphNormal && hasMorphColor)
        break;
    }
    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
      return Promise.resolve(geometry);
    const pendingPositionAccessors = [];
    const pendingNormalAccessors = [];
    const pendingColorAccessors = [];
    for (let i5 = 0, il3 = targets.length; i5 < il3; i5++) {
      const target = targets[i5];
      if (hasMorphPosition) {
        const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
      if (hasMorphColor) {
        const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
        pendingColorAccessors.push(pendingAccessor);
      }
    }
    return Promise.all([
      Promise.all(pendingPositionAccessors),
      Promise.all(pendingNormalAccessors),
      Promise.all(pendingColorAccessors)
    ]).then(function(accessors) {
      const morphPositions = accessors[0];
      const morphNormals = accessors[1];
      const morphColors = accessors[2];
      if (hasMorphPosition)
        geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal)
        geometry.morphAttributes.normal = morphNormals;
      if (hasMorphColor)
        geometry.morphAttributes.color = morphColors;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
      for (let i5 = 0, il3 = meshDef.weights.length; i5 < il3; i5++) {
        mesh.morphTargetInfluences[i5] = meshDef.weights[i5];
      }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      const targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (let i5 = 0, il3 = targetNames.length; i5 < il3; i5++) {
          mesh.morphTargetDictionary[targetNames[i5]] = i5;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    let geometryKey;
    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    if (primitiveDef.targets !== void 0) {
      for (let i5 = 0, il3 = primitiveDef.targets.length; i5 < il3; i5++) {
        geometryKey += ":" + createAttributesKey(primitiveDef.targets[i5]);
      }
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    let attributesKey = "";
    const keys = Object.keys(attributes).sort();
    for (let i5 = 0, il3 = keys.length; i5 < il3; i5++) {
      attributesKey += keys[i5] + ":" + attributes[keys[i5]] + ";";
    }
    return attributesKey;
  }
  function getNormalizedComponentScale(constructor) {
    switch (constructor) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  function getImageURIMimeType(uri) {
    if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
      return "image/jpeg";
    if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
      return "image/webp";
    return "image/png";
  }
  function computeBounds(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const box = new Box3();
    if (attributes.POSITION !== void 0) {
      const accessor = parser.json.accessors[attributes.POSITION];
      const min = accessor.min;
      const max2 = accessor.max;
      if (min !== void 0 && max2 !== void 0) {
        box.set(
          new Vector3(min[0], min[1], min[2]),
          new Vector3(max2[0], max2[1], max2[2])
        );
        if (accessor.normalized) {
          const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
          box.min.multiplyScalar(boxScale);
          box.max.multiplyScalar(boxScale);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }
    const targets = primitiveDef.targets;
    if (targets !== void 0) {
      const maxDisplacement = new Vector3();
      const vector = new Vector3();
      for (let i5 = 0, il3 = targets.length; i5 < il3; i5++) {
        const target = targets[i5];
        if (target.POSITION !== void 0) {
          const accessor = parser.json.accessors[target.POSITION];
          const min = accessor.min;
          const max2 = accessor.max;
          if (min !== void 0 && max2 !== void 0) {
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max2[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max2[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max2[2])));
            if (accessor.normalized) {
              const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
              vector.multiplyScalar(boxScale);
            }
            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      }
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    const sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }
    for (const gltfAttributeName in attributes) {
      const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
      if (threeAttributeName in geometry.attributes)
        continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
      const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
        geometry.setIndex(accessor2);
      });
      pending.push(accessor);
    }
    if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
      console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
      return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  var GLTFLoader, EXTENSIONS, GLTFLightsExtension, GLTFMaterialsUnlitExtension, GLTFMaterialsEmissiveStrengthExtension, GLTFMaterialsClearcoatExtension, GLTFMaterialsIridescenceExtension, GLTFMaterialsSheenExtension, GLTFMaterialsTransmissionExtension, GLTFMaterialsVolumeExtension, GLTFMaterialsIorExtension, GLTFMaterialsSpecularExtension, GLTFMaterialsAnisotropyExtension, GLTFTextureBasisUExtension, GLTFTextureWebPExtension, GLTFTextureAVIFExtension, GLTFMeshoptCompression, GLTFMeshGpuInstancing, BINARY_EXTENSION_HEADER_MAGIC, BINARY_EXTENSION_HEADER_LENGTH, BINARY_EXTENSION_CHUNK_TYPES, GLTFBinaryExtension, GLTFDracoMeshCompressionExtension, GLTFTextureTransformExtension, GLTFMeshQuantizationExtension, GLTFCubicSplineInterpolant, _q, GLTFCubicSplineQuaternionInterpolant, WEBGL_CONSTANTS, WEBGL_COMPONENT_TYPES, WEBGL_FILTERS, WEBGL_WRAPPINGS, WEBGL_TYPE_SIZES, ATTRIBUTES, PATH_PROPERTIES, INTERPOLATION, ALPHA_MODES, _identityMatrix2, GLTFParser;
  var init_GLTFLoader = __esm({
    "node_modules/three/examples/jsm/loaders/GLTFLoader.js"() {
      init_three_module();
      init_BufferGeometryUtils();
      GLTFLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.dracoLoader = null;
          this.ktx2Loader = null;
          this.meshoptDecoder = null;
          this.pluginCallbacks = [];
          this.register(function(parser) {
            return new GLTFMaterialsClearcoatExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureBasisUExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureWebPExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureAVIFExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsSheenExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsTransmissionExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsVolumeExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsIorExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsEmissiveStrengthExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsSpecularExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsIridescenceExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsAnisotropyExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFLightsExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMeshoptCompression(parser);
          });
          this.register(function(parser) {
            return new GLTFMeshGpuInstancing(parser);
          });
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          let resourcePath;
          if (this.resourcePath !== "") {
            resourcePath = this.resourcePath;
          } else if (this.path !== "") {
            resourcePath = this.path;
          } else {
            resourcePath = LoaderUtils.extractUrlBase(url);
          }
          this.manager.itemStart(url);
          const _onError = function(e4) {
            if (onError) {
              onError(e4);
            } else {
              console.error(e4);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          };
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(data) {
            try {
              scope.parse(data, resourcePath, function(gltf) {
                onLoad(gltf);
                scope.manager.itemEnd(url);
              }, _onError);
            } catch (e4) {
              _onError(e4);
            }
          }, onProgress, _onError);
        }
        setDRACOLoader(dracoLoader) {
          this.dracoLoader = dracoLoader;
          return this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(ktx2Loader) {
          this.ktx2Loader = ktx2Loader;
          return this;
        }
        setMeshoptDecoder(meshoptDecoder) {
          this.meshoptDecoder = meshoptDecoder;
          return this;
        }
        register(callback) {
          if (this.pluginCallbacks.indexOf(callback) === -1) {
            this.pluginCallbacks.push(callback);
          }
          return this;
        }
        unregister(callback) {
          if (this.pluginCallbacks.indexOf(callback) !== -1) {
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
          }
          return this;
        }
        parse(data, path, onLoad, onError) {
          let json;
          const extensions = {};
          const plugins = {};
          const textDecoder = new TextDecoder();
          if (typeof data === "string") {
            json = JSON.parse(data);
          } else if (data instanceof ArrayBuffer) {
            const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
              try {
                extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
              } catch (error) {
                if (onError)
                  onError(error);
                return;
              }
              json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
            } else {
              json = JSON.parse(textDecoder.decode(data));
            }
          } else {
            json = data;
          }
          if (json.asset === void 0 || json.asset.version[0] < 2) {
            if (onError)
              onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const parser = new GLTFParser(json, {
            path: path || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
          });
          parser.fileLoader.setRequestHeader(this.requestHeader);
          for (let i5 = 0; i5 < this.pluginCallbacks.length; i5++) {
            const plugin = this.pluginCallbacks[i5](parser);
            if (!plugin.name)
              console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
            plugins[plugin.name] = plugin;
            extensions[plugin.name] = true;
          }
          if (json.extensionsUsed) {
            for (let i5 = 0; i5 < json.extensionsUsed.length; ++i5) {
              const extensionName = json.extensionsUsed[i5];
              const extensionsRequired = json.extensionsRequired || [];
              switch (extensionName) {
                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                  extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                  break;
                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                  extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                  break;
                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                  extensions[extensionName] = new GLTFTextureTransformExtension();
                  break;
                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                  extensions[extensionName] = new GLTFMeshQuantizationExtension();
                  break;
                default:
                  if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                    console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                  }
              }
            }
          }
          parser.setExtensions(extensions);
          parser.setPlugins(plugins);
          parser.parse(onLoad, onError);
        }
        parseAsync(data, path) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.parse(data, path, resolve, reject);
          });
        }
      };
      EXTENSIONS = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
      };
      GLTFLightsExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
          this.cache = { refs: {}, uses: {} };
        }
        _markDefs() {
          const parser = this.parser;
          const nodeDefs = this.parser.json.nodes || [];
          for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
              parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
            }
          }
        }
        _loadLight(lightIndex) {
          const parser = this.parser;
          const cacheKey = "light:" + lightIndex;
          let dependency = parser.cache.get(cacheKey);
          if (dependency)
            return dependency;
          const json = parser.json;
          const extensions = json.extensions && json.extensions[this.name] || {};
          const lightDefs = extensions.lights || [];
          const lightDef = lightDefs[lightIndex];
          let lightNode;
          const color = new Color(16777215);
          if (lightDef.color !== void 0)
            color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
          const range = lightDef.range !== void 0 ? lightDef.range : 0;
          switch (lightDef.type) {
            case "directional":
              lightNode = new DirectionalLight(color);
              lightNode.target.position.set(0, 0, -1);
              lightNode.add(lightNode.target);
              break;
            case "point":
              lightNode = new PointLight(color);
              lightNode.distance = range;
              break;
            case "spot":
              lightNode = new SpotLight(color);
              lightNode.distance = range;
              lightDef.spot = lightDef.spot || {};
              lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
              lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
              lightNode.angle = lightDef.spot.outerConeAngle;
              lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
              lightNode.target.position.set(0, 0, -1);
              lightNode.add(lightNode.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
          }
          lightNode.position.set(0, 0, 0);
          lightNode.decay = 2;
          assignExtrasToUserData(lightNode, lightDef);
          if (lightDef.intensity !== void 0)
            lightNode.intensity = lightDef.intensity;
          lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
          dependency = Promise.resolve(lightNode);
          parser.cache.add(cacheKey, dependency);
          return dependency;
        }
        getDependency(type, index) {
          if (type !== "light")
            return;
          return this._loadLight(index);
        }
        createNodeAttachment(nodeIndex) {
          const self2 = this;
          const parser = this.parser;
          const json = parser.json;
          const nodeDef = json.nodes[nodeIndex];
          const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
          const lightIndex = lightDef.light;
          if (lightIndex === void 0)
            return null;
          return this._loadLight(lightIndex).then(function(light) {
            return parser._getNodeRef(self2.cache, lightIndex, light);
          });
        }
      };
      GLTFMaterialsUnlitExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return MeshBasicMaterial;
        }
        extendParams(materialParams, materialDef, parser) {
          const pending = [];
          materialParams.color = new Color(1, 1, 1);
          materialParams.opacity = 1;
          const metallicRoughness = materialDef.pbrMetallicRoughness;
          if (metallicRoughness) {
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
              const array = metallicRoughness.baseColorFactor;
              materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
              materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
            }
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsEmissiveStrengthExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
          if (emissiveStrength !== void 0) {
            materialParams.emissiveIntensity = emissiveStrength;
          }
          return Promise.resolve();
        }
      };
      GLTFMaterialsClearcoatExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.clearcoatFactor !== void 0) {
            materialParams.clearcoat = extension.clearcoatFactor;
          }
          if (extension.clearcoatTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
          }
          if (extension.clearcoatRoughnessFactor !== void 0) {
            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
          }
          if (extension.clearcoatRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
          }
          if (extension.clearcoatNormalTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
            if (extension.clearcoatNormalTexture.scale !== void 0) {
              const scale4 = extension.clearcoatNormalTexture.scale;
              materialParams.clearcoatNormalScale = new Vector2(scale4, scale4);
            }
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsIridescenceExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.iridescenceFactor !== void 0) {
            materialParams.iridescence = extension.iridescenceFactor;
          }
          if (extension.iridescenceTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
          }
          if (extension.iridescenceIor !== void 0) {
            materialParams.iridescenceIOR = extension.iridescenceIor;
          }
          if (materialParams.iridescenceThicknessRange === void 0) {
            materialParams.iridescenceThicknessRange = [100, 400];
          }
          if (extension.iridescenceThicknessMinimum !== void 0) {
            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
          }
          if (extension.iridescenceThicknessMaximum !== void 0) {
            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
          }
          if (extension.iridescenceThicknessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsSheenExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          materialParams.sheenColor = new Color(0, 0, 0);
          materialParams.sheenRoughness = 0;
          materialParams.sheen = 1;
          const extension = materialDef.extensions[this.name];
          if (extension.sheenColorFactor !== void 0) {
            const colorFactor = extension.sheenColorFactor;
            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
          }
          if (extension.sheenRoughnessFactor !== void 0) {
            materialParams.sheenRoughness = extension.sheenRoughnessFactor;
          }
          if (extension.sheenColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
          }
          if (extension.sheenRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsTransmissionExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.transmissionFactor !== void 0) {
            materialParams.transmission = extension.transmissionFactor;
          }
          if (extension.transmissionTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsVolumeExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
          if (extension.thicknessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
          }
          materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
          const colorArray = extension.attenuationColor || [1, 1, 1];
          materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
          return Promise.all(pending);
        }
      };
      GLTFMaterialsIorExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_IOR;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const extension = materialDef.extensions[this.name];
          materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
          return Promise.resolve();
        }
      };
      GLTFMaterialsSpecularExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
          if (extension.specularTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
          }
          const colorArray = extension.specularColorFactor || [1, 1, 1];
          materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
          if (extension.specularColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsAnisotropyExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.anisotropyStrength !== void 0) {
            materialParams.anisotropy = extension.anisotropyStrength;
          }
          if (extension.anisotropyRotation !== void 0) {
            materialParams.anisotropyRotation = extension.anisotropyRotation;
          }
          if (extension.anisotropyTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
          }
          return Promise.all(pending);
        }
      };
      GLTFTextureBasisUExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
        }
        loadTexture(textureIndex) {
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[this.name]) {
            return null;
          }
          const extension = textureDef.extensions[this.name];
          const loader = parser.options.ktx2Loader;
          if (!loader) {
            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
              throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            } else {
              return null;
            }
          }
          return parser.loadTextureImage(textureIndex, extension.source, loader);
        }
      };
      GLTFTextureWebPExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
          this.isSupported = null;
        }
        loadTexture(textureIndex) {
          const name2 = this.name;
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[name2]) {
            return null;
          }
          const extension = textureDef.extensions[name2];
          const source = json.images[extension.source];
          let loader = parser.textureLoader;
          if (source.uri) {
            const handler = parser.options.manager.getHandler(source.uri);
            if (handler !== null)
              loader = handler;
          }
          return this.detectSupport().then(function(isSupported) {
            if (isSupported)
              return parser.loadTextureImage(textureIndex, extension.source, loader);
            if (json.extensionsRequired && json.extensionsRequired.indexOf(name2) >= 0) {
              throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            }
            return parser.loadTexture(textureIndex);
          });
        }
        detectSupport() {
          if (!this.isSupported) {
            this.isSupported = new Promise(function(resolve) {
              const image = new Image();
              image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
              image.onload = image.onerror = function() {
                resolve(image.height === 1);
              };
            });
          }
          return this.isSupported;
        }
      };
      GLTFTextureAVIFExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
          this.isSupported = null;
        }
        loadTexture(textureIndex) {
          const name2 = this.name;
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[name2]) {
            return null;
          }
          const extension = textureDef.extensions[name2];
          const source = json.images[extension.source];
          let loader = parser.textureLoader;
          if (source.uri) {
            const handler = parser.options.manager.getHandler(source.uri);
            if (handler !== null)
              loader = handler;
          }
          return this.detectSupport().then(function(isSupported) {
            if (isSupported)
              return parser.loadTextureImage(textureIndex, extension.source, loader);
            if (json.extensionsRequired && json.extensionsRequired.indexOf(name2) >= 0) {
              throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            }
            return parser.loadTexture(textureIndex);
          });
        }
        detectSupport() {
          if (!this.isSupported) {
            this.isSupported = new Promise(function(resolve) {
              const image = new Image();
              image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
              image.onload = image.onerror = function() {
                resolve(image.height === 1);
              };
            });
          }
          return this.isSupported;
        }
      };
      GLTFMeshoptCompression = class {
        constructor(parser) {
          this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
          this.parser = parser;
        }
        loadBufferView(index) {
          const json = this.parser.json;
          const bufferView = json.bufferViews[index];
          if (bufferView.extensions && bufferView.extensions[this.name]) {
            const extensionDef = bufferView.extensions[this.name];
            const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
            const decoder = this.parser.options.meshoptDecoder;
            if (!decoder || !decoder.supported) {
              if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              } else {
                return null;
              }
            }
            return buffer.then(function(res) {
              const byteOffset = extensionDef.byteOffset || 0;
              const byteLength = extensionDef.byteLength || 0;
              const count = extensionDef.count;
              const stride = extensionDef.byteStride;
              const source = new Uint8Array(res, byteOffset, byteLength);
              if (decoder.decodeGltfBufferAsync) {
                return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
                  return res2.buffer;
                });
              } else {
                return decoder.ready.then(function() {
                  const result = new ArrayBuffer(count * stride);
                  decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
                  return result;
                });
              }
            });
          } else {
            return null;
          }
        }
      };
      GLTFMeshGpuInstancing = class {
        constructor(parser) {
          this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
          this.parser = parser;
        }
        createNodeMesh(nodeIndex) {
          const json = this.parser.json;
          const nodeDef = json.nodes[nodeIndex];
          if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
            return null;
          }
          const meshDef = json.meshes[nodeDef.mesh];
          for (const primitive of meshDef.primitives) {
            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
              return null;
            }
          }
          const extensionDef = nodeDef.extensions[this.name];
          const attributesDef = extensionDef.attributes;
          const pending = [];
          const attributes = {};
          for (const key in attributesDef) {
            pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
              attributes[key] = accessor;
              return attributes[key];
            }));
          }
          if (pending.length < 1) {
            return null;
          }
          pending.push(this.parser.createNodeMesh(nodeIndex));
          return Promise.all(pending).then((results) => {
            const nodeObject = results.pop();
            const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
            const count = results[0].count;
            const instancedMeshes = [];
            for (const mesh of meshes) {
              const m4 = new Matrix4();
              const p4 = new Vector3();
              const q4 = new Quaternion();
              const s4 = new Vector3(1, 1, 1);
              const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
              for (let i5 = 0; i5 < count; i5++) {
                if (attributes.TRANSLATION) {
                  p4.fromBufferAttribute(attributes.TRANSLATION, i5);
                }
                if (attributes.ROTATION) {
                  q4.fromBufferAttribute(attributes.ROTATION, i5);
                }
                if (attributes.SCALE) {
                  s4.fromBufferAttribute(attributes.SCALE, i5);
                }
                instancedMesh.setMatrixAt(i5, m4.compose(p4, q4, s4));
              }
              for (const attributeName in attributes) {
                if (attributeName === "_COLOR_0") {
                  const attr = attributes[attributeName];
                  instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
                } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
                  mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
                }
              }
              Object3D.prototype.copy.call(instancedMesh, mesh);
              this.parser.assignFinalMaterial(instancedMesh);
              instancedMeshes.push(instancedMesh);
            }
            if (nodeObject.isGroup) {
              nodeObject.clear();
              nodeObject.add(...instancedMeshes);
              return nodeObject;
            }
            return instancedMeshes[0];
          });
        }
      };
      BINARY_EXTENSION_HEADER_MAGIC = "glTF";
      BINARY_EXTENSION_HEADER_LENGTH = 12;
      BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
      GLTFBinaryExtension = class {
        constructor(data) {
          this.name = EXTENSIONS.KHR_BINARY_GLTF;
          this.content = null;
          this.body = null;
          const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
          const textDecoder = new TextDecoder();
          this.header = {
            magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
          };
          if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          } else if (this.header.version < 2) {
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          }
          const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
          const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
          let chunkIndex = 0;
          while (chunkIndex < chunkContentsLength) {
            const chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            const chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
              const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
              this.content = textDecoder.decode(contentArray);
            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
              const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
              this.body = data.slice(byteOffset, byteOffset + chunkLength);
            }
            chunkIndex += chunkLength;
          }
          if (this.content === null) {
            throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
      };
      GLTFDracoMeshCompressionExtension = class {
        constructor(json, dracoLoader) {
          if (!dracoLoader) {
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          }
          this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
          this.json = json;
          this.dracoLoader = dracoLoader;
          this.dracoLoader.preload();
        }
        decodePrimitive(primitive, parser) {
          const json = this.json;
          const dracoLoader = this.dracoLoader;
          const bufferViewIndex = primitive.extensions[this.name].bufferView;
          const gltfAttributeMap = primitive.extensions[this.name].attributes;
          const threeAttributeMap = {};
          const attributeNormalizedMap = {};
          const attributeTypeMap = {};
          for (const attributeName in gltfAttributeMap) {
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
          }
          for (const attributeName in primitive.attributes) {
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            if (gltfAttributeMap[attributeName] !== void 0) {
              const accessorDef = json.accessors[primitive.attributes[attributeName]];
              const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
              attributeTypeMap[threeAttributeName] = componentType.name;
              attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
            }
          }
          return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
            return new Promise(function(resolve) {
              dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                for (const attributeName in geometry.attributes) {
                  const attribute = geometry.attributes[attributeName];
                  const normalized = attributeNormalizedMap[attributeName];
                  if (normalized !== void 0)
                    attribute.normalized = normalized;
                }
                resolve(geometry);
              }, threeAttributeMap, attributeTypeMap);
            });
          });
        }
      };
      GLTFTextureTransformExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(texture, transform) {
          if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
            return texture;
          }
          texture = texture.clone();
          if (transform.texCoord !== void 0) {
            texture.channel = transform.texCoord;
          }
          if (transform.offset !== void 0) {
            texture.offset.fromArray(transform.offset);
          }
          if (transform.rotation !== void 0) {
            texture.rotation = transform.rotation;
          }
          if (transform.scale !== void 0) {
            texture.repeat.fromArray(transform.scale);
          }
          texture.needsUpdate = true;
          return texture;
        }
      };
      GLTFMeshQuantizationExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
        }
      };
      GLTFCubicSplineInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
          for (let i5 = 0; i5 !== valueSize; i5++) {
            result[i5] = values[offset + i5];
          }
          return result;
        }
        interpolate_(i1, t0, t4, t1) {
          const result = this.resultBuffer;
          const values = this.sampleValues;
          const stride = this.valueSize;
          const stride2 = stride * 2;
          const stride3 = stride * 3;
          const td3 = t1 - t0;
          const p4 = (t4 - t0) / td3;
          const pp2 = p4 * p4;
          const ppp = pp2 * p4;
          const offset1 = i1 * stride3;
          const offset0 = offset1 - stride3;
          const s22 = -2 * ppp + 3 * pp2;
          const s32 = ppp - pp2;
          const s0 = 1 - s22;
          const s1 = s32 - pp2 + p4;
          for (let i5 = 0; i5 !== stride; i5++) {
            const p0 = values[offset0 + i5 + stride];
            const m0 = values[offset0 + i5 + stride2] * td3;
            const p1 = values[offset1 + i5 + stride];
            const m1 = values[offset1 + i5] * td3;
            result[i5] = s0 * p0 + s1 * m0 + s22 * p1 + s32 * m1;
          }
          return result;
        }
      };
      _q = new Quaternion();
      GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
        interpolate_(i1, t0, t4, t1) {
          const result = super.interpolate_(i1, t0, t4, t1);
          _q.fromArray(result).normalize().toArray(result);
          return result;
        }
      };
      WEBGL_CONSTANTS = {
        FLOAT: 5126,
        //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
      };
      WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      };
      WEBGL_FILTERS = {
        9728: NearestFilter,
        9729: LinearFilter,
        9984: NearestMipmapNearestFilter,
        9985: LinearMipmapNearestFilter,
        9986: NearestMipmapLinearFilter,
        9987: LinearMipmapLinearFilter
      };
      WEBGL_WRAPPINGS = {
        33071: ClampToEdgeWrapping,
        33648: MirroredRepeatWrapping,
        10497: RepeatWrapping
      };
      WEBGL_TYPE_SIZES = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
      };
      ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      };
      PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      };
      INTERPOLATION = {
        CUBICSPLINE: void 0,
        // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
        // keyframe track will be initialized with a default interpolation type, then modified.
        LINEAR: InterpolateLinear,
        STEP: InterpolateDiscrete
      };
      ALPHA_MODES = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      _identityMatrix2 = new Matrix4();
      GLTFParser = class {
        constructor(json = {}, options = {}) {
          this.json = json;
          this.extensions = {};
          this.plugins = {};
          this.options = options;
          this.cache = new GLTFRegistry();
          this.associations = /* @__PURE__ */ new Map();
          this.primitiveCache = {};
          this.nodeCache = {};
          this.meshCache = { refs: {}, uses: {} };
          this.cameraCache = { refs: {}, uses: {} };
          this.lightCache = { refs: {}, uses: {} };
          this.sourceCache = {};
          this.textureCache = {};
          this.nodeNamesUsed = {};
          let isSafari = false;
          let isFirefox = false;
          let firefoxVersion = -1;
          if (typeof navigator !== "undefined") {
            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
            isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
          }
          if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
            this.textureLoader = new TextureLoader(this.options.manager);
          } else {
            this.textureLoader = new ImageBitmapLoader(this.options.manager);
          }
          this.textureLoader.setCrossOrigin(this.options.crossOrigin);
          this.textureLoader.setRequestHeader(this.options.requestHeader);
          this.fileLoader = new FileLoader(this.options.manager);
          this.fileLoader.setResponseType("arraybuffer");
          if (this.options.crossOrigin === "use-credentials") {
            this.fileLoader.setWithCredentials(true);
          }
        }
        setExtensions(extensions) {
          this.extensions = extensions;
        }
        setPlugins(plugins) {
          this.plugins = plugins;
        }
        parse(onLoad, onError) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          this.cache.removeAll();
          this.nodeCache = {};
          this._invokeAll(function(ext) {
            return ext._markDefs && ext._markDefs();
          });
          Promise.all(this._invokeAll(function(ext) {
            return ext.beforeRoot && ext.beforeRoot();
          })).then(function() {
            return Promise.all([
              parser.getDependencies("scene"),
              parser.getDependencies("animation"),
              parser.getDependencies("camera")
            ]);
          }).then(function(dependencies) {
            const result = {
              scene: dependencies[0][json.scene || 0],
              scenes: dependencies[0],
              animations: dependencies[1],
              cameras: dependencies[2],
              asset: json.asset,
              parser,
              userData: {}
            };
            addUnknownExtensionsToUserData(extensions, result, json);
            assignExtrasToUserData(result, json);
            return Promise.all(parser._invokeAll(function(ext) {
              return ext.afterRoot && ext.afterRoot(result);
            })).then(function() {
              onLoad(result);
            });
          }).catch(onError);
        }
        /**
         * Marks the special nodes/meshes in json for efficient parse.
         */
        _markDefs() {
          const nodeDefs = this.json.nodes || [];
          const skinDefs = this.json.skins || [];
          const meshDefs = this.json.meshes || [];
          for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
            const joints = skinDefs[skinIndex].joints;
            for (let i5 = 0, il3 = joints.length; i5 < il3; i5++) {
              nodeDefs[joints[i5]].isBone = true;
            }
          }
          for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.mesh !== void 0) {
              this._addNodeRef(this.meshCache, nodeDef.mesh);
              if (nodeDef.skin !== void 0) {
                meshDefs[nodeDef.mesh].isSkinnedMesh = true;
              }
            }
            if (nodeDef.camera !== void 0) {
              this._addNodeRef(this.cameraCache, nodeDef.camera);
            }
          }
        }
        /**
         * Counts references to shared node / Object3D resources. These resources
         * can be reused, or "instantiated", at multiple nodes in the scene
         * hierarchy. Mesh, Camera, and Light instances are instantiated and must
         * be marked. Non-scenegraph resources (like Materials, Geometries, and
         * Textures) can be reused directly and are not marked here.
         *
         * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
         */
        _addNodeRef(cache, index) {
          if (index === void 0)
            return;
          if (cache.refs[index] === void 0) {
            cache.refs[index] = cache.uses[index] = 0;
          }
          cache.refs[index]++;
        }
        /** Returns a reference to a shared resource, cloning it if necessary. */
        _getNodeRef(cache, index, object) {
          if (cache.refs[index] <= 1)
            return object;
          const ref = object.clone();
          const updateMappings = (original, clone5) => {
            const mappings = this.associations.get(original);
            if (mappings != null) {
              this.associations.set(clone5, mappings);
            }
            for (const [i5, child] of original.children.entries()) {
              updateMappings(child, clone5.children[i5]);
            }
          };
          updateMappings(object, ref);
          ref.name += "_instance_" + cache.uses[index]++;
          return ref;
        }
        _invokeOne(func) {
          const extensions = Object.values(this.plugins);
          extensions.push(this);
          for (let i5 = 0; i5 < extensions.length; i5++) {
            const result = func(extensions[i5]);
            if (result)
              return result;
          }
          return null;
        }
        _invokeAll(func) {
          const extensions = Object.values(this.plugins);
          extensions.unshift(this);
          const pending = [];
          for (let i5 = 0; i5 < extensions.length; i5++) {
            const result = func(extensions[i5]);
            if (result)
              pending.push(result);
          }
          return pending;
        }
        /**
         * Requests the specified dependency asynchronously, with caching.
         * @param {string} type
         * @param {number} index
         * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
         */
        getDependency(type, index) {
          const cacheKey = type + ":" + index;
          let dependency = this.cache.get(cacheKey);
          if (!dependency) {
            switch (type) {
              case "scene":
                dependency = this.loadScene(index);
                break;
              case "node":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadNode && ext.loadNode(index);
                });
                break;
              case "mesh":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadMesh && ext.loadMesh(index);
                });
                break;
              case "accessor":
                dependency = this.loadAccessor(index);
                break;
              case "bufferView":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadBufferView && ext.loadBufferView(index);
                });
                break;
              case "buffer":
                dependency = this.loadBuffer(index);
                break;
              case "material":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadMaterial && ext.loadMaterial(index);
                });
                break;
              case "texture":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadTexture && ext.loadTexture(index);
                });
                break;
              case "skin":
                dependency = this.loadSkin(index);
                break;
              case "animation":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadAnimation && ext.loadAnimation(index);
                });
                break;
              case "camera":
                dependency = this.loadCamera(index);
                break;
              default:
                dependency = this._invokeOne(function(ext) {
                  return ext != this && ext.getDependency && ext.getDependency(type, index);
                });
                if (!dependency) {
                  throw new Error("Unknown type: " + type);
                }
                break;
            }
            this.cache.add(cacheKey, dependency);
          }
          return dependency;
        }
        /**
         * Requests all dependencies of the specified type asynchronously, with caching.
         * @param {string} type
         * @return {Promise<Array<Object>>}
         */
        getDependencies(type) {
          let dependencies = this.cache.get(type);
          if (!dependencies) {
            const parser = this;
            const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
            dependencies = Promise.all(defs.map(function(def, index) {
              return parser.getDependency(type, index);
            }));
            this.cache.add(type, dependencies);
          }
          return dependencies;
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
         * @param {number} bufferIndex
         * @return {Promise<ArrayBuffer>}
         */
        loadBuffer(bufferIndex) {
          const bufferDef = this.json.buffers[bufferIndex];
          const loader = this.fileLoader;
          if (bufferDef.type && bufferDef.type !== "arraybuffer") {
            throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
          }
          if (bufferDef.uri === void 0 && bufferIndex === 0) {
            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
          }
          const options = this.options;
          return new Promise(function(resolve, reject) {
            loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
              reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
            });
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
         * @param {number} bufferViewIndex
         * @return {Promise<ArrayBuffer>}
         */
        loadBufferView(bufferViewIndex) {
          const bufferViewDef = this.json.bufferViews[bufferViewIndex];
          return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
            const byteLength = bufferViewDef.byteLength || 0;
            const byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
         * @param {number} accessorIndex
         * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
         */
        loadAccessor(accessorIndex) {
          const parser = this;
          const json = this.json;
          const accessorDef = this.json.accessors[accessorIndex];
          if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            const normalized = accessorDef.normalized === true;
            const array = new TypedArray(accessorDef.count * itemSize);
            return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
          }
          const pendingBufferViews = [];
          if (accessorDef.bufferView !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
          } else {
            pendingBufferViews.push(null);
          }
          if (accessorDef.sparse !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
          }
          return Promise.all(pendingBufferViews).then(function(bufferViews) {
            const bufferView = bufferViews[0];
            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            const elementBytes = TypedArray.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessorDef.byteOffset || 0;
            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
            const normalized = accessorDef.normalized === true;
            let array, bufferAttribute;
            if (byteStride && byteStride !== itemBytes) {
              const ibSlice = Math.floor(byteOffset / byteStride);
              const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
              let ib2 = parser.cache.get(ibCacheKey);
              if (!ib2) {
                array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
                ib2 = new InterleavedBuffer(array, byteStride / elementBytes);
                parser.cache.add(ibCacheKey, ib2);
              }
              bufferAttribute = new InterleavedBufferAttribute(ib2, itemSize, byteOffset % byteStride / elementBytes, normalized);
            } else {
              if (bufferView === null) {
                array = new TypedArray(accessorDef.count * itemSize);
              } else {
                array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
              }
              bufferAttribute = new BufferAttribute(array, itemSize, normalized);
            }
            if (accessorDef.sparse !== void 0) {
              const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
              const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
              const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
              const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
              const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
              const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
              if (bufferView !== null) {
                bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
              }
              for (let i5 = 0, il3 = sparseIndices.length; i5 < il3; i5++) {
                const index = sparseIndices[i5];
                bufferAttribute.setX(index, sparseValues[i5 * itemSize]);
                if (itemSize >= 2)
                  bufferAttribute.setY(index, sparseValues[i5 * itemSize + 1]);
                if (itemSize >= 3)
                  bufferAttribute.setZ(index, sparseValues[i5 * itemSize + 2]);
                if (itemSize >= 4)
                  bufferAttribute.setW(index, sparseValues[i5 * itemSize + 3]);
                if (itemSize >= 5)
                  throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
            }
            return bufferAttribute;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
         * @param {number} textureIndex
         * @return {Promise<THREE.Texture|null>}
         */
        loadTexture(textureIndex) {
          const json = this.json;
          const options = this.options;
          const textureDef = json.textures[textureIndex];
          const sourceIndex = textureDef.source;
          const sourceDef = json.images[sourceIndex];
          let loader = this.textureLoader;
          if (sourceDef.uri) {
            const handler = options.manager.getHandler(sourceDef.uri);
            if (handler !== null)
              loader = handler;
          }
          return this.loadTextureImage(textureIndex, sourceIndex, loader);
        }
        loadTextureImage(textureIndex, sourceIndex, loader) {
          const parser = this;
          const json = this.json;
          const textureDef = json.textures[textureIndex];
          const sourceDef = json.images[sourceIndex];
          const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
          if (this.textureCache[cacheKey]) {
            return this.textureCache[cacheKey];
          }
          const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
            texture.flipY = false;
            texture.name = textureDef.name || sourceDef.name || "";
            if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
              texture.name = sourceDef.uri;
            }
            const samplers = json.samplers || {};
            const sampler = samplers[textureDef.sampler] || {};
            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
            parser.associations.set(texture, { textures: textureIndex });
            return texture;
          }).catch(function() {
            return null;
          });
          this.textureCache[cacheKey] = promise;
          return promise;
        }
        loadImageSource(sourceIndex, loader) {
          const parser = this;
          const json = this.json;
          const options = this.options;
          if (this.sourceCache[sourceIndex] !== void 0) {
            return this.sourceCache[sourceIndex].then((texture) => texture.clone());
          }
          const sourceDef = json.images[sourceIndex];
          const URL2 = self.URL || self.webkitURL;
          let sourceURI = sourceDef.uri || "";
          let isObjectURL = false;
          if (sourceDef.bufferView !== void 0) {
            sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
              isObjectURL = true;
              const blob = new Blob([bufferView], { type: sourceDef.mimeType });
              sourceURI = URL2.createObjectURL(blob);
              return sourceURI;
            });
          } else if (sourceDef.uri === void 0) {
            throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
          }
          const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
            return new Promise(function(resolve, reject) {
              let onLoad = resolve;
              if (loader.isImageBitmapLoader === true) {
                onLoad = function(imageBitmap) {
                  const texture = new Texture(imageBitmap);
                  texture.needsUpdate = true;
                  resolve(texture);
                };
              }
              loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
            });
          }).then(function(texture) {
            if (isObjectURL === true) {
              URL2.revokeObjectURL(sourceURI);
            }
            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
            return texture;
          }).catch(function(error) {
            console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
            throw error;
          });
          this.sourceCache[sourceIndex] = promise;
          return promise;
        }
        /**
         * Asynchronously assigns a texture to the given material parameters.
         * @param {Object} materialParams
         * @param {string} mapName
         * @param {Object} mapDef
         * @return {Promise<Texture>}
         */
        assignTexture(materialParams, mapName, mapDef, colorSpace) {
          const parser = this;
          return this.getDependency("texture", mapDef.index).then(function(texture) {
            if (!texture)
              return null;
            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
              texture = texture.clone();
              texture.channel = mapDef.texCoord;
            }
            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
              const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
              if (transform) {
                const gltfReference = parser.associations.get(texture);
                texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                parser.associations.set(texture, gltfReference);
              }
            }
            if (colorSpace !== void 0) {
              texture.colorSpace = colorSpace;
            }
            materialParams[mapName] = texture;
            return texture;
          });
        }
        /**
         * Assigns final material to a Mesh, Line, or Points instance. The instance
         * already has a material (generated from the glTF material options alone)
         * but reuse of the same glTF material may require multiple threejs materials
         * to accommodate different primitive types, defines, etc. New materials will
         * be created if necessary, and reused from a cache.
         * @param  {Object3D} mesh Mesh, Line, or Points instance.
         */
        assignFinalMaterial(mesh) {
          const geometry = mesh.geometry;
          let material = mesh.material;
          const useDerivativeTangents = geometry.attributes.tangent === void 0;
          const useVertexColors = geometry.attributes.color !== void 0;
          const useFlatShading = geometry.attributes.normal === void 0;
          if (mesh.isPoints) {
            const cacheKey = "PointsMaterial:" + material.uuid;
            let pointsMaterial = this.cache.get(cacheKey);
            if (!pointsMaterial) {
              pointsMaterial = new PointsMaterial();
              Material.prototype.copy.call(pointsMaterial, material);
              pointsMaterial.color.copy(material.color);
              pointsMaterial.map = material.map;
              pointsMaterial.sizeAttenuation = false;
              this.cache.add(cacheKey, pointsMaterial);
            }
            material = pointsMaterial;
          } else if (mesh.isLine) {
            const cacheKey = "LineBasicMaterial:" + material.uuid;
            let lineMaterial = this.cache.get(cacheKey);
            if (!lineMaterial) {
              lineMaterial = new LineBasicMaterial();
              Material.prototype.copy.call(lineMaterial, material);
              lineMaterial.color.copy(material.color);
              lineMaterial.map = material.map;
              this.cache.add(cacheKey, lineMaterial);
            }
            material = lineMaterial;
          }
          if (useDerivativeTangents || useVertexColors || useFlatShading) {
            let cacheKey = "ClonedMaterial:" + material.uuid + ":";
            if (useDerivativeTangents)
              cacheKey += "derivative-tangents:";
            if (useVertexColors)
              cacheKey += "vertex-colors:";
            if (useFlatShading)
              cacheKey += "flat-shading:";
            let cachedMaterial = this.cache.get(cacheKey);
            if (!cachedMaterial) {
              cachedMaterial = material.clone();
              if (useVertexColors)
                cachedMaterial.vertexColors = true;
              if (useFlatShading)
                cachedMaterial.flatShading = true;
              if (useDerivativeTangents) {
                if (cachedMaterial.normalScale)
                  cachedMaterial.normalScale.y *= -1;
                if (cachedMaterial.clearcoatNormalScale)
                  cachedMaterial.clearcoatNormalScale.y *= -1;
              }
              this.cache.add(cacheKey, cachedMaterial);
              this.associations.set(cachedMaterial, this.associations.get(material));
            }
            material = cachedMaterial;
          }
          mesh.material = material;
        }
        getMaterialType() {
          return MeshStandardMaterial;
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
         * @param {number} materialIndex
         * @return {Promise<Material>}
         */
        loadMaterial(materialIndex) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          const materialDef = json.materials[materialIndex];
          let materialType;
          const materialParams = {};
          const materialExtensions = materialDef.extensions || {};
          const pending = [];
          if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType();
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
          } else {
            const metallicRoughness = materialDef.pbrMetallicRoughness || {};
            materialParams.color = new Color(1, 1, 1);
            materialParams.opacity = 1;
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
              const array = metallicRoughness.baseColorFactor;
              materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
              materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
            }
            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
            if (metallicRoughness.metallicRoughnessTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
              pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
            }
            materialType = this._invokeOne(function(ext) {
              return ext.getMaterialType && ext.getMaterialType(materialIndex);
            });
            pending.push(Promise.all(this._invokeAll(function(ext) {
              return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
            })));
          }
          if (materialDef.doubleSided === true) {
            materialParams.side = DoubleSide;
          }
          const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
          if (alphaMode === ALPHA_MODES.BLEND) {
            materialParams.transparent = true;
            materialParams.depthWrite = false;
          } else {
            materialParams.transparent = false;
            if (alphaMode === ALPHA_MODES.MASK) {
              materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
            }
          }
          if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
            materialParams.normalScale = new Vector2(1, 1);
            if (materialDef.normalTexture.scale !== void 0) {
              const scale4 = materialDef.normalTexture.scale;
              materialParams.normalScale.set(scale4, scale4);
            }
          }
          if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
            if (materialDef.occlusionTexture.strength !== void 0) {
              materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
            }
          }
          if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
            const emissiveFactor = materialDef.emissiveFactor;
            materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
          }
          if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
          }
          return Promise.all(pending).then(function() {
            const material = new materialType(materialParams);
            if (materialDef.name)
              material.name = materialDef.name;
            assignExtrasToUserData(material, materialDef);
            parser.associations.set(material, { materials: materialIndex });
            if (materialDef.extensions)
              addUnknownExtensionsToUserData(extensions, material, materialDef);
            return material;
          });
        }
        /** When Object3D instances are targeted by animation, they need unique names. */
        createUniqueName(originalName) {
          const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
          if (sanitizedName in this.nodeNamesUsed) {
            return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
          } else {
            this.nodeNamesUsed[sanitizedName] = 0;
            return sanitizedName;
          }
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
         *
         * Creates BufferGeometries from primitives.
         *
         * @param {Array<GLTF.Primitive>} primitives
         * @return {Promise<Array<BufferGeometry>>}
         */
        loadGeometries(primitives) {
          const parser = this;
          const extensions = this.extensions;
          const cache = this.primitiveCache;
          function createDracoPrimitive(primitive) {
            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
              return addPrimitiveAttributes(geometry, primitive, parser);
            });
          }
          const pending = [];
          for (let i5 = 0, il3 = primitives.length; i5 < il3; i5++) {
            const primitive = primitives[i5];
            const cacheKey = createPrimitiveKey(primitive);
            const cached = cache[cacheKey];
            if (cached) {
              pending.push(cached.promise);
            } else {
              let geometryPromise;
              if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
                geometryPromise = createDracoPrimitive(primitive);
              } else {
                geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
              }
              cache[cacheKey] = { primitive, promise: geometryPromise };
              pending.push(geometryPromise);
            }
          }
          return Promise.all(pending);
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
         * @param {number} meshIndex
         * @return {Promise<Group|Mesh|SkinnedMesh>}
         */
        loadMesh(meshIndex) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          const meshDef = json.meshes[meshIndex];
          const primitives = meshDef.primitives;
          const pending = [];
          for (let i5 = 0, il3 = primitives.length; i5 < il3; i5++) {
            const material = primitives[i5].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i5].material);
            pending.push(material);
          }
          pending.push(parser.loadGeometries(primitives));
          return Promise.all(pending).then(function(results) {
            const materials = results.slice(0, results.length - 1);
            const geometries = results[results.length - 1];
            const meshes = [];
            for (let i5 = 0, il3 = geometries.length; i5 < il3; i5++) {
              const geometry = geometries[i5];
              const primitive = primitives[i5];
              let mesh;
              const material = materials[i5];
              if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
                mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
                if (mesh.isSkinnedMesh === true) {
                  mesh.normalizeSkinWeights();
                }
                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                  mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
                } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                  mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
                }
              } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
                mesh = new LineSegments(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
                mesh = new Line(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
                mesh = new LineLoop(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
                mesh = new Points(geometry, material);
              } else {
                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
              }
              if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
                updateMorphTargets(mesh, meshDef);
              }
              mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
              assignExtrasToUserData(mesh, meshDef);
              if (primitive.extensions)
                addUnknownExtensionsToUserData(extensions, mesh, primitive);
              parser.assignFinalMaterial(mesh);
              meshes.push(mesh);
            }
            for (let i5 = 0, il3 = meshes.length; i5 < il3; i5++) {
              parser.associations.set(meshes[i5], {
                meshes: meshIndex,
                primitives: i5
              });
            }
            if (meshes.length === 1) {
              if (meshDef.extensions)
                addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
              return meshes[0];
            }
            const group = new Group();
            if (meshDef.extensions)
              addUnknownExtensionsToUserData(extensions, group, meshDef);
            parser.associations.set(group, { meshes: meshIndex });
            for (let i5 = 0, il3 = meshes.length; i5 < il3; i5++) {
              group.add(meshes[i5]);
            }
            return group;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
         * @param {number} cameraIndex
         * @return {Promise<THREE.Camera>}
         */
        loadCamera(cameraIndex) {
          let camera;
          const cameraDef = this.json.cameras[cameraIndex];
          const params = cameraDef[cameraDef.type];
          if (!params) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          if (cameraDef.type === "perspective") {
            camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
          } else if (cameraDef.type === "orthographic") {
            camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
          }
          if (cameraDef.name)
            camera.name = this.createUniqueName(cameraDef.name);
          assignExtrasToUserData(camera, cameraDef);
          return Promise.resolve(camera);
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
         * @param {number} skinIndex
         * @return {Promise<Skeleton>}
         */
        loadSkin(skinIndex) {
          const skinDef = this.json.skins[skinIndex];
          const pending = [];
          for (let i5 = 0, il3 = skinDef.joints.length; i5 < il3; i5++) {
            pending.push(this._loadNodeShallow(skinDef.joints[i5]));
          }
          if (skinDef.inverseBindMatrices !== void 0) {
            pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
          } else {
            pending.push(null);
          }
          return Promise.all(pending).then(function(results) {
            const inverseBindMatrices = results.pop();
            const jointNodes = results;
            const bones = [];
            const boneInverses = [];
            for (let i5 = 0, il3 = jointNodes.length; i5 < il3; i5++) {
              const jointNode = jointNodes[i5];
              if (jointNode) {
                bones.push(jointNode);
                const mat = new Matrix4();
                if (inverseBindMatrices !== null) {
                  mat.fromArray(inverseBindMatrices.array, i5 * 16);
                }
                boneInverses.push(mat);
              } else {
                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i5]);
              }
            }
            return new Skeleton(bones, boneInverses);
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
         * @param {number} animationIndex
         * @return {Promise<AnimationClip>}
         */
        loadAnimation(animationIndex) {
          const json = this.json;
          const parser = this;
          const animationDef = json.animations[animationIndex];
          const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
          const pendingNodes = [];
          const pendingInputAccessors = [];
          const pendingOutputAccessors = [];
          const pendingSamplers = [];
          const pendingTargets = [];
          for (let i5 = 0, il3 = animationDef.channels.length; i5 < il3; i5++) {
            const channel = animationDef.channels[i5];
            const sampler = animationDef.samplers[channel.sampler];
            const target = channel.target;
            const name2 = target.node;
            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
            if (target.node === void 0)
              continue;
            pendingNodes.push(this.getDependency("node", name2));
            pendingInputAccessors.push(this.getDependency("accessor", input));
            pendingOutputAccessors.push(this.getDependency("accessor", output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);
          }
          return Promise.all([
            Promise.all(pendingNodes),
            Promise.all(pendingInputAccessors),
            Promise.all(pendingOutputAccessors),
            Promise.all(pendingSamplers),
            Promise.all(pendingTargets)
          ]).then(function(dependencies) {
            const nodes = dependencies[0];
            const inputAccessors = dependencies[1];
            const outputAccessors = dependencies[2];
            const samplers = dependencies[3];
            const targets = dependencies[4];
            const tracks = [];
            for (let i5 = 0, il3 = nodes.length; i5 < il3; i5++) {
              const node = nodes[i5];
              const inputAccessor = inputAccessors[i5];
              const outputAccessor = outputAccessors[i5];
              const sampler = samplers[i5];
              const target = targets[i5];
              if (node === void 0)
                continue;
              if (node.updateMatrix) {
                node.updateMatrix();
              }
              const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
              if (createdTracks) {
                for (let k4 = 0; k4 < createdTracks.length; k4++) {
                  tracks.push(createdTracks[k4]);
                }
              }
            }
            return new AnimationClip(animationName, void 0, tracks);
          });
        }
        createNodeMesh(nodeIndex) {
          const json = this.json;
          const parser = this;
          const nodeDef = json.nodes[nodeIndex];
          if (nodeDef.mesh === void 0)
            return null;
          return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
            if (nodeDef.weights !== void 0) {
              node.traverse(function(o4) {
                if (!o4.isMesh)
                  return;
                for (let i5 = 0, il3 = nodeDef.weights.length; i5 < il3; i5++) {
                  o4.morphTargetInfluences[i5] = nodeDef.weights[i5];
                }
              });
            }
            return node;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
         * @param {number} nodeIndex
         * @return {Promise<Object3D>}
         */
        loadNode(nodeIndex) {
          const json = this.json;
          const parser = this;
          const nodeDef = json.nodes[nodeIndex];
          const nodePending = parser._loadNodeShallow(nodeIndex);
          const childPending = [];
          const childrenDef = nodeDef.children || [];
          for (let i5 = 0, il3 = childrenDef.length; i5 < il3; i5++) {
            childPending.push(parser.getDependency("node", childrenDef[i5]));
          }
          const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
          return Promise.all([
            nodePending,
            Promise.all(childPending),
            skeletonPending
          ]).then(function(results) {
            const node = results[0];
            const children = results[1];
            const skeleton = results[2];
            if (skeleton !== null) {
              node.traverse(function(mesh) {
                if (!mesh.isSkinnedMesh)
                  return;
                mesh.bind(skeleton, _identityMatrix2);
              });
            }
            for (let i5 = 0, il3 = children.length; i5 < il3; i5++) {
              node.add(children[i5]);
            }
            return node;
          });
        }
        // ._loadNodeShallow() parses a single node.
        // skin and child nodes are created and added in .loadNode() (no '_' prefix).
        _loadNodeShallow(nodeIndex) {
          const json = this.json;
          const extensions = this.extensions;
          const parser = this;
          if (this.nodeCache[nodeIndex] !== void 0) {
            return this.nodeCache[nodeIndex];
          }
          const nodeDef = json.nodes[nodeIndex];
          const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
          const pending = [];
          const meshPromise = parser._invokeOne(function(ext) {
            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
          });
          if (meshPromise) {
            pending.push(meshPromise);
          }
          if (nodeDef.camera !== void 0) {
            pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
              return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
            }));
          }
          parser._invokeAll(function(ext) {
            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
          }).forEach(function(promise) {
            pending.push(promise);
          });
          this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
            let node;
            if (nodeDef.isBone === true) {
              node = new Bone();
            } else if (objects.length > 1) {
              node = new Group();
            } else if (objects.length === 1) {
              node = objects[0];
            } else {
              node = new Object3D();
            }
            if (node !== objects[0]) {
              for (let i5 = 0, il3 = objects.length; i5 < il3; i5++) {
                node.add(objects[i5]);
              }
            }
            if (nodeDef.name) {
              node.userData.name = nodeDef.name;
              node.name = nodeName;
            }
            assignExtrasToUserData(node, nodeDef);
            if (nodeDef.extensions)
              addUnknownExtensionsToUserData(extensions, node, nodeDef);
            if (nodeDef.matrix !== void 0) {
              const matrix = new Matrix4();
              matrix.fromArray(nodeDef.matrix);
              node.applyMatrix4(matrix);
            } else {
              if (nodeDef.translation !== void 0) {
                node.position.fromArray(nodeDef.translation);
              }
              if (nodeDef.rotation !== void 0) {
                node.quaternion.fromArray(nodeDef.rotation);
              }
              if (nodeDef.scale !== void 0) {
                node.scale.fromArray(nodeDef.scale);
              }
            }
            if (!parser.associations.has(node)) {
              parser.associations.set(node, {});
            }
            parser.associations.get(node).nodes = nodeIndex;
            return node;
          });
          return this.nodeCache[nodeIndex];
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
         * @param {number} sceneIndex
         * @return {Promise<Group>}
         */
        loadScene(sceneIndex) {
          const extensions = this.extensions;
          const sceneDef = this.json.scenes[sceneIndex];
          const parser = this;
          const scene = new Group();
          if (sceneDef.name)
            scene.name = parser.createUniqueName(sceneDef.name);
          assignExtrasToUserData(scene, sceneDef);
          if (sceneDef.extensions)
            addUnknownExtensionsToUserData(extensions, scene, sceneDef);
          const nodeIds = sceneDef.nodes || [];
          const pending = [];
          for (let i5 = 0, il3 = nodeIds.length; i5 < il3; i5++) {
            pending.push(parser.getDependency("node", nodeIds[i5]));
          }
          return Promise.all(pending).then(function(nodes) {
            for (let i5 = 0, il3 = nodes.length; i5 < il3; i5++) {
              scene.add(nodes[i5]);
            }
            const reduceAssociations = (node) => {
              const reducedAssociations = /* @__PURE__ */ new Map();
              for (const [key, value] of parser.associations) {
                if (key instanceof Material || key instanceof Texture) {
                  reducedAssociations.set(key, value);
                }
              }
              node.traverse((node2) => {
                const mappings = parser.associations.get(node2);
                if (mappings != null) {
                  reducedAssociations.set(node2, mappings);
                }
              });
              return reducedAssociations;
            };
            parser.associations = reduceAssociations(scene);
            return scene;
          });
        }
        _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
          const tracks = [];
          const targetName = node.name ? node.name : node.uuid;
          const targetNames = [];
          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            node.traverse(function(object) {
              if (object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }
          let TypedKeyframeTrack;
          switch (PATH_PROPERTIES[target.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;
            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = QuaternionKeyframeTrack;
              break;
            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
            default:
              switch (outputAccessor.itemSize) {
                case 1:
                  TypedKeyframeTrack = NumberKeyframeTrack;
                  break;
                case 2:
                case 3:
                default:
                  TypedKeyframeTrack = VectorKeyframeTrack;
                  break;
              }
              break;
          }
          const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
          const outputArray = this._getArrayFromAccessor(outputAccessor);
          for (let j4 = 0, jl3 = targetNames.length; j4 < jl3; j4++) {
            const track = new TypedKeyframeTrack(
              targetNames[j4] + "." + PATH_PROPERTIES[target.path],
              inputAccessor.array,
              outputArray,
              interpolation
            );
            if (sampler.interpolation === "CUBICSPLINE") {
              this._createCubicSplineTrackInterpolant(track);
            }
            tracks.push(track);
          }
          return tracks;
        }
        _getArrayFromAccessor(accessor) {
          let outputArray = accessor.array;
          if (accessor.normalized) {
            const scale4 = getNormalizedComponentScale(outputArray.constructor);
            const scaled = new Float32Array(outputArray.length);
            for (let j4 = 0, jl3 = outputArray.length; j4 < jl3; j4++) {
              scaled[j4] = outputArray[j4] * scale4;
            }
            outputArray = scaled;
          }
          return outputArray;
        }
        _createCubicSplineTrackInterpolant(track) {
          track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
            const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
          };
          track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/util.js
  var getTypedKeys;
  var init_util = __esm({
    "node_modules/@sermas/toolkit/avatar/util.js"() {
      getTypedKeys = (object) => object ? Object.keys(object) : [];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/animation.base.js
  var AnimationBase;
  var init_animation_base = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/animation.base.js"() {
      AnimationBase = class {
        constructor(avatar) {
          this.avatar = avatar;
          this.filterMeshRegExp = void 0;
          const config = avatar.getConfig();
          if (config.animations?.filterMesh !== void 0 && config.animations?.filterMesh) {
            this.filterMeshRegExp = config.animations?.filterMesh;
          }
        }
        getConfig() {
          return this.avatar.getConfig();
        }
        getModel() {
          return this.avatar.getModel();
        }
        getScene() {
          return this.avatar.getScene();
        }
        isStopped() {
          return this.avatar.isStopped();
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/animator/index.js
  var Animator;
  var init_animator = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/animator/index.js"() {
      init_logger();
      init_three_module();
      Animator = class {
        constructor(model, scene, camera, isRPM) {
          this.logger = new Logger("Animator");
          this.bones = {};
          this.isRPM = isRPM;
          this.scene = scene;
          this.camera = camera;
          this.init(model);
        }
        init(model) {
          model.traverse((child) => {
            if (child.morphTargetInfluences) {
              if (child.name == "Wolf3D_Head") {
                this.morphTargets = child.morphTargetInfluences;
                this.morphDict = child.morphTargetDictionary;
              }
            }
          });
          const skeletonHelper = new SkeletonHelper(model);
          this.skeleton = new Skeleton(skeletonHelper.bones);
          this.loadBones();
          this.lookAt(this.camera.position);
        }
        getBone(name2) {
          const bone = this.skeleton.getBoneByName(`${name2}`);
          if (!bone) {
            this.logger.error(`${name2} bone not found`);
            return new Bone();
          }
          return bone;
        }
        loadBones() {
          const prefix = this.isRPM ? "" : "mixamorig";
          this.bones.neck = this.getBone(`${prefix}Head`);
          this.bones.leftEye = this.getBone(`${prefix}LeftEye`);
          this.bones.rightEye = this.getBone(`${prefix}RightEye`);
        }
        pixelToPerc(val, isHeight = false) {
          if (isHeight) {
            return val / window.innerHeight;
          }
          return val / window.innerWidth;
        }
        lookAt(target) {
          this.bones.leftEye.lookAt(target);
          this.bones.rightEye.lookAt(target);
        }
        setEyesTarget(x4, y3) {
          if (this.eyesResetTimeout) {
            clearTimeout(this.eyesResetTimeout);
          }
          this.eyesResetTimeout = setTimeout(() => {
            this.lookAt(this.camera.position);
          }, 5e3);
          const down = y3;
          const left = x4 - 0.2;
          const center_x = 200;
          const center_y = 200;
          let dist = Math.sqrt(Math.pow(center_x - x4, 2) + Math.pow(center_y - y3, 2));
          dist = 10;
          const scale4 = 3;
          const target = new Vector3(left * scale4, down * scale4, dist);
          this.lookAt(target);
        }
        animate(results) {
        }
        moveEyes(position) {
          this.setEyesTarget(position.x, position.y);
        }
      };
    }
  });

  // node_modules/three/examples/jsm/libs/lil-gui.module.min.js
  function e(t4) {
    let i5, e4;
    return (i5 = t4.match(/(#|0x)?([a-f0-9]{6})/i)) ? e4 = i5[2] : (i5 = t4.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? e4 = parseInt(i5[1]).toString(16).padStart(2, 0) + parseInt(i5[2]).toString(16).padStart(2, 0) + parseInt(i5[3]).toString(16).padStart(2, 0) : (i5 = t4.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (e4 = i5[1] + i5[1] + i5[2] + i5[2] + i5[3] + i5[3]), !!e4 && "#" + e4;
  }
  var t, i, s, n, l, r, o, a, h, d, c, u, p, g;
  var init_lil_gui_module_min = __esm({
    "node_modules/three/examples/jsm/libs/lil-gui.module.min.js"() {
      t = class _t3 {
        constructor(i5, e4, s4, n4, l4 = "div") {
          this.parent = i5, this.object = e4, this.property = s4, this._disabled = false, this._hidden = false, this.initialValue = this.getValue(), this.domElement = document.createElement("div"), this.domElement.classList.add("controller"), this.domElement.classList.add(n4), this.$name = document.createElement("div"), this.$name.classList.add("name"), _t3.nextNameID = _t3.nextNameID || 0, this.$name.id = "lil-gui-name-" + ++_t3.nextNameID, this.$widget = document.createElement(l4), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(s4);
        }
        name(t4) {
          return this._name = t4, this.$name.innerHTML = t4, this;
        }
        onChange(t4) {
          return this._onChange = t4, this;
        }
        _callOnChange() {
          this.parent._callOnChange(this), void 0 !== this._onChange && this._onChange.call(this, this.getValue()), this._changed = true;
        }
        onFinishChange(t4) {
          return this._onFinishChange = t4, this;
        }
        _callOnFinishChange() {
          this._changed && (this.parent._callOnFinishChange(this), void 0 !== this._onFinishChange && this._onFinishChange.call(this, this.getValue())), this._changed = false;
        }
        reset() {
          return this.setValue(this.initialValue), this._callOnFinishChange(), this;
        }
        enable(t4 = true) {
          return this.disable(!t4);
        }
        disable(t4 = true) {
          return t4 === this._disabled || (this._disabled = t4, this.domElement.classList.toggle("disabled", t4), this.$disable.toggleAttribute("disabled", t4)), this;
        }
        show(t4 = true) {
          return this._hidden = !t4, this.domElement.style.display = this._hidden ? "none" : "", this;
        }
        hide() {
          return this.show(false);
        }
        options(t4) {
          const i5 = this.parent.add(this.object, this.property, t4);
          return i5.name(this._name), this.destroy(), i5;
        }
        min(t4) {
          return this;
        }
        max(t4) {
          return this;
        }
        step(t4) {
          return this;
        }
        decimals(t4) {
          return this;
        }
        listen(t4 = true) {
          return this._listening = t4, void 0 !== this._listenCallbackID && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this;
        }
        _listenCallback() {
          this._listenCallbackID = requestAnimationFrame(this._listenCallback);
          const t4 = this.save();
          t4 !== this._listenPrevValue && this.updateDisplay(), this._listenPrevValue = t4;
        }
        getValue() {
          return this.object[this.property];
        }
        setValue(t4) {
          return this.object[this.property] = t4, this._callOnChange(), this.updateDisplay(), this;
        }
        updateDisplay() {
          return this;
        }
        load(t4) {
          return this.setValue(t4), this._callOnFinishChange(), this;
        }
        save() {
          return this.getValue();
        }
        destroy() {
          this.listen(false), this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement);
        }
      };
      i = class extends t {
        constructor(t4, i5, e4) {
          super(t4, i5, e4, "boolean", "label"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "checkbox"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$input.addEventListener("change", () => {
            this.setValue(this.$input.checked), this._callOnFinishChange();
          }), this.$disable = this.$input, this.updateDisplay();
        }
        updateDisplay() {
          return this.$input.checked = this.getValue(), this;
        }
      };
      s = { isPrimitive: true, match: (t4) => "string" == typeof t4, fromHexString: e, toHexString: e };
      n = { isPrimitive: true, match: (t4) => "number" == typeof t4, fromHexString: (t4) => parseInt(t4.substring(1), 16), toHexString: (t4) => "#" + t4.toString(16).padStart(6, 0) };
      l = { isPrimitive: false, match: Array.isArray, fromHexString(t4, i5, e4 = 1) {
        const s4 = n.fromHexString(t4);
        i5[0] = (s4 >> 16 & 255) / 255 * e4, i5[1] = (s4 >> 8 & 255) / 255 * e4, i5[2] = (255 & s4) / 255 * e4;
      }, toHexString: ([t4, i5, e4], s4 = 1) => n.toHexString(t4 * (s4 = 255 / s4) << 16 ^ i5 * s4 << 8 ^ e4 * s4 << 0) };
      r = { isPrimitive: false, match: (t4) => Object(t4) === t4, fromHexString(t4, i5, e4 = 1) {
        const s4 = n.fromHexString(t4);
        i5.r = (s4 >> 16 & 255) / 255 * e4, i5.g = (s4 >> 8 & 255) / 255 * e4, i5.b = (255 & s4) / 255 * e4;
      }, toHexString: ({ r: t4, g: i5, b: e4 }, s4 = 1) => n.toHexString(t4 * (s4 = 255 / s4) << 16 ^ i5 * s4 << 8 ^ e4 * s4 << 0) };
      o = [s, n, l, r];
      a = class extends t {
        constructor(t4, i5, s4, n4) {
          var l4;
          super(t4, i5, s4, "color"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "color"), this.$input.setAttribute("tabindex", -1), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$text = document.createElement("input"), this.$text.setAttribute("type", "text"), this.$text.setAttribute("spellcheck", "false"), this.$text.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$display.appendChild(this.$input), this.$widget.appendChild(this.$display), this.$widget.appendChild(this.$text), this._format = (l4 = this.initialValue, o.find((t5) => t5.match(l4))), this._rgbScale = n4, this._initialValueHexString = this.save(), this._textFocused = false, this.$input.addEventListener("input", () => {
            this._setValueFromHexString(this.$input.value);
          }), this.$input.addEventListener("blur", () => {
            this._callOnFinishChange();
          }), this.$text.addEventListener("input", () => {
            const t5 = e(this.$text.value);
            t5 && this._setValueFromHexString(t5);
          }), this.$text.addEventListener("focus", () => {
            this._textFocused = true, this.$text.select();
          }), this.$text.addEventListener("blur", () => {
            this._textFocused = false, this.updateDisplay(), this._callOnFinishChange();
          }), this.$disable = this.$text, this.updateDisplay();
        }
        reset() {
          return this._setValueFromHexString(this._initialValueHexString), this;
        }
        _setValueFromHexString(t4) {
          if (this._format.isPrimitive) {
            const i5 = this._format.fromHexString(t4);
            this.setValue(i5);
          } else
            this._format.fromHexString(t4, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay();
        }
        save() {
          return this._format.toHexString(this.getValue(), this._rgbScale);
        }
        load(t4) {
          return this._setValueFromHexString(t4), this._callOnFinishChange(), this;
        }
        updateDisplay() {
          return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this;
        }
      };
      h = class extends t {
        constructor(t4, i5, e4) {
          super(t4, i5, e4, "function"), this.$button = document.createElement("button"), this.$button.appendChild(this.$name), this.$widget.appendChild(this.$button), this.$button.addEventListener("click", (t5) => {
            t5.preventDefault(), this.getValue().call(this.object);
          }), this.$button.addEventListener("touchstart", () => {
          }, { passive: true }), this.$disable = this.$button;
        }
      };
      d = class extends t {
        constructor(t4, i5, e4, s4, n4, l4) {
          super(t4, i5, e4, "number"), this._initInput(), this.min(s4), this.max(n4);
          const r4 = void 0 !== l4;
          this.step(r4 ? l4 : this._getImplicitStep(), r4), this.updateDisplay();
        }
        decimals(t4) {
          return this._decimals = t4, this.updateDisplay(), this;
        }
        min(t4) {
          return this._min = t4, this._onUpdateMinMax(), this;
        }
        max(t4) {
          return this._max = t4, this._onUpdateMinMax(), this;
        }
        step(t4, i5 = true) {
          return this._step = t4, this._stepExplicit = i5, this;
        }
        updateDisplay() {
          const t4 = this.getValue();
          if (this._hasSlider) {
            let i5 = (t4 - this._min) / (this._max - this._min);
            i5 = Math.max(0, Math.min(i5, 1)), this.$fill.style.width = 100 * i5 + "%";
          }
          return this._inputFocused || (this.$input.value = void 0 === this._decimals ? t4 : t4.toFixed(this._decimals)), this;
        }
        _initInput() {
          this.$input = document.createElement("input"), this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$disable = this.$input;
          const t4 = (t5) => {
            const i6 = parseFloat(this.$input.value);
            isNaN(i6) || (this._snapClampSetValue(i6 + t5), this.$input.value = this.getValue());
          };
          let i5, e4, s4, n4, l4, r4 = false;
          const o4 = (t5) => {
            if (r4) {
              const s5 = t5.clientX - i5, n5 = t5.clientY - e4;
              Math.abs(n5) > 5 ? (t5.preventDefault(), this.$input.blur(), r4 = false, this._setDraggingStyle(true, "vertical")) : Math.abs(s5) > 5 && a4();
            }
            if (!r4) {
              const i6 = t5.clientY - s4;
              l4 -= i6 * this._step * this._arrowKeyMultiplier(t5), n4 + l4 > this._max ? l4 = this._max - n4 : n4 + l4 < this._min && (l4 = this._min - n4), this._snapClampSetValue(n4 + l4);
            }
            s4 = t5.clientY;
          }, a4 = () => {
            this._setDraggingStyle(false, "vertical"), this._callOnFinishChange(), window.removeEventListener("mousemove", o4), window.removeEventListener("mouseup", a4);
          };
          this.$input.addEventListener("input", () => {
            let t5 = parseFloat(this.$input.value);
            isNaN(t5) || (this._stepExplicit && (t5 = this._snap(t5)), this.setValue(this._clamp(t5)));
          }), this.$input.addEventListener("keydown", (i6) => {
            "Enter" === i6.code && this.$input.blur(), "ArrowUp" === i6.code && (i6.preventDefault(), t4(this._step * this._arrowKeyMultiplier(i6))), "ArrowDown" === i6.code && (i6.preventDefault(), t4(this._step * this._arrowKeyMultiplier(i6) * -1));
          }), this.$input.addEventListener("wheel", (i6) => {
            this._inputFocused && (i6.preventDefault(), t4(this._step * this._normalizeMouseWheel(i6)));
          }, { passive: false }), this.$input.addEventListener("mousedown", (t5) => {
            i5 = t5.clientX, e4 = s4 = t5.clientY, r4 = true, n4 = this.getValue(), l4 = 0, window.addEventListener("mousemove", o4), window.addEventListener("mouseup", a4);
          }), this.$input.addEventListener("focus", () => {
            this._inputFocused = true;
          }), this.$input.addEventListener("blur", () => {
            this._inputFocused = false, this.updateDisplay(), this._callOnFinishChange();
          });
        }
        _initSlider() {
          this._hasSlider = true, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
          const t4 = (t5) => {
            const i6 = this.$slider.getBoundingClientRect();
            let e5 = (s5 = t5, n5 = i6.left, l5 = i6.right, r5 = this._min, o5 = this._max, (s5 - n5) / (l5 - n5) * (o5 - r5) + r5);
            var s5, n5, l5, r5, o5;
            this._snapClampSetValue(e5);
          }, i5 = (i6) => {
            t4(i6.clientX);
          }, e4 = () => {
            this._callOnFinishChange(), this._setDraggingStyle(false), window.removeEventListener("mousemove", i5), window.removeEventListener("mouseup", e4);
          };
          let s4, n4, l4 = false;
          const r4 = (i6) => {
            i6.preventDefault(), this._setDraggingStyle(true), t4(i6.touches[0].clientX), l4 = false;
          }, o4 = (i6) => {
            if (l4) {
              const t5 = i6.touches[0].clientX - s4, e5 = i6.touches[0].clientY - n4;
              Math.abs(t5) > Math.abs(e5) ? r4(i6) : (window.removeEventListener("touchmove", o4), window.removeEventListener("touchend", a4));
            } else
              i6.preventDefault(), t4(i6.touches[0].clientX);
          }, a4 = () => {
            this._callOnFinishChange(), this._setDraggingStyle(false), window.removeEventListener("touchmove", o4), window.removeEventListener("touchend", a4);
          }, h4 = this._callOnFinishChange.bind(this);
          let d4;
          this.$slider.addEventListener("mousedown", (s5) => {
            this._setDraggingStyle(true), t4(s5.clientX), window.addEventListener("mousemove", i5), window.addEventListener("mouseup", e4);
          }), this.$slider.addEventListener("touchstart", (t5) => {
            t5.touches.length > 1 || (this._hasScrollBar ? (s4 = t5.touches[0].clientX, n4 = t5.touches[0].clientY, l4 = true) : r4(t5), window.addEventListener("touchmove", o4, { passive: false }), window.addEventListener("touchend", a4));
          }, { passive: false }), this.$slider.addEventListener("wheel", (t5) => {
            if (Math.abs(t5.deltaX) < Math.abs(t5.deltaY) && this._hasScrollBar)
              return;
            t5.preventDefault();
            const i6 = this._normalizeMouseWheel(t5) * this._step;
            this._snapClampSetValue(this.getValue() + i6), this.$input.value = this.getValue(), clearTimeout(d4), d4 = setTimeout(h4, 400);
          }, { passive: false });
        }
        _setDraggingStyle(t4, i5 = "horizontal") {
          this.$slider && this.$slider.classList.toggle("active", t4), document.body.classList.toggle("lil-gui-dragging", t4), document.body.classList.toggle("lil-gui-" + i5, t4);
        }
        _getImplicitStep() {
          return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1;
        }
        _onUpdateMinMax() {
          !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), false), this._initSlider(), this.updateDisplay());
        }
        _normalizeMouseWheel(t4) {
          let { deltaX: i5, deltaY: e4 } = t4;
          Math.floor(t4.deltaY) !== t4.deltaY && t4.wheelDelta && (i5 = 0, e4 = -t4.wheelDelta / 120, e4 *= this._stepExplicit ? 1 : 10);
          return i5 + -e4;
        }
        _arrowKeyMultiplier(t4) {
          let i5 = this._stepExplicit ? 1 : 10;
          return t4.shiftKey ? i5 *= 10 : t4.altKey && (i5 /= 10), i5;
        }
        _snap(t4) {
          const i5 = Math.round(t4 / this._step) * this._step;
          return parseFloat(i5.toPrecision(15));
        }
        _clamp(t4) {
          return t4 < this._min && (t4 = this._min), t4 > this._max && (t4 = this._max), t4;
        }
        _snapClampSetValue(t4) {
          this.setValue(this._clamp(this._snap(t4)));
        }
        get _hasScrollBar() {
          const t4 = this.parent.root.$children;
          return t4.scrollHeight > t4.clientHeight;
        }
        get _hasMin() {
          return void 0 !== this._min;
        }
        get _hasMax() {
          return void 0 !== this._max;
        }
      };
      c = class extends t {
        constructor(t4, i5, e4, s4) {
          super(t4, i5, e4, "option"), this.$select = document.createElement("select"), this.$select.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this._values = Array.isArray(s4) ? s4 : Object.values(s4), this._names = Array.isArray(s4) ? s4 : Object.keys(s4), this._names.forEach((t5) => {
            const i6 = document.createElement("option");
            i6.innerHTML = t5, this.$select.appendChild(i6);
          }), this.$select.addEventListener("change", () => {
            this.setValue(this._values[this.$select.selectedIndex]), this._callOnFinishChange();
          }), this.$select.addEventListener("focus", () => {
            this.$display.classList.add("focus");
          }), this.$select.addEventListener("blur", () => {
            this.$display.classList.remove("focus");
          }), this.$widget.appendChild(this.$select), this.$widget.appendChild(this.$display), this.$disable = this.$select, this.updateDisplay();
        }
        updateDisplay() {
          const t4 = this.getValue(), i5 = this._values.indexOf(t4);
          return this.$select.selectedIndex = i5, this.$display.innerHTML = -1 === i5 ? t4 : this._names[i5], this;
        }
      };
      u = class extends t {
        constructor(t4, i5, e4) {
          super(t4, i5, e4, "string"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$input.addEventListener("input", () => {
            this.setValue(this.$input.value);
          }), this.$input.addEventListener("keydown", (t5) => {
            "Enter" === t5.code && this.$input.blur();
          }), this.$input.addEventListener("blur", () => {
            this._callOnFinishChange();
          }), this.$widget.appendChild(this.$input), this.$disable = this.$input, this.updateDisplay();
        }
        updateDisplay() {
          return this.$input.value = this.getValue(), this;
        }
      };
      p = false;
      g = class _g2 {
        constructor({ parent: t4, autoPlace: i5 = void 0 === t4, container: e4, width: s4, title: n4 = "Controls", injectStyles: l4 = true, touchStyles: r4 = true } = {}) {
          if (this.parent = t4, this.root = t4 ? t4.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = false, this._hidden = false, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", true), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", () => this.openAnimated(this._closed)), this.$title.addEventListener("keydown", (t5) => {
            "Enter" !== t5.code && "Space" !== t5.code || (t5.preventDefault(), this.$title.click());
          }), this.$title.addEventListener("touchstart", () => {
          }, { passive: true }), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(n4), r4 && this.domElement.classList.add("allow-touch-styles"), this.parent)
            return this.parent.children.push(this), this.parent.folders.push(this), void this.parent.$children.appendChild(this.domElement);
          this.domElement.classList.add("root"), !p && l4 && (!function(t5) {
            const i6 = document.createElement("style");
            i6.innerHTML = t5;
            const e5 = document.querySelector("head link[rel=stylesheet], head style");
            e5 ? document.head.insertBefore(i6, e5) : document.head.appendChild(i6);
          }('.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"\u2195";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"\u25BE";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"\u25B8"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"\u2713";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}'), p = true), e4 ? e4.appendChild(this.domElement) : i5 && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), s4 && this.domElement.style.setProperty("--width", s4 + "px"), this.domElement.addEventListener("keydown", (t5) => t5.stopPropagation()), this.domElement.addEventListener("keyup", (t5) => t5.stopPropagation());
        }
        add(t4, e4, s4, n4, l4) {
          if (Object(s4) === s4)
            return new c(this, t4, e4, s4);
          const r4 = t4[e4];
          switch (typeof r4) {
            case "number":
              return new d(this, t4, e4, s4, n4, l4);
            case "boolean":
              return new i(this, t4, e4);
            case "string":
              return new u(this, t4, e4);
            case "function":
              return new h(this, t4, e4);
          }
          console.error("gui.add failed\n	property:", e4, "\n	object:", t4, "\n	value:", r4);
        }
        addColor(t4, i5, e4 = 1) {
          return new a(this, t4, i5, e4);
        }
        addFolder(t4) {
          return new _g2({ parent: this, title: t4 });
        }
        load(t4, i5 = true) {
          return t4.controllers && this.controllers.forEach((i6) => {
            i6 instanceof h || i6._name in t4.controllers && i6.load(t4.controllers[i6._name]);
          }), i5 && t4.folders && this.folders.forEach((i6) => {
            i6._title in t4.folders && i6.load(t4.folders[i6._title]);
          }), this;
        }
        save(t4 = true) {
          const i5 = { controllers: {}, folders: {} };
          return this.controllers.forEach((t5) => {
            if (!(t5 instanceof h)) {
              if (t5._name in i5.controllers)
                throw new Error(`Cannot save GUI with duplicate property "${t5._name}"`);
              i5.controllers[t5._name] = t5.save();
            }
          }), t4 && this.folders.forEach((t5) => {
            if (t5._title in i5.folders)
              throw new Error(`Cannot save GUI with duplicate folder "${t5._title}"`);
            i5.folders[t5._title] = t5.save();
          }), i5;
        }
        open(t4 = true) {
          return this._closed = !t4, this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this;
        }
        close() {
          return this.open(false);
        }
        show(t4 = true) {
          return this._hidden = !t4, this.domElement.style.display = this._hidden ? "none" : "", this;
        }
        hide() {
          return this.show(false);
        }
        openAnimated(t4 = true) {
          return this._closed = !t4, this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame(() => {
            const i5 = this.$children.clientHeight;
            this.$children.style.height = i5 + "px", this.domElement.classList.add("transition");
            const e4 = (t5) => {
              t5.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", e4));
            };
            this.$children.addEventListener("transitionend", e4);
            const s4 = t4 ? this.$children.scrollHeight : 0;
            this.domElement.classList.toggle("closed", !t4), requestAnimationFrame(() => {
              this.$children.style.height = s4 + "px";
            });
          }), this;
        }
        title(t4) {
          return this._title = t4, this.$title.innerHTML = t4, this;
        }
        reset(t4 = true) {
          return (t4 ? this.controllersRecursive() : this.controllers).forEach((t5) => t5.reset()), this;
        }
        onChange(t4) {
          return this._onChange = t4, this;
        }
        _callOnChange(t4) {
          this.parent && this.parent._callOnChange(t4), void 0 !== this._onChange && this._onChange.call(this, { object: t4.object, property: t4.property, value: t4.getValue(), controller: t4 });
        }
        onFinishChange(t4) {
          return this._onFinishChange = t4, this;
        }
        _callOnFinishChange(t4) {
          this.parent && this.parent._callOnFinishChange(t4), void 0 !== this._onFinishChange && this._onFinishChange.call(this, { object: t4.object, property: t4.property, value: t4.getValue(), controller: t4 });
        }
        destroy() {
          this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach((t4) => t4.destroy());
        }
        controllersRecursive() {
          let t4 = Array.from(this.controllers);
          return this.folders.forEach((i5) => {
            t4 = t4.concat(i5.controllersRecursive());
          }), t4;
        }
        foldersRecursive() {
          let t4 = Array.from(this.folders);
          return this.folders.forEach((i5) => {
            t4 = t4.concat(i5.foldersRecursive());
          }), t4;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/angry.json
  var angry_default;
  var init_angry = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/angry.json"() {
      angry_default = [
        {
          index: 0,
          score: 31146998935582815e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.12202511727809906,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.079414963722229,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.0011697816662490368,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.02403600513935089,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.04333483800292015,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 566202390473336e-18,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 5327626126927498e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 18271987300977344e-22,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.20512261986732483,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.12996985018253326,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.30235350131988525,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.2873704731464386,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.02235325798392296,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.15749751031398773,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.1409347951412201,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.03434053808450699,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.03450843319296837,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.026469947770237923,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.4718779921531677,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.3156534433364868,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.004954138305038214,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.004765935707837343,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 0.0021025072783231735,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.0018396422965452075,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.058530133217573166,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 13475572632160038e-20,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.0018035740358754992,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.014251871034502983,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.001218835124745965,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 41948954458348453e-20,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 5325949168764055e-19,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.010880295187234879,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.12644077837467194,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.12121827900409698,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 0.1372513622045517,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.012385726906359196,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.020981786772608757,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.006018844433128834,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 9002251886158774e-22,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.00885757990181446,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.01637343131005764,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 6954487762413919e-19,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.013729064725339413,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 0.5172632932662964,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 0.48411914706230164,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 0.014998987317085266,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.09222601354122162,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.5258127450942993,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.40610599517822266,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 99920475804538e-20,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 2973544724227395e-21,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/disgust.json
  var disgust_default;
  var init_disgust = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/disgust.json"() {
      disgust_default = [
        {
          index: 0,
          score: 13888555940866354e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.3860434591770172,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.3619810938835144,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 965545405051671e-19,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.010158455930650234,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.012170204892754555,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 8275849395431578e-19,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 4258265278167528e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 5908779598939873e-22,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.2562994658946991,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.1982024759054184,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.3765765130519867,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.35346683859825134,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.008129140362143517,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.2508396506309509,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.24881471693515778,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.024446049705147743,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.02432764135301113,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.02140810526907444,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.6720457077026367,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.4988962411880493,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.002591195050626993,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.0029919822700321674,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 0.0017256265273317695,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.0024212165735661983,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.06316550076007843,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 23529326426796615e-20,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 9604489314369857e-19,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.007180497981607914,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.004029749892652035,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 11405700934119523e-20,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 9792584023671225e-20,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.019486594945192337,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.06459743529558182,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.22579094767570496,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 0.225372314453125,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.006221790798008442,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.015350667759776115,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.023871535435318947,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 27581434096646262e-22,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.0036444629076868296,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.00747070973739028,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 8235009736381471e-19,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.024706272408366203,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 0.46998074650764465,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 0.406308114528656,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 0.006638335529714823,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.006862149108201265,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.580317497253418,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.5144633650779724,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 7964570727381215e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 20329785002104472e-22,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/eyes_close.json
  var eyes_close_default;
  var init_eyes_close = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/eyes_close.json"() {
      eyes_close_default = [{
        index: 10,
        score: 1,
        categoryName: "eyeBlinkRight",
        displayName: ""
      }, {
        index: 9,
        score: 1,
        categoryName: "eyeBlinkLeft",
        displayName: ""
      }];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/eyes_open.json
  var eyes_open_default;
  var init_eyes_open = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/eyes_open.json"() {
      eyes_open_default = [{
        index: 10,
        score: 0,
        categoryName: "eyeBlinkRight",
        displayName: ""
      }, {
        index: 9,
        score: 0,
        categoryName: "eyeBlinkLeft",
        displayName: ""
      }];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/fear.json
  var fear_default;
  var init_fear = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/fear.json"() {
      fear_default = [
        {
          index: 0,
          score: 9175560080620926e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 16871381376404315e-21,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 17206728807650506e-20,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.8945149779319763,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.8573151230812073,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.379844069480896,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 8275280379166361e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 9766383755049901e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 33575531688256888e-22,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.004933416377753019,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.009029969573020935,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.40094640851020813,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.38921868801116943,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.02796860598027706,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.2242133468389511,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.21582168340682983,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.015424320474267006,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.021231841295957565,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.011761398054659367,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.026067377999424934,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.010701539926230907,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.12963120639324188,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.09238862246274948,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 17477972505730577e-21,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 20556866365950555e-20,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.02014615572988987,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 0.007284938357770443,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.0023973023053258657,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.005772181786596775,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.00208293623290956,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 10881687194341794e-20,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 30870045884512365e-20,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.0024106104392558336,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 6689815199933946e-19,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 30335807241499424e-20,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 5681509501300752e-19,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.005370288621634245,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.0028569037094712257,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.7925542593002319,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 0.0326157882809639,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.326907753944397,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.11734701693058014,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.17350995540618896,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.023998860269784927,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 6872486437714542e-22,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 5644464522447379e-22,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 7661135896341875e-21,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.0013855596771463752,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 29807433747919276e-21,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 16481584680150263e-21,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 5659342605213169e-21,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 22204321226126922e-23,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/happy.json
  var happy_default;
  var init_happy = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/happy.json"() {
      happy_default = [
        {
          index: 0,
          score: 3376105041752453e-21,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.08007711917161942,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.08877258747816086,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.007368626073002815,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.05030057206749916,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.03056645207107067,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 29939963133074343e-20,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 12625598628801527e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 9082379506253346e-22,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.15426139533519745,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.14469507336616516,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.30295124650001526,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.2807958424091339,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.05478493869304657,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.08809614181518555,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.08084604144096375,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.06086810678243637,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.036639463156461716,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.02983127534389496,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.34289082884788513,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.3587568998336792,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.006495383568108082,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.007008927408605814,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 7668629987165332e-19,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 4774076514877379e-19,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.010226869024336338,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 10034655861090869e-20,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 890886876732111e-18,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.010534120723605156,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.02456211857497692,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 4824432107852772e-20,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 42081512219738215e-21,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.012945222668349743,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.003386017633602023,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.0260978564620018,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 0.03419683128595352,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.05333373695611954,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.14260604977607727,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.010078176856040955,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 38762204349040985e-20,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.003989920020103455,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.019912822172045708,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.0049530453979969025,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.018191926181316376,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 0.9084819555282593,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 0.9294198751449585,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 0.013155139051377773,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.013700329698622227,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.6547701358795166,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.7074416875839233,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 13109854535287013e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 264044479081349e-20,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/neutral.json
  var neutral_default;
  var init_neutral = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/neutral.json"() {
      neutral_default = [
        {
          index: 0,
          score: 17088963204514585e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.06596320122480392,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.04881156608462334,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.002793708350509405,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.06535282731056213,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.05755187198519707,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 6267382559599355e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 1355523693291616e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 2652713817496988e-22,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.15191787481307983,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.11332893371582031,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.14745189249515533,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.13728508353233337,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.04368281364440918,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.07041669636964798,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.07537584006786346,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.052627332508563995,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.052172545343637466,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.054241523146629333,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.3655259609222412,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.3467720150947571,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.003595831338316202,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.0030374466441571712,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 8723687642486766e-21,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 999380717985332e-18,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.010234937071800232,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 772743733250536e-19,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.0020893460605293512,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.002543865703046322,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.004154594149440527,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 3133558784611523e-19,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 4556537314783782e-19,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 3735879436135292e-19,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.00248367409221828,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 10913725418504328e-20,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 650070360279642e-19,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.023392336443066597,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.046846501529216766,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.030865289270877838,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 7158457883633673e-19,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.08874211460351944,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.020436905324459076,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.16089430451393127,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.01930229552090168,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 4601913315127604e-20,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 5725476876250468e-20,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 25718490360304713e-20,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.0013743136078119278,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 4415023067849688e-20,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 7722692680545151e-20,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 472223888436929e-21,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 32183780263039807e-23,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/sad.json
  var sad_default;
  var init_sad = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/sad.json"() {
      sad_default = [
        {
          index: 0,
          score: 5598607458523475e-21,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.06300339102745056,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.07175912708044052,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.06267412006855011,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.054822295904159546,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.02259214036166668,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 7561995516880415e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 25410543003090424e-23,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 6612635843339376e-22,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.2507481276988983,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.2579236626625061,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.5937086343765259,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.5426660776138306,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.007969372905790806,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.2853552997112274,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.2679644525051117,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.017895091325044632,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.009807043708860874,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.006413142662495375,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.18625064194202423,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.13103772699832916,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.0032693338580429554,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.002714985515922308,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 34417373626638437e-22,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 20978505199309438e-20,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.0015311554307118058,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 6408304034266621e-20,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 7625800935784355e-20,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.03330376371741295,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.02821914479136467,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 0.0017830142751336098,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 0.002867334522306919,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 7036778697511181e-20,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.001090176054276526,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 1814083407225553e-20,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 8524994882463943e-21,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.15149599313735962,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.15303419530391693,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 8403615211136639e-19,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 0.0022807808127254248,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.03194635733962059,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.004878072068095207,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.9746707081794739,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.6640940308570862,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 0.01863987371325493,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 0.024529961869120598,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 0.002515125088393688,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.01814049854874611,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.024997973814606667,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.024662990123033524,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 15016406678114436e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 12249528253960307e-22,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/surprise.json
  var surprise_default;
  var init_surprise = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/surprise.json"() {
      surprise_default = [
        {
          index: 0,
          score: 3909997587925318e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 812329089967534e-19,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 5046099977334961e-20,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.831498920917511,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.6804746389389038,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.5799413919448853,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 75645343713404145e-22,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 14575695104213082e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 482651671518397e-21,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.050102025270462036,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.02210935950279236,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.5937166213989258,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.5916911363601685,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.10804039239883423,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.05065017193555832,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.04483450576663017,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.11335204541683197,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.008635475300252438,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.006642817985266447,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.07992427796125412,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.06591271609067917,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.021875863894820213,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.05043920874595642,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 21434376321849413e-21,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.005684222560375929,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.26605480909347534,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 0.007258694618940353,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.011939202435314655,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.0016010596882551908,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.0029089925810694695,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 16238094758591615e-21,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 2368194327573292e-20,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.06705708056688309,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.004238925874233246,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 9005393367260695e-19,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 6260065129026771e-19,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 28900045435875654e-20,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.0010341332526877522,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.9570332765579224,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 0.005450753029435873,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.08946340531110764,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.09793296456336975,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.028418129310011864,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.01701507158577442,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 26850659651245223e-23,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 2271618910754114e-22,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 4804212494491367e-21,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 345734333677683e-19,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 11225818161619827e-20,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 11235820420552045e-20,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 13908583014199394e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 16918357914619264e-23,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_A.json
  var viseme_A_default;
  var init_viseme_A = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_A.json"() {
      viseme_A_default = [
        {
          index: 0,
          score: 21803909930895315e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.08363643288612366,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.0508524514734745,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.012287103570997715,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.027952292934060097,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.022305820137262344,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 9152348502539098e-20,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 5203402793085843e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 31009071221888007e-23,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.1738348752260208,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.11646311730146408,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.3514833152294159,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.34324193000793457,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.09117495268583298,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.04076579213142395,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.044019199907779694,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.078274667263031,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.02107238583266735,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.01834831014275551,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.2520901560783386,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.23951762914657593,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.0038976024370640516,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.003104546805843711,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 1299295836361125e-19,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.034885652363300323,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.42860937118530273,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 1190978437080048e-19,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.00700392434373498,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.007756737060844898,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.004655333701521158,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 0.0016884779324755073,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 0.002314203418791294,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.004657216370105743,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.0014698123559355736,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.007842869497835636,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 0.007628834340721369,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.02960706688463688,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.04060244932770729,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.001956538064405322,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 8913888450479135e-20,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.012471158057451248,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.011515446938574314,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.015703553333878517,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.05721293389797211,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 0.002061746548861265,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 0.0016954917227849364,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 0.0013627068838104606,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.0018462304724380374,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.017731482163071632,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.01698959246277809,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 7925836484901083e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 2928013827840914e-21,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_R.json
  var viseme_R_default;
  var init_viseme_R = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_R.json"() {
      viseme_R_default = [
        {
          index: 0,
          score: 14633357068305486e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.05387187376618385,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.035134218633174896,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.017924930900335312,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.060742996633052826,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.026589689776301384,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 5790775321656838e-20,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 11070593473050394e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 14683779170354683e-23,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.21599295735359192,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.1655154526233673,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.3848760426044464,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.3788372874259949,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.042179860174655914,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.08077599108219147,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.07709444314241409,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.0431082509458065,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.017549781128764153,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.01577386073768139,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.20437440276145935,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.2589115798473358,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.0033932968508452177,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.002355279168114066,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 1040301431203261e-19,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.013495323248207569,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.21737347543239594,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 1055764514603652e-19,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.005412518512457609,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 5334721645340323e-19,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.006030800752341747,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 0.005574377253651619,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 0.0040961503982543945,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.010012870654463768,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 7811011164449155e-19,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.01960122026503086,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 0.008371779695153236,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.003953998442739248,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.02408779226243496,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.013278709724545479,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 3238014760427177e-19,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.02210543118417263,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.006220254581421614,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.03332764282822609,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.188176691532135,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 4306816845200956e-19,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 5655061104334891e-19,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 0.0022264313884079456,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 6804327131249011e-19,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.12191426753997803,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.2575533390045166,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 7443903200510249e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 15198442042674287e-22,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_I.json
  var viseme_I_default;
  var init_viseme_I = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_I.json"() {
      viseme_I_default = [
        {
          index: 0,
          score: 18368413066127687e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.03427436947822571,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.030819710344076157,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.016365086659789085,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.08926714956760406,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.033123649656772614,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 22432081095757894e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 3157209675919148e-22,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 14139308746052848e-23,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.26403704285621643,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.25644615292549133,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.4780615270137787,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.47856414318084717,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.008290532976388931,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.2703847885131836,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.25793787837028503,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.011919054202735424,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.011744207702577114,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.009668879210948944,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.20730678737163544,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.26966917514801025,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.0023520870599895716,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.0011060016695410013,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 5933424472459592e-20,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.0015950159868225455,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.024187013506889343,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 5766330286860466e-20,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.003986869007349014,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 8463463163934648e-19,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.0042655072174966335,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 0.0025341494474560022,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 0.003364859614521265,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.0017169634811580181,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.001084326533600688,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.001007332350127399,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 5847426946274936e-19,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.01576109603047371,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.09030764549970627,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.004029520321637392,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 3932149847969413e-19,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.020040905103087425,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.008632638491690159,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.032590750604867935,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.07229644060134888,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 8027702569961548e-19,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 0.0014607857447117567,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 984087586402893e-18,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.004211658611893654,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 0.003714581485837698,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 0.007825886830687523,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 8092116559055285e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 11934928352275165e-22,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_O.json
  var viseme_O_default;
  var init_viseme_O = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_O.json"() {
      viseme_O_default = [
        {
          index: 0,
          score: 6231797442524112e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.047416966408491135,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.039295390248298645,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.015113890171051025,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.06493847072124481,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.0380944199860096,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 10984535947500262e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 26089807647622365e-23,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 122491044862727e-21,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.20573699474334717,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.16145706176757812,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.33147233724594116,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.33260640501976013,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.030819909647107124,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.09622488915920258,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.1022229790687561,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.04357973486185074,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.02262393943965435,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.01972467638552189,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.2309904843568802,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.28694480657577515,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.004151293076574802,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.0034393637906759977,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 27112060706713237e-21,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.010560309514403343,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.16598932445049286,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 5467729060910642e-19,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.009863607585430145,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.0016950462013483047,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.005007538944482803,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 402131445298437e-20,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 5075879471405642e-21,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.07195696234703064,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.005458215717226267,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 0.0016122544184327126,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 8345688111148775e-19,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 696909090038389e-18,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.0024417894892394543,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.7966775894165039,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 0.0012870302889496088,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.03605373576283455,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.09704086184501648,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.006554194260388613,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.036077916622161865,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 29237864964670734e-22,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 31167055567493662e-22,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 11489370081108063e-21,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 3548900713212788e-20,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 5132965743541718e-19,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 8066545706242323e-19,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 5614999736280879e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 2660154336808773e-22,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_U.json
  var viseme_U_default;
  var init_viseme_U = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_U.json"() {
      viseme_U_default = [
        {
          index: 0,
          score: 2906686518144852e-22,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.06839989870786667,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.050818298012018204,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.01684984192252159,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.06740451604127884,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.04761263728141785,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 2831543042702833e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 7801196488799178e-23,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 4118138363651269e-23,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.2694171667098999,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.2093409150838852,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.3619375228881836,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.35875609517097473,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.04310642555356026,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.07583697140216827,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.08481767028570175,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.05711514875292778,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.02178993634879589,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.02126617170870304,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.2236364632844925,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.2606903612613678,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.00313507579267025,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.0024375685025006533,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 12107637303415686e-21,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.0020398234482854605,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.005487476475536823,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 6560800829902291e-20,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.002785251010209322,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 2902377746067941e-19,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.0013295924291014671,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 11089452891610563e-20,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 10315719555364922e-20,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 0.005804609041661024,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.005318634212017059,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 13158157526049763e-20,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 4262859874870628e-20,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 5981039139442146e-19,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.003037357237190008,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.7936274409294128,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 8130481583066285e-19,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.004528038203716278,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.003158071544021368,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.018536308780312538,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.014622112736105919,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 1347362922388129e-20,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 15821788110770285e-21,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 26323628844693303e-20,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 2237324952147901e-19,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 13321229198481888e-20,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 2725329250097275e-19,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 8515865488334384e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 12769977786319942e-23,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_NEUTRAL.json
  var viseme_NEUTRAL_default;
  var init_viseme_NEUTRAL = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/viseme_NEUTRAL.json"() {
      viseme_NEUTRAL_default = [
        {
          index: 0,
          score: 2630727749419748e-21,
          categoryName: "_neutral",
          displayName: ""
        },
        {
          index: 1,
          score: 0.13020889461040497,
          categoryName: "browDownLeft",
          displayName: ""
        },
        {
          index: 2,
          score: 0.09943081438541412,
          categoryName: "browDownRight",
          displayName: ""
        },
        {
          index: 3,
          score: 0.002150430344045162,
          categoryName: "browInnerUp",
          displayName: ""
        },
        {
          index: 4,
          score: 0.030101221054792404,
          categoryName: "browOuterUpLeft",
          displayName: ""
        },
        {
          index: 5,
          score: 0.02087479457259178,
          categoryName: "browOuterUpRight",
          displayName: ""
        },
        {
          index: 6,
          score: 6719449174852343e-21,
          categoryName: "cheekPuff",
          displayName: ""
        },
        {
          index: 7,
          score: 10215688917014631e-23,
          categoryName: "cheekSquintLeft",
          displayName: ""
        },
        {
          index: 8,
          score: 18004327273501985e-23,
          categoryName: "cheekSquintRight",
          displayName: ""
        },
        {
          index: 9,
          score: 0.1693396270275116,
          categoryName: "eyeBlinkLeft",
          displayName: ""
        },
        {
          index: 10,
          score: 0.13259759545326233,
          categoryName: "eyeBlinkRight",
          displayName: ""
        },
        {
          index: 11,
          score: 0.1106262356042862,
          categoryName: "eyeLookDownLeft",
          displayName: ""
        },
        {
          index: 12,
          score: 0.11171294003725052,
          categoryName: "eyeLookDownRight",
          displayName: ""
        },
        {
          index: 13,
          score: 0.03368312120437622,
          categoryName: "eyeLookInLeft",
          displayName: ""
        },
        {
          index: 14,
          score: 0.09691077470779419,
          categoryName: "eyeLookInRight",
          displayName: ""
        },
        {
          index: 15,
          score: 0.09376100450754166,
          categoryName: "eyeLookOutLeft",
          displayName: ""
        },
        {
          index: 16,
          score: 0.04009873792529106,
          categoryName: "eyeLookOutRight",
          displayName: ""
        },
        {
          index: 17,
          score: 0.07177720218896866,
          categoryName: "eyeLookUpLeft",
          displayName: ""
        },
        {
          index: 18,
          score: 0.07159104198217392,
          categoryName: "eyeLookUpRight",
          displayName: ""
        },
        {
          index: 19,
          score: 0.3303208351135254,
          categoryName: "eyeSquintLeft",
          displayName: ""
        },
        {
          index: 20,
          score: 0.31396231055259705,
          categoryName: "eyeSquintRight",
          displayName: ""
        },
        {
          index: 21,
          score: 0.0034851098898798227,
          categoryName: "eyeWideLeft",
          displayName: ""
        },
        {
          index: 22,
          score: 0.0022434901911765337,
          categoryName: "eyeWideRight",
          displayName: ""
        },
        {
          index: 23,
          score: 8091846211755183e-21,
          categoryName: "jawForward",
          displayName: ""
        },
        {
          index: 24,
          score: 0.001295537338592112,
          categoryName: "jawLeft",
          displayName: ""
        },
        {
          index: 25,
          score: 0.009332051500678062,
          categoryName: "jawOpen",
          displayName: ""
        },
        {
          index: 26,
          score: 26114972570212558e-21,
          categoryName: "jawRight",
          displayName: ""
        },
        {
          index: 27,
          score: 0.003347803605720401,
          categoryName: "mouthClose",
          displayName: ""
        },
        {
          index: 28,
          score: 0.0030687295366078615,
          categoryName: "mouthDimpleLeft",
          displayName: ""
        },
        {
          index: 29,
          score: 0.003360423259437084,
          categoryName: "mouthDimpleRight",
          displayName: ""
        },
        {
          index: 30,
          score: 6423582090064883e-19,
          categoryName: "mouthFrownLeft",
          displayName: ""
        },
        {
          index: 31,
          score: 0.001050050021149218,
          categoryName: "mouthFrownRight",
          displayName: ""
        },
        {
          index: 32,
          score: 24222707725130022e-20,
          categoryName: "mouthFunnel",
          displayName: ""
        },
        {
          index: 33,
          score: 0.004422335885465145,
          categoryName: "mouthLeft",
          displayName: ""
        },
        {
          index: 34,
          score: 6499184382846579e-20,
          categoryName: "mouthLowerDownLeft",
          displayName: ""
        },
        {
          index: 35,
          score: 30261142455856316e-21,
          categoryName: "mouthLowerDownRight",
          displayName: ""
        },
        {
          index: 36,
          score: 0.037353213876485825,
          categoryName: "mouthPressLeft",
          displayName: ""
        },
        {
          index: 37,
          score: 0.08526048064231873,
          categoryName: "mouthPressRight",
          displayName: ""
        },
        {
          index: 38,
          score: 0.009590551257133484,
          categoryName: "mouthPucker",
          displayName: ""
        },
        {
          index: 39,
          score: 25985081447288394e-20,
          categoryName: "mouthRight",
          displayName: ""
        },
        {
          index: 40,
          score: 0.06270235031843185,
          categoryName: "mouthRollLower",
          displayName: ""
        },
        {
          index: 41,
          score: 0.014600061811506748,
          categoryName: "mouthRollUpper",
          displayName: ""
        },
        {
          index: 42,
          score: 0.3125866651535034,
          categoryName: "mouthShrugLower",
          displayName: ""
        },
        {
          index: 43,
          score: 0.024530421942472458,
          categoryName: "mouthShrugUpper",
          displayName: ""
        },
        {
          index: 44,
          score: 1871389104053378e-19,
          categoryName: "mouthSmileLeft",
          displayName: ""
        },
        {
          index: 45,
          score: 2114246308337897e-19,
          categoryName: "mouthSmileRight",
          displayName: ""
        },
        {
          index: 46,
          score: 6105343927629292e-19,
          categoryName: "mouthStretchLeft",
          displayName: ""
        },
        {
          index: 47,
          score: 0.002688670763745904,
          categoryName: "mouthStretchRight",
          displayName: ""
        },
        {
          index: 48,
          score: 10361948079662398e-20,
          categoryName: "mouthUpperUpLeft",
          displayName: ""
        },
        {
          index: 49,
          score: 17687681247480214e-20,
          categoryName: "mouthUpperUpRight",
          displayName: ""
        },
        {
          index: 50,
          score: 3551591873929283e-22,
          categoryName: "noseSneerLeft",
          displayName: ""
        },
        {
          index: 51,
          score: 3692105963182257e-22,
          categoryName: "noseSneerRight",
          displayName: ""
        }
      ];
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/index.js
  var viseme, viseme_default;
  var init_viseme = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/viseme/index.js"() {
      init_viseme_A();
      init_viseme_R();
      init_viseme_I();
      init_viseme_O();
      init_viseme_U();
      init_viseme_NEUTRAL();
      viseme = { a: viseme_A_default, e: viseme_R_default, i: viseme_I_default, o: viseme_O_default, u: viseme_U_default, neutral: viseme_NEUTRAL_default };
      viseme_default = viseme;
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/index.js
  var lib_default;
  var init_lib = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/lib/index.js"() {
      init_angry();
      init_disgust();
      init_eyes_close();
      init_eyes_open();
      init_fear();
      init_happy();
      init_neutral();
      init_sad();
      init_surprise();
      init_viseme();
      lib_default = {
        emotion: {
          angry: angry_default,
          disgust: disgust_default,
          fear: fear_default,
          happy: happy_default,
          neutral: neutral_default,
          sad: sad_default,
          surprise: surprise_default
        },
        eyes: {
          closed: eyes_close_default,
          open: eyes_open_default
        },
        viseme: viseme_default
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/blendshapes/index.js
  var logger3, BlendShapeAnimation;
  var init_blendshapes = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/blendshapes/index.js"() {
      init_lil_gui_module_min();
      init_logger();
      init_animation_base();
      init_lib();
      logger3 = new Logger("webavatar.animation.blendShapes");
      BlendShapeAnimation = class extends AnimationBase {
        constructor() {
          super(...arguments);
          this.blinkInterval = 4e3;
          this.eyeClosed = false;
          this.foundBlendShapes = [];
        }
        animate(delta) {
        }
        async init() {
          this.processModel();
          this.loadBlendShapes();
          this.blinkEyes();
        }
        async destroy() {
          if (this.gui) {
            this.gui.hide();
            this.gui.destroy();
          }
        }
        getEmotion(name2) {
          return lib_default.emotion[name2] || lib_default.emotion.neutral;
        }
        moveEyes(position) {
          const down = position.y;
          const left = position.x;
          const downLeft = {
            index: 23,
            score: down,
            categoryName: "eyeLookDownLeft",
            displayName: ""
          };
          const downRight = {
            index: 24,
            score: down,
            categoryName: "eyeLookDownRight",
            displayName: ""
          };
          const inLeft = {
            index: 27,
            score: -left,
            categoryName: "eyeLookInLeft",
            displayName: ""
          };
          const inRight = {
            index: 28,
            score: left,
            categoryName: "eyeLookInRight",
            displayName: ""
          };
          const outLeft = {
            index: 29,
            score: -left,
            categoryName: "eyeLookOutLeft",
            displayName: ""
          };
          const outRight = {
            index: 30,
            score: left,
            categoryName: "eyeLookOutRight",
            displayName: ""
          };
          this.setFaceBlendShapes([
            downLeft,
            downRight,
            // upLeft,
            // upRight,
            inLeft,
            inRight,
            outLeft,
            outRight
          ]);
        }
        blinkEyes() {
          if (this.isStopped())
            return;
          let startBlinkTime = performance.now();
          setInterval(() => {
            const time = performance.now();
            if (this.eyeClosed) {
              this.setFaceBlendShapes(lib_default.eyes.open);
              this.eyeClosed = !this.eyeClosed;
              startBlinkTime = performance.now();
            } else {
              if (time - startBlinkTime > this.blinkInterval) {
                this.setFaceBlendShapes(lib_default.eyes.closed);
                this.eyeClosed = !this.eyeClosed;
              }
            }
          }, 150);
        }
        getViseme(name2) {
          return lib_default.viseme[name2] || lib_default.viseme.neutral;
        }
        setViseme(viseme2) {
          const blendshapeViseme = this.getViseme(viseme2);
          if (!blendshapeViseme)
            logger3.log(`blendshapes for viseme ${viseme2} not found`);
          this.setFaceBlendShapes(blendshapeViseme);
        }
        setEmotion(emotion) {
          if (!lib_default.emotion[emotion]) {
            logger3.warn(`Emotion ${emotion} has no blendShapes`);
            return;
          }
          this.setFaceBlendShapes(lib_default.emotion[emotion]);
        }
        async processModel() {
          const model = this.getModel();
          const config = this.getConfig();
          if (!model)
            return;
          model.traverse((child) => {
            if (!child.isMesh || !child.visible)
              return;
            if (child.morphTargetInfluences) {
              this.foundBlendShapes.push(child);
            }
            if (child.name === config.animations?.blendShapes?.name) {
              if (!child.morphTargetInfluences && !child.morphTargetDictionary) {
                logger3.warn(`Mesh ${child.name} does not have blend shapes`);
              } else {
                if (this.blendShapeTarget) {
                  logger3.warn(`Blend shape target '${child.name}' is already set`);
                } else {
                  this.blendShapeTarget = child;
                }
              }
            }
          });
        }
        setFaceBlendShapes(blendShapes) {
          if (!blendShapes)
            return;
          blendShapes.forEach((blendShape) => {
            this.setBlendShape(blendShape.categoryName, blendShape.score);
          });
        }
        setBlendShape(label, value) {
          if (!this.blendShapeTarget)
            return;
          const mappings = this.getConfig().animations?.blendShapes?.mappings || {};
          label = mappings[label] || label;
          const morphTargetDictionary = this.blendShapeTarget.morphTargetDictionary || {};
          const key = morphTargetDictionary[label];
          if (!this.blendShapeTarget.morphTargetInfluences)
            return void 0;
          if (label === "jawOpen") {
            const maxValue = 0.3;
            const normalized = value * maxValue;
            value = normalized;
          }
          this.blendShapeTarget.morphTargetInfluences[key] = value;
        }
        getBlendShape(label) {
          const mappings = this.getConfig().animations?.blendShapes?.mappings || {};
          const morphTargetDictionary = this.blendShapeTarget.morphTargetDictionary || {};
          label = mappings[label] || label;
          const key = morphTargetDictionary[label];
          if (this.blendShapeTarget.morphTargetInfluences === void 0)
            return void 0;
          return this.blendShapeTarget.morphTargetInfluences[key];
        }
        showBlendShapeGui() {
          if (!this.blendShapeTarget)
            return;
          if (this.gui) {
            return;
          }
          const morphTargetDictionary = this.blendShapeTarget.morphTargetDictionary || {};
          this.gui = new g({
            container: document.getElementById("blendshape-controls") || void 0
          });
          if (this.gui) {
            this.gui.hide();
            this.gui.reset();
          }
          const influences = this.blendShapeTarget.morphTargetInfluences || [];
          const blendShapeslist = [];
          for (const [key, value] of Object.entries(morphTargetDictionary)) {
            blendShapeslist.push(key);
            if (this.gui) {
              this.gui.add(influences, "" + value, 0, 1, 0.01).name(key).listen(true);
            }
          }
          if (this.gui) {
            this.gui.show();
            this.gui.close();
          }
        }
        hideBlendShapeGui() {
          if (!this.gui)
            return;
          this.gui.destroy();
        }
        loadBlendShapes() {
          if (!this.blendShapeTarget)
            return;
          const blendShapes = {};
          const morphTargetDictionary = this.blendShapeTarget.morphTargetDictionary || {};
          Object.keys(morphTargetDictionary).forEach((label) => {
            Object.defineProperty(blendShapes, label, {
              get: () => this.getBlendShape(label),
              set: (val) => this.setBlendShape(label, val)
            });
          });
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/loader/index.js
  var AnimationsLoader;
  var init_loader = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/loader/index.js"() {
      init_FBXLoader();
      init_GLTFLoader();
      init_logger();
      AnimationsLoader = class {
        constructor(config) {
          this.logger = new Logger("AnimationsLoader");
          this.mapping = {
            gesture_default: [],
            gesture_idle: [
              // https://github.com/readyplayerme/animation-library/tree/master/feminine/fbx/idle
              "F_Standing_Idle_001"
              // 'F_Standing_Idle_Variations_001',
              // 'F_Standing_Idle_Variations_008',
              // 'M_Standing_Idle_001',
              // 'M_Standing_Idle_Variations_002',
              //   'M_Standing_Idle_Variations_003',
              //   'M_Standing_Idle_Variations_005',
            ],
            gesture_waving: [
              //
              "M_Standing_Expressions_001"
            ],
            gesture_listening: [
              //
              "F_Talking_Variations_002"
              // 'M_Talking_Variations_001',
            ],
            gesture_talking: [
              // 'F_Talking_Variations_001',
              "F_Talking_Variations_002"
              // 'F_Talking_Variations_005',
              //   'M_Talking_Variations_001',
              //   'M_Talking_Variations_008',
              //   'M_Talking_Variations_009',
            ],
            gesture_donotknow: [
              "F_Talking_Variations_003"
              //   'M_Standing_Expressions_005',
            ],
            gesture_walk: [
              // 'F_Walk_002',
              // 'F_Walk_003'
            ],
            gesture_show_left: [],
            gesture_show_right: []
          };
          this.animations = [];
          this.config = config;
        }
        getMapping() {
          return this.mapping;
        }
        getAnimations() {
          return this.animations;
        }
        async loadAnimationsFromModel(path, type = "fbx") {
          const loader = type === "fbx" ? new FBXLoader() : new GLTFLoader();
          const model = await loader.loadAsync(path);
          const gltf = model;
          if (gltf.parser !== void 0 && gltf.scene !== void 0) {
            return gltf.animations;
          }
          return model.animations;
        }
        mapTrackName(n4) {
          const mappings = this.config.animations?.gesture?.mappings || {};
          for (const [key, value] of Object.entries(mappings)) {
            if (n4.indexOf(key) !== -1) {
              return n4.replace(key, value);
            }
          }
          return n4;
        }
        remapAnimation(a4) {
          a4.tracks = a4.tracks.map((t4) => {
            t4.name = this.mapTrackName(t4.name);
            return t4;
          });
          return a4;
        }
        async loadAnimations() {
          const genderPath = this.config.gender == "M" ? "masculine" : "feminine";
          for (const [key, value] of Object.entries(this.mapping)) {
            await Promise.all(value.map(async (a4, idx) => {
              const ext = "glb";
              const path = `/animations/${genderPath}/${ext}/${a4}.${ext}`;
              try {
                this.logger.debug(`Loading animation ${a4}`);
                const animations = await this.loadAnimationsFromModel(path, ext);
                animations.forEach((a5) => {
                  a5.name = `${key}_${idx}`;
                  if (this.config.modelType === "readyplayerme") {
                    this.animations.push(a5);
                  } else {
                    this.animations.push(this.remapAnimation(a5));
                  }
                });
              } catch (e4) {
                this.logger.error(`Failed to load animation from ${path}, error: ${e4.message}`);
              }
            }));
          }
          this.logger.debug(`loaded ${this.animations.length} animations`);
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/animations/index.js
  var logger4, WebavatarAnimation;
  var init_animations = __esm({
    "node_modules/@sermas/toolkit/avatar/animations/index.js"() {
      init_three_module();
      init_logger();
      init_util();
      init_animation_base();
      init_animator();
      init_blendshapes();
      init_loader();
      logger4 = new Logger("webavatar.animation");
      WebavatarAnimation = class extends AnimationBase {
        constructor(avatar) {
          super(avatar);
          this.animationEnabled = true;
          this.mixer = {};
          this.currentGesture = "gesture_idle";
          this.loopableGestures = [
            "gesture_idle",
            "gesture_talking",
            "gesture_walk"
          ];
          this.gestureIndexes = {
            gesture_default: 0,
            gesture_idle: 0,
            gesture_waving: 0,
            gesture_listening: 0,
            gesture_talking: 0,
            gesture_donotknow: 0,
            gesture_walk: 0,
            gesture_show_left: 0,
            gesture_show_right: 0
          };
          this.mirrorModeEnabled = false;
          this.lookAtUser = false;
          this.animationLoader = new AnimationsLoader(this.avatar.getConfig());
          this.blendShapes = new BlendShapeAnimation(this.avatar);
          this.getAnimator();
        }
        moveEyes(position) {
          if (!this.lookAtUser)
            return;
          this.getAnimator()?.moveEyes(position);
          this.blendShapes.moveEyes(position);
        }
        getBlendShapes() {
          return this.blendShapes;
        }
        animate(delta) {
          getTypedKeys(this.mixer).forEach((group) => this.mixer[group]?.update(delta));
          this.blendShapes.animate(delta);
        }
        async init() {
          const model = this.avatar.getModel();
          if (!model)
            return;
          await this.animationLoader.loadAnimations();
          this.onAnimationFinished = this.onAnimationFinished.bind(this);
          this.processModel();
          this.mixer["gesture"] = new AnimationMixer(model);
          this.mixer["gesture"].addEventListener("finished", this.onAnimationFinished);
          await this.loadAnimations();
          await this.blendShapes.init();
        }
        getAnimator() {
          const model = this.getModel();
          if (!model)
            return void 0;
          if (!this.animator) {
            this.animator = new Animator(model, this.avatar.getScene(), this.avatar.getCamera(), this.avatar.getConfig().modelType == "readyplayerme");
          }
          return this.animator;
        }
        async destroy() {
          getTypedKeys(this.mixer).forEach((group) => this.mixer[group]?.removeEventListener("finished", this.onAnimationFinished));
          await this.blendShapes.destroy();
        }
        setPoses(results) {
          if (!this.animationEnabled || !this.mirrorModeEnabled)
            return;
          this.stopAnimations("gesture");
          this.getAnimator()?.animate(results);
        }
        getAnimation(group, name2) {
          let label = {
            group,
            name: name2 || ""
          };
          if (!name2) {
            label = this.getAnimationLabel(group);
          }
          if (!this.animations[label.group])
            return null;
          return this.animations[label.group][label.name];
        }
        getAnimationLabel(name2) {
          const parts = name2.split("_");
          return {
            group: parts[0],
            name: parts.slice(1).join("_")
          };
        }
        normalizeAnimationName(name2) {
          const config = this.getConfig();
          if (config.animations?.normalizeName) {
            name2 = config.animations?.normalizeName(name2);
          }
          return name2;
        }
        async loadAnimations() {
          const model = this.getModel();
          const config = this.getConfig();
          if (!model)
            return;
          const imported = this.animationLoader.getAnimations();
          this.animations = [...model.animations, ...imported].map((animationClip) => {
            const name2 = this.normalizeAnimationName(animationClip.name);
            const label = this.getAnimationLabel(name2);
            return { ...label, animationName: name2, animationClip };
          }).reduce((o4, { group, name: name2, animationName, animationClip }) => {
            let maskedClip = animationClip;
            if (config.animations?.masks) {
              getTypedKeys(config.animations?.masks).forEach((maskGroup) => {
                if (animationClip.name.indexOf(maskGroup) === -1)
                  return;
                maskedClip = new AnimationClip(animationClip.name, animationClip.duration, animationClip.tracks);
                if (this.filterMeshRegExp || config.animations?.masks && config.animations?.masks[maskGroup].length) {
                  maskedClip.tracks = maskedClip.tracks.filter((track) => {
                    if (this.filterMeshRegExp) {
                      if (track.name.match(this.filterMeshRegExp))
                        return false;
                    }
                    if (!config.animations?.masks)
                      return true;
                    const list = config.animations?.masks[maskGroup] || [];
                    return track.name.match(new RegExp(list.join("|")));
                  });
                }
              });
            }
            if (!this.mixer[group]) {
              logger4.warn(`Mixer ${group} not found`);
              return o4;
            }
            const action = this.mixer[group].clipAction(maskedClip);
            this.resetAction(action);
            const handler = {
              name: name2,
              group,
              clip: maskedClip,
              action,
              settings: {
                weight: 1
              }
            };
            o4[group] = o4[group] || {};
            o4[group][name2] = handler;
            return o4;
          }, {});
        }
        resetAction(action) {
          action.reset().setLoop(LoopOnce, 1).setEffectiveWeight(1).setEffectiveTimeScale(1);
          action.clampWhenFinished = true;
        }
        onAnimationFinished(event) {
          const action = event.action;
          const actionName = action.getClip().name;
          const animationName = this.normalizeAnimationName(actionName);
          const label = this.getAnimationLabel(animationName);
          if (label.group === "gesture") {
            if (this.loopableGestures.indexOf(this.currentGesture) === -1) {
              this.currentGesture = "gesture_idle";
            } else {
            }
            this.playGesture(this.currentGesture);
          }
        }
        getGestureAnimations(gestureKey) {
          return this.animationLoader.getMapping()[gestureKey] || [];
        }
        getNextGestureAnimationName(gestureKey) {
          const animations = this.animationLoader.getMapping()[gestureKey] || [];
          if (!animations.length)
            return null;
          const animationLength = animations.length - 1;
          this.gestureIndexes[gestureKey] = this.gestureIndexes[gestureKey] || 0;
          this.gestureIndexes[gestureKey]++;
          if (this.gestureIndexes[gestureKey] >= animationLength)
            this.gestureIndexes[gestureKey] = 0;
          const [, gestureName] = gestureKey.split("_");
          return `${gestureName}_${this.gestureIndexes[gestureKey]}`;
        }
        getCurrentGestureAnimationName(gestureKey) {
          const animations = this.animationLoader.getMapping()[gestureKey] || [];
          if (!animations.length)
            return null;
          if (this.gestureIndexes[gestureKey] === void 0)
            return null;
          const [, gestureName] = gestureKey.split("_");
          return `${gestureName}_${this.gestureIndexes[gestureKey]}`;
        }
        playGesture(gestureKey) {
          const animationName = this.getNextGestureAnimationName(gestureKey);
          if (!animationName) {
            logger4.warn(`Animation not found ${gestureKey}`);
            return;
          }
          this.play("gesture", animationName);
          this.currentGesture = gestureKey;
        }
        playGestureIdle() {
          this.playGesture("gesture_idle");
        }
        playGestureTalking() {
          this.playGesture("gesture_talking");
        }
        playGestureListening() {
          this.playGesture("gesture_listening");
        }
        play(group, name2, durationSec = 1) {
          if (!this.animationEnabled) {
            return;
          }
          const anim = this.getAnimation(group, name2);
          if (!anim) {
            return;
          }
          if (anim.action.isRunning()) {
            return;
          }
          logger4.log(`Play ${group} ${anim.name}`);
          const animationRunning = [];
          const animations = this.getAnimations(group);
          const baseName = name2.replace(/_[0-9]/, "");
          animations.forEach((a4) => {
            if (a4.name === name2)
              return;
            if (a4.action.isRunning() || a4.name.startsWith(baseName)) {
              animationRunning.push(a4);
              return;
            }
            this.resetAction(a4.action);
            a4.action.stop();
          });
          this.resetAction(anim.action);
          anim.action.play();
          if (animationRunning.length) {
            animationRunning.forEach((a4) => {
              a4.action.crossFadeTo(anim.action, durationSec, false);
            });
          }
        }
        getRunningAnimations(group) {
          const animations = this.animations[group];
          return Object.values(animations).filter((a4) => a4.action.isRunning());
        }
        stopAnimations(group) {
          this.getRunningAnimations(group).forEach((a4) => a4.action.fadeOut(0.5).stop());
        }
        processModel() {
          const model = this.avatar.getModel();
          model?.traverse((child) => {
            if (!child.isMesh || !child.visible)
              return;
            if (child.animations && child.animations.length) {
              logger4.debug(`Found animations in mesh ${child.name}`);
              logger4.debug(child.animations);
            }
          });
        }
        getAnimations(group) {
          return Object.values(this.animations[group] || {});
        }
        setMirrorModeEnabled(enabled) {
          this.mirrorModeEnabled = enabled;
        }
        setAnimationEnabled(enabled) {
          this.animationEnabled = enabled;
        }
        setLookAtUser(enabled) {
          this.lookAtUser = enabled;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/events.js
  var import_eventemitter22, emitter, sendStatus, EventListenerTracker;
  var init_events = __esm({
    "node_modules/@sermas/toolkit/events.js"() {
      import_eventemitter22 = __toESM(require_eventemitter2(), 1);
      emitter = new import_eventemitter22.default();
      sendStatus = (message) => {
        emitter.emit("ui.status", { message });
      };
      EventListenerTracker = class {
        constructor(emitter2) {
          this.emitter = emitter2;
          this.listener = {};
        }
        add(event, fn4) {
          this.listener[event] = this.listener[event] || [];
          this.listener[event].push(fn4);
        }
        remove(event, listeners) {
          this.listener[event] = this.listener[event] || [];
          if (listeners === void 0) {
            this.remove(event, this.listener[event]);
            this.listener[event] = [];
            return;
          }
          listeners = listeners instanceof Array ? listeners : [listeners];
          for (const listener of listeners) {
            const i5 = this.listener[event].indexOf(listener);
            if (i5 > -1)
              this.listener[event].splice(i5, 1);
          }
          listeners.forEach((listener) => this.emitter.removeListener(event, listener));
        }
        clear() {
          Object.keys(this.listener).forEach((event) => this.remove(event));
          this.listener = {};
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/loader/TextureLoader2.js
  var TextureLoader2;
  var init_TextureLoader2 = __esm({
    "node_modules/@sermas/toolkit/avatar/loader/TextureLoader2.js"() {
      init_axios2();
      init_three_module();
      TextureLoader2 = class extends TextureLoader {
        toBase64(blob) {
          const fileReaderInstance = new FileReader();
          fileReaderInstance.readAsDataURL(blob);
          return new Promise((resolve, reject) => {
            let done = false;
            fileReaderInstance.onload = () => {
              if (done)
                return;
              done = true;
              resolve(fileReaderInstance.result);
            };
            fileReaderInstance.onerror = (err) => {
              if (done)
                return;
              done = true;
              reject(err);
            };
          });
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture();
          axios_default.get(url, {
            responseType: "blob",
            headers: {
              ...this.requestHeader || {}
            },
            withCredentials: this.withCredentials
          }).then(async (res) => {
            const img = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            const dataUrl = await this.toBase64(res.data);
            img.src = dataUrl;
            texture.image = img;
            texture.needsUpdate = true;
            onLoad && onLoad(texture);
          }).catch((err) => {
            onError && onError(err);
            return Promise.resolve();
          });
          return texture;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/webavatar.defaults.js
  var DefaultAvatarConfig, DefaultReadyPlayerMeAvatarConfig;
  var init_webavatar_defaults = __esm({
    "node_modules/@sermas/toolkit/avatar/webavatar.defaults.js"() {
      DefaultAvatarConfig = {
        type: "avatars",
        id: "default",
        path: "https://models.readyplayer.me/654cc759f1a79ed2ebab0207.glb",
        gender: "F",
        modelType: "readyplayerme",
        domId: "web-avatar",
        camera: {
          position: {
            x: -0.1039700347755792,
            y: 0.7280937522640802,
            z: 1.5018928584731202
          },
          rotation: {
            x: -0.19938471268290073,
            y: -0.2542801277228938,
            z: -0.050786631884382503
          }
        },
        cameraMobile: {
          position: {
            x: -0.010965805547590052,
            y: 0.6154045898608999,
            z: 1.4016687340357339
          },
          rotation: {
            x: -0.13381844098619816,
            y: -0.01929222913574782,
            z: -0.0025970104995767787
          }
        },
        animations: {
          gesture: {
            mappings: {}
          },
          masks: {
            gesture: []
          },
          blendShapes: {
            name: "Wolf3D_Head"
          }
        }
      };
      DefaultReadyPlayerMeAvatarConfig = {
        id: "default",
        type: "avatars",
        path: "",
        gender: "F",
        domId: "web-avatar",
        modelType: "readyplayerme"
      };
    }
  });

  // node_modules/@sermas/toolkit/fps.js
  var FPS_MIN, FPS_TTL, FpsMonitor;
  var init_fps = __esm({
    "node_modules/@sermas/toolkit/fps.js"() {
      init_logger();
      FPS_MIN = 15;
      FPS_TTL = 10;
      FpsMonitor = class _FpsMonitor {
        constructor(emitter2) {
          this.emitter = emitter2;
          this.logger = new Logger(_FpsMonitor.name);
          this.times = [];
          this.stopped = false;
        }
        refreshLoop() {
          if (!window)
            return;
          window.requestAnimationFrame(() => {
            if (this.stopped)
              return;
            const now3 = performance.now();
            while (this.times.length > 0 && this.times[0] <= now3 - 1e3) {
              this.times.shift();
            }
            this.times.push(now3);
            this.fps = this.times.length;
            this.refreshLoop();
          });
        }
        init() {
          this.refreshLoop();
          let lastMin = 0;
          let status = "normal";
          const updateStatus = (newStatus) => {
            if (status === newStatus)
              return;
            status = newStatus;
            this.logger.warn(`Performance ${status} for ${FPS_TTL}seconds, current fps:${this.fps}`);
            this.emitter.emit("performance", {
              fps: this.fps,
              status
            });
          };
          this.intv = setInterval(() => {
            if (this.fps < FPS_MIN) {
              lastMin++;
              if (lastMin > FPS_TTL) {
                if (status === "degraded")
                  return;
                updateStatus("degraded");
                return;
              }
            } else {
              lastMin--;
              if (lastMin < 0)
                lastMin = 0;
              if (lastMin === 0) {
                if (status === "degraded") {
                  updateStatus("restored");
                  return;
                }
              }
            }
          }, 1e3);
        }
        destroy() {
          this.stopped = true;
          if (this.intv)
            clearInterval(this.intv);
        }
        getFPS() {
          return this.fps;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/global.js
  var init_global = __esm({
    "node_modules/@sermas/toolkit/global.js"() {
    }
  });

  // node_modules/@sermas/toolkit/utils.js
  var getChunkId;
  var init_utils3 = __esm({
    "node_modules/@sermas/toolkit/utils.js"() {
      init_fps();
      init_global();
      init_logger();
      getChunkId = () => Date.now() + performance.now();
    }
  });

  // node_modules/@sermas/toolkit/avatar/webavatar.handler.js
  var logger5, WebAvatarHandler;
  var init_webavatar_handler = __esm({
    "node_modules/@sermas/toolkit/avatar/webavatar.handler.js"() {
      init_dto();
      init_events();
      init_utils3();
      init_avatar();
      logger5 = new Logger("webavatar.handler");
      WebAvatarHandler = class {
        constructor(avatar) {
          this.avatar = avatar;
          this.audioQueue = [];
          this.messagesQueue = {};
          this.isPlaying = false;
          this.callbacks = {
            "detection.characterization": this.onDetection,
            "dialogue.speech": this.onSpeech,
            "dialogue.messages": this.onDialogueMessage,
            "session.session": this.onSession,
            "avatar.face": this.setFace,
            "avatar.speech.stop": this.onForceStop,
            "dialogue.stop": this.onForceStop,
            "detection.pose": this.setPose,
            "detection.audio": this.setListening
          };
        }
        toggleAudio(enabled) {
          this.lipsync?.toggleAudio(enabled);
        }
        onForceStop(chunkId) {
          if (!chunkId) {
            this.audioQueue = !chunkId ? [] : this.audioQueue.filter((q4) => q4.chunkId > chunkId);
          }
          this.lipsync?.stopAudio();
        }
        startSpeech(chunkId) {
          logger5.debug("playing speech started");
          const ev = { status: "started", chunkId };
          emitter.emit("avatar.speech", ev);
          this.avatar.getAnimation()?.playGestureTalking();
        }
        stopSpeech(chunkId) {
          logger5.debug("playing speech ended");
          const ev = { status: "ended", chunkId };
          emitter.emit("avatar.speech", ev);
          this.avatar.getAnimation()?.playGestureIdle();
        }
        // onPlaybackChange(ev: AvatarAudioPlaybackStatus) {
        //   this.avatarModel.setSpeaking(ev.status !== "ended")
        // }
        onDetection(ev) {
          if (ev.source !== UserCharacterizationEventSource.emotion_tracker)
            return;
          if (!this.avatar)
            return;
          if (!ev.detections || !ev.detections.length)
            return;
          const { emotion } = ev.detections[0];
          const emotionValue = emotion.value;
          if (this.lastSet && (Date.now() - this.lastSet.time < 1e3 || this.lastSet.emotion === emotionValue))
            return;
          this.lastSet = {
            time: Date.now(),
            emotion: emotionValue
          };
          logger5.debug(`Set emotion ${emotionValue}`);
          this.avatar.getBlendShapes()?.setEmotion(emotionValue);
        }
        setListening(op3) {
          if (op3 === "started") {
            this.avatar.getAnimation()?.playGesture("gesture_listening");
          } else {
            this.avatar.getAnimation()?.playGesture("gesture_idle");
          }
        }
        onSession(ev) {
          if (ev.operation === "created") {
            this.avatar.getAnimation()?.playGesture("gesture_waving");
          }
          if (ev.operation === "updated") {
            if (ev.record.closedAt) {
              this.avatar.getAnimation()?.playGesture("gesture_waving");
            }
          }
        }
        onSpeech(ev, raw) {
          if (!this.lipsync)
            return;
          const buffer = raw.message.payload;
          const [, chunkId] = raw.context;
          this.audioQueue.push({ chunkId, buffer });
          if (!this.lipsync?.paused) {
            logger5.debug(`lypsync is paused`);
            return;
          }
          setTimeout(() => this.playAudio(), 10);
        }
        playAudio() {
          if (this.isPlaying) {
            logger5.debug(`already playing`);
            return;
          }
          this.isPlaying = true;
          if (!this.audioQueue.length)
            return;
          const raw = this.audioQueue.sort((a4, b3) => +a4.chunkId > +b3.chunkId ? 1 : -1).splice(0, 1)[0];
          logger5.debug(`play speech chunk chunkId=${raw.chunkId}`);
          this.lipsync?.startFromAudioFile(raw.buffer);
        }
        onDialogueMessage(ev) {
          if (ev.actor === "user")
            return;
          if (!ev.text) {
            this.stopSpeech();
            return;
          }
        }
        setFace(blendingShapes) {
          this.avatar?.getBlendShapes()?.setFaceBlendShapes(blendingShapes);
        }
        setPose(poses) {
          this.avatar?.setPoses(poses);
        }
        async stopLipsync() {
          await this.lipsync?.destroy();
          this.lipsync?.removeAllListeners();
        }
        async startLipsync() {
          this.lipsync = new LipSync();
          let speechStopped = true;
          this.lipsync.on("viseme", (ev) => {
            if (speechStopped)
              return;
            this.avatar.getBlendShapes()?.setViseme(ev.key);
          });
          this.lipsync.on("start", () => {
            this.startSpeech();
            speechStopped = false;
          });
          this.lipsync.on("end", () => {
            this.avatar.getBlendShapes()?.setViseme("neutral");
            this.isPlaying = false;
            if (this.audioQueue.length) {
              this.playAudio();
              return;
            }
            speechStopped = true;
            this.stopSpeech();
          });
        }
        async init() {
          Object.keys(this.callbacks).forEach((key) => {
            this.callbacks[key] = this.callbacks[key].bind(this);
            emitter.on(key, this.callbacks[key]);
          });
          await this.startLipsync();
          this.avatar.getAnimation()?.playGestureIdle();
        }
        async destroy() {
          Object.keys(this.callbacks).forEach((key) => {
            emitter.off(key, this.callbacks[key]);
          });
          await this.stopLipsync();
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/xr/hitTest.js
  var HitTestHandler;
  var init_hitTest = __esm({
    "node_modules/@sermas/toolkit/avatar/xr/hitTest.js"() {
      HitTestHandler = class {
        constructor(renderer) {
          this.renderer = renderer;
          this.hitTestSourceRequested = false;
        }
        async onFrame(frame) {
          if (!frame)
            return void 0;
          const referenceSpace = this.renderer.xr.getReferenceSpace();
          const session = this.renderer.xr.getSession();
          if (!session)
            return;
          if (this.hitTestSourceRequested === false) {
            const referenceSpace2 = await session.requestReferenceSpace("viewer");
            if (session.requestHitTestSource === void 0)
              return;
            this.hitTestSource = await session.requestHitTestSource({
              space: referenceSpace2
            });
            session.addEventListener("end", () => {
              this.hitTestSourceRequested = false;
              this.hitTestSource?.cancel();
              this.hitTestSource = void 0;
            });
            this.hitTestSourceRequested = true;
          }
          if (this.hitTestSource && referenceSpace) {
            const hitTestResults = frame.getHitTestResults(this.hitTestSource);
            if (!hitTestResults.length)
              return void 0;
            const hit = hitTestResults[0];
            const xrHitPose = hit.getPose(referenceSpace);
            const xrHitPoseMatrix = xrHitPose?.transform.matrix;
            return xrHitPoseMatrix;
          }
          return void 0;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/xr/planeMarker.js
  function createPlaneMarker() {
    const planeMarkerMaterial = new MeshBasicMaterial({ color: 16777215 });
    const planeMarkerGeometry = new RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
    const planeMarker = new Mesh(planeMarkerGeometry, planeMarkerMaterial);
    planeMarker.matrixAutoUpdate = false;
    planeMarker.visible = false;
    return planeMarker;
  }
  var init_planeMarker = __esm({
    "node_modules/@sermas/toolkit/avatar/xr/planeMarker.js"() {
      init_three_module();
    }
  });

  // node_modules/@sermas/toolkit/avatar/xr/index.js
  var WebAvatarXR;
  var init_xr = __esm({
    "node_modules/@sermas/toolkit/avatar/xr/index.js"() {
      init_events();
      init_logger();
      init_hitTest();
      init_planeMarker();
      WebAvatarXR = class {
        constructor(avatar) {
          this.avatar = avatar;
          this.enabled = false;
          this.started = false;
          this.onSelect = this.onSelect.bind(this);
          this.onSessionEnded = this.onSessionEnded.bind(this);
        }
        isEnabled() {
          return this.enabled;
        }
        async isSupported() {
          const hasXR = "xr" in navigator;
          if (!hasXR)
            return false;
          if (!navigator.xr)
            return false;
          try {
            return await navigator.xr.isSessionSupported("immersive-ar");
          } catch (e4) {
            logger.warn(`Failed to check AR support: ${e4.message}`);
          }
          return false;
        }
        deleteOverlay(id2 = "sermas-ar-overlay", recreateOverlay = true) {
          const exists = document.getElementById(id2);
          if (!exists)
            return;
          exists.remove();
          if (recreateOverlay) {
            this.createOverlay();
          }
        }
        createOverlay(id2 = "sermas-ar-overlay") {
          const exists = document.getElementById(id2);
          if (exists)
            return exists;
          const overlay = document.createElement("div");
          overlay.id = id2;
          overlay.classList.add("sermas-toolkit", "ar-overlay");
          overlay.style.display = "none";
          const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svg.setAttribute("width", "38");
          svg.setAttribute("height", "38");
          svg.style.position = "absolute";
          svg.style.right = "20px";
          svg.style.top = "20px";
          svg.addEventListener("click", () => this.stop());
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28");
          path.setAttribute("stroke", "#fff");
          path.setAttribute("stroke-width", "2");
          svg.appendChild(path);
          overlay.appendChild(svg);
          document.body.appendChild(overlay);
          return overlay;
        }
        async init() {
        }
        async setup() {
          const supported = await this.isSupported();
          if (!supported)
            return;
          if (!this.overlayElement)
            this.overlayElement = this.createOverlay();
          if (!this.hitTestHandler)
            this.hitTestHandler = new HitTestHandler(this.avatar.getRenderer());
        }
        async start() {
          this.setup();
          const started = await this.startXRSession();
          if (!started)
            return false;
          this.setupArScene();
          this.started = true;
          return true;
        }
        async startXRSession() {
          if (this.enabled)
            return true;
          const supported = await this.isSupported();
          if (!supported)
            return false;
          this.started = true;
          const xrSessionInit = {
            requiredFeatures: ["local", "hit-test"],
            optionalFeatures: ["dom-overlay"],
            domOverlay: {
              root: this.overlayElement
            }
          };
          if (!navigator.xr)
            return false;
          if (this.session) {
            this.session.end();
            this.session = void 0;
          }
          try {
            this.session = await navigator.xr.requestSession("immersive-ar", xrSessionInit);
            this.session.addEventListener("end", this.onSessionEnded);
            const renderer = this.avatar.getRenderer();
            renderer.xr.setReferenceSpaceType("local");
            await renderer.xr.setSession(this.session);
            if (this.overlayElement) {
              this.overlayElement.style.display = "";
            }
            this.enabled = true;
            emitter.emit("xr.session", "start");
            return true;
          } catch (e4) {
            logger.error(`Failed to init AR session: ${e4.message}`);
            emitter.emit("xr.session", "error");
          }
          return false;
        }
        async stop() {
          emitter.emit("xr.session", "stop");
          if (!this.started)
            return;
          this.started = false;
          this.enabled = false;
          this.resetOriginalScene();
          this.session?.removeEventListener("end", this.onSessionEnded);
          await this.session?.end();
          this.session = void 0;
          this.deleteOverlay();
          window.location.reload();
        }
        animate(timestamp, frame) {
          this.handleHitTest(frame);
        }
        onSessionEnded() {
          this.stop();
        }
        async destroy() {
          this.stop();
        }
        setupArScene() {
          const model = this.avatar.getModel();
          const scene = this.avatar.getScene();
          const renderer = this.avatar.getRenderer();
          this.planeMarker = createPlaneMarker();
          scene.add(this.planeMarker);
          this.controller = renderer.xr.getController(0);
          scene.add(this.controller);
          if (this.avatar.getBackground()) {
            scene.background = null;
          }
          this.controller.addEventListener("select", this.onSelect);
          if (model) {
            this.modelPosition = model.position;
            this.modelScale = model.scale;
            this.cameraConfig = this.avatar.getCameraConfig();
            scene.remove(model);
          }
        }
        onSelect() {
          const model = this.avatar.getModel();
          const scene = this.avatar.getScene();
          if (!model)
            return;
          if (!this.planeMarker)
            return;
          if (!this.planeMarker.visible)
            return;
          model.position.setFromMatrixPosition(this.planeMarker.matrix);
          model.visible = true;
          model.scale.set(1.5, 1.5, 1.5);
          scene.add(model);
        }
        async handleHitTest(frame) {
          const hitPoseTransformed = await this.hitTestHandler?.onFrame(frame);
          if (!this.planeMarker)
            return;
          if (!hitPoseTransformed) {
            this.planeMarker.visible = false;
            return;
          }
          this.planeMarker.visible = true;
          this.planeMarker.matrix.fromArray(hitPoseTransformed);
        }
        async resetOriginalScene() {
          const model = this.avatar.getModel();
          const scene = this.avatar.getScene();
          const camera = this.avatar.getCamera();
          scene.remove(model);
          if (this.planeMarker) {
            scene.remove(this.planeMarker);
            this.planeMarker = void 0;
          }
          if (this.controller)
            scene.remove(this.controller);
          this.controller = void 0;
          const background = this.avatar.getBackground();
          if (background) {
            scene.background = background;
          }
          if (model && this.modelScale && this.modelPosition) {
            model.scale.set(this.modelScale.x, this.modelScale.y, this.modelScale.z);
            model.position.set(this.modelPosition.x, this.modelPosition.y, this.modelPosition.z);
            this.avatar.setCameraConfig(this.cameraConfig);
            camera.fov = 45;
            camera.updateProjectionMatrix();
          }
          scene.add(model);
        }
      };
    }
  });

  // node_modules/three/examples/jsm/webxr/VRButton.js
  var VRButton;
  var init_VRButton = __esm({
    "node_modules/three/examples/jsm/webxr/VRButton.js"() {
      VRButton = class _VRButton {
        static createButton(renderer) {
          const button = document.createElement("button");
          function showEnterVR() {
            let currentSession = null;
            async function onSessionStarted(session) {
              session.addEventListener("end", onSessionEnded);
              await renderer.xr.setSession(session);
              button.textContent = "EXIT VR";
              currentSession = session;
            }
            function onSessionEnded() {
              currentSession.removeEventListener("end", onSessionEnded);
              button.textContent = "ENTER VR";
              currentSession = null;
            }
            button.style.display = "";
            button.style.cursor = "pointer";
            button.style.left = "calc(50% - 50px)";
            button.style.width = "100px";
            button.textContent = "ENTER VR";
            button.onmouseenter = function() {
              button.style.opacity = "1.0";
            };
            button.onmouseleave = function() {
              button.style.opacity = "0.5";
            };
            button.onclick = function() {
              if (currentSession === null) {
                const sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
                navigator.xr.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
              } else {
                currentSession.end();
              }
            };
          }
          function disableButton() {
            button.style.display = "";
            button.style.cursor = "auto";
            button.style.left = "calc(50% - 75px)";
            button.style.width = "150px";
            button.onmouseenter = null;
            button.onmouseleave = null;
            button.onclick = null;
          }
          function showWebXRNotFound() {
            disableButton();
            button.textContent = "VR NOT SUPPORTED";
          }
          function showVRNotAllowed(exception) {
            disableButton();
            console.warn("Exception when trying to call xr.isSessionSupported", exception);
            button.textContent = "VR NOT ALLOWED";
          }
          function stylizeElement(element) {
            element.style.position = "absolute";
            element.style.bottom = "20px";
            element.style.padding = "12px 6px";
            element.style.border = "1px solid #fff";
            element.style.borderRadius = "4px";
            element.style.background = "rgba(0,0,0,0.1)";
            element.style.color = "#fff";
            element.style.font = "normal 13px sans-serif";
            element.style.textAlign = "center";
            element.style.opacity = "0.5";
            element.style.outline = "none";
            element.style.zIndex = "999";
          }
          if ("xr" in navigator) {
            button.id = "VRButton";
            button.style.display = "none";
            stylizeElement(button);
            navigator.xr.isSessionSupported("immersive-vr").then(function(supported) {
              supported ? showEnterVR() : showWebXRNotFound();
              if (supported && _VRButton.xrSessionIsGranted) {
                button.click();
              }
            }).catch(showVRNotAllowed);
            return button;
          } else {
            const message = document.createElement("a");
            if (window.isSecureContext === false) {
              message.href = document.location.href.replace(/^http:/, "https:");
              message.innerHTML = "WEBXR NEEDS HTTPS";
            } else {
              message.href = "https://immersiveweb.dev/";
              message.innerHTML = "WEBXR NOT AVAILABLE";
            }
            message.style.left = "calc(50% - 90px)";
            message.style.width = "180px";
            message.style.textDecoration = "none";
            stylizeElement(message);
            return message;
          }
        }
        static registerSessionGrantedListener() {
          if (typeof navigator !== "undefined" && "xr" in navigator) {
            if (/WebXRViewer\//i.test(navigator.userAgent))
              return;
            navigator.xr.addEventListener("sessiongranted", () => {
              _VRButton.xrSessionIsGranted = true;
            });
          }
        }
      };
      VRButton.xrSessionIsGranted = false;
      VRButton.registerSessionGrantedListener();
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/lib/EventTarget.js
  var PRIVATE, EventTarget2;
  var init_EventTarget = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/lib/EventTarget.js"() {
      PRIVATE = Symbol("@@webxr-polyfill/EventTarget");
      EventTarget2 = class {
        constructor() {
          this[PRIVATE] = {
            listeners: /* @__PURE__ */ new Map()
          };
        }
        /**
         * @param {string} type
         * @param {Function} listener
         */
        addEventListener(type, listener) {
          if (typeof type !== "string") {
            throw new Error("`type` must be a string");
          }
          if (typeof listener !== "function") {
            throw new Error("`listener` must be a function");
          }
          const typedListeners = this[PRIVATE].listeners.get(type) || [];
          typedListeners.push(listener);
          this[PRIVATE].listeners.set(type, typedListeners);
        }
        /**
         * @param {string} type
         * @param {Function} listener
         */
        removeEventListener(type, listener) {
          if (typeof type !== "string") {
            throw new Error("`type` must be a string");
          }
          if (typeof listener !== "function") {
            throw new Error("`listener` must be a function");
          }
          const typedListeners = this[PRIVATE].listeners.get(type) || [];
          for (let i5 = typedListeners.length; i5 >= 0; i5--) {
            if (typedListeners[i5] === listener) {
              typedListeners.pop();
            }
          }
        }
        /**
         * @param {string} type
         * @param {object} event
         */
        dispatchEvent(type, event) {
          const typedListeners = this[PRIVATE].listeners.get(type) || [];
          const queue = [];
          for (let i5 = 0; i5 < typedListeners.length; i5++) {
            queue[i5] = typedListeners[i5];
          }
          for (let listener of queue) {
            listener(event);
          }
          if (typeof this[`on${type}`] === "function") {
            this[`on${type}`](event);
          }
        }
      };
    }
  });

  // node_modules/gl-matrix/src/gl-matrix/common.js
  var EPSILON, ARRAY_TYPE, degree;
  var init_common = __esm({
    "node_modules/gl-matrix/src/gl-matrix/common.js"() {
      EPSILON = 1e-6;
      ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
      degree = Math.PI / 180;
    }
  });

  // node_modules/gl-matrix/src/gl-matrix/mat4.js
  function create() {
    let out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function copy(out, a4) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    out[4] = a4[4];
    out[5] = a4[5];
    out[6] = a4[6];
    out[7] = a4[7];
    out[8] = a4[8];
    out[9] = a4[9];
    out[10] = a4[10];
    out[11] = a4[11];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function invert(out, a4) {
    let a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
    let a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
    let a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
    let a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
    let b00 = a00 * a11 - a01 * a10;
    let b01 = a00 * a12 - a02 * a10;
    let b02 = a00 * a13 - a03 * a10;
    let b03 = a01 * a12 - a02 * a11;
    let b04 = a01 * a13 - a03 * a11;
    let b05 = a02 * a13 - a03 * a12;
    let b06 = a20 * a31 - a21 * a30;
    let b07 = a20 * a32 - a22 * a30;
    let b08 = a20 * a33 - a23 * a30;
    let b09 = a21 * a32 - a22 * a31;
    let b10 = a21 * a33 - a23 * a31;
    let b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function multiply(out, a4, b3) {
    let a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
    let a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
    let a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
    let a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
    let b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    b0 = b3[4];
    b1 = b3[5];
    b22 = b3[6];
    b32 = b3[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    b0 = b3[8];
    b1 = b3[9];
    b22 = b3[10];
    b32 = b3[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    b0 = b3[12];
    b1 = b3[13];
    b22 = b3[14];
    b32 = b3[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    return out;
  }
  function fromRotationTranslation(out, q4, v5) {
    let x4 = q4[0], y3 = q4[1], z4 = q4[2], w3 = q4[3];
    let x22 = x4 + x4;
    let y22 = y3 + y3;
    let z22 = z4 + z4;
    let xx = x4 * x22;
    let xy = x4 * y22;
    let xz = x4 * z22;
    let yy = y3 * y22;
    let yz = y3 * z22;
    let zz = z4 * z22;
    let wx2 = w3 * x22;
    let wy = w3 * y22;
    let wz = w3 * z22;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx2;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx2;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v5[0];
    out[13] = v5[1];
    out[14] = v5[2];
    out[15] = 1;
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getRotation(out, mat) {
    let trace = mat[0] + mat[5] + mat[10];
    let S3 = 0;
    if (trace > 0) {
      S3 = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S3;
      out[0] = (mat[6] - mat[9]) / S3;
      out[1] = (mat[8] - mat[2]) / S3;
      out[2] = (mat[1] - mat[4]) / S3;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
      S3 = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
      out[3] = (mat[6] - mat[9]) / S3;
      out[0] = 0.25 * S3;
      out[1] = (mat[1] + mat[4]) / S3;
      out[2] = (mat[8] + mat[2]) / S3;
    } else if (mat[5] > mat[10]) {
      S3 = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
      out[3] = (mat[8] - mat[2]) / S3;
      out[0] = (mat[1] + mat[4]) / S3;
      out[1] = 0.25 * S3;
      out[2] = (mat[6] + mat[9]) / S3;
    } else {
      S3 = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
      out[3] = (mat[1] - mat[4]) / S3;
      out[0] = (mat[8] + mat[2]) / S3;
      out[1] = (mat[6] + mat[9]) / S3;
      out[2] = 0.25 * S3;
    }
    return out;
  }
  function perspective(out, fovy, aspect2, near, far) {
    let f3 = 1 / Math.tan(fovy / 2), nf2;
    out[0] = f3 / aspect2;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f3;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf2 = 1 / (near - far);
      out[10] = (far + near) * nf2;
      out[14] = 2 * far * near * nf2;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var init_mat4 = __esm({
    "node_modules/gl-matrix/src/gl-matrix/mat4.js"() {
      init_common();
    }
  });

  // node_modules/gl-matrix/src/gl-matrix/vec3.js
  function create2() {
    let out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone(a4) {
    var out = new ARRAY_TYPE(3);
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    return out;
  }
  function length(a4) {
    let x4 = a4[0];
    let y3 = a4[1];
    let z4 = a4[2];
    return Math.sqrt(x4 * x4 + y3 * y3 + z4 * z4);
  }
  function fromValues(x4, y3, z4) {
    let out = new ARRAY_TYPE(3);
    out[0] = x4;
    out[1] = y3;
    out[2] = z4;
    return out;
  }
  function copy2(out, a4) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    return out;
  }
  function add(out, a4, b3) {
    out[0] = a4[0] + b3[0];
    out[1] = a4[1] + b3[1];
    out[2] = a4[2] + b3[2];
    return out;
  }
  function scale(out, a4, b3) {
    out[0] = a4[0] * b3;
    out[1] = a4[1] * b3;
    out[2] = a4[2] * b3;
    return out;
  }
  function normalize2(out, a4) {
    let x4 = a4[0];
    let y3 = a4[1];
    let z4 = a4[2];
    let len2 = x4 * x4 + y3 * y3 + z4 * z4;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
      out[0] = a4[0] * len2;
      out[1] = a4[1] * len2;
      out[2] = a4[2] * len2;
    }
    return out;
  }
  function dot(a4, b3) {
    return a4[0] * b3[0] + a4[1] * b3[1] + a4[2] * b3[2];
  }
  function cross(out, a4, b3) {
    let ax = a4[0], ay = a4[1], az = a4[2];
    let bx = b3[0], by = b3[1], bz = b3[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformQuat(out, a4, q4) {
    let qx = q4[0], qy = q4[1], qz = q4[2], qw2 = q4[3];
    let x4 = a4[0], y3 = a4[1], z4 = a4[2];
    let uvx = qy * z4 - qz * y3, uvy = qz * x4 - qx * z4, uvz = qx * y3 - qy * x4;
    let uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    let w22 = qw2 * 2;
    uvx *= w22;
    uvy *= w22;
    uvz *= w22;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x4 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z4 + uvz + uuvz;
    return out;
  }
  function angle(a4, b3) {
    let tempA = fromValues(a4[0], a4[1], a4[2]);
    let tempB = fromValues(b3[0], b3[1], b3[2]);
    normalize2(tempA, tempA);
    normalize2(tempB, tempB);
    let cosine = dot(tempA, tempB);
    if (cosine > 1) {
      return 0;
    } else if (cosine < -1) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  var len, forEach2;
  var init_vec3 = __esm({
    "node_modules/gl-matrix/src/gl-matrix/vec3.js"() {
      init_common();
      len = length;
      forEach2 = function() {
        let vec = create2();
        return function(a4, stride, offset, count, fn4, arg) {
          let i5, l4;
          if (!stride) {
            stride = 3;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l4 = Math.min(count * stride + offset, a4.length);
          } else {
            l4 = a4.length;
          }
          for (i5 = offset; i5 < l4; i5 += stride) {
            vec[0] = a4[i5];
            vec[1] = a4[i5 + 1];
            vec[2] = a4[i5 + 2];
            fn4(vec, vec, arg);
            a4[i5] = vec[0];
            a4[i5 + 1] = vec[1];
            a4[i5 + 2] = vec[2];
          }
          return a4;
        };
      }();
    }
  });

  // node_modules/gl-matrix/src/gl-matrix/mat3.js
  function create3() {
    let out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  var init_mat3 = __esm({
    "node_modules/gl-matrix/src/gl-matrix/mat3.js"() {
      init_common();
    }
  });

  // node_modules/gl-matrix/src/gl-matrix/vec4.js
  function create4() {
    let out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone2(a4) {
    let out = new ARRAY_TYPE(4);
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    return out;
  }
  function fromValues2(x4, y3, z4, w3) {
    let out = new ARRAY_TYPE(4);
    out[0] = x4;
    out[1] = y3;
    out[2] = z4;
    out[3] = w3;
    return out;
  }
  function copy3(out, a4) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    return out;
  }
  function normalize3(out, a4) {
    let x4 = a4[0];
    let y3 = a4[1];
    let z4 = a4[2];
    let w3 = a4[3];
    let len2 = x4 * x4 + y3 * y3 + z4 * z4 + w3 * w3;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
      out[0] = x4 * len2;
      out[1] = y3 * len2;
      out[2] = z4 * len2;
      out[3] = w3 * len2;
    }
    return out;
  }
  var forEach3;
  var init_vec4 = __esm({
    "node_modules/gl-matrix/src/gl-matrix/vec4.js"() {
      init_common();
      forEach3 = function() {
        let vec = create4();
        return function(a4, stride, offset, count, fn4, arg) {
          let i5, l4;
          if (!stride) {
            stride = 4;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l4 = Math.min(count * stride + offset, a4.length);
          } else {
            l4 = a4.length;
          }
          for (i5 = offset; i5 < l4; i5 += stride) {
            vec[0] = a4[i5];
            vec[1] = a4[i5 + 1];
            vec[2] = a4[i5 + 2];
            vec[3] = a4[i5 + 3];
            fn4(vec, vec, arg);
            a4[i5] = vec[0];
            a4[i5 + 1] = vec[1];
            a4[i5 + 2] = vec[2];
            a4[i5 + 3] = vec[3];
          }
          return a4;
        };
      }();
    }
  });

  // node_modules/gl-matrix/src/gl-matrix/quat.js
  function create5() {
    let out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    let s4 = Math.sin(rad);
    out[0] = s4 * axis[0];
    out[1] = s4 * axis[1];
    out[2] = s4 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply2(out, a4, b3) {
    let ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
    let bx = b3[0], by = b3[1], bz = b3[2], bw2 = b3[3];
    out[0] = ax * bw2 + aw * bx + ay * bz - az * by;
    out[1] = ay * bw2 + aw * by + az * bx - ax * bz;
    out[2] = az * bw2 + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw2 - ax * bx - ay * by - az * bz;
    return out;
  }
  function slerp(out, a4, b3, t4) {
    let ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
    let bx = b3[0], by = b3[1], bz = b3[2], bw2 = b3[3];
    let omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw2;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw2 = -bw2;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t4) * omega) / sinom;
      scale1 = Math.sin(t4 * omega) / sinom;
    } else {
      scale0 = 1 - t4;
      scale1 = t4;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw2;
    return out;
  }
  function invert2(out, a4) {
    let a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
    let dot3 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    let invDot = dot3 ? 1 / dot3 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function fromMat3(out, m4) {
    let fTrace = m4[0] + m4[4] + m4[8];
    let fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m4[5] - m4[7]) * fRoot;
      out[1] = (m4[6] - m4[2]) * fRoot;
      out[2] = (m4[1] - m4[3]) * fRoot;
    } else {
      let i5 = 0;
      if (m4[4] > m4[0])
        i5 = 1;
      if (m4[8] > m4[i5 * 3 + i5])
        i5 = 2;
      let j4 = (i5 + 1) % 3;
      let k4 = (i5 + 2) % 3;
      fRoot = Math.sqrt(m4[i5 * 3 + i5] - m4[j4 * 3 + j4] - m4[k4 * 3 + k4] + 1);
      out[i5] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m4[j4 * 3 + k4] - m4[k4 * 3 + j4]) * fRoot;
      out[j4] = (m4[j4 * 3 + i5] + m4[i5 * 3 + j4]) * fRoot;
      out[k4] = (m4[k4 * 3 + i5] + m4[i5 * 3 + k4]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x4, y3, z4) {
    let halfToRad = 0.5 * Math.PI / 180;
    x4 *= halfToRad;
    y3 *= halfToRad;
    z4 *= halfToRad;
    let sx = Math.sin(x4);
    let cx = Math.cos(x4);
    let sy = Math.sin(y3);
    let cy = Math.cos(y3);
    let sz = Math.sin(z4);
    let cz = Math.cos(z4);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  var clone3, fromValues3, copy4, normalize4, rotationTo, sqlerp, setAxes;
  var init_quat = __esm({
    "node_modules/gl-matrix/src/gl-matrix/quat.js"() {
      init_common();
      init_mat3();
      init_vec3();
      init_vec4();
      clone3 = clone2;
      fromValues3 = fromValues2;
      copy4 = copy3;
      normalize4 = normalize3;
      rotationTo = function() {
        let tmpvec3 = create2();
        let xUnitVec3 = fromValues(1, 0, 0);
        let yUnitVec3 = fromValues(0, 1, 0);
        return function(out, a4, b3) {
          let dot3 = dot(a4, b3);
          if (dot3 < -0.999999) {
            cross(tmpvec3, xUnitVec3, a4);
            if (len(tmpvec3) < 1e-6)
              cross(tmpvec3, yUnitVec3, a4);
            normalize2(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
          } else if (dot3 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
          } else {
            cross(tmpvec3, a4, b3);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot3;
            return normalize4(out, out);
          }
        };
      }();
      sqlerp = function() {
        let temp1 = create5();
        let temp2 = create5();
        return function(out, a4, b3, c5, d4, t4) {
          slerp(temp1, a4, d4, t4);
          slerp(temp2, b3, c5, t4);
          slerp(out, temp1, temp2, 2 * t4 * (1 - t4));
          return out;
        };
      }();
      setAxes = function() {
        let matr = create3();
        return function(out, view, right, up2) {
          matr[0] = right[0];
          matr[3] = right[1];
          matr[6] = right[2];
          matr[1] = up2[0];
          matr[4] = up2[1];
          matr[7] = up2[2];
          matr[2] = -view[0];
          matr[5] = -view[1];
          matr[8] = -view[2];
          return normalize4(out, fromMat3(out, matr));
        };
      }();
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRRigidTransform.js
  var PRIVATE2, XRRigidTransform2;
  var init_XRRigidTransform = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRRigidTransform.js"() {
      init_mat4();
      init_vec3();
      init_quat();
      PRIVATE2 = Symbol("@@webxr-polyfill/XRRigidTransform");
      XRRigidTransform2 = class _XRRigidTransform {
        // no arguments: identity transform
        // (Float32Array): transform based on matrix
        // (DOMPointReadOnly): transform based on position without any rotation
        // (DOMPointReadOnly, DOMPointReadOnly): transform based on position and
        // orientation quaternion
        constructor() {
          this[PRIVATE2] = {
            matrix: null,
            position: null,
            orientation: null,
            inverse: null
          };
          if (arguments.length === 0) {
            this[PRIVATE2].matrix = identity(new Float32Array(16));
          } else if (arguments.length === 1) {
            if (arguments[0] instanceof Float32Array) {
              this[PRIVATE2].matrix = arguments[0];
            } else {
              this[PRIVATE2].position = this._getPoint(arguments[0]);
              this[PRIVATE2].orientation = DOMPointReadOnly.fromPoint({
                x: 0,
                y: 0,
                z: 0,
                w: 1
              });
            }
          } else if (arguments.length === 2) {
            this[PRIVATE2].position = this._getPoint(arguments[0]);
            this[PRIVATE2].orientation = this._getPoint(arguments[1]);
          } else {
            throw new Error("Too many arguments!");
          }
          if (this[PRIVATE2].matrix) {
            let position = create2();
            getTranslation(position, this[PRIVATE2].matrix);
            this[PRIVATE2].position = DOMPointReadOnly.fromPoint({
              x: position[0],
              y: position[1],
              z: position[2]
            });
            let orientation = create5();
            getRotation(orientation, this[PRIVATE2].matrix);
            this[PRIVATE2].orientation = DOMPointReadOnly.fromPoint({
              x: orientation[0],
              y: orientation[1],
              z: orientation[2],
              w: orientation[3]
            });
          } else {
            this[PRIVATE2].matrix = identity(new Float32Array(16));
            fromRotationTranslation(
              this[PRIVATE2].matrix,
              fromValues3(
                this[PRIVATE2].orientation.x,
                this[PRIVATE2].orientation.y,
                this[PRIVATE2].orientation.z,
                this[PRIVATE2].orientation.w
              ),
              fromValues(
                this[PRIVATE2].position.x,
                this[PRIVATE2].position.y,
                this[PRIVATE2].position.z
              )
            );
          }
        }
        /**
         * Try to convert arg to a DOMPointReadOnly if it isn't already one.
         * @param {*} arg
         * @return {DOMPointReadOnly}
         */
        _getPoint(arg) {
          if (arg instanceof DOMPointReadOnly) {
            return arg;
          }
          return DOMPointReadOnly.fromPoint(arg);
        }
        /**
         * @return {Float32Array}
         */
        get matrix() {
          return this[PRIVATE2].matrix;
        }
        /**
         * @return {DOMPointReadOnly}
         */
        get position() {
          return this[PRIVATE2].position;
        }
        /**
         * @return {DOMPointReadOnly}
         */
        get orientation() {
          return this[PRIVATE2].orientation;
        }
        /**
         * @return {XRRigidTransform}
         */
        get inverse() {
          if (this[PRIVATE2].inverse === null) {
            let invMatrix = identity(new Float32Array(16));
            invert(invMatrix, this[PRIVATE2].matrix);
            this[PRIVATE2].inverse = new _XRRigidTransform(invMatrix);
            this[PRIVATE2].inverse[PRIVATE2].inverse = this;
          }
          return this[PRIVATE2].inverse;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRSpace.js
  var PRIVATE3, XRSpace;
  var init_XRSpace = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRSpace.js"() {
      init_XRRigidTransform();
      init_mat4();
      PRIVATE3 = Symbol("@@webxr-polyfill/XRSpace");
      XRSpace = class {
        /**
         * @param {string?} specialType
         * @param {XRInputSource?} inputSource 
         */
        constructor(specialType = null, inputSource = null) {
          this[PRIVATE3] = {
            specialType,
            inputSource,
            // The transform for the space in the base space, along with it's inverse
            baseMatrix: null,
            inverseBaseMatrix: null,
            lastFrameId: -1
          };
        }
        /**
         * @return {string?}
         */
        get _specialType() {
          return this[PRIVATE3].specialType;
        }
        /**
         * @return {XRInputSource?}
         */
        get _inputSource() {
          return this[PRIVATE3].inputSource;
        }
        /**
         * NON-STANDARD
         * Trigger an update for this space's base pose if necessary
         * @param {XRDevice} device
         * @param {Number} frameId
         */
        _ensurePoseUpdated(device, frameId) {
          if (frameId == this[PRIVATE3].lastFrameId)
            return;
          this[PRIVATE3].lastFrameId = frameId;
          this._onPoseUpdate(device);
        }
        /**
         * NON-STANDARD
         * Called when this space's base pose needs to be updated
         * @param {XRDevice} device
         */
        _onPoseUpdate(device) {
          if (this[PRIVATE3].specialType == "viewer") {
            this._baseMatrix = device.getBasePoseMatrix();
          }
        }
        /**
         * NON-STANDARD
         * @param {Float32Array(16)} matrix
         */
        set _baseMatrix(matrix) {
          this[PRIVATE3].baseMatrix = matrix;
          this[PRIVATE3].inverseBaseMatrix = null;
        }
        /**
         * NON-STANDARD
         * @return {Float32Array(16)}
         */
        get _baseMatrix() {
          if (!this[PRIVATE3].baseMatrix) {
            if (this[PRIVATE3].inverseBaseMatrix) {
              this[PRIVATE3].baseMatrix = new Float32Array(16);
              invert(this[PRIVATE3].baseMatrix, this[PRIVATE3].inverseBaseMatrix);
            }
          }
          return this[PRIVATE3].baseMatrix;
        }
        /**
         * NON-STANDARD
         * @param {Float32Array(16)} matrix
         */
        set _inverseBaseMatrix(matrix) {
          this[PRIVATE3].inverseBaseMatrix = matrix;
          this[PRIVATE3].baseMatrix = null;
        }
        /**
         * NON-STANDARD
         * @return {Float32Array(16)}
         */
        get _inverseBaseMatrix() {
          if (!this[PRIVATE3].inverseBaseMatrix) {
            if (this[PRIVATE3].baseMatrix) {
              this[PRIVATE3].inverseBaseMatrix = new Float32Array(16);
              invert(this[PRIVATE3].inverseBaseMatrix, this[PRIVATE3].baseMatrix);
            }
          }
          return this[PRIVATE3].inverseBaseMatrix;
        }
        /**
         * NON-STANDARD
         * Gets the transform of the given space in this space
         *
         * @param {XRSpace} space
         * @return {XRRigidTransform}
         */
        _getSpaceRelativeTransform(space) {
          if (!this._inverseBaseMatrix || !space._baseMatrix) {
            return null;
          }
          let out = new Float32Array(16);
          multiply(out, this._inverseBaseMatrix, space._baseMatrix);
          return new XRRigidTransform2(out);
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpace.js
  function isFloor(type) {
    return type === "bounded-floor" || type === "local-floor";
  }
  var DEFAULT_EMULATION_HEIGHT, PRIVATE4, XRReferenceSpaceTypes, XRReferenceSpace;
  var init_XRReferenceSpace = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpace.js"() {
      init_XRSpace();
      init_mat4();
      DEFAULT_EMULATION_HEIGHT = 1.6;
      PRIVATE4 = Symbol("@@webxr-polyfill/XRReferenceSpace");
      XRReferenceSpaceTypes = [
        "viewer",
        "local",
        "local-floor",
        "bounded-floor",
        "unbounded"
        // TODO: 'unbounded' is not supported by the polyfill.
      ];
      XRReferenceSpace = class _XRReferenceSpace extends XRSpace {
        /**
         * Optionally takes a `transform` from a device's requestFrameOfReferenceMatrix
         * so device's can provide their own transforms for stage (or if they
         * wanted to override eye-level/head-model).
         *
         * @param {XRReferenceSpaceType} type
         * @param {Float32Array?} transform
         */
        constructor(type, transform = null) {
          if (!XRReferenceSpaceTypes.includes(type)) {
            throw new Error(`XRReferenceSpaceType must be one of ${XRReferenceSpaceTypes}`);
          }
          super(type);
          if (type === "bounded-floor" && !transform) {
            throw new Error(`XRReferenceSpace cannot use 'bounded-floor' type if the platform does not provide the floor level`);
          }
          if (isFloor(type) && !transform) {
            transform = identity(new Float32Array(16));
            transform[13] = DEFAULT_EMULATION_HEIGHT;
          }
          this._inverseBaseMatrix = transform || identity(new Float32Array(16));
          this[PRIVATE4] = {
            type,
            transform,
            originOffset: identity(new Float32Array(16))
          };
        }
        /**
         * NON-STANDARD
         * Takes a base pose model matrix and transforms it by the
         * frame of reference.
         *
         * @param {Float32Array} out
         * @param {Float32Array} pose
         */
        _transformBasePoseMatrix(out, pose) {
          multiply(out, this._inverseBaseMatrix, pose);
        }
        /**
         * NON-STANDARD
         * 
         * @return {Float32Array}
         */
        _originOffsetMatrix() {
          return this[PRIVATE4].originOffset;
        }
        /**
         * transformMatrix = Inv(OriginOffsetMatrix) * transformMatrix
         * @param {Float32Array} transformMatrix 
         */
        _adjustForOriginOffset(transformMatrix) {
          let inverseOriginOffsetMatrix = new Float32Array(16);
          invert(inverseOriginOffsetMatrix, this[PRIVATE4].originOffset);
          multiply(transformMatrix, inverseOriginOffsetMatrix, transformMatrix);
        }
        /**
         * Gets the transform of the given space in this space
         *
         * @param {XRSpace} space
         * @return {XRRigidTransform}
         */
        _getSpaceRelativeTransform(space) {
          let transform = super._getSpaceRelativeTransform(space);
          this._adjustForOriginOffset(transform.matrix);
          return new XRRigidTransform(transform.matrix);
        }
        /**
         * Doesn't update the bound geometry for bounded reference spaces.
         * @param {XRRigidTransform} additionalOffset
         * @return {XRReferenceSpace}
        */
        getOffsetReferenceSpace(additionalOffset) {
          let newSpace = new _XRReferenceSpace(
            this[PRIVATE4].type,
            this[PRIVATE4].transform,
            this[PRIVATE4].bounds
          );
          multiply(newSpace[PRIVATE4].originOffset, this[PRIVATE4].originOffset, additionalOffset.matrix);
          return newSpace;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRSystem.js
  var PRIVATE5, XRSessionModes, DEFAULT_SESSION_OPTIONS, POLYFILL_REQUEST_SESSION_ERROR, XRSystem;
  var init_XRSystem = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRSystem.js"() {
      init_EventTarget();
      init_XRReferenceSpace();
      PRIVATE5 = Symbol("@@webxr-polyfill/XR");
      XRSessionModes = ["inline", "immersive-vr", "immersive-ar"];
      DEFAULT_SESSION_OPTIONS = {
        "inline": {
          requiredFeatures: ["viewer"],
          optionalFeatures: []
        },
        "immersive-vr": {
          requiredFeatures: ["viewer", "local"],
          optionalFeatures: []
        },
        "immersive-ar": {
          requiredFeatures: ["viewer", "local"],
          optionalFeatures: []
        }
      };
      POLYFILL_REQUEST_SESSION_ERROR = `Polyfill Error: Must call navigator.xr.isSessionSupported() with any XRSessionMode
or navigator.xr.requestSession('inline') prior to requesting an immersive
session. This is a limitation specific to the WebXR Polyfill and does not apply
to native implementations of the API.`;
      XRSystem = class extends EventTarget2 {
        /**
         * Receives a promise of an XRDevice, so that the polyfill
         * can pass in some initial checks to asynchronously provide XRDevices
         * if content immediately requests `requestDevice()`.
         *
         * @param {Promise<XRDevice>} devicePromise
         */
        constructor(devicePromise) {
          super();
          this[PRIVATE5] = {
            device: null,
            devicePromise,
            immersiveSession: null,
            inlineSessions: /* @__PURE__ */ new Set()
          };
          devicePromise.then((device) => {
            this[PRIVATE5].device = device;
          });
        }
        /**
         * @param {XRSessionMode} mode
         * @return {Promise<boolean>}
         */
        async isSessionSupported(mode) {
          if (!this[PRIVATE5].device) {
            await this[PRIVATE5].devicePromise;
          }
          if (mode != "inline") {
            return Promise.resolve(this[PRIVATE5].device.isSessionSupported(mode));
          }
          return Promise.resolve(true);
        }
        /**
         * @param {XRSessionMode} mode
         * @param {XRSessionInit} options
         * @return {Promise<XRSession>}
         */
        async requestSession(mode, options) {
          if (!this[PRIVATE5].device) {
            if (mode != "inline") {
              throw new Error(POLYFILL_REQUEST_SESSION_ERROR);
            } else {
              await this[PRIVATE5].devicePromise;
            }
          }
          if (!XRSessionModes.includes(mode)) {
            throw new TypeError(
              `The provided value '${mode}' is not a valid enum value of type XRSessionMode`
            );
          }
          const defaultOptions = DEFAULT_SESSION_OPTIONS[mode];
          const requiredFeatures = defaultOptions.requiredFeatures.concat(
            options && options.requiredFeatures ? options.requiredFeatures : []
          );
          const optionalFeatures = defaultOptions.optionalFeatures.concat(
            options && options.optionalFeatures ? options.optionalFeatures : []
          );
          const enabledFeatures = /* @__PURE__ */ new Set();
          let requirementsFailed = false;
          for (let feature of requiredFeatures) {
            if (!this[PRIVATE5].device.isFeatureSupported(feature)) {
              console.error(`The required feature '${feature}' is not supported`);
              requirementsFailed = true;
            } else {
              enabledFeatures.add(feature);
            }
          }
          if (requirementsFailed) {
            throw new DOMException("Session does not support some required features", "NotSupportedError");
          }
          for (let feature of optionalFeatures) {
            if (!this[PRIVATE5].device.isFeatureSupported(feature)) {
              console.log(`The optional feature '${feature}' is not supported`);
            } else {
              enabledFeatures.add(feature);
            }
          }
          const sessionId = await this[PRIVATE5].device.requestSession(mode, enabledFeatures);
          const session = new XRSession(this[PRIVATE5].device, mode, sessionId);
          if (mode == "inline") {
            this[PRIVATE5].inlineSessions.add(session);
          } else {
            this[PRIVATE5].immersiveSession = session;
          }
          const onSessionEnd = () => {
            if (mode == "inline") {
              this[PRIVATE5].inlineSessions.delete(session);
            } else {
              this[PRIVATE5].immersiveSession = null;
            }
            session.removeEventListener("end", onSessionEnd);
          };
          session.addEventListener("end", onSessionEnd);
          return session;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/lib/global.js
  var _global2, global_default;
  var init_global2 = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/lib/global.js"() {
      _global2 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      global_default = _global2;
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/lib/now.js
  var now2, now_default;
  var init_now = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/lib/now.js"() {
      init_global2();
      if ("performance" in global_default === false) {
        let startTime = Date.now();
        now2 = () => Date.now() - startTime;
      } else {
        now2 = () => performance.now();
      }
      now_default = now2;
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRPose.js
  var PRIVATE6, XRPose2;
  var init_XRPose = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRPose.js"() {
      PRIVATE6 = Symbol("@@webxr-polyfill/XRPose");
      XRPose2 = class {
        /**
         * @param {XRRigidTransform} transform 
         * @param {boolean} emulatedPosition 
         */
        constructor(transform, emulatedPosition) {
          this[PRIVATE6] = {
            transform,
            emulatedPosition
          };
        }
        /**
         * @return {XRRigidTransform}
         */
        get transform() {
          return this[PRIVATE6].transform;
        }
        /**
         * @return {bool}
         */
        get emulatedPosition() {
          return this[PRIVATE6].emulatedPosition;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRViewerPose.js
  var PRIVATE7, XRViewerPose;
  var init_XRViewerPose = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRViewerPose.js"() {
      init_XRPose();
      PRIVATE7 = Symbol("@@webxr-polyfill/XRViewerPose");
      XRViewerPose = class extends XRPose2 {
        /**
         * @param {XRDevice} device
         */
        constructor(transform, views, emulatedPosition = false) {
          super(transform, emulatedPosition);
          this[PRIVATE7] = {
            views
          };
        }
        /**
         * @return {Array<XRView>}
         */
        get views() {
          return this[PRIVATE7].views;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRViewport.js
  var PRIVATE8, XRViewport;
  var init_XRViewport = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRViewport.js"() {
      PRIVATE8 = Symbol("@@webxr-polyfill/XRViewport");
      XRViewport = class {
        /**
         * Takes a proxy object that this viewport's XRView
         * updates and we serve here to match API.
         *
         * @param {Object} target
         */
        constructor(target) {
          this[PRIVATE8] = { target };
        }
        /**
         * @return {number}
         */
        get x() {
          return this[PRIVATE8].target.x;
        }
        /**
         * @return {number}
         */
        get y() {
          return this[PRIVATE8].target.y;
        }
        /**
         * @return {number}
         */
        get width() {
          return this[PRIVATE8].target.width;
        }
        /**
         * @return {number}
         */
        get height() {
          return this[PRIVATE8].target.height;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRView.js
  var XREyes, PRIVATE9, XRView;
  var init_XRView = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRView.js"() {
      init_XRViewport();
      init_XRRigidTransform();
      XREyes = ["left", "right", "none"];
      PRIVATE9 = Symbol("@@webxr-polyfill/XRView");
      XRView = class {
        /**
         * @param {XRDevice} device
         * @param {XREye} eye
         * @param {number} sessionId
         * @param {number} viewIndex
         */
        constructor(device, transform, eye, sessionId, viewIndex) {
          if (!XREyes.includes(eye)) {
            throw new Error(`XREye must be one of: ${XREyes}`);
          }
          const temp = /* @__PURE__ */ Object.create(null);
          const viewport = new XRViewport(temp);
          this[PRIVATE9] = {
            device,
            eye,
            viewport,
            temp,
            sessionId,
            transform,
            viewIndex
          };
        }
        /**
         * @return {XREye}
         */
        get eye() {
          return this[PRIVATE9].eye;
        }
        /**
         * @return {Float32Array}
         */
        get projectionMatrix() {
          return this[PRIVATE9].device.getProjectionMatrix(this.eye, this[PRIVATE9].viewIndex);
        }
        /**
         * @return {XRRigidTransform}
         */
        get transform() {
          return this[PRIVATE9].transform;
        }
        /**
         * NON-STANDARD
         *
         * `getViewport` is now exposed via XRWebGLLayer instead of XRView.
         * XRWebGLLayer delegates all the actual work to this function.
         *
         * @param {XRWebGLLayer} layer
         * @return {XRViewport?}
         */
        _getViewport(layer) {
          if (this[PRIVATE9].device.getViewport(
            this[PRIVATE9].sessionId,
            this.eye,
            layer,
            this[PRIVATE9].temp,
            this[PRIVATE9].viewIndex
          )) {
            return this[PRIVATE9].viewport;
          }
          return void 0;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRFrame.js
  var PRIVATE11, NON_ACTIVE_MSG, NON_ANIMFRAME_MSG, NEXT_FRAME_ID, XRFrame;
  var init_XRFrame = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRFrame.js"() {
      init_XRSession();
      init_XRViewerPose();
      init_XRView();
      PRIVATE11 = Symbol("@@webxr-polyfill/XRFrame");
      NON_ACTIVE_MSG = "XRFrame access outside the callback that produced it is invalid.";
      NON_ANIMFRAME_MSG = "getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.";
      NEXT_FRAME_ID = 0;
      XRFrame = class {
        /**
         * @param {XRDevice} device
         * @param {XRSession} session
         * @param {number} sessionId
         */
        constructor(device, session, sessionId) {
          this[PRIVATE11] = {
            id: ++NEXT_FRAME_ID,
            active: false,
            animationFrame: false,
            device,
            session,
            sessionId
          };
        }
        /**
         * @return {XRSession} session
         */
        get session() {
          return this[PRIVATE11].session;
        }
        /**
         * @param {XRReferenceSpace} referenceSpace
         * @return {XRViewerPose?}
         */
        getViewerPose(referenceSpace) {
          if (!this[PRIVATE11].animationFrame) {
            throw new DOMException(NON_ANIMFRAME_MSG, "InvalidStateError");
          }
          if (!this[PRIVATE11].active) {
            throw new DOMException(NON_ACTIVE_MSG, "InvalidStateError");
          }
          const device = this[PRIVATE11].device;
          const session = this[PRIVATE11].session;
          session[PRIVATE10].viewerSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
          referenceSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
          let viewerTransform = referenceSpace._getSpaceRelativeTransform(session[PRIVATE10].viewerSpace);
          const views = [];
          for (const viewSpace of session[PRIVATE10].viewSpaces) {
            viewSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
            let viewTransform = referenceSpace._getSpaceRelativeTransform(viewSpace);
            let view = new XRView(device, viewTransform, viewSpace.eye, this[PRIVATE11].sessionId, viewSpace.viewIndex);
            views.push(view);
          }
          let viewerPose = new XRViewerPose(
            viewerTransform,
            views,
            false
            /* TODO: emulatedPosition */
          );
          return viewerPose;
        }
        /**
         * @param {XRSpace} space
         * @param {XRSpace} baseSpace
         * @return {XRPose?} pose
         */
        getPose(space, baseSpace) {
          if (!this[PRIVATE11].active) {
            throw new DOMException(NON_ACTIVE_MSG, "InvalidStateError");
          }
          const device = this[PRIVATE11].device;
          if (space._specialType === "target-ray" || space._specialType === "grip") {
            return device.getInputPose(
              space._inputSource,
              baseSpace,
              space._specialType
            );
          } else {
            space._ensurePoseUpdated(device, this[PRIVATE11].id);
            baseSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
            let transform = baseSpace._getSpaceRelativeTransform(space);
            if (!transform) {
              return null;
            }
            return new XRPose(
              transform,
              false
              /* TODO: emulatedPosition */
            );
          }
          return null;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRRenderState.js
  var PRIVATE12, XRRenderStateInit, XRRenderState;
  var init_XRRenderState = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRRenderState.js"() {
      PRIVATE12 = Symbol("@@webxr-polyfill/XRRenderState");
      XRRenderStateInit = Object.freeze({
        depthNear: 0.1,
        depthFar: 1e3,
        inlineVerticalFieldOfView: null,
        baseLayer: null
      });
      XRRenderState = class {
        /**
         * @param {Object?} stateInit
         */
        constructor(stateInit = {}) {
          const config = Object.assign({}, XRRenderStateInit, stateInit);
          this[PRIVATE12] = { config };
        }
        /**
         * @return {number}
         */
        get depthNear() {
          return this[PRIVATE12].config.depthNear;
        }
        /**
         * @return {number}
         */
        get depthFar() {
          return this[PRIVATE12].config.depthFar;
        }
        /**
         * @return {number?}
         */
        get inlineVerticalFieldOfView() {
          return this[PRIVATE12].config.inlineVerticalFieldOfView;
        }
        /**
         * @return {XRWebGLLayer}
         */
        get baseLayer() {
          return this[PRIVATE12].config.baseLayer;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourceEvent.js
  var PRIVATE13, XRInputSourceEvent;
  var init_XRInputSourceEvent = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourceEvent.js"() {
      PRIVATE13 = Symbol("@@webxr-polyfill/XRInputSourceEvent");
      XRInputSourceEvent = class _XRInputSourceEvent extends Event {
        /**
         * @param {string} type
         * @param {Object} eventInitDict
         */
        constructor(type, eventInitDict) {
          super(type, eventInitDict);
          this[PRIVATE13] = {
            frame: eventInitDict.frame,
            inputSource: eventInitDict.inputSource
          };
          Object.setPrototypeOf(this, _XRInputSourceEvent.prototype);
        }
        /**
         * @return {XRFrame}
         */
        get frame() {
          return this[PRIVATE13].frame;
        }
        /**
         * @return {XRInputSource}
         */
        get inputSource() {
          return this[PRIVATE13].inputSource;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRSessionEvent.js
  var PRIVATE14, XRSessionEvent;
  var init_XRSessionEvent = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRSessionEvent.js"() {
      PRIVATE14 = Symbol("@@webxr-polyfill/XRSessionEvent");
      XRSessionEvent = class _XRSessionEvent extends Event {
        /**
         * @param {string} type
         * @param {Object} eventInitDict
         */
        constructor(type, eventInitDict) {
          super(type, eventInitDict);
          this[PRIVATE14] = {
            session: eventInitDict.session
          };
          Object.setPrototypeOf(this, _XRSessionEvent.prototype);
        }
        /**
         * @return {XRSession}
         */
        get session() {
          return this[PRIVATE14].session;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourcesChangeEvent.js
  var PRIVATE15, XRInputSourcesChangeEvent;
  var init_XRInputSourcesChangeEvent = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourcesChangeEvent.js"() {
      PRIVATE15 = Symbol("@@webxr-polyfill/XRInputSourcesChangeEvent");
      XRInputSourcesChangeEvent = class _XRInputSourcesChangeEvent extends Event {
        /**
         * @param {string} type
         * @param {Object} eventInitDict
         */
        constructor(type, eventInitDict) {
          super(type, eventInitDict);
          this[PRIVATE15] = {
            session: eventInitDict.session,
            added: eventInitDict.added,
            removed: eventInitDict.removed
          };
          Object.setPrototypeOf(this, _XRInputSourcesChangeEvent.prototype);
        }
        /**
         * @return {XRSession}
         */
        get session() {
          return this[PRIVATE15].session;
        }
        /**
         * @return {Array<XRInputSource>}
         */
        get added() {
          return this[PRIVATE15].added;
        }
        /**
         * @return {Array<XRInputSource>}
         */
        get removed() {
          return this[PRIVATE15].removed;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRSession.js
  var PRIVATE10, XRViewSpace, XRSession2;
  var init_XRSession = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRSession.js"() {
      init_EventTarget();
      init_now();
      init_XRFrame();
      init_XRReferenceSpace();
      init_XRRenderState();
      init_XRInputSourceEvent();
      init_XRSessionEvent();
      init_XRSpace();
      init_XRInputSourcesChangeEvent();
      PRIVATE10 = Symbol("@@webxr-polyfill/XRSession");
      XRViewSpace = class extends XRSpace {
        constructor(eye) {
          super(eye);
        }
        get eye() {
          return this._specialType;
        }
        /**
         * Called when this space's base pose needs to be updated
         * @param {XRDevice} device
         */
        _onPoseUpdate(device) {
          this._inverseBaseMatrix = device.getBaseViewMatrix(this._specialType);
        }
      };
      XRSession2 = class extends EventTarget2 {
        /**
         * @param {XRDevice} device
         * @param {XRSessionMode} mode
         * @param {number} id
         */
        constructor(device, mode, id2) {
          super();
          let immersive = mode != "inline";
          let initialRenderState = new XRRenderState({
            inlineVerticalFieldOfView: immersive ? null : Math.PI * 0.5
          });
          const defaultViewSpaces = immersive ? [new XRViewSpace("left"), new XRViewSpace("right")] : [new XRViewSpace("none")];
          Object.freeze(defaultViewSpaces);
          this[PRIVATE10] = {
            device,
            mode,
            immersive,
            ended: false,
            suspended: false,
            frameCallbacks: [],
            currentFrameCallbacks: null,
            frameHandle: 0,
            deviceFrameHandle: null,
            id: id2,
            activeRenderState: initialRenderState,
            pendingRenderState: null,
            viewerSpace: new XRReferenceSpace("viewer"),
            get viewSpaces() {
              return device.getViewSpaces(mode) || defaultViewSpaces;
            },
            currentInputSources: []
          };
          this[PRIVATE10].onDeviceFrame = () => {
            if (this[PRIVATE10].ended || this[PRIVATE10].suspended) {
              return;
            }
            this[PRIVATE10].deviceFrameHandle = null;
            this[PRIVATE10].startDeviceFrameLoop();
            if (this[PRIVATE10].pendingRenderState !== null) {
              this[PRIVATE10].activeRenderState = new XRRenderState(this[PRIVATE10].pendingRenderState);
              this[PRIVATE10].pendingRenderState = null;
              if (this[PRIVATE10].activeRenderState.baseLayer) {
                this[PRIVATE10].device.onBaseLayerSet(
                  this[PRIVATE10].id,
                  this[PRIVATE10].activeRenderState.baseLayer
                );
              }
            }
            if (this[PRIVATE10].activeRenderState.baseLayer === null) {
              return;
            }
            const frame = new XRFrame(device, this, this[PRIVATE10].id);
            const callbacks = this[PRIVATE10].currentFrameCallbacks = this[PRIVATE10].frameCallbacks;
            this[PRIVATE10].frameCallbacks = [];
            frame[PRIVATE11].active = true;
            frame[PRIVATE11].animationFrame = true;
            this[PRIVATE10].device.onFrameStart(this[PRIVATE10].id, this[PRIVATE10].activeRenderState);
            this._checkInputSourcesChange();
            const rightNow = now_default();
            for (let i5 = 0; i5 < callbacks.length; i5++) {
              try {
                if (!callbacks[i5].cancelled && typeof callbacks[i5].callback === "function") {
                  callbacks[i5].callback(rightNow, frame);
                }
              } catch (err) {
                console.error(err);
              }
            }
            this[PRIVATE10].currentFrameCallbacks = null;
            frame[PRIVATE11].active = false;
            this[PRIVATE10].device.onFrameEnd(this[PRIVATE10].id);
          };
          this[PRIVATE10].startDeviceFrameLoop = () => {
            if (this[PRIVATE10].deviceFrameHandle === null) {
              this[PRIVATE10].deviceFrameHandle = this[PRIVATE10].device.requestAnimationFrame(
                this[PRIVATE10].onDeviceFrame
              );
            }
          };
          this[PRIVATE10].stopDeviceFrameLoop = () => {
            const handle = this[PRIVATE10].deviceFrameHandle;
            if (handle !== null) {
              this[PRIVATE10].device.cancelAnimationFrame(handle);
              this[PRIVATE10].deviceFrameHandle = null;
            }
          };
          this[PRIVATE10].onPresentationEnd = (sessionId) => {
            if (sessionId !== this[PRIVATE10].id) {
              this[PRIVATE10].suspended = false;
              this[PRIVATE10].startDeviceFrameLoop();
              this.dispatchEvent("focus", { session: this });
              return;
            }
            this[PRIVATE10].ended = true;
            this[PRIVATE10].stopDeviceFrameLoop();
            device.removeEventListener("@@webxr-polyfill/vr-present-end", this[PRIVATE10].onPresentationEnd);
            device.removeEventListener("@@webxr-polyfill/vr-present-start", this[PRIVATE10].onPresentationStart);
            device.removeEventListener("@@webxr-polyfill/input-select-start", this[PRIVATE10].onSelectStart);
            device.removeEventListener("@@webxr-polyfill/input-select-end", this[PRIVATE10].onSelectEnd);
            this.dispatchEvent("end", new XRSessionEvent("end", { session: this }));
          };
          device.addEventListener("@@webxr-polyfill/vr-present-end", this[PRIVATE10].onPresentationEnd);
          this[PRIVATE10].onPresentationStart = (sessionId) => {
            if (sessionId === this[PRIVATE10].id) {
              return;
            }
            this[PRIVATE10].suspended = true;
            this[PRIVATE10].stopDeviceFrameLoop();
            this.dispatchEvent("blur", { session: this });
          };
          device.addEventListener("@@webxr-polyfill/vr-present-start", this[PRIVATE10].onPresentationStart);
          this[PRIVATE10].onSelectStart = (evt) => {
            if (evt.sessionId !== this[PRIVATE10].id) {
              return;
            }
            this[PRIVATE10].dispatchInputSourceEvent("selectstart", evt.inputSource);
          };
          device.addEventListener("@@webxr-polyfill/input-select-start", this[PRIVATE10].onSelectStart);
          this[PRIVATE10].onSelectEnd = (evt) => {
            if (evt.sessionId !== this[PRIVATE10].id) {
              return;
            }
            this[PRIVATE10].dispatchInputSourceEvent("selectend", evt.inputSource);
            this[PRIVATE10].dispatchInputSourceEvent("select", evt.inputSource);
          };
          device.addEventListener("@@webxr-polyfill/input-select-end", this[PRIVATE10].onSelectEnd);
          this[PRIVATE10].onSqueezeStart = (evt) => {
            if (evt.sessionId !== this[PRIVATE10].id) {
              return;
            }
            this[PRIVATE10].dispatchInputSourceEvent("squeezestart", evt.inputSource);
          };
          device.addEventListener("@@webxr-polyfill/input-squeeze-start", this[PRIVATE10].onSqueezeStart);
          this[PRIVATE10].onSqueezeEnd = (evt) => {
            if (evt.sessionId !== this[PRIVATE10].id) {
              return;
            }
            this[PRIVATE10].dispatchInputSourceEvent("squeezeend", evt.inputSource);
            this[PRIVATE10].dispatchInputSourceEvent("squeeze", evt.inputSource);
          };
          device.addEventListener("@@webxr-polyfill/input-squeeze-end", this[PRIVATE10].onSqueezeEnd);
          this[PRIVATE10].dispatchInputSourceEvent = (type, inputSource) => {
            const frame = new XRFrame(device, this, this[PRIVATE10].id);
            const event = new XRInputSourceEvent(type, { frame, inputSource });
            frame[PRIVATE11].active = true;
            this.dispatchEvent(type, event);
            frame[PRIVATE11].active = false;
          };
          this[PRIVATE10].startDeviceFrameLoop();
          this.onblur = void 0;
          this.onfocus = void 0;
          this.onresetpose = void 0;
          this.onend = void 0;
          this.onselect = void 0;
          this.onselectstart = void 0;
          this.onselectend = void 0;
        }
        /**
         * @return {XRRenderState}
         */
        get renderState() {
          return this[PRIVATE10].activeRenderState;
        }
        /**
         * @return {XREnvironmentBlendMode}
         */
        get environmentBlendMode() {
          return this[PRIVATE10].device.environmentBlendMode || "opaque";
        }
        /**
         * @param {string} type
         * @return {XRReferenceSpace}
         */
        async requestReferenceSpace(type) {
          if (this[PRIVATE10].ended) {
            return;
          }
          if (!XRReferenceSpaceTypes.includes(type)) {
            throw new TypeError(`XRReferenceSpaceType must be one of ${XRReferenceSpaceTypes}`);
          }
          if (!this[PRIVATE10].device.doesSessionSupportReferenceSpace(this[PRIVATE10].id, type)) {
            throw new DOMException(`The ${type} reference space is not supported by this session.`, "NotSupportedError");
          }
          if (type === "viewer") {
            return this[PRIVATE10].viewerSpace;
          }
          let transform = await this[PRIVATE10].device.requestFrameOfReferenceTransform(type);
          if (type === "bounded-floor") {
            if (!transform) {
              throw new DOMException(`${type} XRReferenceSpace not supported by this device.`, "NotSupportedError");
            }
            let bounds = this[PRIVATE10].device.requestStageBounds();
            if (!bounds) {
              throw new DOMException(`${type} XRReferenceSpace not supported by this device.`, "NotSupportedError");
            }
            throw new DOMException(`The WebXR polyfill does not support the ${type} reference space yet.`, "NotSupportedError");
          }
          return new XRReferenceSpace(type, transform);
        }
        /**
         * @param {Function} callback
         * @return {number}
         */
        requestAnimationFrame(callback) {
          if (this[PRIVATE10].ended) {
            return;
          }
          const handle = ++this[PRIVATE10].frameHandle;
          this[PRIVATE10].frameCallbacks.push({
            handle,
            callback,
            cancelled: false
          });
          return handle;
        }
        /**
         * @param {number} handle
         */
        cancelAnimationFrame(handle) {
          let callbacks = this[PRIVATE10].frameCallbacks;
          let index = callbacks.findIndex((d4) => d4 && d4.handle === handle);
          if (index > -1) {
            callbacks[index].cancelled = true;
            callbacks.splice(index, 1);
          }
          callbacks = this[PRIVATE10].currentFrameCallbacks;
          if (callbacks) {
            index = callbacks.findIndex((d4) => d4 && d4.handle === handle);
            if (index > -1) {
              callbacks[index].cancelled = true;
            }
          }
        }
        /**
         * @return {Array<XRInputSource>} input sources
         */
        get inputSources() {
          return this[PRIVATE10].device.getInputSources();
        }
        /**
         * @return {Promise<void>}
         */
        async end() {
          if (this[PRIVATE10].ended) {
            return;
          }
          if (this[PRIVATE10].immersive) {
            this[PRIVATE10].ended = true;
            this[PRIVATE10].device.removeEventListener(
              "@@webxr-polyfill/vr-present-start",
              this[PRIVATE10].onPresentationStart
            );
            this[PRIVATE10].device.removeEventListener(
              "@@webxr-polyfill/vr-present-end",
              this[PRIVATE10].onPresentationEnd
            );
            this[PRIVATE10].device.removeEventListener(
              "@@webxr-polyfill/input-select-start",
              this[PRIVATE10].onSelectStart
            );
            this[PRIVATE10].device.removeEventListener(
              "@@webxr-polyfill/input-select-end",
              this[PRIVATE10].onSelectEnd
            );
            this.dispatchEvent("end", new XRSessionEvent("end", { session: this }));
          }
          this[PRIVATE10].stopDeviceFrameLoop();
          return this[PRIVATE10].device.endSession(this[PRIVATE10].id);
        }
        /**
         * Queues an update to the active render state to be applied on the next
         * frame. Unset fields of newState will not be changed.
         * 
         * @param {XRRenderStateInit?} newState 
         */
        updateRenderState(newState) {
          if (this[PRIVATE10].ended) {
            const message = "Can't call updateRenderState on an XRSession that has already ended.";
            throw new Error(message);
          }
          if (newState.baseLayer && newState.baseLayer._session !== this) {
            const message = "Called updateRenderState with a base layer that was created by a different session.";
            throw new Error(message);
          }
          const fovSet = newState.inlineVerticalFieldOfView !== null && newState.inlineVerticalFieldOfView !== void 0;
          if (fovSet) {
            if (this[PRIVATE10].immersive) {
              const message = "inlineVerticalFieldOfView must not be set for an XRRenderState passed to updateRenderState for an immersive session.";
              throw new Error(message);
            } else {
              newState.inlineVerticalFieldOfView = Math.min(
                3.13,
                Math.max(0.01, newState.inlineVerticalFieldOfView)
              );
            }
          }
          if (this[PRIVATE10].pendingRenderState === null) {
            const activeRenderState = this[PRIVATE10].activeRenderState;
            this[PRIVATE10].pendingRenderState = {
              depthNear: activeRenderState.depthNear,
              depthFar: activeRenderState.depthFar,
              inlineVerticalFieldOfView: activeRenderState.inlineVerticalFieldOfView,
              baseLayer: activeRenderState.baseLayer
            };
          }
          Object.assign(this[PRIVATE10].pendingRenderState, newState);
        }
        /**
         * Compares the inputSources with the ones in the previous frame.
         * Fires imputsourceschange event if any added or removed
         * inputSource is found.
         */
        _checkInputSourcesChange() {
          const added = [];
          const removed = [];
          const newInputSources = this.inputSources;
          const oldInputSources = this[PRIVATE10].currentInputSources;
          for (const newInputSource of newInputSources) {
            if (!oldInputSources.includes(newInputSource)) {
              added.push(newInputSource);
            }
          }
          for (const oldInputSource of oldInputSources) {
            if (!newInputSources.includes(oldInputSource)) {
              removed.push(oldInputSource);
            }
          }
          if (added.length > 0 || removed.length > 0) {
            this.dispatchEvent("inputsourceschange", new XRInputSourcesChangeEvent("inputsourceschange", {
              session: this,
              added,
              removed
            }));
          }
          this[PRIVATE10].currentInputSources.length = 0;
          for (const newInputSource of newInputSources) {
            this[PRIVATE10].currentInputSources.push(newInputSource);
          }
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSource.js
  var PRIVATE16, XRInputSource;
  var init_XRInputSource = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSource.js"() {
      init_XRSpace();
      PRIVATE16 = Symbol("@@webxr-polyfill/XRInputSource");
      XRInputSource = class {
        /**
         * @param {GamepadXRInputSource} impl 
         */
        constructor(impl) {
          this[PRIVATE16] = {
            impl,
            gripSpace: new XRSpace("grip", this),
            targetRaySpace: new XRSpace("target-ray", this)
          };
        }
        /**
         * @return {XRHandedness}
         */
        get handedness() {
          return this[PRIVATE16].impl.handedness;
        }
        /**
         * @return {XRTargetRayMode}
         */
        get targetRayMode() {
          return this[PRIVATE16].impl.targetRayMode;
        }
        /**
         * @return {XRSpace}
         */
        get gripSpace() {
          let mode = this[PRIVATE16].impl.targetRayMode;
          if (mode === "gaze" || mode === "screen") {
            return null;
          }
          return this[PRIVATE16].gripSpace;
        }
        /**
         * @return {XRSpace}
         */
        get targetRaySpace() {
          return this[PRIVATE16].targetRaySpace;
        }
        /**
         * @return {Array<String>}
         */
        get profiles() {
          return this[PRIVATE16].impl.profiles;
        }
        /**
         * @return {Gamepad}
         */
        get gamepad() {
          return this[PRIVATE16].impl.gamepad;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/constants.js
  var POLYFILLED_XR_COMPATIBLE, XR_COMPATIBLE;
  var init_constants = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/constants.js"() {
      POLYFILLED_XR_COMPATIBLE = Symbol("@@webxr-polyfill/polyfilled-xr-compatible");
      XR_COMPATIBLE = Symbol("@@webxr-polyfill/xr-compatible");
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRWebGLLayer.js
  var PRIVATE17, XRWebGLLayerInit, XRWebGLLayer2;
  var init_XRWebGLLayer = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRWebGLLayer.js"() {
      init_XRSession();
      init_constants();
      PRIVATE17 = Symbol("@@webxr-polyfill/XRWebGLLayer");
      XRWebGLLayerInit = Object.freeze({
        antialias: true,
        depth: true,
        stencil: false,
        alpha: true,
        multiview: false,
        ignoreDepthValues: false,
        framebufferScaleFactor: 1
      });
      XRWebGLLayer2 = class {
        /**
         * @param {XRSession} session 
         * @param {XRWebGLRenderingContext} context 
         * @param {Object?} layerInit 
         */
        constructor(session, context, layerInit = {}) {
          const config = Object.assign({}, XRWebGLLayerInit, layerInit);
          if (!(session instanceof XRSession2)) {
            throw new Error("session must be a XRSession");
          }
          if (session.ended) {
            throw new Error(`InvalidStateError`);
          }
          if (context[POLYFILLED_XR_COMPATIBLE]) {
            if (context[XR_COMPATIBLE] !== true) {
              throw new Error(`InvalidStateError`);
            }
          }
          this[PRIVATE17] = {
            context,
            config,
            session
          };
        }
        /**
         * @return {WebGLRenderingContext}
         */
        get context() {
          return this[PRIVATE17].context;
        }
        /**
         * @return {boolean}
         */
        get antialias() {
          return this[PRIVATE17].config.antialias;
        }
        /**
         * The polyfill will always ignore depth values.
         *
         * @return {boolean}
         */
        get ignoreDepthValues() {
          return true;
        }
        /**
         * @return {WebGLFramebuffer}
         */
        get framebuffer() {
          return null;
        }
        /**
         * @return {number}
         */
        get framebufferWidth() {
          return this[PRIVATE17].context.drawingBufferWidth;
        }
        /**
         * @return {number}
         */
        get framebufferHeight() {
          return this[PRIVATE17].context.drawingBufferHeight;
        }
        /**
         * @return {XRSession}
         */
        get _session() {
          return this[PRIVATE17].session;
        }
        /**
         * @TODO No mention in spec on not reusing the XRViewport on every frame.
         * 
         * @TODO In the future maybe all this logic should be handled here instead of
         * delegated to the XRView?
         *
         * @param {XRView} view
         * @return {XRViewport?}
         */
        getViewport(view) {
          return view._getViewport(this);
        }
        /**
         * Gets the scale factor to be requested if you want to match the device
         * resolution at the center of the user's vision. The polyfill will always
         * report 1.0.
         * 
         * @param {XRSession} session 
         * @return {number}
         */
        static getNativeFramebufferScaleFactor(session) {
          if (!session) {
            throw new TypeError("getNativeFramebufferScaleFactor must be passed a session.");
          }
          if (session[PRIVATE10].ended) {
            return 0;
          }
          return 1;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpaceEvent.js
  var PRIVATE18, XRReferenceSpaceEvent;
  var init_XRReferenceSpaceEvent = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpaceEvent.js"() {
      PRIVATE18 = Symbol("@@webxr-polyfill/XRReferenceSpaceEvent");
      XRReferenceSpaceEvent = class _XRReferenceSpaceEvent extends Event {
        /**
         * @param {string} type
         * @param {Object} eventInitDict
         */
        constructor(type, eventInitDict) {
          super(type, eventInitDict);
          this[PRIVATE18] = {
            referenceSpace: eventInitDict.referenceSpace,
            transform: eventInitDict.transform || null
          };
          Object.setPrototypeOf(this, _XRReferenceSpaceEvent.prototype);
        }
        /**
         * @return {XRFrame}
         */
        get referenceSpace() {
          return this[PRIVATE18].referenceSpace;
        }
        /**
         * @return {XRInputSource}
         */
        get transform() {
          return this[PRIVATE18].transform;
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/api/index.js
  var api_default;
  var init_api2 = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/api/index.js"() {
      init_XRSystem();
      init_XRSession();
      init_XRSessionEvent();
      init_XRFrame();
      init_XRView();
      init_XRViewport();
      init_XRViewerPose();
      init_XRInputSource();
      init_XRInputSourceEvent();
      init_XRInputSourcesChangeEvent();
      init_XRWebGLLayer();
      init_XRSpace();
      init_XRReferenceSpace();
      init_XRReferenceSpaceEvent();
      init_XRRenderState();
      init_XRRigidTransform();
      init_XRPose();
      api_default = {
        XRSystem,
        XRSession: XRSession2,
        XRSessionEvent,
        XRFrame,
        XRView,
        XRViewport,
        XRViewerPose,
        XRWebGLLayer: XRWebGLLayer2,
        XRSpace,
        XRReferenceSpace,
        XRReferenceSpaceEvent,
        XRInputSource,
        XRInputSourceEvent,
        XRInputSourcesChangeEvent,
        XRRenderState,
        XRRigidTransform: XRRigidTransform2,
        XRPose: XRPose2
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/polyfill-globals.js
  var polyfillMakeXRCompatible, polyfillGetContext;
  var init_polyfill_globals = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/polyfill-globals.js"() {
      init_constants();
      polyfillMakeXRCompatible = (Context) => {
        if (typeof Context.prototype.makeXRCompatible === "function") {
        }
        Context.prototype.makeXRCompatible = function() {
          this[XR_COMPATIBLE] = true;
          return Promise.resolve();
        };
        return true;
      };
      polyfillGetContext = (Canvas) => {
        const getContext = Canvas.prototype.getContext;
        Canvas.prototype.getContext = function(contextType, glAttribs) {
          const ctx = getContext.call(this, contextType, glAttribs);
          if (ctx) {
            ctx[POLYFILLED_XR_COMPATIBLE] = true;
            if (glAttribs && "xrCompatible" in glAttribs) {
              ctx[XR_COMPATIBLE] = glAttribs.xrCompatible;
            }
          }
          return ctx;
        };
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/utils.js
  var isImageBitmapSupported, isMobile, applyCanvasStylesForMinimalRendering;
  var init_utils4 = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/utils.js"() {
      isImageBitmapSupported = (global2) => !!(global2.ImageBitmapRenderingContext && global2.createImageBitmap);
      isMobile = (global2) => {
        var check = false;
        (function(a4) {
          if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a4) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a4.substr(0, 4)))
            check = true;
        })(global2.navigator.userAgent || global2.navigator.vendor || global2.opera);
        return check;
      };
      applyCanvasStylesForMinimalRendering = (canvas) => {
        canvas.style.display = "block";
        canvas.style.position = "absolute";
        canvas.style.width = canvas.style.height = "1px";
        canvas.style.top = canvas.style.left = "0px";
      };
    }
  });

  // node_modules/cardboard-vr-display/dist/cardboard-vr-display.js
  var require_cardboard_vr_display = __commonJS({
    "node_modules/cardboard-vr-display/dist/cardboard-vr-display.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.CardboardVRDisplay = factory();
      })(exports2, function() {
        "use strict";
        var asyncGenerator = function() {
          function AwaitValue(value) {
            this.value = value;
          }
          function AsyncGenerator(gen) {
            var front, back;
            function send(key, arg) {
              return new Promise(function(resolve, reject) {
                var request = {
                  key,
                  arg,
                  resolve,
                  reject,
                  next: null
                };
                if (back) {
                  back = back.next = request;
                } else {
                  front = back = request;
                  resume(key, arg);
                }
              });
            }
            function resume(key, arg) {
              try {
                var result = gen[key](arg);
                var value = result.value;
                if (value instanceof AwaitValue) {
                  Promise.resolve(value.value).then(function(arg2) {
                    resume("next", arg2);
                  }, function(arg2) {
                    resume("throw", arg2);
                  });
                } else {
                  settle2(result.done ? "return" : "normal", result.value);
                }
              } catch (err) {
                settle2("throw", err);
              }
            }
            function settle2(type, value) {
              switch (type) {
                case "return":
                  front.resolve({
                    value,
                    done: true
                  });
                  break;
                case "throw":
                  front.reject(value);
                  break;
                default:
                  front.resolve({
                    value,
                    done: false
                  });
                  break;
              }
              front = front.next;
              if (front) {
                resume(front.key, front.arg);
              } else {
                back = null;
              }
            }
            this._invoke = send;
            if (typeof gen.return !== "function") {
              this.return = void 0;
            }
          }
          if (typeof Symbol === "function" && Symbol.asyncIterator) {
            AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
              return this;
            };
          }
          AsyncGenerator.prototype.next = function(arg) {
            return this._invoke("next", arg);
          };
          AsyncGenerator.prototype.throw = function(arg) {
            return this._invoke("throw", arg);
          };
          AsyncGenerator.prototype.return = function(arg) {
            return this._invoke("return", arg);
          };
          return {
            wrap: function(fn4) {
              return function() {
                return new AsyncGenerator(fn4.apply(this, arguments));
              };
            },
            await: function(value) {
              return new AwaitValue(value);
            }
          };
        }();
        var classCallCheck = function(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        };
        var createClass = /* @__PURE__ */ function() {
          function defineProperties(target, props) {
            for (var i5 = 0; i5 < props.length; i5++) {
              var descriptor = props[i5];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var slicedToArray = /* @__PURE__ */ function() {
          function sliceIterator(arr, i5) {
            var _arr = [];
            var _n3 = true;
            var _d = false;
            var _e6 = void 0;
            try {
              for (var _i3 = arr[Symbol.iterator](), _s3; !(_n3 = (_s3 = _i3.next()).done); _n3 = true) {
                _arr.push(_s3.value);
                if (i5 && _arr.length === i5)
                  break;
              }
            } catch (err) {
              _d = true;
              _e6 = err;
            } finally {
              try {
                if (!_n3 && _i3["return"])
                  _i3["return"]();
              } finally {
                if (_d)
                  throw _e6;
              }
            }
            return _arr;
          }
          return function(arr, i5) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i5);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var MIN_TIMESTEP = 1e-3;
        var MAX_TIMESTEP = 1;
        var dataUri = function dataUri2(mimeType, svg) {
          return "data:" + mimeType + "," + encodeURIComponent(svg);
        };
        var lerp3 = function lerp4(a4, b3, t4) {
          return a4 + (b3 - a4) * t4;
        };
        var isIOS = function() {
          var isIOS2 = /iPad|iPhone|iPod/.test(navigator.platform);
          return function() {
            return isIOS2;
          };
        }();
        var isWebViewAndroid = function() {
          var isWebViewAndroid2 = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
          return function() {
            return isWebViewAndroid2;
          };
        }();
        var isSafari = function() {
          var isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          return function() {
            return isSafari2;
          };
        }();
        var isFirefoxAndroid = function() {
          var isFirefoxAndroid2 = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
          return function() {
            return isFirefoxAndroid2;
          };
        }();
        var getChromeVersion = function() {
          var match = navigator.userAgent.match(/.*Chrome\/([0-9]+)/);
          var value = match ? parseInt(match[1], 10) : null;
          return function() {
            return value;
          };
        }();
        var isSafariWithoutDeviceMotion = function() {
          var value = false;
          value = isIOS() && isSafari() && navigator.userAgent.indexOf("13_4") !== -1;
          return function() {
            return value;
          };
        }();
        var isChromeWithoutDeviceMotion = function() {
          var value = false;
          if (getChromeVersion() === 65) {
            var match = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
            if (match) {
              var _match$1$split = match[1].split("."), _match$1$split2 = slicedToArray(_match$1$split, 4), major = _match$1$split2[0], minor = _match$1$split2[1], branch = _match$1$split2[2], build = _match$1$split2[3];
              value = parseInt(branch, 10) === 3325 && parseInt(build, 10) < 148;
            }
          }
          return function() {
            return value;
          };
        }();
        var isR7 = function() {
          var isR72 = navigator.userAgent.indexOf("R7 Build") !== -1;
          return function() {
            return isR72;
          };
        }();
        var isLandscapeMode = function isLandscapeMode2() {
          var rtn = window.orientation == 90 || window.orientation == -90;
          return isR7() ? !rtn : rtn;
        };
        var isTimestampDeltaValid = function isTimestampDeltaValid2(timestampDeltaS) {
          if (isNaN(timestampDeltaS)) {
            return false;
          }
          if (timestampDeltaS <= MIN_TIMESTEP) {
            return false;
          }
          if (timestampDeltaS > MAX_TIMESTEP) {
            return false;
          }
          return true;
        };
        var getScreenWidth = function getScreenWidth2() {
          return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
        };
        var getScreenHeight = function getScreenHeight2() {
          return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
        };
        var requestFullscreen = function requestFullscreen2(element) {
          if (isWebViewAndroid()) {
            return false;
          }
          if (element.requestFullscreen) {
            element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
          } else {
            return false;
          }
          return true;
        };
        var exitFullscreen = function exitFullscreen2() {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            return false;
          }
          return true;
        };
        var getFullscreenElement = function getFullscreenElement2() {
          return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        };
        var linkProgram = function linkProgram2(gl3, vertexSource, fragmentSource, attribLocationMap) {
          var vertexShader = gl3.createShader(gl3.VERTEX_SHADER);
          gl3.shaderSource(vertexShader, vertexSource);
          gl3.compileShader(vertexShader);
          var fragmentShader = gl3.createShader(gl3.FRAGMENT_SHADER);
          gl3.shaderSource(fragmentShader, fragmentSource);
          gl3.compileShader(fragmentShader);
          var program = gl3.createProgram();
          gl3.attachShader(program, vertexShader);
          gl3.attachShader(program, fragmentShader);
          for (var attribName in attribLocationMap) {
            gl3.bindAttribLocation(program, attribLocationMap[attribName], attribName);
          }
          gl3.linkProgram(program);
          gl3.deleteShader(vertexShader);
          gl3.deleteShader(fragmentShader);
          return program;
        };
        var getProgramUniforms = function getProgramUniforms2(gl3, program) {
          var uniforms = {};
          var uniformCount = gl3.getProgramParameter(program, gl3.ACTIVE_UNIFORMS);
          var uniformName = "";
          for (var i5 = 0; i5 < uniformCount; i5++) {
            var uniformInfo = gl3.getActiveUniform(program, i5);
            uniformName = uniformInfo.name.replace("[0]", "");
            uniforms[uniformName] = gl3.getUniformLocation(program, uniformName);
          }
          return uniforms;
        };
        var orthoMatrix = function orthoMatrix2(out, left, right, bottom, top, near, far) {
          var lr4 = 1 / (left - right), bt4 = 1 / (bottom - top), nf2 = 1 / (near - far);
          out[0] = -2 * lr4;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = -2 * bt4;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 2 * nf2;
          out[11] = 0;
          out[12] = (left + right) * lr4;
          out[13] = (top + bottom) * bt4;
          out[14] = (far + near) * nf2;
          out[15] = 1;
          return out;
        };
        var isMobile2 = function isMobile3() {
          var check = false;
          (function(a4) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a4) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a4.substr(0, 4)))
              check = true;
          })(navigator.userAgent || navigator.vendor || window.opera);
          return check;
        };
        var extend2 = function extend3(dest, src) {
          for (var key in src) {
            if (src.hasOwnProperty(key)) {
              dest[key] = src[key];
            }
          }
          return dest;
        };
        var safariCssSizeWorkaround = function safariCssSizeWorkaround2(canvas) {
          if (isIOS()) {
            var width = canvas.style.width;
            var height = canvas.style.height;
            canvas.style.width = parseInt(width) + 1 + "px";
            canvas.style.height = parseInt(height) + "px";
            setTimeout(function() {
              canvas.style.width = width;
              canvas.style.height = height;
            }, 100);
          }
          window.canvas = canvas;
        };
        var frameDataFromPose = function() {
          var piOver180 = Math.PI / 180;
          var rad45 = Math.PI * 0.25;
          function mat4_perspectiveFromFieldOfView(out, fov2, near, far) {
            var upTan = Math.tan(fov2 ? fov2.upDegrees * piOver180 : rad45), downTan = Math.tan(fov2 ? fov2.downDegrees * piOver180 : rad45), leftTan = Math.tan(fov2 ? fov2.leftDegrees * piOver180 : rad45), rightTan = Math.tan(fov2 ? fov2.rightDegrees * piOver180 : rad45), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
            out[0] = xScale;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = yScale;
            out[6] = 0;
            out[7] = 0;
            out[8] = -((leftTan - rightTan) * xScale * 0.5);
            out[9] = (upTan - downTan) * yScale * 0.5;
            out[10] = far / (near - far);
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = far * near / (near - far);
            out[15] = 0;
            return out;
          }
          function mat4_fromRotationTranslation(out, q4, v5) {
            var x4 = q4[0], y3 = q4[1], z4 = q4[2], w3 = q4[3], x22 = x4 + x4, y22 = y3 + y3, z22 = z4 + z4, xx = x4 * x22, xy = x4 * y22, xz = x4 * z22, yy = y3 * y22, yz = y3 * z22, zz = z4 * z22, wx2 = w3 * x22, wy = w3 * y22, wz = w3 * z22;
            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;
            out[3] = 0;
            out[4] = xy - wz;
            out[5] = 1 - (xx + zz);
            out[6] = yz + wx2;
            out[7] = 0;
            out[8] = xz + wy;
            out[9] = yz - wx2;
            out[10] = 1 - (xx + yy);
            out[11] = 0;
            out[12] = v5[0];
            out[13] = v5[1];
            out[14] = v5[2];
            out[15] = 1;
            return out;
          }
          function mat4_translate(out, a4, v5) {
            var x4 = v5[0], y3 = v5[1], z4 = v5[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
            if (a4 === out) {
              out[12] = a4[0] * x4 + a4[4] * y3 + a4[8] * z4 + a4[12];
              out[13] = a4[1] * x4 + a4[5] * y3 + a4[9] * z4 + a4[13];
              out[14] = a4[2] * x4 + a4[6] * y3 + a4[10] * z4 + a4[14];
              out[15] = a4[3] * x4 + a4[7] * y3 + a4[11] * z4 + a4[15];
            } else {
              a00 = a4[0];
              a01 = a4[1];
              a02 = a4[2];
              a03 = a4[3];
              a10 = a4[4];
              a11 = a4[5];
              a12 = a4[6];
              a13 = a4[7];
              a20 = a4[8];
              a21 = a4[9];
              a22 = a4[10];
              a23 = a4[11];
              out[0] = a00;
              out[1] = a01;
              out[2] = a02;
              out[3] = a03;
              out[4] = a10;
              out[5] = a11;
              out[6] = a12;
              out[7] = a13;
              out[8] = a20;
              out[9] = a21;
              out[10] = a22;
              out[11] = a23;
              out[12] = a00 * x4 + a10 * y3 + a20 * z4 + a4[12];
              out[13] = a01 * x4 + a11 * y3 + a21 * z4 + a4[13];
              out[14] = a02 * x4 + a12 * y3 + a22 * z4 + a4[14];
              out[15] = a03 * x4 + a13 * y3 + a23 * z4 + a4[15];
            }
            return out;
          }
          function mat4_invert(out, a4) {
            var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3], a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7], a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11], a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) {
              return null;
            }
            det = 1 / det;
            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
            return out;
          }
          var defaultOrientation = new Float32Array([0, 0, 0, 1]);
          var defaultPosition = new Float32Array([0, 0, 0]);
          function updateEyeMatrices(projection, view, pose, fov2, offset, vrDisplay) {
            mat4_perspectiveFromFieldOfView(projection, fov2 || null, vrDisplay.depthNear, vrDisplay.depthFar);
            var orientation = pose.orientation || defaultOrientation;
            var position = pose.position || defaultPosition;
            mat4_fromRotationTranslation(view, orientation, position);
            if (offset)
              mat4_translate(view, view, offset);
            mat4_invert(view, view);
          }
          return function(frameData, pose, vrDisplay) {
            if (!frameData || !pose)
              return false;
            frameData.pose = pose;
            frameData.timestamp = pose.timestamp;
            updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay._getFieldOfView("left"), vrDisplay._getEyeOffset("left"), vrDisplay);
            updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay._getFieldOfView("right"), vrDisplay._getEyeOffset("right"), vrDisplay);
            return true;
          };
        }();
        var isInsideCrossOriginIFrame = function isInsideCrossOriginIFrame2() {
          var isFramed = window.self !== window.top;
          var refOrigin = getOriginFromUrl(document.referrer);
          var thisOrigin = getOriginFromUrl(window.location.href);
          return isFramed && refOrigin !== thisOrigin;
        };
        var getOriginFromUrl = function getOriginFromUrl2(url) {
          var domainIdx;
          var protoSepIdx = url.indexOf("://");
          if (protoSepIdx !== -1) {
            domainIdx = protoSepIdx + 3;
          } else {
            domainIdx = 0;
          }
          var domainEndIdx = url.indexOf("/", domainIdx);
          if (domainEndIdx === -1) {
            domainEndIdx = url.length;
          }
          return url.substring(0, domainEndIdx);
        };
        var getQuaternionAngle = function getQuaternionAngle2(quat) {
          if (quat.w > 1) {
            console.warn("getQuaternionAngle: w > 1");
            return 0;
          }
          var angle2 = 2 * Math.acos(quat.w);
          return angle2;
        };
        var warnOnce2 = /* @__PURE__ */ function() {
          var observedWarnings = {};
          return function(key, message) {
            if (observedWarnings[key] === void 0) {
              console.warn("webvr-polyfill: " + message);
              observedWarnings[key] = true;
            }
          };
        }();
        var deprecateWarning = function deprecateWarning2(deprecated, suggested) {
          var alternative = suggested ? "Please use " + suggested + " instead." : "";
          warnOnce2(deprecated, deprecated + " has been deprecated. This may not work on native WebVR displays. " + alternative);
        };
        function WGLUPreserveGLState(gl3, bindings, callback) {
          if (!bindings) {
            callback(gl3);
            return;
          }
          var boundValues = [];
          var activeTexture = null;
          for (var i5 = 0; i5 < bindings.length; ++i5) {
            var binding = bindings[i5];
            switch (binding) {
              case gl3.TEXTURE_BINDING_2D:
              case gl3.TEXTURE_BINDING_CUBE_MAP:
                var textureUnit = bindings[++i5];
                if (textureUnit < gl3.TEXTURE0 || textureUnit > gl3.TEXTURE31) {
                  console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
                  boundValues.push(null, null);
                  break;
                }
                if (!activeTexture) {
                  activeTexture = gl3.getParameter(gl3.ACTIVE_TEXTURE);
                }
                gl3.activeTexture(textureUnit);
                boundValues.push(gl3.getParameter(binding), null);
                break;
              case gl3.ACTIVE_TEXTURE:
                activeTexture = gl3.getParameter(gl3.ACTIVE_TEXTURE);
                boundValues.push(null);
                break;
              default:
                boundValues.push(gl3.getParameter(binding));
                break;
            }
          }
          callback(gl3);
          for (var i5 = 0; i5 < bindings.length; ++i5) {
            var binding = bindings[i5];
            var boundValue = boundValues[i5];
            switch (binding) {
              case gl3.ACTIVE_TEXTURE:
                break;
              case gl3.ARRAY_BUFFER_BINDING:
                gl3.bindBuffer(gl3.ARRAY_BUFFER, boundValue);
                break;
              case gl3.COLOR_CLEAR_VALUE:
                gl3.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                break;
              case gl3.COLOR_WRITEMASK:
                gl3.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                break;
              case gl3.CURRENT_PROGRAM:
                gl3.useProgram(boundValue);
                break;
              case gl3.ELEMENT_ARRAY_BUFFER_BINDING:
                gl3.bindBuffer(gl3.ELEMENT_ARRAY_BUFFER, boundValue);
                break;
              case gl3.FRAMEBUFFER_BINDING:
                gl3.bindFramebuffer(gl3.FRAMEBUFFER, boundValue);
                break;
              case gl3.RENDERBUFFER_BINDING:
                gl3.bindRenderbuffer(gl3.RENDERBUFFER, boundValue);
                break;
              case gl3.TEXTURE_BINDING_2D:
                var textureUnit = bindings[++i5];
                if (textureUnit < gl3.TEXTURE0 || textureUnit > gl3.TEXTURE31)
                  break;
                gl3.activeTexture(textureUnit);
                gl3.bindTexture(gl3.TEXTURE_2D, boundValue);
                break;
              case gl3.TEXTURE_BINDING_CUBE_MAP:
                var textureUnit = bindings[++i5];
                if (textureUnit < gl3.TEXTURE0 || textureUnit > gl3.TEXTURE31)
                  break;
                gl3.activeTexture(textureUnit);
                gl3.bindTexture(gl3.TEXTURE_CUBE_MAP, boundValue);
                break;
              case gl3.VIEWPORT:
                gl3.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                break;
              case gl3.BLEND:
              case gl3.CULL_FACE:
              case gl3.DEPTH_TEST:
              case gl3.SCISSOR_TEST:
              case gl3.STENCIL_TEST:
                if (boundValue) {
                  gl3.enable(binding);
                } else {
                  gl3.disable(binding);
                }
                break;
              default:
                console.log("No GL restore behavior for 0x" + binding.toString(16));
                break;
            }
            if (activeTexture) {
              gl3.activeTexture(activeTexture);
            }
          }
        }
        var glPreserveState = WGLUPreserveGLState;
        var distortionVS = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join("\n");
        var distortionFS = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join("\n");
        function CardboardDistorter(gl3, cardboardUI, bufferScale, dirtySubmitFrameBindings) {
          this.gl = gl3;
          this.cardboardUI = cardboardUI;
          this.bufferScale = bufferScale;
          this.dirtySubmitFrameBindings = dirtySubmitFrameBindings;
          this.ctxAttribs = gl3.getContextAttributes();
          this.instanceExt = gl3.getExtension("ANGLE_instanced_arrays");
          this.meshWidth = 20;
          this.meshHeight = 20;
          this.bufferWidth = gl3.drawingBufferWidth;
          this.bufferHeight = gl3.drawingBufferHeight;
          this.realBindFramebuffer = gl3.bindFramebuffer;
          this.realEnable = gl3.enable;
          this.realDisable = gl3.disable;
          this.realColorMask = gl3.colorMask;
          this.realClearColor = gl3.clearColor;
          this.realViewport = gl3.viewport;
          if (!isIOS()) {
            this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl3.canvas.__proto__, "width");
            this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl3.canvas.__proto__, "height");
          }
          this.isPatched = false;
          this.lastBoundFramebuffer = null;
          this.cullFace = false;
          this.depthTest = false;
          this.blend = false;
          this.scissorTest = false;
          this.stencilTest = false;
          this.viewport = [0, 0, 0, 0];
          this.colorMask = [true, true, true, true];
          this.clearColor = [0, 0, 0, 0];
          this.attribs = {
            position: 0,
            texCoord: 1
          };
          this.program = linkProgram(gl3, distortionVS, distortionFS, this.attribs);
          this.uniforms = getProgramUniforms(gl3, this.program);
          this.viewportOffsetScale = new Float32Array(8);
          this.setTextureBounds();
          this.vertexBuffer = gl3.createBuffer();
          this.indexBuffer = gl3.createBuffer();
          this.indexCount = 0;
          this.renderTarget = gl3.createTexture();
          this.framebuffer = gl3.createFramebuffer();
          this.depthStencilBuffer = null;
          this.depthBuffer = null;
          this.stencilBuffer = null;
          if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
            this.depthStencilBuffer = gl3.createRenderbuffer();
          } else if (this.ctxAttribs.depth) {
            this.depthBuffer = gl3.createRenderbuffer();
          } else if (this.ctxAttribs.stencil) {
            this.stencilBuffer = gl3.createRenderbuffer();
          }
          this.patch();
          this.onResize();
        }
        CardboardDistorter.prototype.destroy = function() {
          var gl3 = this.gl;
          this.unpatch();
          gl3.deleteProgram(this.program);
          gl3.deleteBuffer(this.vertexBuffer);
          gl3.deleteBuffer(this.indexBuffer);
          gl3.deleteTexture(this.renderTarget);
          gl3.deleteFramebuffer(this.framebuffer);
          if (this.depthStencilBuffer) {
            gl3.deleteRenderbuffer(this.depthStencilBuffer);
          }
          if (this.depthBuffer) {
            gl3.deleteRenderbuffer(this.depthBuffer);
          }
          if (this.stencilBuffer) {
            gl3.deleteRenderbuffer(this.stencilBuffer);
          }
          if (this.cardboardUI) {
            this.cardboardUI.destroy();
          }
        };
        CardboardDistorter.prototype.onResize = function() {
          var gl3 = this.gl;
          var self2 = this;
          var glState = [gl3.RENDERBUFFER_BINDING, gl3.TEXTURE_BINDING_2D, gl3.TEXTURE0];
          glPreserveState(gl3, glState, function(gl4) {
            self2.realBindFramebuffer.call(gl4, gl4.FRAMEBUFFER, null);
            if (self2.scissorTest) {
              self2.realDisable.call(gl4, gl4.SCISSOR_TEST);
            }
            self2.realColorMask.call(gl4, true, true, true, true);
            self2.realViewport.call(gl4, 0, 0, gl4.drawingBufferWidth, gl4.drawingBufferHeight);
            self2.realClearColor.call(gl4, 0, 0, 0, 1);
            gl4.clear(gl4.COLOR_BUFFER_BIT);
            self2.realBindFramebuffer.call(gl4, gl4.FRAMEBUFFER, self2.framebuffer);
            gl4.bindTexture(gl4.TEXTURE_2D, self2.renderTarget);
            gl4.texImage2D(gl4.TEXTURE_2D, 0, self2.ctxAttribs.alpha ? gl4.RGBA : gl4.RGB, self2.bufferWidth, self2.bufferHeight, 0, self2.ctxAttribs.alpha ? gl4.RGBA : gl4.RGB, gl4.UNSIGNED_BYTE, null);
            gl4.texParameteri(gl4.TEXTURE_2D, gl4.TEXTURE_MAG_FILTER, gl4.LINEAR);
            gl4.texParameteri(gl4.TEXTURE_2D, gl4.TEXTURE_MIN_FILTER, gl4.LINEAR);
            gl4.texParameteri(gl4.TEXTURE_2D, gl4.TEXTURE_WRAP_S, gl4.CLAMP_TO_EDGE);
            gl4.texParameteri(gl4.TEXTURE_2D, gl4.TEXTURE_WRAP_T, gl4.CLAMP_TO_EDGE);
            gl4.framebufferTexture2D(gl4.FRAMEBUFFER, gl4.COLOR_ATTACHMENT0, gl4.TEXTURE_2D, self2.renderTarget, 0);
            if (self2.ctxAttribs.depth && self2.ctxAttribs.stencil) {
              gl4.bindRenderbuffer(gl4.RENDERBUFFER, self2.depthStencilBuffer);
              gl4.renderbufferStorage(gl4.RENDERBUFFER, gl4.DEPTH_STENCIL, self2.bufferWidth, self2.bufferHeight);
              gl4.framebufferRenderbuffer(gl4.FRAMEBUFFER, gl4.DEPTH_STENCIL_ATTACHMENT, gl4.RENDERBUFFER, self2.depthStencilBuffer);
            } else if (self2.ctxAttribs.depth) {
              gl4.bindRenderbuffer(gl4.RENDERBUFFER, self2.depthBuffer);
              gl4.renderbufferStorage(gl4.RENDERBUFFER, gl4.DEPTH_COMPONENT16, self2.bufferWidth, self2.bufferHeight);
              gl4.framebufferRenderbuffer(gl4.FRAMEBUFFER, gl4.DEPTH_ATTACHMENT, gl4.RENDERBUFFER, self2.depthBuffer);
            } else if (self2.ctxAttribs.stencil) {
              gl4.bindRenderbuffer(gl4.RENDERBUFFER, self2.stencilBuffer);
              gl4.renderbufferStorage(gl4.RENDERBUFFER, gl4.STENCIL_INDEX8, self2.bufferWidth, self2.bufferHeight);
              gl4.framebufferRenderbuffer(gl4.FRAMEBUFFER, gl4.STENCIL_ATTACHMENT, gl4.RENDERBUFFER, self2.stencilBuffer);
            }
            if (!gl4.checkFramebufferStatus(gl4.FRAMEBUFFER) === gl4.FRAMEBUFFER_COMPLETE) {
              console.error("Framebuffer incomplete!");
            }
            self2.realBindFramebuffer.call(gl4, gl4.FRAMEBUFFER, self2.lastBoundFramebuffer);
            if (self2.scissorTest) {
              self2.realEnable.call(gl4, gl4.SCISSOR_TEST);
            }
            self2.realColorMask.apply(gl4, self2.colorMask);
            self2.realViewport.apply(gl4, self2.viewport);
            self2.realClearColor.apply(gl4, self2.clearColor);
          });
          if (this.cardboardUI) {
            this.cardboardUI.onResize();
          }
        };
        CardboardDistorter.prototype.patch = function() {
          if (this.isPatched) {
            return;
          }
          var self2 = this;
          var canvas = this.gl.canvas;
          var gl3 = this.gl;
          if (!isIOS()) {
            canvas.width = getScreenWidth() * this.bufferScale;
            canvas.height = getScreenHeight() * this.bufferScale;
            Object.defineProperty(canvas, "width", {
              configurable: true,
              enumerable: true,
              get: function get() {
                return self2.bufferWidth;
              },
              set: function set3(value) {
                self2.bufferWidth = value;
                self2.realCanvasWidth.set.call(canvas, value);
                self2.onResize();
              }
            });
            Object.defineProperty(canvas, "height", {
              configurable: true,
              enumerable: true,
              get: function get() {
                return self2.bufferHeight;
              },
              set: function set3(value) {
                self2.bufferHeight = value;
                self2.realCanvasHeight.set.call(canvas, value);
                self2.onResize();
              }
            });
          }
          this.lastBoundFramebuffer = gl3.getParameter(gl3.FRAMEBUFFER_BINDING);
          if (this.lastBoundFramebuffer == null) {
            this.lastBoundFramebuffer = this.framebuffer;
            this.gl.bindFramebuffer(gl3.FRAMEBUFFER, this.framebuffer);
          }
          this.gl.bindFramebuffer = function(target, framebuffer) {
            self2.lastBoundFramebuffer = framebuffer ? framebuffer : self2.framebuffer;
            self2.realBindFramebuffer.call(gl3, target, self2.lastBoundFramebuffer);
          };
          this.cullFace = gl3.getParameter(gl3.CULL_FACE);
          this.depthTest = gl3.getParameter(gl3.DEPTH_TEST);
          this.blend = gl3.getParameter(gl3.BLEND);
          this.scissorTest = gl3.getParameter(gl3.SCISSOR_TEST);
          this.stencilTest = gl3.getParameter(gl3.STENCIL_TEST);
          gl3.enable = function(pname) {
            switch (pname) {
              case gl3.CULL_FACE:
                self2.cullFace = true;
                break;
              case gl3.DEPTH_TEST:
                self2.depthTest = true;
                break;
              case gl3.BLEND:
                self2.blend = true;
                break;
              case gl3.SCISSOR_TEST:
                self2.scissorTest = true;
                break;
              case gl3.STENCIL_TEST:
                self2.stencilTest = true;
                break;
            }
            self2.realEnable.call(gl3, pname);
          };
          gl3.disable = function(pname) {
            switch (pname) {
              case gl3.CULL_FACE:
                self2.cullFace = false;
                break;
              case gl3.DEPTH_TEST:
                self2.depthTest = false;
                break;
              case gl3.BLEND:
                self2.blend = false;
                break;
              case gl3.SCISSOR_TEST:
                self2.scissorTest = false;
                break;
              case gl3.STENCIL_TEST:
                self2.stencilTest = false;
                break;
            }
            self2.realDisable.call(gl3, pname);
          };
          this.colorMask = gl3.getParameter(gl3.COLOR_WRITEMASK);
          gl3.colorMask = function(r4, g4, b3, a4) {
            self2.colorMask[0] = r4;
            self2.colorMask[1] = g4;
            self2.colorMask[2] = b3;
            self2.colorMask[3] = a4;
            self2.realColorMask.call(gl3, r4, g4, b3, a4);
          };
          this.clearColor = gl3.getParameter(gl3.COLOR_CLEAR_VALUE);
          gl3.clearColor = function(r4, g4, b3, a4) {
            self2.clearColor[0] = r4;
            self2.clearColor[1] = g4;
            self2.clearColor[2] = b3;
            self2.clearColor[3] = a4;
            self2.realClearColor.call(gl3, r4, g4, b3, a4);
          };
          this.viewport = gl3.getParameter(gl3.VIEWPORT);
          gl3.viewport = function(x4, y3, w3, h4) {
            self2.viewport[0] = x4;
            self2.viewport[1] = y3;
            self2.viewport[2] = w3;
            self2.viewport[3] = h4;
            self2.realViewport.call(gl3, x4, y3, w3, h4);
          };
          this.isPatched = true;
          safariCssSizeWorkaround(canvas);
        };
        CardboardDistorter.prototype.unpatch = function() {
          if (!this.isPatched) {
            return;
          }
          var gl3 = this.gl;
          var canvas = this.gl.canvas;
          if (!isIOS()) {
            Object.defineProperty(canvas, "width", this.realCanvasWidth);
            Object.defineProperty(canvas, "height", this.realCanvasHeight);
          }
          canvas.width = this.bufferWidth;
          canvas.height = this.bufferHeight;
          gl3.bindFramebuffer = this.realBindFramebuffer;
          gl3.enable = this.realEnable;
          gl3.disable = this.realDisable;
          gl3.colorMask = this.realColorMask;
          gl3.clearColor = this.realClearColor;
          gl3.viewport = this.realViewport;
          if (this.lastBoundFramebuffer == this.framebuffer) {
            gl3.bindFramebuffer(gl3.FRAMEBUFFER, null);
          }
          this.isPatched = false;
          setTimeout(function() {
            safariCssSizeWorkaround(canvas);
          }, 1);
        };
        CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
          if (!leftBounds) {
            leftBounds = [0, 0, 0.5, 1];
          }
          if (!rightBounds) {
            rightBounds = [0.5, 0, 0.5, 1];
          }
          this.viewportOffsetScale[0] = leftBounds[0];
          this.viewportOffsetScale[1] = leftBounds[1];
          this.viewportOffsetScale[2] = leftBounds[2];
          this.viewportOffsetScale[3] = leftBounds[3];
          this.viewportOffsetScale[4] = rightBounds[0];
          this.viewportOffsetScale[5] = rightBounds[1];
          this.viewportOffsetScale[6] = rightBounds[2];
          this.viewportOffsetScale[7] = rightBounds[3];
        };
        CardboardDistorter.prototype.submitFrame = function() {
          var gl3 = this.gl;
          var self2 = this;
          var glState = [];
          if (!this.dirtySubmitFrameBindings) {
            glState.push(gl3.CURRENT_PROGRAM, gl3.ARRAY_BUFFER_BINDING, gl3.ELEMENT_ARRAY_BUFFER_BINDING, gl3.TEXTURE_BINDING_2D, gl3.TEXTURE0);
          }
          glPreserveState(gl3, glState, function(gl4) {
            self2.realBindFramebuffer.call(gl4, gl4.FRAMEBUFFER, null);
            var positionDivisor = 0;
            var texCoordDivisor = 0;
            if (self2.instanceExt) {
              positionDivisor = gl4.getVertexAttrib(self2.attribs.position, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
              texCoordDivisor = gl4.getVertexAttrib(self2.attribs.texCoord, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
            }
            if (self2.cullFace) {
              self2.realDisable.call(gl4, gl4.CULL_FACE);
            }
            if (self2.depthTest) {
              self2.realDisable.call(gl4, gl4.DEPTH_TEST);
            }
            if (self2.blend) {
              self2.realDisable.call(gl4, gl4.BLEND);
            }
            if (self2.scissorTest) {
              self2.realDisable.call(gl4, gl4.SCISSOR_TEST);
            }
            if (self2.stencilTest) {
              self2.realDisable.call(gl4, gl4.STENCIL_TEST);
            }
            self2.realColorMask.call(gl4, true, true, true, true);
            self2.realViewport.call(gl4, 0, 0, gl4.drawingBufferWidth, gl4.drawingBufferHeight);
            if (self2.ctxAttribs.alpha || isIOS()) {
              self2.realClearColor.call(gl4, 0, 0, 0, 1);
              gl4.clear(gl4.COLOR_BUFFER_BIT);
            }
            gl4.useProgram(self2.program);
            gl4.bindBuffer(gl4.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
            gl4.bindBuffer(gl4.ARRAY_BUFFER, self2.vertexBuffer);
            gl4.enableVertexAttribArray(self2.attribs.position);
            gl4.enableVertexAttribArray(self2.attribs.texCoord);
            gl4.vertexAttribPointer(self2.attribs.position, 2, gl4.FLOAT, false, 20, 0);
            gl4.vertexAttribPointer(self2.attribs.texCoord, 3, gl4.FLOAT, false, 20, 8);
            if (self2.instanceExt) {
              if (positionDivisor != 0) {
                self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, 0);
              }
              if (texCoordDivisor != 0) {
                self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, 0);
              }
            }
            gl4.activeTexture(gl4.TEXTURE0);
            gl4.uniform1i(self2.uniforms.diffuse, 0);
            gl4.bindTexture(gl4.TEXTURE_2D, self2.renderTarget);
            gl4.uniform4fv(self2.uniforms.viewportOffsetScale, self2.viewportOffsetScale);
            gl4.drawElements(gl4.TRIANGLES, self2.indexCount, gl4.UNSIGNED_SHORT, 0);
            if (self2.cardboardUI) {
              self2.cardboardUI.renderNoState();
            }
            self2.realBindFramebuffer.call(self2.gl, gl4.FRAMEBUFFER, self2.framebuffer);
            if (!self2.ctxAttribs.preserveDrawingBuffer) {
              self2.realClearColor.call(gl4, 0, 0, 0, 0);
              gl4.clear(gl4.COLOR_BUFFER_BIT);
            }
            if (!self2.dirtySubmitFrameBindings) {
              self2.realBindFramebuffer.call(gl4, gl4.FRAMEBUFFER, self2.lastBoundFramebuffer);
            }
            if (self2.cullFace) {
              self2.realEnable.call(gl4, gl4.CULL_FACE);
            }
            if (self2.depthTest) {
              self2.realEnable.call(gl4, gl4.DEPTH_TEST);
            }
            if (self2.blend) {
              self2.realEnable.call(gl4, gl4.BLEND);
            }
            if (self2.scissorTest) {
              self2.realEnable.call(gl4, gl4.SCISSOR_TEST);
            }
            if (self2.stencilTest) {
              self2.realEnable.call(gl4, gl4.STENCIL_TEST);
            }
            self2.realColorMask.apply(gl4, self2.colorMask);
            self2.realViewport.apply(gl4, self2.viewport);
            if (self2.ctxAttribs.alpha || !self2.ctxAttribs.preserveDrawingBuffer) {
              self2.realClearColor.apply(gl4, self2.clearColor);
            }
            if (self2.instanceExt) {
              if (positionDivisor != 0) {
                self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, positionDivisor);
              }
              if (texCoordDivisor != 0) {
                self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, texCoordDivisor);
              }
            }
          });
          if (isIOS()) {
            var canvas = gl3.canvas;
            if (canvas.width != self2.bufferWidth || canvas.height != self2.bufferHeight) {
              self2.bufferWidth = canvas.width;
              self2.bufferHeight = canvas.height;
              self2.onResize();
            }
          }
        };
        CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
          var gl3 = this.gl;
          var self2 = this;
          var glState = [gl3.ARRAY_BUFFER_BINDING, gl3.ELEMENT_ARRAY_BUFFER_BINDING];
          glPreserveState(gl3, glState, function(gl4) {
            var vertices = self2.computeMeshVertices_(self2.meshWidth, self2.meshHeight, deviceInfo);
            gl4.bindBuffer(gl4.ARRAY_BUFFER, self2.vertexBuffer);
            gl4.bufferData(gl4.ARRAY_BUFFER, vertices, gl4.STATIC_DRAW);
            if (!self2.indexCount) {
              var indices = self2.computeMeshIndices_(self2.meshWidth, self2.meshHeight);
              gl4.bindBuffer(gl4.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
              gl4.bufferData(gl4.ELEMENT_ARRAY_BUFFER, indices, gl4.STATIC_DRAW);
              self2.indexCount = indices.length;
            }
          });
        };
        CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
          var vertices = new Float32Array(2 * width * height * 5);
          var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
          var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
          var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
          var vidx = 0;
          for (var e4 = 0; e4 < 2; e4++) {
            for (var j4 = 0; j4 < height; j4++) {
              for (var i5 = 0; i5 < width; i5++, vidx++) {
                var u4 = i5 / (width - 1);
                var v5 = j4 / (height - 1);
                var s4 = u4;
                var t4 = v5;
                var x4 = lerp3(lensFrustum[0], lensFrustum[2], u4);
                var y3 = lerp3(lensFrustum[3], lensFrustum[1], v5);
                var d4 = Math.sqrt(x4 * x4 + y3 * y3);
                var r4 = deviceInfo.distortion.distortInverse(d4);
                var p4 = x4 * r4 / d4;
                var q4 = y3 * r4 / d4;
                u4 = (p4 - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
                v5 = (q4 - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
                u4 = (viewport.x + u4 * viewport.width - 0.5) * 2;
                v5 = (viewport.y + v5 * viewport.height - 0.5) * 2;
                vertices[vidx * 5 + 0] = u4;
                vertices[vidx * 5 + 1] = v5;
                vertices[vidx * 5 + 2] = s4;
                vertices[vidx * 5 + 3] = t4;
                vertices[vidx * 5 + 4] = e4;
              }
            }
            var w3 = lensFrustum[2] - lensFrustum[0];
            lensFrustum[0] = -(w3 + lensFrustum[0]);
            lensFrustum[2] = w3 - lensFrustum[2];
            w3 = noLensFrustum[2] - noLensFrustum[0];
            noLensFrustum[0] = -(w3 + noLensFrustum[0]);
            noLensFrustum[2] = w3 - noLensFrustum[2];
            viewport.x = 1 - (viewport.x + viewport.width);
          }
          return vertices;
        };
        CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
          var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
          var halfwidth = width / 2;
          var halfheight = height / 2;
          var vidx = 0;
          var iidx = 0;
          for (var e4 = 0; e4 < 2; e4++) {
            for (var j4 = 0; j4 < height; j4++) {
              for (var i5 = 0; i5 < width; i5++, vidx++) {
                if (i5 == 0 || j4 == 0)
                  continue;
                if (i5 <= halfwidth == j4 <= halfheight) {
                  indices[iidx++] = vidx;
                  indices[iidx++] = vidx - width - 1;
                  indices[iidx++] = vidx - width;
                  indices[iidx++] = vidx - width - 1;
                  indices[iidx++] = vidx;
                  indices[iidx++] = vidx - 1;
                } else {
                  indices[iidx++] = vidx - 1;
                  indices[iidx++] = vidx - width;
                  indices[iidx++] = vidx;
                  indices[iidx++] = vidx - width;
                  indices[iidx++] = vidx - 1;
                  indices[iidx++] = vidx - width - 1;
                }
              }
            }
          }
          return indices;
        };
        CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
          var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
          if (descriptor.get === void 0 || descriptor.set === void 0) {
            descriptor.configurable = true;
            descriptor.enumerable = true;
            descriptor.get = function() {
              return this.getAttribute(attrName);
            };
            descriptor.set = function(val) {
              this.setAttribute(attrName, val);
            };
          }
          return descriptor;
        };
        var uiVS = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join("\n");
        var uiFS = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join("\n");
        var DEG2RAD2 = Math.PI / 180;
        var kAnglePerGearSection = 60;
        var kOuterRimEndAngle = 12;
        var kInnerRimBeginAngle = 20;
        var kOuterRadius = 1;
        var kMiddleRadius = 0.75;
        var kInnerRadius = 0.3125;
        var kCenterLineThicknessDp = 4;
        var kButtonWidthDp = 28;
        var kTouchSlopFactor = 1.5;
        function CardboardUI(gl3) {
          this.gl = gl3;
          this.attribs = {
            position: 0
          };
          this.program = linkProgram(gl3, uiVS, uiFS, this.attribs);
          this.uniforms = getProgramUniforms(gl3, this.program);
          this.vertexBuffer = gl3.createBuffer();
          this.gearOffset = 0;
          this.gearVertexCount = 0;
          this.arrowOffset = 0;
          this.arrowVertexCount = 0;
          this.projMat = new Float32Array(16);
          this.listener = null;
          this.onResize();
        }
        CardboardUI.prototype.destroy = function() {
          var gl3 = this.gl;
          if (this.listener) {
            gl3.canvas.removeEventListener("click", this.listener, false);
          }
          gl3.deleteProgram(this.program);
          gl3.deleteBuffer(this.vertexBuffer);
        };
        CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
          var canvas = this.gl.canvas;
          this.listener = function(event) {
            var midline = canvas.clientWidth / 2;
            var buttonSize = kButtonWidthDp * kTouchSlopFactor;
            if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize) {
              optionsCallback(event);
            } else if (event.clientX < buttonSize && event.clientY < buttonSize) {
              backCallback(event);
            }
          };
          canvas.addEventListener("click", this.listener, false);
        };
        CardboardUI.prototype.onResize = function() {
          var gl3 = this.gl;
          var self2 = this;
          var glState = [gl3.ARRAY_BUFFER_BINDING];
          glPreserveState(gl3, glState, function(gl4) {
            var vertices = [];
            var midline = gl4.drawingBufferWidth / 2;
            var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
            var scalingRatio = gl4.drawingBufferWidth / physicalPixels;
            var dps = scalingRatio * window.devicePixelRatio;
            var lineWidth = kCenterLineThicknessDp * dps / 2;
            var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
            var buttonScale = kButtonWidthDp * dps / 2;
            var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
            vertices.push(midline - lineWidth, buttonSize);
            vertices.push(midline - lineWidth, gl4.drawingBufferHeight);
            vertices.push(midline + lineWidth, buttonSize);
            vertices.push(midline + lineWidth, gl4.drawingBufferHeight);
            self2.gearOffset = vertices.length / 2;
            function addGearSegment(theta, r4) {
              var angle2 = (90 - theta) * DEG2RAD2;
              var x4 = Math.cos(angle2);
              var y3 = Math.sin(angle2);
              vertices.push(kInnerRadius * x4 * buttonScale + midline, kInnerRadius * y3 * buttonScale + buttonScale);
              vertices.push(r4 * x4 * buttonScale + midline, r4 * y3 * buttonScale + buttonScale);
            }
            for (var i5 = 0; i5 <= 6; i5++) {
              var segmentTheta = i5 * kAnglePerGearSection;
              addGearSegment(segmentTheta, kOuterRadius);
              addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
              addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
              addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
              addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
            }
            self2.gearVertexCount = vertices.length / 2 - self2.gearOffset;
            self2.arrowOffset = vertices.length / 2;
            function addArrowVertex(x4, y3) {
              vertices.push(buttonBorder + x4, gl4.drawingBufferHeight - buttonBorder - y3);
            }
            var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD2);
            addArrowVertex(0, buttonScale);
            addArrowVertex(buttonScale, 0);
            addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
            addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
            addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
            addArrowVertex(0, buttonScale);
            addArrowVertex(buttonScale, buttonScale * 2);
            addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);
            addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
            addArrowVertex(0, buttonScale);
            addArrowVertex(angledLineWidth, buttonScale - lineWidth);
            addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
            addArrowVertex(angledLineWidth, buttonScale + lineWidth);
            addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
            self2.arrowVertexCount = vertices.length / 2 - self2.arrowOffset;
            gl4.bindBuffer(gl4.ARRAY_BUFFER, self2.vertexBuffer);
            gl4.bufferData(gl4.ARRAY_BUFFER, new Float32Array(vertices), gl4.STATIC_DRAW);
          });
        };
        CardboardUI.prototype.render = function() {
          var gl3 = this.gl;
          var self2 = this;
          var glState = [gl3.CULL_FACE, gl3.DEPTH_TEST, gl3.BLEND, gl3.SCISSOR_TEST, gl3.STENCIL_TEST, gl3.COLOR_WRITEMASK, gl3.VIEWPORT, gl3.CURRENT_PROGRAM, gl3.ARRAY_BUFFER_BINDING];
          glPreserveState(gl3, glState, function(gl4) {
            gl4.disable(gl4.CULL_FACE);
            gl4.disable(gl4.DEPTH_TEST);
            gl4.disable(gl4.BLEND);
            gl4.disable(gl4.SCISSOR_TEST);
            gl4.disable(gl4.STENCIL_TEST);
            gl4.colorMask(true, true, true, true);
            gl4.viewport(0, 0, gl4.drawingBufferWidth, gl4.drawingBufferHeight);
            self2.renderNoState();
          });
        };
        CardboardUI.prototype.renderNoState = function() {
          var gl3 = this.gl;
          gl3.useProgram(this.program);
          gl3.bindBuffer(gl3.ARRAY_BUFFER, this.vertexBuffer);
          gl3.enableVertexAttribArray(this.attribs.position);
          gl3.vertexAttribPointer(this.attribs.position, 2, gl3.FLOAT, false, 8, 0);
          gl3.uniform4f(this.uniforms.color, 1, 1, 1, 1);
          orthoMatrix(this.projMat, 0, gl3.drawingBufferWidth, 0, gl3.drawingBufferHeight, 0.1, 1024);
          gl3.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
          gl3.drawArrays(gl3.TRIANGLE_STRIP, 0, 4);
          gl3.drawArrays(gl3.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
          gl3.drawArrays(gl3.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
        };
        function Distortion(coefficients) {
          this.coefficients = coefficients;
        }
        Distortion.prototype.distortInverse = function(radius) {
          var r0 = 0;
          var r1 = 1;
          var dr0 = radius - this.distort(r0);
          while (Math.abs(r1 - r0) > 1e-4) {
            var dr1 = radius - this.distort(r1);
            var r22 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
            r0 = r1;
            r1 = r22;
            dr0 = dr1;
          }
          return r1;
        };
        Distortion.prototype.distort = function(radius) {
          var r22 = radius * radius;
          var ret = 0;
          for (var i5 = 0; i5 < this.coefficients.length; i5++) {
            ret = r22 * (ret + this.coefficients[i5]);
          }
          return (ret + 1) * radius;
        };
        var degToRad2 = Math.PI / 180;
        var radToDeg2 = 180 / Math.PI;
        var Vector32 = function Vector33(x4, y3, z4) {
          this.x = x4 || 0;
          this.y = y3 || 0;
          this.z = z4 || 0;
        };
        Vector32.prototype = {
          constructor: Vector32,
          set: function set3(x4, y3, z4) {
            this.x = x4;
            this.y = y3;
            this.z = z4;
            return this;
          },
          copy: function copy6(v5) {
            this.x = v5.x;
            this.y = v5.y;
            this.z = v5.z;
            return this;
          },
          length: function length3() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
          },
          normalize: function normalize5() {
            var scalar = this.length();
            if (scalar !== 0) {
              var invScalar = 1 / scalar;
              this.multiplyScalar(invScalar);
            } else {
              this.x = 0;
              this.y = 0;
              this.z = 0;
            }
            return this;
          },
          multiplyScalar: function multiplyScalar2(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
          },
          applyQuaternion: function applyQuaternion(q4) {
            var x4 = this.x;
            var y3 = this.y;
            var z4 = this.z;
            var qx = q4.x;
            var qy = q4.y;
            var qz = q4.z;
            var qw2 = q4.w;
            var ix = qw2 * x4 + qy * z4 - qz * y3;
            var iy = qw2 * y3 + qz * x4 - qx * z4;
            var iz = qw2 * z4 + qx * y3 - qy * x4;
            var iw = -qx * x4 - qy * y3 - qz * z4;
            this.x = ix * qw2 + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw2 + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw2 + iw * -qz + ix * -qy - iy * -qx;
            return this;
          },
          dot: function dot3(v5) {
            return this.x * v5.x + this.y * v5.y + this.z * v5.z;
          },
          crossVectors: function crossVectors(a4, b3) {
            var ax = a4.x, ay = a4.y, az = a4.z;
            var bx = b3.x, by = b3.y, bz = b3.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
          }
        };
        var Quaternion2 = function Quaternion3(x4, y3, z4, w3) {
          this.x = x4 || 0;
          this.y = y3 || 0;
          this.z = z4 || 0;
          this.w = w3 !== void 0 ? w3 : 1;
        };
        Quaternion2.prototype = {
          constructor: Quaternion2,
          set: function set3(x4, y3, z4, w3) {
            this.x = x4;
            this.y = y3;
            this.z = z4;
            this.w = w3;
            return this;
          },
          copy: function copy6(quaternion) {
            this.x = quaternion.x;
            this.y = quaternion.y;
            this.z = quaternion.z;
            this.w = quaternion.w;
            return this;
          },
          setFromEulerXYZ: function setFromEulerXYZ(x4, y3, z4) {
            var c1 = Math.cos(x4 / 2);
            var c22 = Math.cos(y3 / 2);
            var c32 = Math.cos(z4 / 2);
            var s1 = Math.sin(x4 / 2);
            var s22 = Math.sin(y3 / 2);
            var s32 = Math.sin(z4 / 2);
            this.x = s1 * c22 * c32 + c1 * s22 * s32;
            this.y = c1 * s22 * c32 - s1 * c22 * s32;
            this.z = c1 * c22 * s32 + s1 * s22 * c32;
            this.w = c1 * c22 * c32 - s1 * s22 * s32;
            return this;
          },
          setFromEulerYXZ: function setFromEulerYXZ(x4, y3, z4) {
            var c1 = Math.cos(x4 / 2);
            var c22 = Math.cos(y3 / 2);
            var c32 = Math.cos(z4 / 2);
            var s1 = Math.sin(x4 / 2);
            var s22 = Math.sin(y3 / 2);
            var s32 = Math.sin(z4 / 2);
            this.x = s1 * c22 * c32 + c1 * s22 * s32;
            this.y = c1 * s22 * c32 - s1 * c22 * s32;
            this.z = c1 * c22 * s32 - s1 * s22 * c32;
            this.w = c1 * c22 * c32 + s1 * s22 * s32;
            return this;
          },
          setFromAxisAngle: function setFromAxisAngle(axis, angle2) {
            var halfAngle = angle2 / 2, s4 = Math.sin(halfAngle);
            this.x = axis.x * s4;
            this.y = axis.y * s4;
            this.z = axis.z * s4;
            this.w = Math.cos(halfAngle);
            return this;
          },
          multiply: function multiply4(q4) {
            return this.multiplyQuaternions(this, q4);
          },
          multiplyQuaternions: function multiplyQuaternions(a4, b3) {
            var qax = a4.x, qay = a4.y, qaz = a4.z, qaw = a4.w;
            var qbx = b3.x, qby = b3.y, qbz = b3.z, qbw = b3.w;
            this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            return this;
          },
          inverse: function inverse() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            this.normalize();
            return this;
          },
          normalize: function normalize5() {
            var l4 = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            if (l4 === 0) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 1;
            } else {
              l4 = 1 / l4;
              this.x = this.x * l4;
              this.y = this.y * l4;
              this.z = this.z * l4;
              this.w = this.w * l4;
            }
            return this;
          },
          slerp: function slerp2(qb2, t4) {
            if (t4 === 0)
              return this;
            if (t4 === 1)
              return this.copy(qb2);
            var x4 = this.x, y3 = this.y, z4 = this.z, w3 = this.w;
            var cosHalfTheta = w3 * qb2.w + x4 * qb2.x + y3 * qb2.y + z4 * qb2.z;
            if (cosHalfTheta < 0) {
              this.w = -qb2.w;
              this.x = -qb2.x;
              this.y = -qb2.y;
              this.z = -qb2.z;
              cosHalfTheta = -cosHalfTheta;
            } else {
              this.copy(qb2);
            }
            if (cosHalfTheta >= 1) {
              this.w = w3;
              this.x = x4;
              this.y = y3;
              this.z = z4;
              return this;
            }
            var halfTheta = Math.acos(cosHalfTheta);
            var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 1e-3) {
              this.w = 0.5 * (w3 + this.w);
              this.x = 0.5 * (x4 + this.x);
              this.y = 0.5 * (y3 + this.y);
              this.z = 0.5 * (z4 + this.z);
              return this;
            }
            var ratioA = Math.sin((1 - t4) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t4 * halfTheta) / sinHalfTheta;
            this.w = w3 * ratioA + this.w * ratioB;
            this.x = x4 * ratioA + this.x * ratioB;
            this.y = y3 * ratioA + this.y * ratioB;
            this.z = z4 * ratioA + this.z * ratioB;
            return this;
          },
          setFromUnitVectors: /* @__PURE__ */ function() {
            var v1, r4;
            var EPS = 1e-6;
            return function(vFrom, vTo) {
              if (v1 === void 0)
                v1 = new Vector32();
              r4 = vFrom.dot(vTo) + 1;
              if (r4 < EPS) {
                r4 = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                  v1.set(-vFrom.y, vFrom.x, 0);
                } else {
                  v1.set(0, -vFrom.z, vFrom.y);
                }
              } else {
                v1.crossVectors(vFrom, vTo);
              }
              this.x = v1.x;
              this.y = v1.y;
              this.z = v1.z;
              this.w = r4;
              this.normalize();
              return this;
            };
          }()
        };
        function Device(params) {
          this.width = params.width || getScreenWidth();
          this.height = params.height || getScreenHeight();
          this.widthMeters = params.widthMeters;
          this.heightMeters = params.heightMeters;
          this.bevelMeters = params.bevelMeters;
        }
        var DEFAULT_ANDROID = new Device({
          widthMeters: 0.11,
          heightMeters: 0.062,
          bevelMeters: 4e-3
        });
        var DEFAULT_IOS = new Device({
          widthMeters: 0.1038,
          heightMeters: 0.0584,
          bevelMeters: 4e-3
        });
        var Viewers = {
          CardboardV1: new CardboardViewer({
            id: "CardboardV1",
            label: "Cardboard I/O 2014",
            fov: 40,
            interLensDistance: 0.06,
            baselineLensDistance: 0.035,
            screenLensDistance: 0.042,
            distortionCoefficients: [0.441, 0.156],
            inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
          }),
          CardboardV2: new CardboardViewer({
            id: "CardboardV2",
            label: "Cardboard I/O 2015",
            fov: 60,
            interLensDistance: 0.064,
            baselineLensDistance: 0.035,
            screenLensDistance: 0.039,
            distortionCoefficients: [0.34, 0.55],
            inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
          })
        };
        function DeviceInfo(deviceParams, additionalViewers) {
          this.viewer = Viewers.CardboardV2;
          this.updateDeviceParams(deviceParams);
          this.distortion = new Distortion(this.viewer.distortionCoefficients);
          for (var i5 = 0; i5 < additionalViewers.length; i5++) {
            var viewer = additionalViewers[i5];
            Viewers[viewer.id] = new CardboardViewer(viewer);
          }
        }
        DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
          this.device = this.determineDevice_(deviceParams) || this.device;
        };
        DeviceInfo.prototype.getDevice = function() {
          return this.device;
        };
        DeviceInfo.prototype.setViewer = function(viewer) {
          this.viewer = viewer;
          this.distortion = new Distortion(this.viewer.distortionCoefficients);
        };
        DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
          if (!deviceParams) {
            if (isIOS()) {
              console.warn("Using fallback iOS device measurements.");
              return DEFAULT_IOS;
            } else {
              console.warn("Using fallback Android device measurements.");
              return DEFAULT_ANDROID;
            }
          }
          var METERS_PER_INCH = 0.0254;
          var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
          var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
          var width = getScreenWidth();
          var height = getScreenHeight();
          return new Device({
            widthMeters: metersPerPixelX * width,
            heightMeters: metersPerPixelY * height,
            bevelMeters: deviceParams.bevelMm * 1e-3
          });
        };
        DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
          var viewer = this.viewer;
          var device = this.device;
          var distortion = this.distortion;
          var eyeToScreenDistance = viewer.screenLensDistance;
          var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
          var innerDist = viewer.interLensDistance / 2;
          var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
          var topDist = device.heightMeters - bottomDist;
          var outerAngle = radToDeg2 * Math.atan(distortion.distort(outerDist / eyeToScreenDistance));
          var innerAngle = radToDeg2 * Math.atan(distortion.distort(innerDist / eyeToScreenDistance));
          var bottomAngle = radToDeg2 * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance));
          var topAngle = radToDeg2 * Math.atan(distortion.distort(topDist / eyeToScreenDistance));
          return {
            leftDegrees: Math.min(outerAngle, viewer.fov),
            rightDegrees: Math.min(innerAngle, viewer.fov),
            downDegrees: Math.min(bottomAngle, viewer.fov),
            upDegrees: Math.min(topAngle, viewer.fov)
          };
        };
        DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
          var viewer = this.viewer;
          var device = this.device;
          var distortion = this.distortion;
          var fovLeft = Math.tan(-degToRad2 * viewer.fov);
          var fovTop = Math.tan(degToRad2 * viewer.fov);
          var fovRight = Math.tan(degToRad2 * viewer.fov);
          var fovBottom = Math.tan(-degToRad2 * viewer.fov);
          var halfWidth = device.widthMeters / 4;
          var halfHeight = device.heightMeters / 2;
          var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
          var centerX = viewer.interLensDistance / 2 - halfWidth;
          var centerY = -verticalLensOffset;
          var centerZ = viewer.screenLensDistance;
          var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
          var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
          var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
          var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
          var result = new Float32Array(4);
          result[0] = Math.max(fovLeft, screenLeft);
          result[1] = Math.min(fovTop, screenTop);
          result[2] = Math.min(fovRight, screenRight);
          result[3] = Math.max(fovBottom, screenBottom);
          return result;
        };
        DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
          var viewer = this.viewer;
          var device = this.device;
          var distortion = this.distortion;
          var result = new Float32Array(4);
          var fovLeft = distortion.distortInverse(Math.tan(-degToRad2 * viewer.fov));
          var fovTop = distortion.distortInverse(Math.tan(degToRad2 * viewer.fov));
          var fovRight = distortion.distortInverse(Math.tan(degToRad2 * viewer.fov));
          var fovBottom = distortion.distortInverse(Math.tan(-degToRad2 * viewer.fov));
          var halfWidth = device.widthMeters / 4;
          var halfHeight = device.heightMeters / 2;
          var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
          var centerX = viewer.interLensDistance / 2 - halfWidth;
          var centerY = -verticalLensOffset;
          var centerZ = viewer.screenLensDistance;
          var screenLeft = (centerX - halfWidth) / centerZ;
          var screenTop = (centerY + halfHeight) / centerZ;
          var screenRight = (centerX + halfWidth) / centerZ;
          var screenBottom = (centerY - halfHeight) / centerZ;
          result[0] = Math.max(fovLeft, screenLeft);
          result[1] = Math.min(fovTop, screenTop);
          result[2] = Math.min(fovRight, screenRight);
          result[3] = Math.max(fovBottom, screenBottom);
          return result;
        };
        DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
          var viewer = this.viewer;
          var device = this.device;
          var dist = viewer.screenLensDistance;
          var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
          var eyeY = viewer.baselineLensDistance - device.bevelMeters;
          var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
          var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
          var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
          var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
          return {
            x: left,
            y: bottom,
            width: right - left,
            height: top - bottom
          };
        };
        DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
          return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
        };
        DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
          var fov2 = this.getFieldOfViewLeftEye(opt_isUndistorted);
          return {
            leftDegrees: fov2.rightDegrees,
            rightDegrees: fov2.leftDegrees,
            upDegrees: fov2.upDegrees,
            downDegrees: fov2.downDegrees
          };
        };
        DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
          var p4 = this.getUndistortedParams_();
          return {
            leftDegrees: radToDeg2 * Math.atan(p4.outerDist),
            rightDegrees: radToDeg2 * Math.atan(p4.innerDist),
            downDegrees: radToDeg2 * Math.atan(p4.bottomDist),
            upDegrees: radToDeg2 * Math.atan(p4.topDist)
          };
        };
        DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
          var p4 = this.getUndistortedParams_();
          var viewer = this.viewer;
          var device = this.device;
          var eyeToScreenDistance = viewer.screenLensDistance;
          var screenWidth = device.widthMeters / eyeToScreenDistance;
          var screenHeight = device.heightMeters / eyeToScreenDistance;
          var xPxPerTanAngle = device.width / screenWidth;
          var yPxPerTanAngle = device.height / screenHeight;
          var x4 = Math.round((p4.eyePosX - p4.outerDist) * xPxPerTanAngle);
          var y3 = Math.round((p4.eyePosY - p4.bottomDist) * yPxPerTanAngle);
          return {
            x: x4,
            y: y3,
            width: Math.round((p4.eyePosX + p4.innerDist) * xPxPerTanAngle) - x4,
            height: Math.round((p4.eyePosY + p4.topDist) * yPxPerTanAngle) - y3
          };
        };
        DeviceInfo.prototype.getUndistortedParams_ = function() {
          var viewer = this.viewer;
          var device = this.device;
          var distortion = this.distortion;
          var eyeToScreenDistance = viewer.screenLensDistance;
          var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
          var screenWidth = device.widthMeters / eyeToScreenDistance;
          var screenHeight = device.heightMeters / eyeToScreenDistance;
          var eyePosX = screenWidth / 2 - halfLensDistance;
          var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
          var maxFov = viewer.fov;
          var viewerMax = distortion.distortInverse(Math.tan(degToRad2 * maxFov));
          var outerDist = Math.min(eyePosX, viewerMax);
          var innerDist = Math.min(halfLensDistance, viewerMax);
          var bottomDist = Math.min(eyePosY, viewerMax);
          var topDist = Math.min(screenHeight - eyePosY, viewerMax);
          return {
            outerDist,
            innerDist,
            topDist,
            bottomDist,
            eyePosX,
            eyePosY
          };
        };
        function CardboardViewer(params) {
          this.id = params.id;
          this.label = params.label;
          this.fov = params.fov;
          this.interLensDistance = params.interLensDistance;
          this.baselineLensDistance = params.baselineLensDistance;
          this.screenLensDistance = params.screenLensDistance;
          this.distortionCoefficients = params.distortionCoefficients;
          this.inverseCoefficients = params.inverseCoefficients;
        }
        DeviceInfo.Viewers = Viewers;
        var format = 1;
        var last_updated = "2019-11-09T17:36:14Z";
        var devices = [{ "type": "android", "rules": [{ "mdmh": "asus/*/Nexus 7/*" }, { "ua": "Nexus 7" }], "dpi": [320.8, 323], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_X00PD/*" }, { "ua": "ASUS_X00PD" }], "dpi": 245, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_X008D/*" }, { "ua": "ASUS_X008D" }], "dpi": 282, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_Z00AD/*" }, { "ua": "ASUS_Z00AD" }], "dpi": [403, 404.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 2 XL/*" }, { "ua": "Pixel 2 XL" }], "dpi": 537.9, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 3 XL/*" }, { "ua": "Pixel 3 XL" }], "dpi": [558.5, 553.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel XL/*" }, { "ua": "Pixel XL" }], "dpi": [537.9, 533], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 3/*" }, { "ua": "Pixel 3" }], "dpi": 442.4, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 2/*" }, { "ua": "Pixel 2" }], "dpi": 441, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel/*" }, { "ua": "Pixel" }], "dpi": [432.6, 436.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC6435LVW/*" }, { "ua": "HTC6435LVW" }], "dpi": [449.7, 443.3], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One XL/*" }, { "ua": "HTC One XL" }], "dpi": [315.3, 314.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "htc/*/Nexus 9/*" }, { "ua": "Nexus 9" }], "dpi": 289, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One M9/*" }, { "ua": "HTC One M9" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One_M8/*" }, { "ua": "HTC One_M8" }], "dpi": [449.7, 447.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One/*" }, { "ua": "HTC One" }], "dpi": 472.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/Nexus 6P/*" }, { "ua": "Nexus 6P" }], "dpi": [515.1, 518], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/BLN-L24/*" }, { "ua": "HONORBLN-L24" }], "dpi": 480, "bw": 4, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/BKL-L09/*" }, { "ua": "BKL-L09" }], "dpi": 403, "bw": 3.47, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LENOVO/*/Lenovo PB2-690Y/*" }, { "ua": "Lenovo PB2-690Y" }], "dpi": [457.2, 454.713], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5X/*" }, { "ua": "Nexus 5X" }], "dpi": [422, 419.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS345/*" }, { "ua": "LGMS345" }], "dpi": [221.7, 219.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D800/*" }, { "ua": "LG-D800" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D850/*" }, { "ua": "LG-D850" }], "dpi": [537.9, 541.9], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/VS985 4G/*" }, { "ua": "VS985 4G" }], "dpi": [537.9, 535.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5/*" }, { "ua": "Nexus 5 B" }], "dpi": [442.4, 444.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 4/*" }, { "ua": "Nexus 4" }], "dpi": [319.8, 318.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-P769/*" }, { "ua": "LG-P769" }], "dpi": [240.6, 247.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS323/*" }, { "ua": "LGMS323" }], "dpi": [206.6, 204.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGLS996/*" }, { "ua": "LGLS996" }], "dpi": [403.4, 401.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/4560MMX/*" }, { "ua": "4560MMX" }], "dpi": [240, 219.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/A250/*" }, { "ua": "Micromax A250" }], "dpi": [480, 446.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/Micromax AQ4501/*" }, { "ua": "Micromax AQ4501" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G5/*" }, { "ua": "Moto G (5) Plus" }], "dpi": [403.4, 403], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/DROID RAZR/*" }, { "ua": "DROID RAZR" }], "dpi": [368.1, 256.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT830C/*" }, { "ua": "XT830C" }], "dpi": [254, 255.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1021/*" }, { "ua": "XT1021" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1023/*" }, { "ua": "XT1023" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1028/*" }, { "ua": "XT1028" }], "dpi": [326.6, 327.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1034/*" }, { "ua": "XT1034" }], "dpi": [326.6, 328.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1053/*" }, { "ua": "XT1053" }], "dpi": [315.3, 316.1], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1562/*" }, { "ua": "XT1562" }], "dpi": [403.4, 402.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/Nexus 6/*" }, { "ua": "Nexus 6 B" }], "dpi": [494.3, 489.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1063/*" }, { "ua": "XT1063" }], "dpi": [295, 296.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1064/*" }, { "ua": "XT1064" }], "dpi": [295, 295.6], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1092/*" }, { "ua": "XT1092" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1095/*" }, { "ua": "XT1095" }], "dpi": [422, 423.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G4/*" }, { "ua": "Moto G (4)" }], "dpi": 401, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/A0001/*" }, { "ua": "A0001" }], "dpi": [403.4, 401], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1001/*" }, { "ua": "ONE E1001" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1003/*" }, { "ua": "ONE E1003" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1005/*" }, { "ua": "ONE E1005" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2001/*" }, { "ua": "ONE A2001" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2003/*" }, { "ua": "ONE A2003" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2005/*" }, { "ua": "ONE A2005" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3000/*" }, { "ua": "ONEPLUS A3000" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3003/*" }, { "ua": "ONEPLUS A3003" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3010/*" }, { "ua": "ONEPLUS A3010" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A5000/*" }, { "ua": "ONEPLUS A5000 " }], "dpi": [403.411, 399.737], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A5010/*" }, { "ua": "ONEPLUS A5010" }], "dpi": [403, 400], "bw": 2, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6000/*" }, { "ua": "ONEPLUS A6000" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6003/*" }, { "ua": "ONEPLUS A6003" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6010/*" }, { "ua": "ONEPLUS A6010" }], "dpi": 401, "bw": 2, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6013/*" }, { "ua": "ONEPLUS A6013" }], "dpi": 401, "bw": 2, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OPPO/*/X909/*" }, { "ua": "X909" }], "dpi": [442.4, 444.1], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9082/*" }, { "ua": "GT-I9082" }], "dpi": [184.7, 185.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G360P/*" }, { "ua": "SM-G360P" }], "dpi": [196.7, 205.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Nexus S/*" }, { "ua": "Nexus S" }], "dpi": [234.5, 229.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [304.8, 303.9], "bw": 5, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T230NU/*" }, { "ua": "SM-T230NU" }], "dpi": 216, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-T399/*" }, { "ua": "SGH-T399" }], "dpi": [217.7, 231.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-M919/*" }, { "ua": "SGH-M919" }], "dpi": [440.8, 437.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N9005/*" }, { "ua": "SM-N9005" }], "dpi": [386.4, 387], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" }, { "ua": "SAMSUNG-SM-N900A" }], "dpi": [386.4, 387.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9500/*" }, { "ua": "GT-I9500" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9505/*" }, { "ua": "GT-I9505" }], "dpi": 439.4, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900F/*" }, { "ua": "SM-G900F" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900M/*" }, { "ua": "SM-G900M" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G800F/*" }, { "ua": "SM-G800F" }], "dpi": 326.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G906S/*" }, { "ua": "SM-G906S" }], "dpi": [562.7, 572.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [306.7, 304.8], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T535/*" }, { "ua": "SM-T535" }], "dpi": [142.6, 136.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920C/*" }, { "ua": "SM-N920C" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920P/*" }, { "ua": "SM-N920P" }], "dpi": [386.3655, 390.144], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920W8/*" }, { "ua": "SM-N920W8" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300I/*" }, { "ua": "GT-I9300I" }], "dpi": [304.8, 305.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9195/*" }, { "ua": "GT-I9195" }], "dpi": [249.4, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-L520/*" }, { "ua": "SPH-L520" }], "dpi": [249.4, 255.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" }, { "ua": "SAMSUNG-SGH-I717" }], "dpi": 285.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-D710/*" }, { "ua": "SPH-D710" }], "dpi": [217.7, 204.2], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-N7100/*" }, { "ua": "GT-N7100" }], "dpi": 265.1, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SCH-I605/*" }, { "ua": "SCH-I605" }], "dpi": 265.1, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Galaxy Nexus/*" }, { "ua": "Galaxy Nexus" }], "dpi": [315.3, 314.2], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910H/*" }, { "ua": "SM-N910H" }], "dpi": [515.1, 518], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910C/*" }, { "ua": "SM-N910C" }], "dpi": [515.2, 520.2], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G130M/*" }, { "ua": "SM-G130M" }], "dpi": [165.9, 164.8], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G928I/*" }, { "ua": "SM-G928I" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920F/*" }, { "ua": "SM-G920F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920P/*" }, { "ua": "SM-G920P" }], "dpi": [522.5, 577], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925F/*" }, { "ua": "SM-G925F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925V/*" }, { "ua": "SM-G925V" }], "dpi": [522.5, 576.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G930F/*" }, { "ua": "SM-G930F" }], "dpi": 576.6, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G935F/*" }, { "ua": "SM-G935F" }], "dpi": 533, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G950F/*" }, { "ua": "SM-G950F" }], "dpi": [562.707, 565.293], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955U/*" }, { "ua": "SM-G955U" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955F/*" }, { "ua": "SM-G955F" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960F/*" }, { "ua": "SM-G960F" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G9600/*" }, { "ua": "SM-G9600" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960T/*" }, { "ua": "SM-G960T" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960N/*" }, { "ua": "SM-G960N" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960U/*" }, { "ua": "SM-G960U" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G9608/*" }, { "ua": "SM-G9608" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960FD/*" }, { "ua": "SM-G960FD" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960W/*" }, { "ua": "SM-G960W" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G965F/*" }, { "ua": "SM-G965F" }], "dpi": 529, "bw": 2, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/C6903/*" }, { "ua": "C6903" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/D6653/*" }, { "ua": "D6653" }], "dpi": [428.6, 427.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6653/*" }, { "ua": "E6653" }], "dpi": [428.6, 425.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6853/*" }, { "ua": "E6853" }], "dpi": [403.4, 401.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/SGP321/*" }, { "ua": "SGP321" }], "dpi": [224.7, 224.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { "ua": "ALCATEL ONE TOUCH Fierce" }], "dpi": [240, 247.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "THL/*/thl 5000/*" }, { "ua": "thl 5000" }], "dpi": [480, 443.3], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Fly/*/IQ4412/*" }, { "ua": "IQ4412" }], "dpi": 307.9, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "ZTE/*/ZTE Blade L2/*" }, { "ua": "ZTE Blade L2" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "BENEVE/*/VR518/*" }, { "ua": "VR518" }], "dpi": 480, "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [640, 960] }], "dpi": [325.1, 328.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [640, 1136] }], "dpi": [317.1, 320.2], "bw": 3, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [750, 1334] }], "dpi": 326.4, "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1242, 2208] }], "dpi": [453.6, 458.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1125, 2001] }], "dpi": [410.9, 415.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1125, 2436] }], "dpi": 458, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/EML-L29/*" }, { "ua": "EML-L29" }], "dpi": 428, "bw": 3.45, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Nokia/*/Nokia 7.1/*" }, { "ua": "Nokia 7.1" }], "dpi": [432, 431.9], "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [1242, 2688] }], "dpi": 458, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G570M/*" }, { "ua": "SM-G570M" }], "dpi": 320, "bw": 3.684, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G970F/*" }, { "ua": "SM-G970F" }], "dpi": 438, "bw": 2.281, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G973F/*" }, { "ua": "SM-G973F" }], "dpi": 550, "bw": 2.002, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G975F/*" }, { "ua": "SM-G975F" }], "dpi": 522, "bw": 2.054, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G977F/*" }, { "ua": "SM-G977F" }], "dpi": 505, "bw": 2.334, "ac": 500 }, { "type": "ios", "rules": [{ "res": [828, 1792] }], "dpi": 326, "bw": 5, "ac": 500 }];
        var DPDB_CACHE = {
          format,
          last_updated,
          devices
        };
        function Dpdb(url, onDeviceParamsUpdated) {
          this.dpdb = DPDB_CACHE;
          this.recalculateDeviceParams_();
          if (url) {
            this.onDeviceParamsUpdated = onDeviceParamsUpdated;
            var xhr = new XMLHttpRequest();
            var obj = this;
            xhr.open("GET", url, true);
            xhr.addEventListener("load", function() {
              obj.loading = false;
              if (xhr.status >= 200 && xhr.status <= 299) {
                obj.dpdb = JSON.parse(xhr.response);
                obj.recalculateDeviceParams_();
              } else {
                console.error("Error loading online DPDB!");
              }
            });
            xhr.send();
          }
        }
        Dpdb.prototype.getDeviceParams = function() {
          return this.deviceParams;
        };
        Dpdb.prototype.recalculateDeviceParams_ = function() {
          var newDeviceParams = this.calcDeviceParams_();
          if (newDeviceParams) {
            this.deviceParams = newDeviceParams;
            if (this.onDeviceParamsUpdated) {
              this.onDeviceParamsUpdated(this.deviceParams);
            }
          } else {
            console.error("Failed to recalculate device parameters.");
          }
        };
        Dpdb.prototype.calcDeviceParams_ = function() {
          var db2 = this.dpdb;
          if (!db2) {
            console.error("DPDB not available.");
            return null;
          }
          if (db2.format != 1) {
            console.error("DPDB has unexpected format version.");
            return null;
          }
          if (!db2.devices || !db2.devices.length) {
            console.error("DPDB does not have a devices section.");
            return null;
          }
          var userAgent = navigator.userAgent || navigator.vendor || window.opera;
          var width = getScreenWidth();
          var height = getScreenHeight();
          if (!db2.devices) {
            console.error("DPDB has no devices section.");
            return null;
          }
          for (var i5 = 0; i5 < db2.devices.length; i5++) {
            var device = db2.devices[i5];
            if (!device.rules) {
              console.warn("Device[" + i5 + "] has no rules section.");
              continue;
            }
            if (device.type != "ios" && device.type != "android") {
              console.warn("Device[" + i5 + "] has invalid type.");
              continue;
            }
            if (isIOS() != (device.type == "ios"))
              continue;
            var matched = false;
            for (var j4 = 0; j4 < device.rules.length; j4++) {
              var rule = device.rules[j4];
              if (this.ruleMatches_(rule, userAgent, width, height)) {
                matched = true;
                break;
              }
            }
            if (!matched)
              continue;
            var xdpi = device.dpi[0] || device.dpi;
            var ydpi = device.dpi[1] || device.dpi;
            return new DeviceParams({ xdpi, ydpi, bevelMm: device.bw });
          }
          console.warn("No DPDB device match.");
          return null;
        };
        Dpdb.prototype.ruleMatches_ = function(rule, ua3, screenWidth, screenHeight) {
          if (!rule.ua && !rule.res)
            return false;
          if (rule.ua && rule.ua.substring(0, 2) === "SM")
            rule.ua = rule.ua.substring(0, 7);
          if (rule.ua && ua3.indexOf(rule.ua) < 0)
            return false;
          if (rule.res) {
            if (!rule.res[0] || !rule.res[1])
              return false;
            var resX = rule.res[0];
            var resY = rule.res[1];
            if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
              return false;
            }
          }
          return true;
        };
        function DeviceParams(params) {
          this.xdpi = params.xdpi;
          this.ydpi = params.ydpi;
          this.bevelMm = params.bevelMm;
        }
        function SensorSample(sample, timestampS) {
          this.set(sample, timestampS);
        }
        SensorSample.prototype.set = function(sample, timestampS) {
          this.sample = sample;
          this.timestampS = timestampS;
        };
        SensorSample.prototype.copy = function(sensorSample) {
          this.set(sensorSample.sample, sensorSample.timestampS);
        };
        function ComplementaryFilter(kFilter, isDebug) {
          this.kFilter = kFilter;
          this.isDebug = isDebug;
          this.currentAccelMeasurement = new SensorSample();
          this.currentGyroMeasurement = new SensorSample();
          this.previousGyroMeasurement = new SensorSample();
          if (isIOS()) {
            this.filterQ = new Quaternion2(-1, 0, 0, 1);
          } else {
            this.filterQ = new Quaternion2(1, 0, 0, 1);
          }
          this.previousFilterQ = new Quaternion2();
          this.previousFilterQ.copy(this.filterQ);
          this.accelQ = new Quaternion2();
          this.isOrientationInitialized = false;
          this.estimatedGravity = new Vector32();
          this.measuredGravity = new Vector32();
          this.gyroIntegralQ = new Quaternion2();
        }
        ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
          this.currentAccelMeasurement.set(vector, timestampS);
        };
        ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
          this.currentGyroMeasurement.set(vector, timestampS);
          var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
          if (isTimestampDeltaValid(deltaT)) {
            this.run_();
          }
          this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
        };
        ComplementaryFilter.prototype.run_ = function() {
          if (!this.isOrientationInitialized) {
            this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
            this.previousFilterQ.copy(this.accelQ);
            this.isOrientationInitialized = true;
            return;
          }
          var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;
          var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
          this.gyroIntegralQ.multiply(gyroDeltaQ);
          this.filterQ.copy(this.previousFilterQ);
          this.filterQ.multiply(gyroDeltaQ);
          var invFilterQ = new Quaternion2();
          invFilterQ.copy(this.filterQ);
          invFilterQ.inverse();
          this.estimatedGravity.set(0, 0, -1);
          this.estimatedGravity.applyQuaternion(invFilterQ);
          this.estimatedGravity.normalize();
          this.measuredGravity.copy(this.currentAccelMeasurement.sample);
          this.measuredGravity.normalize();
          var deltaQ = new Quaternion2();
          deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
          deltaQ.inverse();
          if (this.isDebug) {
            console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", radToDeg2 * getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
          }
          var targetQ = new Quaternion2();
          targetQ.copy(this.filterQ);
          targetQ.multiply(deltaQ);
          this.filterQ.slerp(targetQ, 1 - this.kFilter);
          this.previousFilterQ.copy(this.filterQ);
        };
        ComplementaryFilter.prototype.getOrientation = function() {
          return this.filterQ;
        };
        ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
          var normAccel = new Vector32();
          normAccel.copy(accel);
          normAccel.normalize();
          var quat = new Quaternion2();
          quat.setFromUnitVectors(new Vector32(0, 0, -1), normAccel);
          quat.inverse();
          return quat;
        };
        ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt5) {
          var quat = new Quaternion2();
          var axis = new Vector32();
          axis.copy(gyro);
          axis.normalize();
          quat.setFromAxisAngle(axis, gyro.length() * dt5);
          return quat;
        };
        function PosePredictor(predictionTimeS, isDebug) {
          this.predictionTimeS = predictionTimeS;
          this.isDebug = isDebug;
          this.previousQ = new Quaternion2();
          this.previousTimestampS = null;
          this.deltaQ = new Quaternion2();
          this.outQ = new Quaternion2();
        }
        PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
          if (!this.previousTimestampS) {
            this.previousQ.copy(currentQ);
            this.previousTimestampS = timestampS;
            return currentQ;
          }
          var axis = new Vector32();
          axis.copy(gyro);
          axis.normalize();
          var angularSpeed = gyro.length();
          if (angularSpeed < degToRad2 * 20) {
            if (this.isDebug) {
              console.log("Moving slowly, at %s deg/s: no prediction", (radToDeg2 * angularSpeed).toFixed(1));
            }
            this.outQ.copy(currentQ);
            this.previousQ.copy(currentQ);
            return this.outQ;
          }
          var predictAngle = angularSpeed * this.predictionTimeS;
          this.deltaQ.setFromAxisAngle(axis, predictAngle);
          this.outQ.copy(this.previousQ);
          this.outQ.multiply(this.deltaQ);
          this.previousQ.copy(currentQ);
          this.previousTimestampS = timestampS;
          return this.outQ;
        };
        function FusionPoseSensor(kFilter, predictionTime, yawOnly, isDebug) {
          this.yawOnly = yawOnly;
          this.accelerometer = new Vector32();
          this.gyroscope = new Vector32();
          this.filter = new ComplementaryFilter(kFilter, isDebug);
          this.posePredictor = new PosePredictor(predictionTime, isDebug);
          this.isFirefoxAndroid = isFirefoxAndroid();
          this.isIOS = isIOS();
          var chromeVersion = getChromeVersion();
          this.isDeviceMotionInRadians = !this.isIOS && chromeVersion && chromeVersion < 66;
          this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion() || isSafariWithoutDeviceMotion();
          this.filterToWorldQ = new Quaternion2();
          if (isIOS()) {
            this.filterToWorldQ.setFromAxisAngle(new Vector32(1, 0, 0), Math.PI / 2);
          } else {
            this.filterToWorldQ.setFromAxisAngle(new Vector32(1, 0, 0), -Math.PI / 2);
          }
          this.inverseWorldToScreenQ = new Quaternion2();
          this.worldToScreenQ = new Quaternion2();
          this.originalPoseAdjustQ = new Quaternion2();
          this.originalPoseAdjustQ.setFromAxisAngle(new Vector32(0, 0, 1), -window.orientation * Math.PI / 180);
          this.setScreenTransform_();
          if (isLandscapeMode()) {
            this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
          }
          this.resetQ = new Quaternion2();
          this.orientationOut_ = new Float32Array(4);
          this.start();
        }
        FusionPoseSensor.prototype.getPosition = function() {
          return null;
        };
        FusionPoseSensor.prototype.getOrientation = function() {
          var orientation = void 0;
          if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
            this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
              var z4 = new Quaternion2().setFromAxisAngle(new Vector32(0, 0, -1), 0);
              var y3 = new Quaternion2();
              if (window.orientation === -90) {
                y3.setFromAxisAngle(new Vector32(0, 1, 0), Math.PI / -2);
              } else {
                y3.setFromAxisAngle(new Vector32(0, 1, 0), Math.PI / 2);
              }
              return z4.multiply(y3);
            }();
            this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
              var q4 = new Quaternion2();
              q4.setFromAxisAngle(new Vector32(1, 0, 0), -Math.PI / 2);
              return q4;
            }();
            orientation = this._deviceOrientationQ;
            var out = new Quaternion2();
            out.copy(orientation);
            out.multiply(this.deviceOrientationFilterToWorldQ);
            out.multiply(this.resetQ);
            out.multiply(this.worldToScreenQ);
            out.multiplyQuaternions(this.deviceOrientationFixQ, out);
            if (this.yawOnly) {
              out.x = 0;
              out.z = 0;
              out.normalize();
            }
            this.orientationOut_[0] = out.x;
            this.orientationOut_[1] = out.y;
            this.orientationOut_[2] = out.z;
            this.orientationOut_[3] = out.w;
            return this.orientationOut_;
          } else {
            var filterOrientation = this.filter.getOrientation();
            orientation = this.posePredictor.getPrediction(filterOrientation, this.gyroscope, this.previousTimestampS);
          }
          var out = new Quaternion2();
          out.copy(this.filterToWorldQ);
          out.multiply(this.resetQ);
          out.multiply(orientation);
          out.multiply(this.worldToScreenQ);
          if (this.yawOnly) {
            out.x = 0;
            out.z = 0;
            out.normalize();
          }
          this.orientationOut_[0] = out.x;
          this.orientationOut_[1] = out.y;
          this.orientationOut_[2] = out.z;
          this.orientationOut_[3] = out.w;
          return this.orientationOut_;
        };
        FusionPoseSensor.prototype.resetPose = function() {
          this.resetQ.copy(this.filter.getOrientation());
          this.resetQ.x = 0;
          this.resetQ.y = 0;
          this.resetQ.z *= -1;
          this.resetQ.normalize();
          if (isLandscapeMode()) {
            this.resetQ.multiply(this.inverseWorldToScreenQ);
          }
          this.resetQ.multiply(this.originalPoseAdjustQ);
        };
        FusionPoseSensor.prototype.onDeviceOrientation_ = function(e4) {
          this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion2();
          var alpha = e4.alpha, beta = e4.beta, gamma = e4.gamma;
          alpha = (alpha || 0) * Math.PI / 180;
          beta = (beta || 0) * Math.PI / 180;
          gamma = (gamma || 0) * Math.PI / 180;
          this._deviceOrientationQ.setFromEulerYXZ(beta, alpha, -gamma);
        };
        FusionPoseSensor.prototype.onDeviceMotion_ = function(deviceMotion) {
          this.updateDeviceMotion_(deviceMotion);
        };
        FusionPoseSensor.prototype.updateDeviceMotion_ = function(deviceMotion) {
          var accGravity = deviceMotion.accelerationIncludingGravity;
          var rotRate = deviceMotion.rotationRate;
          var timestampS = deviceMotion.timeStamp / 1e3;
          var deltaS = timestampS - this.previousTimestampS;
          if (deltaS < 0) {
            warnOnce2("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion");
            this.previousTimestampS = timestampS;
            return;
          } else if (deltaS <= MIN_TIMESTEP || deltaS > MAX_TIMESTEP) {
            warnOnce2("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range.");
            this.previousTimestampS = timestampS;
            return;
          }
          this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
          if (rotRate) {
            if (isR7()) {
              this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma);
            } else {
              this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
            }
            if (!this.isDeviceMotionInRadians) {
              this.gyroscope.multiplyScalar(Math.PI / 180);
            }
            this.filter.addGyroMeasurement(this.gyroscope, timestampS);
          }
          this.filter.addAccelMeasurement(this.accelerometer, timestampS);
          this.previousTimestampS = timestampS;
        };
        FusionPoseSensor.prototype.onOrientationChange_ = function(screenOrientation) {
          this.setScreenTransform_();
        };
        FusionPoseSensor.prototype.onMessage_ = function(event) {
          var message = event.data;
          if (!message || !message.type) {
            return;
          }
          var type = message.type.toLowerCase();
          if (type !== "devicemotion") {
            return;
          }
          this.updateDeviceMotion_(message.deviceMotionEvent);
        };
        FusionPoseSensor.prototype.setScreenTransform_ = function() {
          this.worldToScreenQ.set(0, 0, 0, 1);
          switch (window.orientation) {
            case 0:
              break;
            case 90:
              this.worldToScreenQ.setFromAxisAngle(new Vector32(0, 0, 1), -Math.PI / 2);
              break;
            case -90:
              this.worldToScreenQ.setFromAxisAngle(new Vector32(0, 0, 1), Math.PI / 2);
              break;
            case 180:
              break;
          }
          this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
          this.inverseWorldToScreenQ.inverse();
        };
        FusionPoseSensor.prototype.start = function() {
          this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
          this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
          this.onMessageCallback_ = this.onMessage_.bind(this);
          this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this);
          if (isIOS() && isInsideCrossOriginIFrame()) {
            window.addEventListener("message", this.onMessageCallback_);
          }
          window.addEventListener("orientationchange", this.onOrientationChangeCallback_);
          if (this.isWithoutDeviceMotion) {
            window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_);
          } else {
            window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
          }
        };
        FusionPoseSensor.prototype.stop = function() {
          window.removeEventListener("devicemotion", this.onDeviceMotionCallback_);
          window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_);
          window.removeEventListener("orientationchange", this.onOrientationChangeCallback_);
          window.removeEventListener("message", this.onMessageCallback_);
        };
        var SENSOR_FREQUENCY = 60;
        var X_AXIS = new Vector32(1, 0, 0);
        var Z_AXIS = new Vector32(0, 0, 1);
        var SENSOR_TO_VR = new Quaternion2();
        SENSOR_TO_VR.setFromAxisAngle(X_AXIS, -Math.PI / 2);
        SENSOR_TO_VR.multiply(new Quaternion2().setFromAxisAngle(Z_AXIS, Math.PI / 2));
        var PoseSensor = function() {
          function PoseSensor2(config2) {
            classCallCheck(this, PoseSensor2);
            this.config = config2;
            this.sensor = null;
            this.fusionSensor = null;
            this._out = new Float32Array(4);
            this.api = null;
            this.errors = [];
            this._sensorQ = new Quaternion2();
            this._outQ = new Quaternion2();
            this._onSensorRead = this._onSensorRead.bind(this);
            this._onSensorError = this._onSensorError.bind(this);
            this.init();
          }
          createClass(PoseSensor2, [{
            key: "init",
            value: function init() {
              var sensor = null;
              try {
                sensor = new RelativeOrientationSensor({
                  frequency: SENSOR_FREQUENCY,
                  referenceFrame: "screen"
                });
                sensor.addEventListener("error", this._onSensorError);
              } catch (error) {
                this.errors.push(error);
                if (error.name === "SecurityError") {
                  console.error("Cannot construct sensors due to the Feature Policy");
                  console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.');
                  this.useDeviceMotion();
                } else if (error.name === "ReferenceError") {
                  this.useDeviceMotion();
                } else {
                  console.error(error);
                }
              }
              if (sensor) {
                this.api = "sensor";
                this.sensor = sensor;
                this.sensor.addEventListener("reading", this._onSensorRead);
                this.sensor.start();
              }
            }
          }, {
            key: "useDeviceMotion",
            value: function useDeviceMotion() {
              this.api = "devicemotion";
              this.fusionSensor = new FusionPoseSensor(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG);
              if (this.sensor) {
                this.sensor.removeEventListener("reading", this._onSensorRead);
                this.sensor.removeEventListener("error", this._onSensorError);
                this.sensor = null;
              }
            }
          }, {
            key: "getOrientation",
            value: function getOrientation() {
              if (this.fusionSensor) {
                return this.fusionSensor.getOrientation();
              }
              if (!this.sensor || !this.sensor.quaternion) {
                this._out[0] = this._out[1] = this._out[2] = 0;
                this._out[3] = 1;
                return this._out;
              }
              var q4 = this.sensor.quaternion;
              this._sensorQ.set(q4[0], q4[1], q4[2], q4[3]);
              var out = this._outQ;
              out.copy(SENSOR_TO_VR);
              out.multiply(this._sensorQ);
              if (this.config.YAW_ONLY) {
                out.x = out.z = 0;
                out.normalize();
              }
              this._out[0] = out.x;
              this._out[1] = out.y;
              this._out[2] = out.z;
              this._out[3] = out.w;
              return this._out;
            }
          }, {
            key: "_onSensorError",
            value: function _onSensorError(event) {
              this.errors.push(event.error);
              if (event.error.name === "NotAllowedError") {
                console.error("Permission to access sensor was denied");
              } else if (event.error.name === "NotReadableError") {
                console.error("Sensor could not be read");
              } else {
                console.error(event.error);
              }
              this.useDeviceMotion();
            }
          }, {
            key: "_onSensorRead",
            value: function _onSensorRead() {
            }
          }]);
          return PoseSensor2;
        }();
        var rotateInstructionsAsset = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
        function RotateInstructions() {
          this.loadIcon_();
          var overlay = document.createElement("div");
          var s4 = overlay.style;
          s4.position = "fixed";
          s4.top = 0;
          s4.right = 0;
          s4.bottom = 0;
          s4.left = 0;
          s4.backgroundColor = "gray";
          s4.fontFamily = "sans-serif";
          s4.zIndex = 1e6;
          var img = document.createElement("img");
          img.src = this.icon;
          var s4 = img.style;
          s4.marginLeft = "25%";
          s4.marginTop = "25%";
          s4.width = "50%";
          overlay.appendChild(img);
          var text = document.createElement("div");
          var s4 = text.style;
          s4.textAlign = "center";
          s4.fontSize = "16px";
          s4.lineHeight = "24px";
          s4.margin = "24px 25%";
          s4.width = "50%";
          text.innerHTML = "Place your phone into your Cardboard viewer.";
          overlay.appendChild(text);
          var snackbar = document.createElement("div");
          var s4 = snackbar.style;
          s4.backgroundColor = "#CFD8DC";
          s4.position = "fixed";
          s4.bottom = 0;
          s4.width = "100%";
          s4.height = "48px";
          s4.padding = "14px 24px";
          s4.boxSizing = "border-box";
          s4.color = "#656A6B";
          overlay.appendChild(snackbar);
          var snackbarText = document.createElement("div");
          snackbarText.style.float = "left";
          snackbarText.innerHTML = "No Cardboard viewer?";
          var snackbarButton = document.createElement("a");
          snackbarButton.href = "https://www.google.com/get/cardboard/get-cardboard/";
          snackbarButton.innerHTML = "get one";
          snackbarButton.target = "_blank";
          var s4 = snackbarButton.style;
          s4.float = "right";
          s4.fontWeight = 600;
          s4.textTransform = "uppercase";
          s4.borderLeft = "1px solid gray";
          s4.paddingLeft = "24px";
          s4.textDecoration = "none";
          s4.color = "#656A6B";
          snackbar.appendChild(snackbarText);
          snackbar.appendChild(snackbarButton);
          this.overlay = overlay;
          this.text = text;
          this.hide();
        }
        RotateInstructions.prototype.show = function(parent) {
          if (!parent && !this.overlay.parentElement) {
            document.body.appendChild(this.overlay);
          } else if (parent) {
            if (this.overlay.parentElement && this.overlay.parentElement != parent)
              this.overlay.parentElement.removeChild(this.overlay);
            parent.appendChild(this.overlay);
          }
          this.overlay.style.display = "block";
          var img = this.overlay.querySelector("img");
          var s4 = img.style;
          if (isLandscapeMode()) {
            s4.width = "20%";
            s4.marginLeft = "40%";
            s4.marginTop = "3%";
          } else {
            s4.width = "50%";
            s4.marginLeft = "25%";
            s4.marginTop = "25%";
          }
        };
        RotateInstructions.prototype.hide = function() {
          this.overlay.style.display = "none";
        };
        RotateInstructions.prototype.showTemporarily = function(ms3, parent) {
          this.show(parent);
          this.timer = setTimeout(this.hide.bind(this), ms3);
        };
        RotateInstructions.prototype.disableShowTemporarily = function() {
          clearTimeout(this.timer);
        };
        RotateInstructions.prototype.update = function() {
          this.disableShowTemporarily();
          if (!isLandscapeMode() && isMobile2()) {
            this.show();
          } else {
            this.hide();
          }
        };
        RotateInstructions.prototype.loadIcon_ = function() {
          this.icon = dataUri("image/svg+xml", rotateInstructionsAsset);
        };
        var DEFAULT_VIEWER = "CardboardV1";
        var VIEWER_KEY = "WEBVR_CARDBOARD_VIEWER";
        var CLASS_NAME = "webvr-polyfill-viewer-selector";
        function ViewerSelector(defaultViewer) {
          try {
            this.selectedKey = localStorage.getItem(VIEWER_KEY);
          } catch (error) {
            console.error("Failed to load viewer profile: %s", error);
          }
          if (!this.selectedKey) {
            this.selectedKey = defaultViewer || DEFAULT_VIEWER;
          }
          this.dialog = this.createDialog_(DeviceInfo.Viewers);
          this.root = null;
          this.onChangeCallbacks_ = [];
        }
        ViewerSelector.prototype.show = function(root2) {
          this.root = root2;
          root2.appendChild(this.dialog);
          var selected = this.dialog.querySelector("#" + this.selectedKey);
          selected.checked = true;
          this.dialog.style.display = "block";
        };
        ViewerSelector.prototype.hide = function() {
          if (this.root && this.root.contains(this.dialog)) {
            this.root.removeChild(this.dialog);
          }
          this.dialog.style.display = "none";
        };
        ViewerSelector.prototype.getCurrentViewer = function() {
          return DeviceInfo.Viewers[this.selectedKey];
        };
        ViewerSelector.prototype.getSelectedKey_ = function() {
          var input = this.dialog.querySelector("input[name=field]:checked");
          if (input) {
            return input.id;
          }
          return null;
        };
        ViewerSelector.prototype.onChange = function(cb2) {
          this.onChangeCallbacks_.push(cb2);
        };
        ViewerSelector.prototype.fireOnChange_ = function(viewer) {
          for (var i5 = 0; i5 < this.onChangeCallbacks_.length; i5++) {
            this.onChangeCallbacks_[i5](viewer);
          }
        };
        ViewerSelector.prototype.onSave_ = function() {
          this.selectedKey = this.getSelectedKey_();
          if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
            console.error("ViewerSelector.onSave_: this should never happen!");
            return;
          }
          this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);
          try {
            localStorage.setItem(VIEWER_KEY, this.selectedKey);
          } catch (error) {
            console.error("Failed to save viewer profile: %s", error);
          }
          this.hide();
        };
        ViewerSelector.prototype.createDialog_ = function(options) {
          var container = document.createElement("div");
          container.classList.add(CLASS_NAME);
          container.style.display = "none";
          var overlay = document.createElement("div");
          var s4 = overlay.style;
          s4.position = "fixed";
          s4.left = 0;
          s4.top = 0;
          s4.width = "100%";
          s4.height = "100%";
          s4.background = "rgba(0, 0, 0, 0.3)";
          overlay.addEventListener("click", this.hide.bind(this));
          var width = 280;
          var dialog = document.createElement("div");
          var s4 = dialog.style;
          s4.boxSizing = "border-box";
          s4.position = "fixed";
          s4.top = "24px";
          s4.left = "50%";
          s4.marginLeft = -width / 2 + "px";
          s4.width = width + "px";
          s4.padding = "24px";
          s4.overflow = "hidden";
          s4.background = "#fafafa";
          s4.fontFamily = "'Roboto', sans-serif";
          s4.boxShadow = "0px 5px 20px #666";
          dialog.appendChild(this.createH1_("Select your viewer"));
          for (var id2 in options) {
            dialog.appendChild(this.createChoice_(id2, options[id2].label));
          }
          dialog.appendChild(this.createButton_("Save", this.onSave_.bind(this)));
          container.appendChild(overlay);
          container.appendChild(dialog);
          return container;
        };
        ViewerSelector.prototype.createH1_ = function(name2) {
          var h1 = document.createElement("h1");
          var s4 = h1.style;
          s4.color = "black";
          s4.fontSize = "20px";
          s4.fontWeight = "bold";
          s4.marginTop = 0;
          s4.marginBottom = "24px";
          h1.innerHTML = name2;
          return h1;
        };
        ViewerSelector.prototype.createChoice_ = function(id2, name2) {
          var div = document.createElement("div");
          div.style.marginTop = "8px";
          div.style.color = "black";
          var input = document.createElement("input");
          input.style.fontSize = "30px";
          input.setAttribute("id", id2);
          input.setAttribute("type", "radio");
          input.setAttribute("value", id2);
          input.setAttribute("name", "field");
          var label = document.createElement("label");
          label.style.marginLeft = "4px";
          label.setAttribute("for", id2);
          label.innerHTML = name2;
          div.appendChild(input);
          div.appendChild(label);
          return div;
        };
        ViewerSelector.prototype.createButton_ = function(label, onclick) {
          var button = document.createElement("button");
          button.innerHTML = label;
          var s4 = button.style;
          s4.float = "right";
          s4.textTransform = "uppercase";
          s4.color = "#1094f7";
          s4.fontSize = "14px";
          s4.letterSpacing = 0;
          s4.border = 0;
          s4.background = "none";
          s4.marginTop = "16px";
          button.addEventListener("click", onclick);
          return button;
        };
        var commonjsGlobal2 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
        function unwrapExports(x4) {
          return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, "default") ? x4["default"] : x4;
        }
        function createCommonjsModule2(fn4, module3) {
          return module3 = { exports: {} }, fn4(module3, module3.exports), module3.exports;
        }
        var NoSleep = createCommonjsModule2(function(module3, exports3) {
          (function webpackUniversalModuleDefinition(root2, factory) {
            module3.exports = factory();
          })(commonjsGlobal2, function() {
            return function(modules) {
              var installedModules = {};
              function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) {
                  return installedModules[moduleId].exports;
                }
                var module4 = installedModules[moduleId] = {
                  i: moduleId,
                  l: false,
                  exports: {}
                };
                modules[moduleId].call(module4.exports, module4, module4.exports, __webpack_require__);
                module4.l = true;
                return module4.exports;
              }
              __webpack_require__.m = modules;
              __webpack_require__.c = installedModules;
              __webpack_require__.d = function(exports4, name2, getter) {
                if (!__webpack_require__.o(exports4, name2)) {
                  Object.defineProperty(exports4, name2, {
                    configurable: false,
                    enumerable: true,
                    get: getter
                  });
                }
              };
              __webpack_require__.n = function(module4) {
                var getter = module4 && module4.__esModule ? function getDefault() {
                  return module4["default"];
                } : function getModuleExports() {
                  return module4;
                };
                __webpack_require__.d(getter, "a", getter);
                return getter;
              };
              __webpack_require__.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __webpack_require__.p = "";
              return __webpack_require__(__webpack_require__.s = 0);
            }([
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var _createClass = /* @__PURE__ */ function() {
                  function defineProperties(target, props) {
                    for (var i5 = 0; i5 < props.length; i5++) {
                      var descriptor = props[i5];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor)
                        descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function(Constructor, protoProps, staticProps) {
                    if (protoProps)
                      defineProperties(Constructor.prototype, protoProps);
                    if (staticProps)
                      defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var mediaFile = __webpack_require__(1);
                var oldIOS = typeof navigator !== "undefined" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream;
                var NoSleep2 = function() {
                  function NoSleep3() {
                    _classCallCheck(this, NoSleep3);
                    if (oldIOS) {
                      this.noSleepTimer = null;
                    } else {
                      this.noSleepVideo = document.createElement("video");
                      this.noSleepVideo.setAttribute("playsinline", "");
                      this.noSleepVideo.setAttribute("src", mediaFile);
                      this.noSleepVideo.addEventListener("timeupdate", function(e4) {
                        if (this.noSleepVideo.currentTime > 0.5) {
                          this.noSleepVideo.currentTime = Math.random();
                        }
                      }.bind(this));
                    }
                  }
                  _createClass(NoSleep3, [{
                    key: "enable",
                    value: function enable() {
                      if (oldIOS) {
                        this.disable();
                        this.noSleepTimer = window.setInterval(function() {
                          window.location.href = "/";
                          window.setTimeout(window.stop, 0);
                        }, 15e3);
                      } else {
                        this.noSleepVideo.play();
                      }
                    }
                  }, {
                    key: "disable",
                    value: function disable() {
                      if (oldIOS) {
                        if (this.noSleepTimer) {
                          window.clearInterval(this.noSleepTimer);
                          this.noSleepTimer = null;
                        }
                      } else {
                        this.noSleepVideo.pause();
                      }
                    }
                  }]);
                  return NoSleep3;
                }();
                module4.exports = NoSleep2;
              },
              function(module4, exports4, __webpack_require__) {
                "use strict";
                module4.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
              }
            ]);
          });
        });
        var NoSleep$1 = unwrapExports(NoSleep);
        var nextDisplayId = 1e3;
        var defaultLeftBounds = [0, 0, 0.5, 1];
        var defaultRightBounds = [0.5, 0, 0.5, 1];
        var raf = window.requestAnimationFrame;
        var caf = window.cancelAnimationFrame;
        function VRFrameData() {
          this.leftProjectionMatrix = new Float32Array(16);
          this.leftViewMatrix = new Float32Array(16);
          this.rightProjectionMatrix = new Float32Array(16);
          this.rightViewMatrix = new Float32Array(16);
          this.pose = null;
        }
        function VRDisplayCapabilities(config2) {
          Object.defineProperties(this, {
            hasPosition: {
              writable: false,
              enumerable: true,
              value: config2.hasPosition
            },
            hasExternalDisplay: {
              writable: false,
              enumerable: true,
              value: config2.hasExternalDisplay
            },
            canPresent: {
              writable: false,
              enumerable: true,
              value: config2.canPresent
            },
            maxLayers: {
              writable: false,
              enumerable: true,
              value: config2.maxLayers
            },
            hasOrientation: {
              enumerable: true,
              get: function get() {
                deprecateWarning("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData");
                return config2.hasOrientation;
              }
            }
          });
        }
        function VRDisplay(config2) {
          config2 = config2 || {};
          var USE_WAKELOCK = "wakelock" in config2 ? config2.wakelock : true;
          this.isPolyfilled = true;
          this.displayId = nextDisplayId++;
          this.displayName = "";
          this.depthNear = 0.01;
          this.depthFar = 1e4;
          this.isPresenting = false;
          Object.defineProperty(this, "isConnected", {
            get: function get() {
              deprecateWarning("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay");
              return false;
            }
          });
          this.capabilities = new VRDisplayCapabilities({
            hasPosition: false,
            hasOrientation: false,
            hasExternalDisplay: false,
            canPresent: false,
            maxLayers: 1
          });
          this.stageParameters = null;
          this.waitingForPresent_ = false;
          this.layer_ = null;
          this.originalParent_ = null;
          this.fullscreenElement_ = null;
          this.fullscreenWrapper_ = null;
          this.fullscreenElementCachedStyle_ = null;
          this.fullscreenEventTarget_ = null;
          this.fullscreenChangeHandler_ = null;
          this.fullscreenErrorHandler_ = null;
          if (USE_WAKELOCK && isMobile2()) {
            this.wakelock_ = new NoSleep$1();
          }
        }
        VRDisplay.prototype.getFrameData = function(frameData) {
          return frameDataFromPose(frameData, this._getPose(), this);
        };
        VRDisplay.prototype.getPose = function() {
          deprecateWarning("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData");
          return this._getPose();
        };
        VRDisplay.prototype.resetPose = function() {
          deprecateWarning("VRDisplay.prototype.resetPose");
          return this._resetPose();
        };
        VRDisplay.prototype.getImmediatePose = function() {
          deprecateWarning("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData");
          return this._getPose();
        };
        VRDisplay.prototype.requestAnimationFrame = function(callback) {
          return raf(callback);
        };
        VRDisplay.prototype.cancelAnimationFrame = function(id2) {
          return caf(id2);
        };
        VRDisplay.prototype.wrapForFullscreen = function(element) {
          if (isIOS()) {
            return element;
          }
          if (!this.fullscreenWrapper_) {
            this.fullscreenWrapper_ = document.createElement("div");
            var cssProperties = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
            this.fullscreenWrapper_.setAttribute("style", cssProperties.join("; ") + ";");
            this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
          }
          if (this.fullscreenElement_ == element) {
            return this.fullscreenWrapper_;
          }
          if (this.fullscreenElement_) {
            if (this.originalParent_) {
              this.originalParent_.appendChild(this.fullscreenElement_);
            } else {
              this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_);
            }
          }
          this.fullscreenElement_ = element;
          this.originalParent_ = element.parentElement;
          if (!this.originalParent_) {
            document.body.appendChild(element);
          }
          if (!this.fullscreenWrapper_.parentElement) {
            var parent = this.fullscreenElement_.parentElement;
            parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
            parent.removeChild(this.fullscreenElement_);
          }
          this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
          this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
          var self2 = this;
          function applyFullscreenElementStyle() {
            if (!self2.fullscreenElement_) {
              return;
            }
            var cssProperties2 = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
            self2.fullscreenElement_.setAttribute("style", cssProperties2.join("; ") + ";");
          }
          applyFullscreenElementStyle();
          return this.fullscreenWrapper_;
        };
        VRDisplay.prototype.removeFullscreenWrapper = function() {
          if (!this.fullscreenElement_) {
            return;
          }
          var element = this.fullscreenElement_;
          if (this.fullscreenElementCachedStyle_) {
            element.setAttribute("style", this.fullscreenElementCachedStyle_);
          } else {
            element.removeAttribute("style");
          }
          this.fullscreenElement_ = null;
          this.fullscreenElementCachedStyle_ = null;
          var parent = this.fullscreenWrapper_.parentElement;
          this.fullscreenWrapper_.removeChild(element);
          if (this.originalParent_ === parent) {
            parent.insertBefore(element, this.fullscreenWrapper_);
          } else if (this.originalParent_) {
            this.originalParent_.appendChild(element);
          }
          parent.removeChild(this.fullscreenWrapper_);
          return element;
        };
        VRDisplay.prototype.requestPresent = function(layers) {
          var wasPresenting = this.isPresenting;
          var self2 = this;
          if (!(layers instanceof Array)) {
            deprecateWarning("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument");
            layers = [layers];
          }
          return new Promise(function(resolve, reject) {
            if (!self2.capabilities.canPresent) {
              reject(new Error("VRDisplay is not capable of presenting."));
              return;
            }
            if (layers.length == 0 || layers.length > self2.capabilities.maxLayers) {
              reject(new Error("Invalid number of layers."));
              return;
            }
            var incomingLayer = layers[0];
            if (!incomingLayer.source) {
              resolve();
              return;
            }
            var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
            var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
            if (wasPresenting) {
              var layer = self2.layer_;
              if (layer.source !== incomingLayer.source) {
                layer.source = incomingLayer.source;
              }
              for (var i5 = 0; i5 < 4; i5++) {
                layer.leftBounds[i5] = leftBounds[i5];
                layer.rightBounds[i5] = rightBounds[i5];
              }
              self2.wrapForFullscreen(self2.layer_.source);
              self2.updatePresent_();
              resolve();
              return;
            }
            self2.layer_ = {
              predistorted: incomingLayer.predistorted,
              source: incomingLayer.source,
              leftBounds: leftBounds.slice(0),
              rightBounds: rightBounds.slice(0)
            };
            self2.waitingForPresent_ = false;
            if (self2.layer_ && self2.layer_.source) {
              var fullscreenElement = self2.wrapForFullscreen(self2.layer_.source);
              var onFullscreenChange = function onFullscreenChange2() {
                var actualFullscreenElement = getFullscreenElement();
                self2.isPresenting = fullscreenElement === actualFullscreenElement;
                if (self2.isPresenting) {
                  if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock("landscape-primary").catch(function(error) {
                      console.error("screen.orientation.lock() failed due to", error.message);
                    });
                  }
                  self2.waitingForPresent_ = false;
                  self2.beginPresent_();
                  resolve();
                } else {
                  if (screen.orientation && screen.orientation.unlock) {
                    screen.orientation.unlock();
                  }
                  self2.removeFullscreenWrapper();
                  self2.disableWakeLock();
                  self2.endPresent_();
                  self2.removeFullscreenListeners_();
                }
                self2.fireVRDisplayPresentChange_();
              };
              var onFullscreenError = function onFullscreenError2() {
                if (!self2.waitingForPresent_) {
                  return;
                }
                self2.removeFullscreenWrapper();
                self2.removeFullscreenListeners_();
                self2.disableWakeLock();
                self2.waitingForPresent_ = false;
                self2.isPresenting = false;
                reject(new Error("Unable to present."));
              };
              self2.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError);
              if (requestFullscreen(fullscreenElement)) {
                self2.enableWakeLock();
                self2.waitingForPresent_ = true;
              } else if (isIOS() || isWebViewAndroid()) {
                self2.enableWakeLock();
                self2.isPresenting = true;
                self2.beginPresent_();
                self2.fireVRDisplayPresentChange_();
                resolve();
              }
            }
            if (!self2.waitingForPresent_ && !isIOS()) {
              exitFullscreen();
              reject(new Error("Unable to present."));
            }
          });
        };
        VRDisplay.prototype.exitPresent = function() {
          var wasPresenting = this.isPresenting;
          var self2 = this;
          this.isPresenting = false;
          this.layer_ = null;
          this.disableWakeLock();
          return new Promise(function(resolve, reject) {
            if (wasPresenting) {
              if (!exitFullscreen() && isIOS()) {
                self2.endPresent_();
                self2.fireVRDisplayPresentChange_();
              }
              if (isWebViewAndroid()) {
                self2.removeFullscreenWrapper();
                self2.removeFullscreenListeners_();
                self2.endPresent_();
                self2.fireVRDisplayPresentChange_();
              }
              resolve();
            } else {
              reject(new Error("Was not presenting to VRDisplay."));
            }
          });
        };
        VRDisplay.prototype.getLayers = function() {
          if (this.layer_) {
            return [this.layer_];
          }
          return [];
        };
        VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
          var event = new CustomEvent("vrdisplaypresentchange", { detail: { display: this } });
          window.dispatchEvent(event);
        };
        VRDisplay.prototype.fireVRDisplayConnect_ = function() {
          var event = new CustomEvent("vrdisplayconnect", { detail: { display: this } });
          window.dispatchEvent(event);
        };
        VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
          this.removeFullscreenListeners_();
          this.fullscreenEventTarget_ = element;
          this.fullscreenChangeHandler_ = changeHandler;
          this.fullscreenErrorHandler_ = errorHandler;
          if (changeHandler) {
            if (document.fullscreenEnabled) {
              element.addEventListener("fullscreenchange", changeHandler, false);
            } else if (document.webkitFullscreenEnabled) {
              element.addEventListener("webkitfullscreenchange", changeHandler, false);
            } else if (document.mozFullScreenEnabled) {
              document.addEventListener("mozfullscreenchange", changeHandler, false);
            } else if (document.msFullscreenEnabled) {
              element.addEventListener("msfullscreenchange", changeHandler, false);
            }
          }
          if (errorHandler) {
            if (document.fullscreenEnabled) {
              element.addEventListener("fullscreenerror", errorHandler, false);
            } else if (document.webkitFullscreenEnabled) {
              element.addEventListener("webkitfullscreenerror", errorHandler, false);
            } else if (document.mozFullScreenEnabled) {
              document.addEventListener("mozfullscreenerror", errorHandler, false);
            } else if (document.msFullscreenEnabled) {
              element.addEventListener("msfullscreenerror", errorHandler, false);
            }
          }
        };
        VRDisplay.prototype.removeFullscreenListeners_ = function() {
          if (!this.fullscreenEventTarget_)
            return;
          var element = this.fullscreenEventTarget_;
          if (this.fullscreenChangeHandler_) {
            var changeHandler = this.fullscreenChangeHandler_;
            element.removeEventListener("fullscreenchange", changeHandler, false);
            element.removeEventListener("webkitfullscreenchange", changeHandler, false);
            document.removeEventListener("mozfullscreenchange", changeHandler, false);
            element.removeEventListener("msfullscreenchange", changeHandler, false);
          }
          if (this.fullscreenErrorHandler_) {
            var errorHandler = this.fullscreenErrorHandler_;
            element.removeEventListener("fullscreenerror", errorHandler, false);
            element.removeEventListener("webkitfullscreenerror", errorHandler, false);
            document.removeEventListener("mozfullscreenerror", errorHandler, false);
            element.removeEventListener("msfullscreenerror", errorHandler, false);
          }
          this.fullscreenEventTarget_ = null;
          this.fullscreenChangeHandler_ = null;
          this.fullscreenErrorHandler_ = null;
        };
        VRDisplay.prototype.enableWakeLock = function() {
          if (this.wakelock_) {
            this.wakelock_.enable();
          }
        };
        VRDisplay.prototype.disableWakeLock = function() {
          if (this.wakelock_) {
            this.wakelock_.disable();
          }
        };
        VRDisplay.prototype.beginPresent_ = function() {
        };
        VRDisplay.prototype.endPresent_ = function() {
        };
        VRDisplay.prototype.submitFrame = function(pose) {
        };
        VRDisplay.prototype.getEyeParameters = function(whichEye) {
          return null;
        };
        var config = {
          ADDITIONAL_VIEWERS: [],
          DEFAULT_VIEWER: "",
          MOBILE_WAKE_LOCK: true,
          DEBUG: false,
          DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
          K_FILTER: 0.98,
          PREDICTION_TIME_S: 0.04,
          CARDBOARD_UI_DISABLED: false,
          ROTATE_INSTRUCTIONS_DISABLED: false,
          YAW_ONLY: false,
          BUFFER_SCALE: 0.5,
          DIRTY_SUBMIT_FRAME_BINDINGS: false
        };
        var Eye = {
          LEFT: "left",
          RIGHT: "right"
        };
        function CardboardVRDisplay2(config$$1) {
          var defaults2 = extend2({}, config);
          config$$1 = extend2(defaults2, config$$1 || {});
          VRDisplay.call(this, {
            wakelock: config$$1.MOBILE_WAKE_LOCK
          });
          this.config = config$$1;
          this.displayName = "Cardboard VRDisplay";
          this.capabilities = new VRDisplayCapabilities({
            hasPosition: false,
            hasOrientation: true,
            hasExternalDisplay: false,
            canPresent: true,
            maxLayers: 1
          });
          this.stageParameters = null;
          this.bufferScale_ = this.config.BUFFER_SCALE;
          this.poseSensor_ = new PoseSensor(this.config);
          this.distorter_ = null;
          this.cardboardUI_ = null;
          this.dpdb_ = new Dpdb(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this));
          this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams(), config$$1.ADDITIONAL_VIEWERS);
          this.viewerSelector_ = new ViewerSelector(config$$1.DEFAULT_VIEWER);
          this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));
          this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
          if (!this.config.ROTATE_INSTRUCTIONS_DISABLED) {
            this.rotateInstructions_ = new RotateInstructions();
          }
          if (isIOS()) {
            window.addEventListener("resize", this.onResize_.bind(this));
          }
        }
        CardboardVRDisplay2.prototype = Object.create(VRDisplay.prototype);
        CardboardVRDisplay2.prototype._getPose = function() {
          return {
            position: null,
            orientation: this.poseSensor_.getOrientation(),
            linearVelocity: null,
            linearAcceleration: null,
            angularVelocity: null,
            angularAcceleration: null
          };
        };
        CardboardVRDisplay2.prototype._resetPose = function() {
          if (this.poseSensor_.resetPose) {
            this.poseSensor_.resetPose();
          }
        };
        CardboardVRDisplay2.prototype._getFieldOfView = function(whichEye) {
          var fieldOfView;
          if (whichEye == Eye.LEFT) {
            fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
          } else if (whichEye == Eye.RIGHT) {
            fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
          } else {
            console.error("Invalid eye provided: %s", whichEye);
            return null;
          }
          return fieldOfView;
        };
        CardboardVRDisplay2.prototype._getEyeOffset = function(whichEye) {
          var offset;
          if (whichEye == Eye.LEFT) {
            offset = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
          } else if (whichEye == Eye.RIGHT) {
            offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
          } else {
            console.error("Invalid eye provided: %s", whichEye);
            return null;
          }
          return offset;
        };
        CardboardVRDisplay2.prototype.getEyeParameters = function(whichEye) {
          var offset = this._getEyeOffset(whichEye);
          var fieldOfView = this._getFieldOfView(whichEye);
          var eyeParams = {
            offset,
            renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
            renderHeight: this.deviceInfo_.device.height * this.bufferScale_
          };
          Object.defineProperty(eyeParams, "fieldOfView", {
            enumerable: true,
            get: function get() {
              deprecateWarning("VRFieldOfView", "VRFrameData's projection matrices");
              return fieldOfView;
            }
          });
          return eyeParams;
        };
        CardboardVRDisplay2.prototype.onDeviceParamsUpdated_ = function(newParams) {
          if (this.config.DEBUG) {
            console.log("DPDB reported that device params were updated.");
          }
          this.deviceInfo_.updateDeviceParams(newParams);
          if (this.distorter_) {
            this.distorter_.updateDeviceInfo(this.deviceInfo_);
          }
        };
        CardboardVRDisplay2.prototype.updateBounds_ = function() {
          if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
            this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
          }
        };
        CardboardVRDisplay2.prototype.beginPresent_ = function() {
          var gl3 = this.layer_.source.getContext("webgl");
          if (!gl3)
            gl3 = this.layer_.source.getContext("experimental-webgl");
          if (!gl3)
            gl3 = this.layer_.source.getContext("webgl2");
          if (!gl3)
            return;
          if (this.layer_.predistorted) {
            if (!this.config.CARDBOARD_UI_DISABLED) {
              gl3.canvas.width = getScreenWidth() * this.bufferScale_;
              gl3.canvas.height = getScreenHeight() * this.bufferScale_;
              this.cardboardUI_ = new CardboardUI(gl3);
            }
          } else {
            if (!this.config.CARDBOARD_UI_DISABLED) {
              this.cardboardUI_ = new CardboardUI(gl3);
            }
            this.distorter_ = new CardboardDistorter(gl3, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS);
            this.distorter_.updateDeviceInfo(this.deviceInfo_);
          }
          if (this.cardboardUI_) {
            this.cardboardUI_.listen(function(e4) {
              this.viewerSelector_.show(this.layer_.source.parentElement);
              e4.stopPropagation();
              e4.preventDefault();
            }.bind(this), function(e4) {
              this.exitPresent();
              e4.stopPropagation();
              e4.preventDefault();
            }.bind(this));
          }
          if (this.rotateInstructions_) {
            if (isLandscapeMode() && isMobile2()) {
              this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement);
            } else {
              this.rotateInstructions_.update();
            }
          }
          this.orientationHandler = this.onOrientationChange_.bind(this);
          window.addEventListener("orientationchange", this.orientationHandler);
          this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
          window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
          this.fireVRDisplayDeviceParamsChange_();
        };
        CardboardVRDisplay2.prototype.endPresent_ = function() {
          if (this.distorter_) {
            this.distorter_.destroy();
            this.distorter_ = null;
          }
          if (this.cardboardUI_) {
            this.cardboardUI_.destroy();
            this.cardboardUI_ = null;
          }
          if (this.rotateInstructions_) {
            this.rotateInstructions_.hide();
          }
          this.viewerSelector_.hide();
          window.removeEventListener("orientationchange", this.orientationHandler);
          window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
        };
        CardboardVRDisplay2.prototype.updatePresent_ = function() {
          this.endPresent_();
          this.beginPresent_();
        };
        CardboardVRDisplay2.prototype.submitFrame = function(pose) {
          if (this.distorter_) {
            this.updateBounds_();
            this.distorter_.submitFrame();
          } else if (this.cardboardUI_ && this.layer_) {
            var gl3 = this.layer_.source.getContext("webgl");
            if (!gl3)
              gl3 = this.layer_.source.getContext("experimental-webgl");
            if (!gl3)
              gl3 = this.layer_.source.getContext("webgl2");
            var canvas = gl3.canvas;
            if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
              this.cardboardUI_.onResize();
            }
            this.lastWidth = canvas.width;
            this.lastHeight = canvas.height;
            this.cardboardUI_.render();
          }
        };
        CardboardVRDisplay2.prototype.onOrientationChange_ = function(e4) {
          this.viewerSelector_.hide();
          if (this.rotateInstructions_) {
            this.rotateInstructions_.update();
          }
          this.onResize_();
        };
        CardboardVRDisplay2.prototype.onResize_ = function(e4) {
          if (this.layer_) {
            var gl3 = this.layer_.source.getContext("webgl");
            if (!gl3)
              gl3 = this.layer_.source.getContext("experimental-webgl");
            if (!gl3)
              gl3 = this.layer_.source.getContext("webgl2");
            var cssProperties = [
              "position: absolute",
              "top: 0",
              "left: 0",
              "width: 100vw",
              "height: 100vh",
              "border: 0",
              "margin: 0",
              "padding: 0px",
              "box-sizing: content-box"
            ];
            gl3.canvas.setAttribute("style", cssProperties.join("; ") + ";");
            safariCssSizeWorkaround(gl3.canvas);
          }
        };
        CardboardVRDisplay2.prototype.onViewerChanged_ = function(viewer) {
          this.deviceInfo_.setViewer(viewer);
          if (this.distorter_) {
            this.distorter_.updateDeviceInfo(this.deviceInfo_);
          }
          this.fireVRDisplayDeviceParamsChange_();
        };
        CardboardVRDisplay2.prototype.fireVRDisplayDeviceParamsChange_ = function() {
          var event = new CustomEvent("vrdisplaydeviceparamschange", {
            detail: {
              vrdisplay: this,
              deviceInfo: this.deviceInfo_
            }
          });
          window.dispatchEvent(event);
        };
        CardboardVRDisplay2.VRFrameData = VRFrameData;
        CardboardVRDisplay2.VRDisplay = VRDisplay;
        return CardboardVRDisplay2;
      });
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices/XRDevice.js
  var XRDevice;
  var init_XRDevice = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices/XRDevice.js"() {
      init_EventTarget();
      init_XRReferenceSpace();
      XRDevice = class extends EventTarget2 {
        /**
         * Takes a VRDisplay object from the WebVR 1.1 spec.
         *
         * @param {Object} global
         */
        constructor(global2) {
          super();
          this.global = global2;
          this.onWindowResize = this.onWindowResize.bind(this);
          this.global.window.addEventListener("resize", this.onWindowResize);
          this.environmentBlendMode = "opaque";
        }
        /**
         * Called when a XRSession has a `baseLayer` property set.
         *
         * @param {number} sessionId
         * @param {XRWebGLLayer} layer
         */
        onBaseLayerSet(sessionId, layer) {
          throw new Error("Not implemented");
        }
        /**
         * @param {XRSessionMode} mode
         * @return {boolean}
         */
        isSessionSupported(mode) {
          throw new Error("Not implemented");
        }
        /**
         * @param {string} featureDescriptor
         * @return {boolean}
         */
        isFeatureSupported(featureDescriptor) {
          throw new Error("Not implemented");
        }
        /**
         * Returns a promise if creating a session is successful.
         * Usually used to set up presentation in the device.
         *
         * @param {XRSessionMode} mode
         * @param {Set<string>} enabledFeatures
         * @return {Promise<number>}
         */
        async requestSession(mode, enabledFeatures) {
          throw new Error("Not implemented");
        }
        /**
         * @return {Function}
         */
        requestAnimationFrame(callback) {
          throw new Error("Not implemented");
        }
        /**
         * @param {number} sessionId
         */
        onFrameStart(sessionId) {
          throw new Error("Not implemented");
        }
        /**
         * @param {number} sessionId
         */
        onFrameEnd(sessionId) {
          throw new Error("Not implemented");
        }
        /**
         * @param {number} sessionId
         * @param {XRReferenceSpaceType} type
         * @return {boolean}
         */
        doesSessionSupportReferenceSpace(sessionId, type) {
          throw new Error("Not implemented");
        }
        /**
         * @return {Object?}
         */
        requestStageBounds() {
          throw new Error("Not implemented");
        }
        /**
         * Returns a promise resolving to a transform if XRDevice
         * can support frame of reference and provides its own values.
         * Can resolve to `undefined` if the polyfilled API can provide
         * a default. Rejects if this XRDevice cannot
         * support the frame of reference.
         *
         * @param {XRFrameOfReferenceType} type
         * @param {XRFrameOfReferenceOptions} options
         * @return {Promise<XRFrameOfReference>}
         */
        async requestFrameOfReferenceTransform(type, options) {
          return void 0;
        }
        /**
         * @param {number} handle
         */
        cancelAnimationFrame(handle) {
          throw new Error("Not implemented");
        }
        /**
         * @param {number} sessionId
         */
        endSession(sessionId) {
          throw new Error("Not implemented");
        }
        /**
         * Allows the XRDevice to override the XRSession's view spaces.
         *
         * @param {XRSessionMode} mode
         * @return {Array<XRSpace> | undefined}
         */
        getViewSpaces(mode) {
          return void 0;
        }
        /**
         * Takes a XREye and a target to apply properties of
         * `x`, `y`, `width` and `height` on. Returns a boolean
         * indicating if it successfully was able to populate
         * target's values.
         *
         * @param {number} sessionId
         * @param {XREye} eye
         * @param {XRWebGLLayer} layer
         * @param {Object?} target
         * @param {number} viewIndex
         * @return {boolean}
         */
        getViewport(sessionId, eye, layer, target, viewIndex) {
          throw new Error("Not implemented");
        }
        /**
         * @param {XREye} eye
         * @param {number} viewIndex
         * @return {Float32Array}
         */
        getProjectionMatrix(eye, viewIndex) {
          throw new Error("Not implemented");
        }
        /**
         * Get model matrix unaffected by frame of reference.
         *
         * @return {Float32Array}
         */
        getBasePoseMatrix() {
          throw new Error("Not implemented");
        }
        /**
         * Get view matrix unaffected by frame of reference.
         *
         * @param {XREye} eye
         * @return {Float32Array}
         */
        getBaseViewMatrix(eye) {
          throw new Error("Not implemented");
        }
        /**
         * Get a list of input sources.
         *
         * @return {Array<XRInputSource>}
         */
        getInputSources() {
          throw new Error("Not implemented");
        }
        /**
         * Get the current pose of an input source.
         *
         * @param {XRInputSource} inputSource
         * @param {XRCoordinateSystem} coordinateSystem
         * @param {String} poseType
         * @return {XRPose}
         */
        getInputPose(inputSource, coordinateSystem, poseType) {
          throw new Error("Not implemented");
        }
        /**
         * Called on window resize.
         */
        onWindowResize() {
          this.onWindowResize();
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadMappings.js
  var daydream, viveFocus, oculusGo, oculusTouch, openVr, samsungGearVR, samsungOdyssey, windowsMixedReality, GamepadMappings, GamepadMappings_default;
  var init_GamepadMappings = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadMappings.js"() {
      daydream = {
        mapping: "",
        profiles: ["google-daydream", "generic-trigger-touchpad"],
        buttons: {
          length: 3,
          0: null,
          1: null,
          2: 0
        }
      };
      viveFocus = {
        mapping: "xr-standard",
        profiles: ["htc-vive-focus", "generic-trigger-touchpad"],
        buttons: {
          length: 3,
          0: 1,
          1: null,
          2: 0
        }
      };
      oculusGo = {
        mapping: "xr-standard",
        profiles: ["oculus-go", "generic-trigger-touchpad"],
        buttons: {
          length: 3,
          0: 1,
          1: null,
          2: 0
        },
        // Grip adjustments determined experimentally.
        gripTransform: {
          orientation: [Math.PI * 0.11, 0, 0, 1]
        }
      };
      oculusTouch = {
        mapping: "xr-standard",
        displayProfiles: {
          "Oculus Quest": ["oculus-touch-v2", "oculus-touch", "generic-trigger-squeeze-thumbstick"]
        },
        profiles: ["oculus-touch", "generic-trigger-squeeze-thumbstick"],
        axes: {
          length: 4,
          0: null,
          1: null,
          2: 0,
          3: 1
        },
        buttons: {
          length: 7,
          0: 1,
          1: 2,
          2: null,
          3: 0,
          4: 3,
          5: 4,
          6: null
        },
        // Grip adjustments determined experimentally.
        gripTransform: {
          position: [0, -0.02, 0.04, 1],
          orientation: [Math.PI * 0.11, 0, 0, 1]
        }
      };
      openVr = {
        mapping: "xr-standard",
        profiles: ["htc-vive", "generic-trigger-squeeze-touchpad"],
        displayProfiles: {
          "HTC Vive": ["htc-vive", "generic-trigger-squeeze-touchpad"],
          "HTC Vive DVT": ["htc-vive", "generic-trigger-squeeze-touchpad"],
          "Valve Index": ["valve-index", "generic-trigger-squeeze-touchpad-thumbstick"]
        },
        buttons: {
          length: 3,
          0: 1,
          1: 2,
          2: 0
        },
        // Transform adjustments determined experimentally.
        gripTransform: {
          position: [0, 0, 0.05, 1]
        },
        targetRayTransform: {
          orientation: [Math.PI * -0.08, 0, 0, 1]
        },
        userAgentOverrides: {
          "Firefox": {
            axes: {
              invert: [1, 3]
            }
          }
        }
      };
      samsungGearVR = {
        mapping: "xr-standard",
        profiles: ["samsung-gearvr", "generic-trigger-touchpad"],
        buttons: {
          length: 3,
          0: 1,
          1: null,
          2: 0
        },
        gripTransform: {
          orientation: [Math.PI * 0.11, 0, 0, 1]
        }
      };
      samsungOdyssey = {
        mapping: "xr-standard",
        profiles: ["samsung-odyssey", "microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
        buttons: {
          length: 4,
          0: 1,
          // index finger trigger
          1: 0,
          // pressable joystick
          2: 2,
          // grip trigger
          3: 4
          // pressable touchpad
        },
        // Grip adjustments determined experimentally.
        gripTransform: {
          position: [0, -0.02, 0.04, 1],
          orientation: [Math.PI * 0.11, 0, 0, 1]
        }
      };
      windowsMixedReality = {
        mapping: "xr-standard",
        profiles: ["microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
        buttons: {
          length: 4,
          0: 1,
          // index finger trigger
          1: 0,
          // pressable joystick
          2: 2,
          // grip trigger
          3: 4
          // pressable touchpad
        },
        // Grip adjustments determined experimentally.
        gripTransform: {
          position: [0, -0.02, 0.04, 1],
          orientation: [Math.PI * 0.11, 0, 0, 1]
        }
      };
      GamepadMappings = {
        "Daydream Controller": daydream,
        "Gear VR Controller": samsungGearVR,
        "HTC Vive Focus Controller": viveFocus,
        "Oculus Go Controller": oculusGo,
        "Oculus Touch (Right)": oculusTouch,
        "Oculus Touch (Left)": oculusTouch,
        "OpenVR Gamepad": openVr,
        "Spatial Controller (Spatial Interaction Source) 045E-065A": windowsMixedReality,
        "Spatial Controller (Spatial Interaction Source) 045E-065D": samsungOdyssey,
        "Windows Mixed Reality (Right)": windowsMixedReality,
        "Windows Mixed Reality (Left)": windowsMixedReality
      };
      GamepadMappings_default = GamepadMappings;
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/lib/OrientationArmModel.js
  function eulerFromQuaternion(out, q4, order) {
    function clamp2(value, min, max2) {
      return value < min ? min : value > max2 ? max2 : value;
    }
    var sqx = q4[0] * q4[0];
    var sqy = q4[1] * q4[1];
    var sqz = q4[2] * q4[2];
    var sqw = q4[3] * q4[3];
    if (order === "XYZ") {
      out[0] = Math.atan2(2 * (q4[0] * q4[3] - q4[1] * q4[2]), sqw - sqx - sqy + sqz);
      out[1] = Math.asin(clamp2(2 * (q4[0] * q4[2] + q4[1] * q4[3]), -1, 1));
      out[2] = Math.atan2(2 * (q4[2] * q4[3] - q4[0] * q4[1]), sqw + sqx - sqy - sqz);
    } else if (order === "YXZ") {
      out[0] = Math.asin(clamp2(2 * (q4[0] * q4[3] - q4[1] * q4[2]), -1, 1));
      out[1] = Math.atan2(2 * (q4[0] * q4[2] + q4[1] * q4[3]), sqw - sqx - sqy + sqz);
      out[2] = Math.atan2(2 * (q4[0] * q4[1] + q4[2] * q4[3]), sqw - sqx + sqy - sqz);
    } else if (order === "ZXY") {
      out[0] = Math.asin(clamp2(2 * (q4[0] * q4[3] + q4[1] * q4[2]), -1, 1));
      out[1] = Math.atan2(2 * (q4[1] * q4[3] - q4[2] * q4[0]), sqw - sqx - sqy + sqz);
      out[2] = Math.atan2(2 * (q4[2] * q4[3] - q4[0] * q4[1]), sqw - sqx + sqy - sqz);
    } else if (order === "ZYX") {
      out[0] = Math.atan2(2 * (q4[0] * q4[3] + q4[2] * q4[1]), sqw - sqx - sqy + sqz);
      out[1] = Math.asin(clamp2(2 * (q4[1] * q4[3] - q4[0] * q4[2]), -1, 1));
      out[2] = Math.atan2(2 * (q4[0] * q4[1] + q4[2] * q4[3]), sqw + sqx - sqy - sqz);
    } else if (order === "YZX") {
      out[0] = Math.atan2(2 * (q4[0] * q4[3] - q4[2] * q4[1]), sqw - sqx + sqy - sqz);
      out[1] = Math.atan2(2 * (q4[1] * q4[3] - q4[0] * q4[2]), sqw + sqx - sqy - sqz);
      out[2] = Math.asin(clamp2(2 * (q4[0] * q4[1] + q4[2] * q4[3]), -1, 1));
    } else if (order === "XZY") {
      out[0] = Math.atan2(2 * (q4[0] * q4[3] + q4[1] * q4[2]), sqw - sqx + sqy - sqz);
      out[1] = Math.atan2(2 * (q4[0] * q4[2] + q4[1] * q4[3]), sqw + sqx - sqy - sqz);
      out[2] = Math.asin(clamp2(2 * (q4[2] * q4[3] - q4[0] * q4[1]), -1, 1));
    } else {
      console.log("No order given for quaternion to euler conversion.");
      return;
    }
  }
  var HEAD_ELBOW_OFFSET_RIGHTHANDED, HEAD_ELBOW_OFFSET_LEFTHANDED, ELBOW_WRIST_OFFSET, WRIST_CONTROLLER_OFFSET, ARM_EXTENSION_OFFSET, ELBOW_BEND_RATIO, EXTENSION_RATIO_WEIGHT, MIN_ANGULAR_SPEED, MIN_ANGLE_DELTA, MIN_EXTENSION_COS, MAX_EXTENSION_COS, RAD_TO_DEG, OrientationArmModel;
  var init_OrientationArmModel = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/lib/OrientationArmModel.js"() {
      init_now();
      init_mat4();
      init_vec3();
      init_quat();
      HEAD_ELBOW_OFFSET_RIGHTHANDED = fromValues(0.155, -0.465, -0.15);
      HEAD_ELBOW_OFFSET_LEFTHANDED = fromValues(-0.155, -0.465, -0.15);
      ELBOW_WRIST_OFFSET = fromValues(0, 0, -0.25);
      WRIST_CONTROLLER_OFFSET = fromValues(0, 0, 0.05);
      ARM_EXTENSION_OFFSET = fromValues(-0.08, 0.14, 0.08);
      ELBOW_BEND_RATIO = 0.4;
      EXTENSION_RATIO_WEIGHT = 0.4;
      MIN_ANGULAR_SPEED = 0.61;
      MIN_ANGLE_DELTA = 0.175;
      MIN_EXTENSION_COS = 0.12;
      MAX_EXTENSION_COS = 0.87;
      RAD_TO_DEG = 180 / Math.PI;
      OrientationArmModel = class {
        constructor() {
          this.hand = "right";
          this.headElbowOffset = HEAD_ELBOW_OFFSET_RIGHTHANDED;
          this.controllerQ = create5();
          this.lastControllerQ = create5();
          this.headQ = create5();
          this.headPos = create2();
          this.elbowPos = create2();
          this.wristPos = create2();
          this.time = null;
          this.lastTime = null;
          this.rootQ = create5();
          this.position = create2();
        }
        setHandedness(hand) {
          if (this.hand != hand) {
            this.hand = hand;
            if (this.hand == "left") {
              this.headElbowOffset = HEAD_ELBOW_OFFSET_LEFTHANDED;
            } else {
              this.headElbowOffset = HEAD_ELBOW_OFFSET_RIGHTHANDED;
            }
          }
        }
        /**
         * Called on a RAF.
         */
        update(controllerOrientation, headPoseMatrix) {
          this.time = now_default();
          if (controllerOrientation) {
            copy4(this.lastControllerQ, this.controllerQ);
            copy4(this.controllerQ, controllerOrientation);
          }
          if (headPoseMatrix) {
            getTranslation(this.headPos, headPoseMatrix);
            getRotation(this.headQ, headPoseMatrix);
          }
          let headYawQ = this.getHeadYawOrientation_();
          let angleDelta = this.quatAngle_(this.lastControllerQ, this.controllerQ);
          let timeDelta = (this.time - this.lastTime) / 1e3;
          let controllerAngularSpeed = angleDelta / timeDelta;
          if (controllerAngularSpeed > MIN_ANGULAR_SPEED) {
            slerp(
              this.rootQ,
              this.rootQ,
              headYawQ,
              Math.min(angleDelta / MIN_ANGLE_DELTA, 1)
            );
          } else {
            copy4(this.rootQ, headYawQ);
          }
          let controllerForward = fromValues(0, 0, -1);
          transformQuat(controllerForward, controllerForward, this.controllerQ);
          let controllerDotY = dot(controllerForward, [0, 1, 0]);
          let extensionRatio = this.clamp_(
            (controllerDotY - MIN_EXTENSION_COS) / MAX_EXTENSION_COS,
            0,
            1
          );
          let controllerCameraQ = clone3(this.rootQ);
          invert2(controllerCameraQ, controllerCameraQ);
          multiply2(controllerCameraQ, controllerCameraQ, this.controllerQ);
          let elbowPos = this.elbowPos;
          copy2(elbowPos, this.headPos);
          add(elbowPos, elbowPos, this.headElbowOffset);
          let elbowOffset = clone(ARM_EXTENSION_OFFSET);
          scale(elbowOffset, elbowOffset, extensionRatio);
          add(elbowPos, elbowPos, elbowOffset);
          let totalAngle = this.quatAngle_(controllerCameraQ, create5());
          let totalAngleDeg = totalAngle * RAD_TO_DEG;
          let lerpSuppression = 1 - Math.pow(totalAngleDeg / 180, 4);
          sssss;
          let elbowRatio = ELBOW_BEND_RATIO;
          let wristRatio = 1 - ELBOW_BEND_RATIO;
          let lerpValue = lerpSuppression * (elbowRatio + wristRatio * extensionRatio * EXTENSION_RATIO_WEIGHT);
          let wristQ = create5();
          slerp(wristQ, wristQ, controllerCameraQ, lerpValue);
          let invWristQ = invert2(create5(), wristQ);
          let elbowQ = clone3(controllerCameraQ);
          multiply2(elbowQ, elbowQ, invWristQ);
          let wristPos = this.wristPos;
          copy2(wristPos, WRIST_CONTROLLER_OFFSET);
          transformQuat(wristPos, wristPos, wristQ);
          add(wristPos, wristPos, ELBOW_WRIST_OFFSET);
          transformQuat(wristPos, wristPos, elbowQ);
          add(wristPos, wristPos, elbowPos);
          let offset = clone(ARM_EXTENSION_OFFSET);
          scale(offset, offset, extensionRatio);
          add(this.position, this.wristPos, offset);
          transformQuat(this.position, this.position, this.rootQ);
          this.lastTime = this.time;
        }
        /**
         * Returns the position calculated by the model.
         */
        getPosition() {
          return this.position;
        }
        getHeadYawOrientation_() {
          let headEuler = create2();
          eulerFromQuaternion(headEuler, this.headQ, "YXZ");
          let destinationQ = fromEuler(create5(), 0, headEuler[1] * RAD_TO_DEG, 0);
          return destinationQ;
        }
        clamp_(value, min, max2) {
          return Math.min(Math.max(value, min), max2);
        }
        quatAngle_(q1, q22) {
          let vec1 = [0, 0, -1];
          let vec2 = [0, 0, -1];
          transformQuat(vec1, vec1, q1);
          transformQuat(vec2, vec2, q22);
          return angle(vec1, vec2);
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadXRInputSource.js
  var PRIVATE19, PLACEHOLDER_BUTTON, XRRemappedGamepad, GamepadXRInputSource;
  var init_GamepadXRInputSource = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadXRInputSource.js"() {
      init_GamepadMappings();
      init_XRInputSource();
      init_OrientationArmModel();
      init_mat4();
      init_vec3();
      init_quat();
      PRIVATE19 = Symbol("@@webxr-polyfill/XRRemappedGamepad");
      PLACEHOLDER_BUTTON = { pressed: false, touched: false, value: 0 };
      Object.freeze(PLACEHOLDER_BUTTON);
      XRRemappedGamepad = class {
        constructor(gamepad, display, map) {
          if (!map) {
            map = {};
          }
          if (map.userAgentOverrides) {
            for (let agent in map.userAgentOverrides) {
              if (navigator.userAgent.includes(agent)) {
                let override = map.userAgentOverrides[agent];
                for (let key in override) {
                  if (key in map) {
                    Object.assign(map[key], override[key]);
                  } else {
                    map[key] = override[key];
                  }
                }
                break;
              }
            }
          }
          let axes = new Array(map.axes && map.axes.length ? map.axes.length : gamepad.axes.length);
          let buttons = new Array(map.buttons && map.buttons.length ? map.buttons.length : gamepad.buttons.length);
          let gripTransform = null;
          if (map.gripTransform) {
            let orientation = map.gripTransform.orientation || [0, 0, 0, 1];
            gripTransform = create();
            fromRotationTranslation(
              gripTransform,
              normalize4(orientation, orientation),
              map.gripTransform.position || [0, 0, 0]
            );
          }
          let targetRayTransform = null;
          if (map.targetRayTransform) {
            let orientation = map.targetRayTransform.orientation || [0, 0, 0, 1];
            targetRayTransform = create();
            fromRotationTranslation(
              targetRayTransform,
              normalize4(orientation, orientation),
              map.targetRayTransform.position || [0, 0, 0]
            );
          }
          let profiles = map.profiles;
          if (map.displayProfiles) {
            if (display.displayName in map.displayProfiles) {
              profiles = map.displayProfiles[display.displayName];
            }
          }
          this[PRIVATE19] = {
            gamepad,
            map,
            profiles: profiles || [gamepad.id],
            mapping: map.mapping || gamepad.mapping,
            axes,
            buttons,
            gripTransform,
            targetRayTransform
          };
          this._update();
        }
        _update() {
          let gamepad = this[PRIVATE19].gamepad;
          let map = this[PRIVATE19].map;
          let axes = this[PRIVATE19].axes;
          for (let i5 = 0; i5 < axes.length; ++i5) {
            if (map.axes && i5 in map.axes) {
              if (map.axes[i5] === null) {
                axes[i5] = 0;
              } else {
                axes[i5] = gamepad.axes[map.axes[i5]];
              }
            } else {
              axes[i5] = gamepad.axes[i5];
            }
          }
          if (map.axes && map.axes.invert) {
            for (let axis of map.axes.invert) {
              if (axis < axes.length) {
                axes[axis] *= -1;
              }
            }
          }
          let buttons = this[PRIVATE19].buttons;
          for (let i5 = 0; i5 < buttons.length; ++i5) {
            if (map.buttons && i5 in map.buttons) {
              if (map.buttons[i5] === null) {
                buttons[i5] = PLACEHOLDER_BUTTON;
              } else {
                buttons[i5] = gamepad.buttons[map.buttons[i5]];
              }
            } else {
              buttons[i5] = gamepad.buttons[i5];
            }
          }
        }
        get id() {
          return "";
        }
        get _profiles() {
          return this[PRIVATE19].profiles;
        }
        get index() {
          return -1;
        }
        get connected() {
          return this[PRIVATE19].gamepad.connected;
        }
        get timestamp() {
          return this[PRIVATE19].gamepad.timestamp;
        }
        get mapping() {
          return this[PRIVATE19].mapping;
        }
        get axes() {
          return this[PRIVATE19].axes;
        }
        get buttons() {
          return this[PRIVATE19].buttons;
        }
        // Non-standard extension
        get hapticActuators() {
          return this[PRIVATE19].gamepad.hapticActuators;
        }
      };
      GamepadXRInputSource = class {
        constructor(polyfill, display, primaryButtonIndex = 0, primarySqueezeButtonIndex = -1) {
          this.polyfill = polyfill;
          this.display = display;
          this.nativeGamepad = null;
          this.gamepad = null;
          this.inputSource = new XRInputSource(this);
          this.lastPosition = create2();
          this.emulatedPosition = false;
          this.basePoseMatrix = create();
          this.outputMatrix = create();
          this.primaryButtonIndex = primaryButtonIndex;
          this.primaryActionPressed = false;
          this.primarySqueezeButtonIndex = primarySqueezeButtonIndex;
          this.primarySqueezeActionPressed = false;
          this.handedness = "";
          this.targetRayMode = "gaze";
          this.armModel = null;
        }
        get profiles() {
          return this.gamepad ? this.gamepad._profiles : [];
        }
        updateFromGamepad(gamepad) {
          if (this.nativeGamepad !== gamepad) {
            this.nativeGamepad = gamepad;
            if (gamepad) {
              this.gamepad = new XRRemappedGamepad(gamepad, this.display, GamepadMappings_default[gamepad.id]);
            } else {
              this.gamepad = null;
            }
          }
          this.handedness = gamepad.hand === "" ? "none" : gamepad.hand;
          if (this.gamepad) {
            this.gamepad._update();
          }
          if (gamepad.pose) {
            this.targetRayMode = "tracked-pointer";
            this.emulatedPosition = !gamepad.pose.hasPosition;
          } else if (gamepad.hand === "") {
            this.targetRayMode = "gaze";
            this.emulatedPosition = false;
          }
        }
        updateBasePoseMatrix() {
          if (this.nativeGamepad && this.nativeGamepad.pose) {
            let pose = this.nativeGamepad.pose;
            let position = pose.position;
            let orientation = pose.orientation;
            if (!position && !orientation) {
              return;
            }
            if (!position) {
              if (!pose.hasPosition) {
                if (!this.armModel) {
                  this.armModel = new OrientationArmModel();
                }
                this.armModel.setHandedness(this.nativeGamepad.hand);
                this.armModel.update(orientation, this.polyfill.getBasePoseMatrix());
                position = this.armModel.getPosition();
              } else {
                position = this.lastPosition;
              }
            } else {
              this.lastPosition[0] = position[0];
              this.lastPosition[1] = position[1];
              this.lastPosition[2] = position[2];
            }
            fromRotationTranslation(this.basePoseMatrix, orientation, position);
          } else {
            copy(this.basePoseMatrix, this.polyfill.getBasePoseMatrix());
          }
          return this.basePoseMatrix;
        }
        /**
         * @param {XRReferenceSpace} coordinateSystem
         * @param {string} poseType
         * @return {XRPose?}
         */
        getXRPose(coordinateSystem, poseType) {
          this.updateBasePoseMatrix();
          switch (poseType) {
            case "target-ray":
              coordinateSystem._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
              if (this.gamepad && this.gamepad[PRIVATE19].targetRayTransform) {
                multiply(this.outputMatrix, this.outputMatrix, this.gamepad[PRIVATE19].targetRayTransform);
              }
              break;
            case "grip":
              if (!this.nativeGamepad || !this.nativeGamepad.pose) {
                return null;
              }
              coordinateSystem._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
              if (this.gamepad && this.gamepad[PRIVATE19].gripTransform) {
                multiply(this.outputMatrix, this.outputMatrix, this.gamepad[PRIVATE19].gripTransform);
              }
              break;
            default:
              return null;
          }
          coordinateSystem._adjustForOriginOffset(this.outputMatrix);
          return new XRPose(new XRRigidTransform(this.outputMatrix), this.emulatedPosition);
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices/WebVRDevice.js
  var PRIVATE20, TEST_ENV, EXTRA_PRESENTATION_ATTRIBUTES, PRIMARY_BUTTON_MAP, SESSION_ID, Session, WebVRDevice;
  var init_WebVRDevice = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices/WebVRDevice.js"() {
      init_mat4();
      init_XRDevice();
      init_GamepadXRInputSource();
      init_utils4();
      PRIVATE20 = Symbol("@@webxr-polyfill/WebVRDevice");
      TEST_ENV = false;
      EXTRA_PRESENTATION_ATTRIBUTES = {
        // Non-standard attribute to enable running at the native device refresh rate
        // on the Oculus Go.
        highRefreshRate: true
      };
      PRIMARY_BUTTON_MAP = {
        oculus: 1,
        openvr: 1,
        "spatial controller (spatial interaction source)": 1
      };
      SESSION_ID = 0;
      Session = class {
        constructor(mode, enabledFeatures, polyfillOptions = {}) {
          this.mode = mode;
          this.enabledFeatures = enabledFeatures;
          this.outputContext = null;
          this.immersive = mode == "immersive-vr" || mode == "immersive-ar";
          this.ended = null;
          this.baseLayer = null;
          this.id = ++SESSION_ID;
          this.modifiedCanvasLayer = false;
          if (this.outputContext && !TEST_ENV) {
            const renderContextType = polyfillOptions.renderContextType || "2d";
            this.renderContext = this.outputContext.canvas.getContext(renderContextType);
          }
        }
      };
      WebVRDevice = class extends XRDevice {
        /**
         * Takes a VRDisplay instance and a VRFrameData
         * constructor from the WebVR 1.1 spec.
         *
         * @param {VRDisplay} display
         * @param {VRFrameData} VRFrameData
         */
        constructor(global2, display) {
          const { canPresent } = display.capabilities;
          super(global2);
          this.display = display;
          this.frame = new global2.VRFrameData();
          this.sessions = /* @__PURE__ */ new Map();
          this.immersiveSession = null;
          this.canPresent = canPresent;
          this.baseModelMatrix = create();
          this.gamepadInputSources = {};
          this.tempVec3 = new Float32Array(3);
          this.onVRDisplayPresentChange = this.onVRDisplayPresentChange.bind(this);
          global2.window.addEventListener("vrdisplaypresentchange", this.onVRDisplayPresentChange);
          this.CAN_USE_GAMEPAD = global2.navigator && "getGamepads" in global2.navigator;
          this.HAS_BITMAP_SUPPORT = isImageBitmapSupported(global2);
        }
        /**
         * @return {number}
         */
        get depthNear() {
          return this.display.depthNear;
        }
        /**
         * @param {number}
         */
        set depthNear(val) {
          this.display.depthNear = val;
        }
        /**
         * @return {number}
         */
        get depthFar() {
          return this.display.depthFar;
        }
        /**
         * @param {number}
         */
        set depthFar(val) {
          this.display.depthFar = val;
        }
        /**
         * Called when a XRSession has a `baseLayer` property set.
         *
         * @param {number} sessionId
         * @param {XRWebGLLayer} layer
         */
        onBaseLayerSet(sessionId, layer) {
          const session = this.sessions.get(sessionId);
          const canvas = layer.context.canvas;
          if (session.immersive) {
            const left = this.display.getEyeParameters("left");
            const right = this.display.getEyeParameters("right");
            canvas.width = Math.max(left.renderWidth, right.renderWidth) * 2;
            canvas.height = Math.max(left.renderHeight, right.renderHeight);
            this.display.requestPresent([{
              source: canvas,
              attributes: EXTRA_PRESENTATION_ATTRIBUTES
            }]).then(() => {
              if (!TEST_ENV && !this.global.document.body.contains(canvas)) {
                session.modifiedCanvasLayer = true;
                this.global.document.body.appendChild(canvas);
                applyCanvasStylesForMinimalRendering(canvas);
              }
              session.baseLayer = layer;
            });
          } else {
            session.baseLayer = layer;
          }
        }
        /**
         * If a 1.1 VRDisplay cannot present, it could be a 6DOF device
         * that doesn't have its own way to present, but used in magic
         * window mode. So in WebXR lingo, this cannot support an
         * "immersive" session.
         *
         * @param {XRSessionMode} mode
         * @return {boolean}
         */
        isSessionSupported(mode) {
          if (mode == "immersive-ar") {
            return false;
          }
          if (mode == "immersive-vr" && this.canPresent === false) {
            return false;
          }
          return true;
        }
        /**
         * @param {string} featureDescriptor
         * @return {boolean}
         */
        isFeatureSupported(featureDescriptor) {
          switch (featureDescriptor) {
            case "viewer":
              return true;
            case "local":
              return true;
            case "local-floor":
              return true;
            case "bounded":
              return false;
            case "unbounded":
              return false;
            default:
              return false;
          }
        }
        /**
         * Returns a promise of a session ID if creating a session is successful.
         * Usually used to set up presentation in the device.
         * We can't start presenting in a 1.1 device until we have a canvas
         * layer, so use a dummy layer until `onBaseLayerSet` is called.
         * May reject if session is not supported, or if an error is thrown
         * when calling `requestPresent`.
         *
         * @param {XRSessionMode} mode
         * @param {Set<string>} enabledFeatures
         * @return {Promise<number>}
         */
        async requestSession(mode, enabledFeatures) {
          if (!this.isSessionSupported(mode)) {
            return Promise.reject();
          }
          let immersive = mode == "immersive-vr";
          if (immersive) {
            const canvas = this.global.document.createElement("canvas");
            if (!TEST_ENV) {
              const ctx = canvas.getContext("webgl");
            }
            await this.display.requestPresent([{
              source: canvas,
              attributes: EXTRA_PRESENTATION_ATTRIBUTES
            }]);
          }
          const session = new Session(mode, enabledFeatures, {
            renderContextType: this.HAS_BITMAP_SUPPORT ? "bitmaprenderer" : "2d"
          });
          this.sessions.set(session.id, session);
          if (immersive) {
            this.immersiveSession = session;
            this.dispatchEvent("@@webxr-polyfill/vr-present-start", session.id);
          }
          return Promise.resolve(session.id);
        }
        /**
         * @return {Function}
         */
        requestAnimationFrame(callback) {
          return this.display.requestAnimationFrame(callback);
        }
        getPrimaryButtonIndex(gamepad) {
          let primaryButton = 0;
          let name2 = gamepad.id.toLowerCase();
          for (let key in PRIMARY_BUTTON_MAP) {
            if (name2.includes(key)) {
              primaryButton = PRIMARY_BUTTON_MAP[key];
              break;
            }
          }
          return Math.min(primaryButton, gamepad.buttons.length - 1);
        }
        onFrameStart(sessionId, renderState) {
          this.display.depthNear = renderState.depthNear;
          this.display.depthFar = renderState.depthFar;
          this.display.getFrameData(this.frame);
          const session = this.sessions.get(sessionId);
          if (session.immersive && this.CAN_USE_GAMEPAD) {
            let prevInputSources = this.gamepadInputSources;
            this.gamepadInputSources = {};
            let gamepads = this.global.navigator.getGamepads();
            for (let i5 = 0; i5 < gamepads.length; ++i5) {
              let gamepad = gamepads[i5];
              if (gamepad && gamepad.displayId > 0) {
                let inputSourceImpl = prevInputSources[i5];
                if (!inputSourceImpl) {
                  inputSourceImpl = new GamepadXRInputSource(this, this.display, this.getPrimaryButtonIndex(gamepad));
                }
                inputSourceImpl.updateFromGamepad(gamepad);
                this.gamepadInputSources[i5] = inputSourceImpl;
                if (inputSourceImpl.primaryButtonIndex != -1) {
                  let primaryActionPressed = gamepad.buttons[inputSourceImpl.primaryButtonIndex].pressed;
                  if (primaryActionPressed && !inputSourceImpl.primaryActionPressed) {
                    this.dispatchEvent("@@webxr-polyfill/input-select-start", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                  } else if (!primaryActionPressed && inputSourceImpl.primaryActionPressed) {
                    this.dispatchEvent("@@webxr-polyfill/input-select-end", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                  }
                  inputSourceImpl.primaryActionPressed = primaryActionPressed;
                }
                if (inputSourceImpl.primarySqueezeButtonIndex != -1) {
                  let primarySqueezeActionPressed = gamepad.buttons[inputSourceImpl.primarySqueezeButtonIndex].pressed;
                  if (primarySqueezeActionPressed && !inputSourceImpl.primarySqueezeActionPressed) {
                    this.dispatchEvent("@@webxr-polyfill/input-squeeze-start", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                  } else if (!primarySqueezeActionPressed && inputSourceImpl.primarySqueezeActionPressed) {
                    this.dispatchEvent("@@webxr-polyfill/input-squeeze-end", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                  }
                  inputSourceImpl.primarySqueezeActionPressed = primarySqueezeActionPressed;
                }
              }
            }
          }
          if (TEST_ENV) {
            return;
          }
          if (!session.immersive && session.baseLayer) {
            const canvas = session.baseLayer.context.canvas;
            perspective(
              this.frame.leftProjectionMatrix,
              renderState.inlineVerticalFieldOfView,
              canvas.width / canvas.height,
              renderState.depthNear,
              renderState.depthFar
            );
          }
        }
        onFrameEnd(sessionId) {
          const session = this.sessions.get(sessionId);
          if (session.ended || !session.baseLayer) {
            return;
          }
          if (session.outputContext && !(session.immersive && !this.display.capabilities.hasExternalDisplay)) {
            const mirroring = session.immersive && this.display.capabilities.hasExternalDisplay;
            const iCanvas = session.baseLayer.context.canvas;
            const iWidth = mirroring ? iCanvas.width / 2 : iCanvas.width;
            const iHeight = iCanvas.height;
            if (!TEST_ENV) {
              const oCanvas = session.outputContext.canvas;
              const oWidth = oCanvas.width;
              const oHeight = oCanvas.height;
              const renderContext = session.renderContext;
              if (this.HAS_BITMAP_SUPPORT) {
                if (iCanvas.transferToImageBitmap) {
                  renderContext.transferFromImageBitmap(iCanvas.transferToImageBitmap());
                } else {
                  this.global.createImageBitmap(iCanvas, 0, 0, iWidth, iHeight, {
                    resizeWidth: oWidth,
                    resizeHeight: oHeight
                  }).then((bitmap) => renderContext.transferFromImageBitmap(bitmap));
                }
              } else {
                renderContext.drawImage(
                  iCanvas,
                  0,
                  0,
                  iWidth,
                  iHeight,
                  0,
                  0,
                  oWidth,
                  oHeight
                );
              }
            }
          }
          if (session.immersive && session.baseLayer) {
            this.display.submitFrame();
          }
        }
        /**
         * @param {number} handle
         */
        cancelAnimationFrame(handle) {
          this.display.cancelAnimationFrame(handle);
        }
        /**
         * @TODO Spec
         */
        async endSession(sessionId) {
          const session = this.sessions.get(sessionId);
          if (session.ended) {
            return;
          }
          if (session.immersive) {
            return this.display.exitPresent();
          } else {
            session.ended = true;
          }
        }
        /**
         * @param {number} sessionId
         * @param {XRReferenceSpaceType} type
         * @return {boolean}
         */
        doesSessionSupportReferenceSpace(sessionId, type) {
          const session = this.sessions.get(sessionId);
          if (session.ended) {
            return false;
          }
          return session.enabledFeatures.has(type);
        }
        /**
         * If the VRDisplay has stage parameters, convert them
         * to an array of X, Z pairings.
         *
         * @return {Object?}
         */
        requestStageBounds() {
          if (this.display.stageParameters) {
            const width = this.display.stageParameters.sizeX;
            const depth = this.display.stageParameters.sizeZ;
            const data = [];
            data.push(-width / 2);
            data.push(-depth / 2);
            data.push(width / 2);
            data.push(-depth / 2);
            data.push(width / 2);
            data.push(depth / 2);
            data.push(-width / 2);
            data.push(depth / 2);
            return data;
          }
          return null;
        }
        /**
         * Returns a promise resolving to a transform if XRDevice
         * can support frame of reference and provides its own values.
         * Can resolve to `undefined` if the polyfilled API can provide
         * a default. Rejects if this XRDevice cannot
         * support the frame of reference.
         *
         * @param {XRFrameOfReferenceType} type
         * @param {XRFrameOfReferenceOptions} options
         * @return {Promise<float32rray>}
         */
        async requestFrameOfReferenceTransform(type, options) {
          if ((type === "local-floor" || type === "bounded-floor") && this.display.stageParameters && this.display.stageParameters.sittingToStandingTransform) {
            return this.display.stageParameters.sittingToStandingTransform;
          }
          return null;
        }
        /**
         * @param {XREye} eye
         * @return {Float32Array}
         */
        getProjectionMatrix(eye) {
          if (eye === "left") {
            return this.frame.leftProjectionMatrix;
          } else if (eye === "right") {
            return this.frame.rightProjectionMatrix;
          } else if (eye === "none") {
            return this.frame.leftProjectionMatrix;
          } else {
            throw new Error(`eye must be of type 'left' or 'right'`);
          }
        }
        /**
         * Takes a XREye and a target to apply properties of
         * `x`, `y`, `width` and `height` on. Returns a boolean
         * indicating if it successfully was able to populate
         * target's values.
         *
         * @param {number} sessionId
         * @param {XREye} eye
         * @param {XRWebGLLayer} layer
         * @param {Object?} target
         * @return {boolean}
         */
        getViewport(sessionId, eye, layer, target) {
          const session = this.sessions.get(sessionId);
          const { width, height } = layer.context.canvas;
          if (!session.immersive) {
            target.x = target.y = 0;
            target.width = width;
            target.height = height;
            return true;
          }
          if (eye === "left" || eye === "none") {
            target.x = 0;
          } else if (eye === "right") {
            target.x = width / 2;
          } else {
            return false;
          }
          target.y = 0;
          target.width = width / 2;
          target.height = height;
          return true;
        }
        /**
         * Get model matrix unaffected by frame of reference.
         *
         * @return {Float32Array}
         */
        getBasePoseMatrix() {
          let { position, orientation } = this.frame.pose;
          if (!position && !orientation) {
            return this.baseModelMatrix;
          }
          if (!position) {
            position = this.tempVec3;
            position[0] = position[1] = position[2] = 0;
          }
          fromRotationTranslation(this.baseModelMatrix, orientation, position);
          return this.baseModelMatrix;
        }
        /**
         * Get view matrix unaffected by frame of reference.
         *
         * @param {XREye} eye
         * @return {Float32Array}
         */
        getBaseViewMatrix(eye) {
          if (eye === "left" || eye === "none") {
            return this.frame.leftViewMatrix;
          } else if (eye === "right") {
            return this.frame.rightViewMatrix;
          } else {
            throw new Error(`eye must be of type 'left' or 'right'`);
          }
        }
        getInputSources() {
          let inputSources = [];
          for (let i5 in this.gamepadInputSources) {
            inputSources.push(this.gamepadInputSources[i5].inputSource);
          }
          return inputSources;
        }
        getInputPose(inputSource, coordinateSystem, poseType) {
          if (!coordinateSystem) {
            return null;
          }
          for (let i5 in this.gamepadInputSources) {
            let inputSourceImpl = this.gamepadInputSources[i5];
            if (inputSourceImpl.inputSource === inputSource) {
              return inputSourceImpl.getXRPose(coordinateSystem, poseType);
            }
          }
          return null;
        }
        /**
         * Triggered on window resize.
         *
         */
        onWindowResize() {
        }
        /**
         * Listens to the Native 1.1 `window.addEventListener('vrdisplaypresentchange')`
         * event.
         *
         * @param {Event} event
         */
        onVRDisplayPresentChange(e4) {
          if (!this.display.isPresenting) {
            this.sessions.forEach((session) => {
              if (session.immersive && !session.ended) {
                if (session.modifiedCanvasLayer) {
                  const canvas = session.baseLayer.context.canvas;
                  document.body.removeChild(canvas);
                  canvas.setAttribute("style", "");
                }
                if (this.immersiveSession === session) {
                  this.immersiveSession = null;
                }
                this.dispatchEvent("@@webxr-polyfill/vr-present-end", session.id);
              }
            });
          }
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices/CardboardXRDevice.js
  var import_cardboard_vr_display, CardboardXRDevice;
  var init_CardboardXRDevice = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices/CardboardXRDevice.js"() {
      import_cardboard_vr_display = __toESM(require_cardboard_vr_display());
      init_WebVRDevice();
      CardboardXRDevice = class extends WebVRDevice {
        /**
         * Takes a VRDisplay instance and a VRFrameData
         * constructor from the WebVR 1.1 spec.
         *
         * @param {VRDisplay} display
         * @param {Object?} cardboardConfig
         */
        constructor(global2, cardboardConfig) {
          const display = new import_cardboard_vr_display.default(cardboardConfig || {});
          super(global2, display);
          this.display = display;
          this.frame = {
            rightViewMatrix: new Float32Array(16),
            leftViewMatrix: new Float32Array(16),
            rightProjectionMatrix: new Float32Array(16),
            leftProjectionMatrix: new Float32Array(16),
            pose: null,
            timestamp: null
          };
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices/InlineDevice.js
  var TEST_ENV2, SESSION_ID2, Session2, InlineDevice;
  var init_InlineDevice = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices/InlineDevice.js"() {
      init_mat4();
      init_XRDevice();
      TEST_ENV2 = false;
      SESSION_ID2 = 0;
      Session2 = class {
        constructor(mode, enabledFeatures) {
          this.mode = mode;
          this.enabledFeatures = enabledFeatures;
          this.ended = null;
          this.baseLayer = null;
          this.id = ++SESSION_ID2;
        }
      };
      InlineDevice = class extends XRDevice {
        /**
         * Constructs an inline-only XRDevice
         */
        constructor(global2) {
          super(global2);
          this.sessions = /* @__PURE__ */ new Map();
          this.projectionMatrix = create();
          this.identityMatrix = create();
        }
        /**
         * Called when a XRSession has a `baseLayer` property set.
         *
         * @param {number} sessionId
         * @param {XRWebGLLayer} layer
         */
        onBaseLayerSet(sessionId, layer) {
          const session = this.sessions.get(sessionId);
          session.baseLayer = layer;
        }
        /**
         * Returns true if the requested mode is inline
         *
         * @param {XRSessionMode} mode
         * @return {boolean}
         */
        isSessionSupported(mode) {
          return mode == "inline";
        }
        /**
         * @param {string} featureDescriptor
         * @return {boolean}
         */
        isFeatureSupported(featureDescriptor) {
          switch (featureDescriptor) {
            case "viewer":
              return true;
            default:
              return false;
          }
        }
        /**
         * Returns a promise of a session ID if creating a session is successful.
         *
         * @param {XRSessionMode} mode
         * @param {Set<string>} enabledFeatures
         * @return {Promise<number>}
         */
        async requestSession(mode, enabledFeatures) {
          if (!this.isSessionSupported(mode)) {
            return Promise.reject();
          }
          const session = new Session2(mode, enabledFeatures);
          this.sessions.set(session.id, session);
          return Promise.resolve(session.id);
        }
        /**
         * @return {Function}
         */
        requestAnimationFrame(callback) {
          return window.requestAnimationFrame(callback);
        }
        /**
         * @param {number} handle
         */
        cancelAnimationFrame(handle) {
          window.cancelAnimationFrame(handle);
        }
        onFrameStart(sessionId, renderState) {
          if (TEST_ENV2) {
            return;
          }
          const session = this.sessions.get(sessionId);
          if (session.baseLayer) {
            const canvas = session.baseLayer.context.canvas;
            perspective(
              this.projectionMatrix,
              renderState.inlineVerticalFieldOfView,
              canvas.width / canvas.height,
              renderState.depthNear,
              renderState.depthFar
            );
          }
        }
        onFrameEnd(sessionId) {
        }
        /**
         * @TODO Spec
         */
        async endSession(sessionId) {
          const session = this.sessions.get(sessionId);
          session.ended = true;
        }
        /**
         * @param {number} sessionId
         * @param {XRReferenceSpaceType} type
         * @return {boolean}
         */
        doesSessionSupportReferenceSpace(sessionId, type) {
          const session = this.sessions.get(sessionId);
          if (session.ended) {
            return false;
          }
          return session.enabledFeatures.has(type);
        }
        /**
         * Inline sessions don't have stage bounds
         *
         * @return {Object?}
         */
        requestStageBounds() {
          return null;
        }
        /**
         * Inline sessions don't have multiple frames of reference
         *
         * @param {XRFrameOfReferenceType} type
         * @param {XRFrameOfReferenceOptions} options
         * @return {Promise<Float32Array>}
         */
        async requestFrameOfReferenceTransform(type, options) {
          return null;
        }
        /**
         * @param {XREye} eye
         * @return {Float32Array}
         */
        getProjectionMatrix(eye) {
          return this.projectionMatrix;
        }
        /**
         * Takes a XREye and a target to apply properties of
         * `x`, `y`, `width` and `height` on. Returns a boolean
         * indicating if it successfully was able to populate
         * target's values.
         *
         * @param {number} sessionId
         * @param {XREye} eye
         * @param {XRWebGLLayer} layer
         * @param {Object?} target
         * @return {boolean}
         */
        getViewport(sessionId, eye, layer, target) {
          const session = this.sessions.get(sessionId);
          const { width, height } = layer.context.canvas;
          target.x = target.y = 0;
          target.width = width;
          target.height = height;
          return true;
        }
        /**
         * Get model matrix unaffected by frame of reference.
         *
         * @return {Float32Array}
         */
        getBasePoseMatrix() {
          return this.identityMatrix;
        }
        /**
         * Get view matrix unaffected by frame of reference.
         *
         * @param {XREye} eye
         * @return {Float32Array}
         */
        getBaseViewMatrix(eye) {
          return this.identityMatrix;
        }
        /**
         * No persistent input sources for the inline session
         */
        getInputSources() {
          return [];
        }
        getInputPose(inputSource, coordinateSystem, poseType) {
          return null;
        }
        /**
         * Triggered on window resize.
         */
        onWindowResize() {
        }
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/devices.js
  var getWebVRDevice, requestXRDevice;
  var init_devices = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/devices.js"() {
      init_CardboardXRDevice();
      init_InlineDevice();
      init_WebVRDevice();
      init_utils4();
      getWebVRDevice = async function(global2) {
        let device = null;
        if ("getVRDisplays" in global2.navigator) {
          try {
            const displays = await global2.navigator.getVRDisplays();
            if (displays && displays.length) {
              device = new WebVRDevice(global2, displays[0]);
            }
          } catch (e4) {
          }
        }
        return device;
      };
      requestXRDevice = async function(global2, config) {
        if (config.webvr) {
          let xr5 = await getWebVRDevice(global2);
          if (xr5) {
            return xr5;
          }
        }
        let mobile = isMobile(global2);
        if (mobile && config.cardboard || !mobile && config.allowCardboardOnDesktop) {
          if (!global2.VRFrameData) {
            global2.VRFrameData = function() {
              this.rightViewMatrix = new Float32Array(16);
              this.leftViewMatrix = new Float32Array(16);
              this.rightProjectionMatrix = new Float32Array(16);
              this.leftProjectionMatrix = new Float32Array(16);
              this.pose = null;
            };
          }
          return new CardboardXRDevice(global2, config.cardboardConfig);
        }
        return new InlineDevice(global2);
      };
    }
  });

  // node_modules/@lookingglass/webxr-polyfill/src/WebXRPolyfill.js
  var CONFIG_DEFAULTS, partials, WebXRPolyfill;
  var init_WebXRPolyfill = __esm({
    "node_modules/@lookingglass/webxr-polyfill/src/WebXRPolyfill.js"() {
      init_global2();
      init_api2();
      init_polyfill_globals();
      init_utils4();
      init_devices();
      CONFIG_DEFAULTS = {
        // The default global to use for needed APIs.
        global: global_default,
        // Whether support for a browser implementing WebVR 1.1 is enabled.
        // If enabled, XR support is powered by native WebVR 1.1 VRDisplays,
        // exposed as XRDevices.
        webvr: true,
        // Whether a CardboardXRDevice should be discoverable if on
        // a mobile device, and no other native (1.1 VRDisplay if `webvr` on,
        // or XRDevice) found.
        cardboard: true,
        // The configuration to be used for CardboardVRDisplay when used.
        // Has no effect if `cardboard: false` or another XRDevice is used.
        // Configuration can be found: https://github.com/immersive-web/cardboard-vr-display/blob/master/src/options.js
        cardboardConfig: null,
        // Whether a CardboardXRDevice should be created if no WebXR API found
        // on desktop or not. Stereoscopic rendering with a gyro often does not make sense on desktop, and probably only useful for debugging.
        allowCardboardOnDesktop: false
      };
      partials = ["navigator", "HTMLCanvasElement", "WebGLRenderingContext"];
      WebXRPolyfill = class {
        /**
         * @param {object?} config
         */
        constructor(config = {}) {
          this.config = Object.freeze(Object.assign({}, CONFIG_DEFAULTS, config));
          this.global = this.config.global;
          this.nativeWebXR = "xr" in this.global.navigator;
          this.injected = false;
          if (true) {
            this._injectPolyfill(this.global);
          } else {
            this._injectCompatibilityShims(this.global);
          }
        }
        _injectPolyfill(global2) {
          if (!partials.every((iface) => !!global2[iface])) {
            throw new Error(`Global must have the following attributes : ${partials}`);
          }
          for (const className of Object.keys(api_default)) {
            if (global2[className] !== void 0) {
              console.warn(`${className} already defined on global.`);
            } else {
              global2[className] = api_default[className];
            }
          }
          if (true) {
            const polyfilledCtx = polyfillMakeXRCompatible(global2.WebGLRenderingContext);
            if (polyfilledCtx) {
              polyfillGetContext(global2.HTMLCanvasElement);
              if (global2.OffscreenCanvas) {
                polyfillGetContext(global2.OffscreenCanvas);
              }
              if (global2.WebGL2RenderingContext) {
                polyfillMakeXRCompatible(global2.WebGL2RenderingContext);
              }
              if (!window.isSecureContext) {
                console.warn(`WebXR Polyfill Warning:
This page is not running in a secure context (https:// or localhost)!
This means that although the page may be able to use the WebXR Polyfill it will
not be able to use native WebXR implementations, and as such will not be able to
access dedicated VR or AR hardware, and will not be able to take advantage of
any performance improvements a native WebXR implementation may offer. Please
host this content on a secure origin for the best user experience.
`);
              }
            }
          }
          this.injected = true;
          this._patchNavigatorXR();
        }
        _patchNavigatorXR() {
          let devicePromise = requestXRDevice(this.global, this.config);
          this.xr = new api_default.XRSystem(devicePromise);
          Object.defineProperty(this.global.navigator, "xr", {
            value: this.xr,
            configurable: true
          });
        }
        _injectCompatibilityShims(global2) {
          if (!partials.every((iface) => !!global2[iface])) {
            throw new Error(`Global must have the following attributes : ${partials}`);
          }
          if (global2.navigator.xr && "supportsSession" in global2.navigator.xr && !("isSessionSupported" in global2.navigator.xr)) {
            let originalSupportsSession = global2.navigator.xr.supportsSession;
            global2.navigator.xr.isSessionSupported = function(mode) {
              return originalSupportsSession.call(this, mode).then(() => {
                return true;
              }).catch(() => {
                return false;
              });
            };
            global2.navigator.xr.supportsSession = function(mode) {
              console.warn("navigator.xr.supportsSession() is deprecated. Please call navigator.xr.isSessionSupported() instead and check the boolean value returned when the promise resolves.");
              return originalSupportsSession.call(this, mode);
            };
          }
        }
      };
    }
  });

  // node_modules/ws/browser.js
  var require_browser = __commonJS({
    "node_modules/ws/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // node_modules/holoplay-core/dist/holoplaycore.module.js
  function createCommonjsModule(fn4, module2) {
    return module2 = { exports: {} }, fn4(module2, module2.exports), module2.exports;
  }
  function generateRng() {
    function xmur3(str2) {
      for (var i5 = 0, h4 = 1779033703 ^ str2.length; i5 < str2.length; i5++)
        h4 = Math.imul(h4 ^ str2.charCodeAt(i5), 3432918353), h4 = h4 << 13 | h4 >>> 19;
      return function() {
        h4 = Math.imul(h4 ^ h4 >>> 16, 2246822507);
        h4 = Math.imul(h4 ^ h4 >>> 13, 3266489909);
        return (h4 ^= h4 >>> 16) >>> 0;
      };
    }
    function xoshiro128ss(a4, b3, c5, d4) {
      return () => {
        var t4 = b3 << 9, r4 = a4 * 5;
        r4 = (r4 << 7 | r4 >>> 25) * 9;
        c5 ^= a4;
        d4 ^= b3;
        b3 ^= c5;
        a4 ^= d4;
        c5 ^= t4;
        d4 = d4 << 11 | d4 >>> 21;
        return (r4 >>> 0) / 4294967296;
      };
    }
    var state = Date.now();
    var seed = xmur3(state.toString());
    return xoshiro128ss(seed(), seed(), seed(), seed());
  }
  function glslifyNumbers(strings, ...values) {
    let s4 = strings[0];
    for (let i5 = 1; i5 < strings.length; ++i5) {
      const v5 = values[i5 - 1];
      s4 += typeof v5 === "number" ? v5.toPrecision(10) : v5;
      s4 += strings[i5];
    }
    return s4;
  }
  function Shader(cfg) {
    return glslifyNumbers`
  precision mediump float;
  uniform int u_viewType;
  uniform sampler2D u_texture;
  varying vec2 v_texcoord;
  const float pitch    = ${cfg.pitch};
  const float tilt     = ${cfg.tilt};
  const float center   = ${cfg.calibration.center.value};
  const float invView  = ${cfg.calibration.invView.value};
  const float flipX    = ${cfg.calibration.flipImageX.value};
  const float flipY    = ${cfg.calibration.flipImageY.value};
  const float subp     = ${cfg.subp};
  const float numViews = ${cfg.numViews};
  const float tilesX   = ${cfg.quiltWidth};
  const float tilesY   = ${cfg.quiltHeight};
  const vec2 quiltViewPortion = vec2(
    ${cfg.quiltWidth * cfg.tileWidth / cfg.framebufferWidth},
    ${cfg.quiltHeight * cfg.tileHeight / cfg.framebufferHeight});
  vec2 texArr(vec3 uvz) {
    float z = floor(uvz.z * numViews);
    float x = (mod(z, tilesX) + uvz.x) / tilesX;
    float y = (floor(z / tilesX) + uvz.y) / tilesY;
    return vec2(x, y) * quiltViewPortion;
  }
  float remap(float value, float from1, float to1, float from2, float to2) {
    return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
  }
  void main() {
    if (u_viewType == 2) { // "quilt" view
      gl_FragColor = texture2D(u_texture, v_texcoord);
      return;
    }
    if (u_viewType == 1) { // middle view
      gl_FragColor = texture2D(u_texture, texArr(vec3(v_texcoord.x, v_texcoord.y, 0.5)));
      return;
    }
    vec4 rgb[3];
    vec3 nuv = vec3(v_texcoord.xy, 0.0);
    // Flip UVs if necessary
    nuv.x = (1.0 - flipX) * nuv.x + flipX * (1.0 - nuv.x);
    nuv.y = (1.0 - flipY) * nuv.y + flipY * (1.0 - nuv.y);
    for (int i = 0; i < 3; i++) {
      nuv.z = (v_texcoord.x + float(i) * subp + v_texcoord.y * tilt) * pitch - center;
      nuv.z = mod(nuv.z + ceil(abs(nuv.z)), 1.0);
      nuv.z = (1.0 - invView) * nuv.z + invView * (1.0 - nuv.z);
      rgb[i] = texture2D(u_texture, texArr(vec3(v_texcoord.x, v_texcoord.y, nuv.z)));
    }
    gl_FragColor = vec4(rgb[0].r, rgb[1].g, rgb[2].b, 1);
  }
`;
  }
  var commonjsGlobal, cbor, WebSocket2, Client, Message, InitMessage, InfoMessage;
  var init_holoplaycore_module = __esm({
    "node_modules/holoplay-core/dist/holoplaycore.module.js"() {
      commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      cbor = createCommonjsModule(function(module2) {
        (function(global2, undefined$1) {
          var POW_2_24 = Math.pow(2, -24), POW_2_32 = Math.pow(2, 32), POW_2_53 = Math.pow(2, 53);
          function encode3(value) {
            var data = new ArrayBuffer(256);
            var dataView = new DataView(data);
            var lastLength;
            var offset = 0;
            function ensureSpace(length3) {
              var newByteLength = data.byteLength;
              var requiredLength = offset + length3;
              while (newByteLength < requiredLength)
                newByteLength *= 2;
              if (newByteLength !== data.byteLength) {
                var oldDataView = dataView;
                data = new ArrayBuffer(newByteLength);
                dataView = new DataView(data);
                var uint32count = offset + 3 >> 2;
                for (var i6 = 0; i6 < uint32count; ++i6)
                  dataView.setUint32(i6 * 4, oldDataView.getUint32(i6 * 4));
              }
              lastLength = length3;
              return dataView;
            }
            function write() {
              offset += lastLength;
            }
            function writeFloat64(value2) {
              write(ensureSpace(8).setFloat64(offset, value2));
            }
            function writeUint8(value2) {
              write(ensureSpace(1).setUint8(offset, value2));
            }
            function writeUint8Array(value2) {
              var dataView2 = ensureSpace(value2.length);
              for (var i6 = 0; i6 < value2.length; ++i6)
                dataView2.setUint8(offset + i6, value2[i6]);
              write();
            }
            function writeUint16(value2) {
              write(ensureSpace(2).setUint16(offset, value2));
            }
            function writeUint32(value2) {
              write(ensureSpace(4).setUint32(offset, value2));
            }
            function writeUint64(value2) {
              var low = value2 % POW_2_32;
              var high = (value2 - low) / POW_2_32;
              var dataView2 = ensureSpace(8);
              dataView2.setUint32(offset, high);
              dataView2.setUint32(offset + 4, low);
              write();
            }
            function writeTypeAndLength(type, length3) {
              if (length3 < 24) {
                writeUint8(type << 5 | length3);
              } else if (length3 < 256) {
                writeUint8(type << 5 | 24);
                writeUint8(length3);
              } else if (length3 < 65536) {
                writeUint8(type << 5 | 25);
                writeUint16(length3);
              } else if (length3 < 4294967296) {
                writeUint8(type << 5 | 26);
                writeUint32(length3);
              } else {
                writeUint8(type << 5 | 27);
                writeUint64(length3);
              }
            }
            function encodeItem(value2) {
              var i6;
              if (value2 === false)
                return writeUint8(244);
              if (value2 === true)
                return writeUint8(245);
              if (value2 === null)
                return writeUint8(246);
              if (value2 === undefined$1)
                return writeUint8(247);
              switch (typeof value2) {
                case "number":
                  if (Math.floor(value2) === value2) {
                    if (0 <= value2 && value2 <= POW_2_53)
                      return writeTypeAndLength(0, value2);
                    if (-POW_2_53 <= value2 && value2 < 0)
                      return writeTypeAndLength(1, -(value2 + 1));
                  }
                  writeUint8(251);
                  return writeFloat64(value2);
                case "string":
                  var utf8data = [];
                  for (i6 = 0; i6 < value2.length; ++i6) {
                    var charCode = value2.charCodeAt(i6);
                    if (charCode < 128) {
                      utf8data.push(charCode);
                    } else if (charCode < 2048) {
                      utf8data.push(192 | charCode >> 6);
                      utf8data.push(128 | charCode & 63);
                    } else if (charCode < 55296) {
                      utf8data.push(224 | charCode >> 12);
                      utf8data.push(128 | charCode >> 6 & 63);
                      utf8data.push(128 | charCode & 63);
                    } else {
                      charCode = (charCode & 1023) << 10;
                      charCode |= value2.charCodeAt(++i6) & 1023;
                      charCode += 65536;
                      utf8data.push(240 | charCode >> 18);
                      utf8data.push(128 | charCode >> 12 & 63);
                      utf8data.push(128 | charCode >> 6 & 63);
                      utf8data.push(128 | charCode & 63);
                    }
                  }
                  writeTypeAndLength(3, utf8data.length);
                  return writeUint8Array(utf8data);
                default:
                  var length3;
                  if (Array.isArray(value2)) {
                    length3 = value2.length;
                    writeTypeAndLength(4, length3);
                    for (i6 = 0; i6 < length3; ++i6)
                      encodeItem(value2[i6]);
                  } else if (value2 instanceof Uint8Array) {
                    writeTypeAndLength(2, value2.length);
                    writeUint8Array(value2);
                  } else {
                    var keys = Object.keys(value2);
                    length3 = keys.length;
                    writeTypeAndLength(5, length3);
                    for (i6 = 0; i6 < length3; ++i6) {
                      var key = keys[i6];
                      encodeItem(key);
                      encodeItem(value2[key]);
                    }
                  }
              }
            }
            encodeItem(value);
            if ("slice" in data)
              return data.slice(0, offset);
            var ret = new ArrayBuffer(offset);
            var retView = new DataView(ret);
            for (var i5 = 0; i5 < offset; ++i5)
              retView.setUint8(i5, dataView.getUint8(i5));
            return ret;
          }
          function decode(data, tagger, simpleValue) {
            var dataView = new DataView(data);
            var offset = 0;
            if (typeof tagger !== "function")
              tagger = function(value) {
                return value;
              };
            if (typeof simpleValue !== "function")
              simpleValue = function() {
                return undefined$1;
              };
            function read(value, length3) {
              offset += length3;
              return value;
            }
            function readArrayBuffer(length3) {
              return read(new Uint8Array(data, offset, length3), length3);
            }
            function readFloat16() {
              var tempArrayBuffer = new ArrayBuffer(4);
              var tempDataView = new DataView(tempArrayBuffer);
              var value = readUint16();
              var sign = value & 32768;
              var exponent = value & 31744;
              var fraction = value & 1023;
              if (exponent === 31744)
                exponent = 255 << 10;
              else if (exponent !== 0)
                exponent += 127 - 15 << 10;
              else if (fraction !== 0)
                return fraction * POW_2_24;
              tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
              return tempDataView.getFloat32(0);
            }
            function readFloat32() {
              return read(dataView.getFloat32(offset), 4);
            }
            function readFloat64() {
              return read(dataView.getFloat64(offset), 8);
            }
            function readUint8() {
              return read(dataView.getUint8(offset), 1);
            }
            function readUint16() {
              return read(dataView.getUint16(offset), 2);
            }
            function readUint32() {
              return read(dataView.getUint32(offset), 4);
            }
            function readUint64() {
              return readUint32() * POW_2_32 + readUint32();
            }
            function readBreak() {
              if (dataView.getUint8(offset) !== 255)
                return false;
              offset += 1;
              return true;
            }
            function readLength(additionalInformation) {
              if (additionalInformation < 24)
                return additionalInformation;
              if (additionalInformation === 24)
                return readUint8();
              if (additionalInformation === 25)
                return readUint16();
              if (additionalInformation === 26)
                return readUint32();
              if (additionalInformation === 27)
                return readUint64();
              if (additionalInformation === 31)
                return -1;
              throw "Invalid length encoding";
            }
            function readIndefiniteStringLength(majorType) {
              var initialByte = readUint8();
              if (initialByte === 255)
                return -1;
              var length3 = readLength(initialByte & 31);
              if (length3 < 0 || initialByte >> 5 !== majorType)
                throw "Invalid indefinite length element";
              return length3;
            }
            function appendUtf16data(utf16data, length3) {
              for (var i5 = 0; i5 < length3; ++i5) {
                var value = readUint8();
                if (value & 128) {
                  if (value < 224) {
                    value = (value & 31) << 6 | readUint8() & 63;
                    length3 -= 1;
                  } else if (value < 240) {
                    value = (value & 15) << 12 | (readUint8() & 63) << 6 | readUint8() & 63;
                    length3 -= 2;
                  } else {
                    value = (value & 15) << 18 | (readUint8() & 63) << 12 | (readUint8() & 63) << 6 | readUint8() & 63;
                    length3 -= 3;
                  }
                }
                if (value < 65536) {
                  utf16data.push(value);
                } else {
                  value -= 65536;
                  utf16data.push(55296 | value >> 10);
                  utf16data.push(56320 | value & 1023);
                }
              }
            }
            function decodeItem() {
              var initialByte = readUint8();
              var majorType = initialByte >> 5;
              var additionalInformation = initialByte & 31;
              var i5;
              var length3;
              if (majorType === 7) {
                switch (additionalInformation) {
                  case 25:
                    return readFloat16();
                  case 26:
                    return readFloat32();
                  case 27:
                    return readFloat64();
                }
              }
              length3 = readLength(additionalInformation);
              if (length3 < 0 && (majorType < 2 || 6 < majorType))
                throw "Invalid length";
              switch (majorType) {
                case 0:
                  return length3;
                case 1:
                  return -1 - length3;
                case 2:
                  if (length3 < 0) {
                    var elements = [];
                    var fullArrayLength = 0;
                    while ((length3 = readIndefiniteStringLength(majorType)) >= 0) {
                      fullArrayLength += length3;
                      elements.push(readArrayBuffer(length3));
                    }
                    var fullArray = new Uint8Array(fullArrayLength);
                    var fullArrayOffset = 0;
                    for (i5 = 0; i5 < elements.length; ++i5) {
                      fullArray.set(elements[i5], fullArrayOffset);
                      fullArrayOffset += elements[i5].length;
                    }
                    return fullArray;
                  }
                  return readArrayBuffer(length3);
                case 3:
                  var utf16data = [];
                  if (length3 < 0) {
                    while ((length3 = readIndefiniteStringLength(majorType)) >= 0)
                      appendUtf16data(utf16data, length3);
                  } else
                    appendUtf16data(utf16data, length3);
                  return String.fromCharCode.apply(null, utf16data);
                case 4:
                  var retArray;
                  if (length3 < 0) {
                    retArray = [];
                    while (!readBreak())
                      retArray.push(decodeItem());
                  } else {
                    retArray = new Array(length3);
                    for (i5 = 0; i5 < length3; ++i5)
                      retArray[i5] = decodeItem();
                  }
                  return retArray;
                case 5:
                  var retObject = {};
                  for (i5 = 0; i5 < length3 || length3 < 0 && !readBreak(); ++i5) {
                    var key = decodeItem();
                    retObject[key] = decodeItem();
                  }
                  return retObject;
                case 6:
                  return tagger(decodeItem(), length3);
                case 7:
                  switch (length3) {
                    case 20:
                      return false;
                    case 21:
                      return true;
                    case 22:
                      return null;
                    case 23:
                      return undefined$1;
                    default:
                      return simpleValue(length3);
                  }
              }
            }
            var ret = decodeItem();
            if (offset !== data.byteLength)
              throw "Remaining bytes";
            return ret;
          }
          var obj = { encode: encode3, decode };
          if (typeof undefined$1 === "function" && undefined$1.amd)
            undefined$1("cbor/cbor", obj);
          else if (module2.exports)
            module2.exports = obj;
          else if (!global2.CBOR)
            global2.CBOR = obj;
        })(commonjsGlobal);
      });
      WebSocket2 = typeof window === "undefined" ? require_browser() : window.WebSocket;
      Client = class {
        /**
         * Establish a client to talk to HoloPlayService.
         * @constructor
         * @param {function} initCallback - optional; a function to trigger when
         *     response is received
         * @param {function} errCallback - optional; a function to trigger when there
         *     is a connection error
         * @param {function} closeCallback - optional; a function to trigger when the
         *     socket is closed
         * @param {boolean} debug - optional; default is false
         * @param {string}  appId - optional
         * @param {boolean} isGreedy - optional
         * @param {string}  oncloseBehavior - optional, can be 'wipe', 'hide', 'none'
         */
        constructor(initCallback, errCallback, closeCallback, debug = false, appId, isGreedy, oncloseBehavior) {
          this.reqs = [];
          this.reps = [];
          this.requestId = this.getRequestId();
          this.debug = debug;
          this.isGreedy = isGreedy;
          this.errCallback = errCallback;
          this.closeCallback = closeCallback;
          this.alwaysdebug = false;
          this.isConnected = false;
          let initCmd = null;
          if (appId || isGreedy || oncloseBehavior) {
            initCmd = new InitMessage(appId, isGreedy, oncloseBehavior, this.debug);
          } else {
            if (debug)
              this.alwaysdebug = true;
            if (typeof initCallback == "function")
              initCmd = new InfoMessage();
          }
          this.openWebsocket(initCmd, initCallback);
        }
        /**
         * Send a message over the websocket to HoloPlayService.
         * @public
         * @param {Message} msg - message object
         * @param {integer} timeoutSecs - optional, default is 60 seconds
         */
        sendMessage(msg, timeoutSecs = 60) {
          if (this.alwaysdebug)
            msg.cmd.debug = true;
          let cborData = msg.toCbor();
          return this.sendRequestObj(cborData, timeoutSecs);
        }
        /**
         * Disconnects from the web socket.
         * @public
         */
        disconnect() {
          this.ws.close();
        }
        /**
         * Open a websocket and set handlers
         * @private
         */
        openWebsocket(firstCmd = null, initCallback = null) {
          this.ws = new WebSocket2("ws://localhost:11222/driver", ["rep.sp.nanomsg.org"]);
          this.ws.parent = this;
          this.ws.binaryType = "arraybuffer";
          this.ws.onmessage = this.messageHandler;
          this.ws.onopen = () => {
            this.isConnected = true;
            if (this.debug) {
              console.log("socket open");
            }
            if (firstCmd != null) {
              this.sendMessage(firstCmd).then(initCallback);
            }
          };
          this.ws.onerror = this.onSocketError;
          this.ws.onclose = this.onClose;
        }
        /**
         * Send a request object over websocket
         * @private
         */
        sendRequestObj(data, timeoutSecs) {
          return new Promise((resolve, reject) => {
            let reqObj = {
              id: this.requestId++,
              parent: this,
              payload: data,
              success: resolve,
              error: reject,
              send: function() {
                if (this.debug)
                  console.log("attemtping to send request with ID " + this.id);
                this.timeout = setTimeout(reqObj.send.bind(this), timeoutSecs * 1e3);
                let tmp = new Uint8Array(data.byteLength + 4);
                let view = new DataView(tmp.buffer);
                view.setUint32(0, this.id);
                tmp.set(new Uint8Array(this.payload), 4);
                this.parent.ws.send(tmp.buffer);
              }
            };
            this.reqs.push(reqObj);
            reqObj.send();
          });
        }
        /**
         * Handles a message when received
         * @private
         */
        messageHandler(event) {
          console.log("message");
          let data = event.data;
          if (data.byteLength < 4)
            return;
          let view = new DataView(data);
          let replyId = view.getUint32(0);
          if (replyId < 2147483648) {
            this.parent.err("bad nng header");
            return;
          }
          let i5 = this.parent.findReqIndex(replyId);
          if (i5 == -1) {
            this.parent.err("got reply that doesn't match known request!");
            return;
          }
          let rep = { id: replyId, payload: cbor.decode(data.slice(4)) };
          if (rep.payload.error == 0) {
            this.parent.reqs[i5].success(rep.payload);
          } else {
            this.parent.reqs[i5].error(rep.payload);
          }
          clearTimeout(this.parent.reqs[i5].timeout);
          this.parent.reqs.splice(i5, 1);
          this.parent.reps.push(rep);
          if (this.debug) {
            console.log(rep.payload);
          }
        }
        getRequestId() {
          return Math.floor(this.prng() * 2147483647) + 2147483648;
        }
        onClose(event) {
          this.parent.isConnected = false;
          if (this.parent.debug) {
            console.log("socket closed");
          }
          if (typeof this.parent.closeCallback == "function")
            this.parent.closeCallback(event);
        }
        onSocketError(error) {
          if (this.parent.debug) {
            console.log(error);
          }
          if (typeof this.parent.errCallback == "function") {
            this.parent.errCallback(error);
          }
        }
        err(errorMsg) {
          if (this.debug) {
            console.log("[DRIVER ERROR]" + errorMsg);
          }
        }
        findReqIndex(replyId) {
          let i5 = 0;
          for (; i5 < this.reqs.length; i5++) {
            if (this.reqs[i5].id == replyId) {
              return i5;
            }
          }
          return -1;
        }
        prng() {
          if (this.rng == void 0) {
            this.rng = generateRng();
          }
          return this.rng();
        }
      };
      Message = class {
        /**
         * Construct a barebone message.
         * @constructor
         */
        constructor(cmd, bin) {
          this.cmd = cmd;
          this.bin = bin;
        }
        /**
         * Convert the class instance to the CBOR format
         * @public
         * @returns {CBOR} - cbor object of the message
         */
        toCbor() {
          return cbor.encode(this);
        }
      };
      InitMessage = class extends Message {
        /**
         * @constructor
         * @param {string}  appId - a unique id for app
         * @param {boolean} isGreedy - will it take over screen
         * @param {string}  oncloseBehavior - can be 'wipe', 'hide', 'none'
         */
        constructor(appId = "", isGreedy = false, onclose = "", debug = false) {
          let cmd = { "init": {} };
          if (appId != "")
            cmd["init"].appid = appId;
          if (onclose != "")
            cmd["init"].onclose = onclose;
          if (isGreedy)
            cmd["init"].greedy = true;
          if (debug)
            cmd["init"].debug = true;
          super(cmd, null);
        }
      };
      InfoMessage = class extends Message {
        /**
         * @constructor
         */
        constructor() {
          let cmd = { "info": {} };
          super(cmd, null);
        }
      };
    }
  });

  // node_modules/gl-matrix/lib/gl-matrix/common.js
  var EPSILON2, ARRAY_TYPE2, degree2;
  var init_common2 = __esm({
    "node_modules/gl-matrix/lib/gl-matrix/common.js"() {
      EPSILON2 = 1e-6;
      ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
      degree2 = Math.PI / 180;
    }
  });

  // node_modules/gl-matrix/lib/gl-matrix/mat4.js
  var mat4_exports2 = {};
  __export(mat4_exports2, {
    add: () => add3,
    adjoint: () => adjoint,
    clone: () => clone4,
    copy: () => copy5,
    create: () => create6,
    determinant: () => determinant,
    equals: () => equals2,
    exactEquals: () => exactEquals2,
    frob: () => frob,
    fromQuat: () => fromQuat,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation,
    fromRotationTranslation: () => fromRotationTranslation2,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues4,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation2,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation2,
    identity: () => identity2,
    invert: () => invert3,
    lookAt: () => lookAt,
    mul: () => mul,
    multiply: () => multiply3,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    ortho: () => ortho,
    perspective: () => perspective2,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    rotate: () => rotate,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    scale: () => scale3,
    set: () => set2,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    targetTo: () => targetTo,
    translate: () => translate,
    transpose: () => transpose
  });
  function create6() {
    var out = new ARRAY_TYPE2(16);
    if (ARRAY_TYPE2 != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone4(a4) {
    var out = new ARRAY_TYPE2(16);
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    out[4] = a4[4];
    out[5] = a4[5];
    out[6] = a4[6];
    out[7] = a4[7];
    out[8] = a4[8];
    out[9] = a4[9];
    out[10] = a4[10];
    out[11] = a4[11];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
    return out;
  }
  function copy5(out, a4) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    out[4] = a4[4];
    out[5] = a4[5];
    out[6] = a4[6];
    out[7] = a4[7];
    out[8] = a4[8];
    out[9] = a4[9];
    out[10] = a4[10];
    out[11] = a4[11];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
    return out;
  }
  function fromValues4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE2(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a4) {
    if (out === a4) {
      var a01 = a4[1], a02 = a4[2], a03 = a4[3];
      var a12 = a4[6], a13 = a4[7];
      var a23 = a4[11];
      out[1] = a4[4];
      out[2] = a4[8];
      out[3] = a4[12];
      out[4] = a01;
      out[6] = a4[9];
      out[7] = a4[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a4[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a4[0];
      out[1] = a4[4];
      out[2] = a4[8];
      out[3] = a4[12];
      out[4] = a4[1];
      out[5] = a4[5];
      out[6] = a4[9];
      out[7] = a4[13];
      out[8] = a4[2];
      out[9] = a4[6];
      out[10] = a4[10];
      out[11] = a4[14];
      out[12] = a4[3];
      out[13] = a4[7];
      out[14] = a4[11];
      out[15] = a4[15];
    }
    return out;
  }
  function invert3(out, a4) {
    var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
    var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
    var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint(out, a4) {
    var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
    var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
    var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  function determinant(a4) {
    var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
    var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
    var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply3(out, a4, b3) {
    var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
    var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
    var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
    var b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    b0 = b3[4];
    b1 = b3[5];
    b22 = b3[6];
    b32 = b3[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    b0 = b3[8];
    b1 = b3[9];
    b22 = b3[10];
    b32 = b3[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    b0 = b3[12];
    b1 = b3[13];
    b22 = b3[14];
    b32 = b3[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
    return out;
  }
  function translate(out, a4, v5) {
    var x4 = v5[0], y3 = v5[1], z4 = v5[2];
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    if (a4 === out) {
      out[12] = a4[0] * x4 + a4[4] * y3 + a4[8] * z4 + a4[12];
      out[13] = a4[1] * x4 + a4[5] * y3 + a4[9] * z4 + a4[13];
      out[14] = a4[2] * x4 + a4[6] * y3 + a4[10] * z4 + a4[14];
      out[15] = a4[3] * x4 + a4[7] * y3 + a4[11] * z4 + a4[15];
    } else {
      a00 = a4[0];
      a01 = a4[1];
      a02 = a4[2];
      a03 = a4[3];
      a10 = a4[4];
      a11 = a4[5];
      a12 = a4[6];
      a13 = a4[7];
      a20 = a4[8];
      a21 = a4[9];
      a22 = a4[10];
      a23 = a4[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x4 + a10 * y3 + a20 * z4 + a4[12];
      out[13] = a01 * x4 + a11 * y3 + a21 * z4 + a4[13];
      out[14] = a02 * x4 + a12 * y3 + a22 * z4 + a4[14];
      out[15] = a03 * x4 + a13 * y3 + a23 * z4 + a4[15];
    }
    return out;
  }
  function scale3(out, a4, v5) {
    var x4 = v5[0], y3 = v5[1], z4 = v5[2];
    out[0] = a4[0] * x4;
    out[1] = a4[1] * x4;
    out[2] = a4[2] * x4;
    out[3] = a4[3] * x4;
    out[4] = a4[4] * y3;
    out[5] = a4[5] * y3;
    out[6] = a4[6] * y3;
    out[7] = a4[7] * y3;
    out[8] = a4[8] * z4;
    out[9] = a4[9] * z4;
    out[10] = a4[10] * z4;
    out[11] = a4[11] * z4;
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
    return out;
  }
  function rotate(out, a4, rad, axis) {
    var x4 = axis[0], y3 = axis[1], z4 = axis[2];
    var len2 = Math.sqrt(x4 * x4 + y3 * y3 + z4 * z4);
    var s4 = void 0, c5 = void 0, t4 = void 0;
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    var b00 = void 0, b01 = void 0, b02 = void 0;
    var b10 = void 0, b11 = void 0, b12 = void 0;
    var b20 = void 0, b21 = void 0, b22 = void 0;
    if (len2 < EPSILON2) {
      return null;
    }
    len2 = 1 / len2;
    x4 *= len2;
    y3 *= len2;
    z4 *= len2;
    s4 = Math.sin(rad);
    c5 = Math.cos(rad);
    t4 = 1 - c5;
    a00 = a4[0];
    a01 = a4[1];
    a02 = a4[2];
    a03 = a4[3];
    a10 = a4[4];
    a11 = a4[5];
    a12 = a4[6];
    a13 = a4[7];
    a20 = a4[8];
    a21 = a4[9];
    a22 = a4[10];
    a23 = a4[11];
    b00 = x4 * x4 * t4 + c5;
    b01 = y3 * x4 * t4 + z4 * s4;
    b02 = z4 * x4 * t4 - y3 * s4;
    b10 = x4 * y3 * t4 - z4 * s4;
    b11 = y3 * y3 * t4 + c5;
    b12 = z4 * y3 * t4 + x4 * s4;
    b20 = x4 * z4 * t4 + y3 * s4;
    b21 = y3 * z4 * t4 - x4 * s4;
    b22 = z4 * z4 * t4 + c5;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a4 !== out) {
      out[12] = a4[12];
      out[13] = a4[13];
      out[14] = a4[14];
      out[15] = a4[15];
    }
    return out;
  }
  function rotateX(out, a4, rad) {
    var s4 = Math.sin(rad);
    var c5 = Math.cos(rad);
    var a10 = a4[4];
    var a11 = a4[5];
    var a12 = a4[6];
    var a13 = a4[7];
    var a20 = a4[8];
    var a21 = a4[9];
    var a22 = a4[10];
    var a23 = a4[11];
    if (a4 !== out) {
      out[0] = a4[0];
      out[1] = a4[1];
      out[2] = a4[2];
      out[3] = a4[3];
      out[12] = a4[12];
      out[13] = a4[13];
      out[14] = a4[14];
      out[15] = a4[15];
    }
    out[4] = a10 * c5 + a20 * s4;
    out[5] = a11 * c5 + a21 * s4;
    out[6] = a12 * c5 + a22 * s4;
    out[7] = a13 * c5 + a23 * s4;
    out[8] = a20 * c5 - a10 * s4;
    out[9] = a21 * c5 - a11 * s4;
    out[10] = a22 * c5 - a12 * s4;
    out[11] = a23 * c5 - a13 * s4;
    return out;
  }
  function rotateY(out, a4, rad) {
    var s4 = Math.sin(rad);
    var c5 = Math.cos(rad);
    var a00 = a4[0];
    var a01 = a4[1];
    var a02 = a4[2];
    var a03 = a4[3];
    var a20 = a4[8];
    var a21 = a4[9];
    var a22 = a4[10];
    var a23 = a4[11];
    if (a4 !== out) {
      out[4] = a4[4];
      out[5] = a4[5];
      out[6] = a4[6];
      out[7] = a4[7];
      out[12] = a4[12];
      out[13] = a4[13];
      out[14] = a4[14];
      out[15] = a4[15];
    }
    out[0] = a00 * c5 - a20 * s4;
    out[1] = a01 * c5 - a21 * s4;
    out[2] = a02 * c5 - a22 * s4;
    out[3] = a03 * c5 - a23 * s4;
    out[8] = a00 * s4 + a20 * c5;
    out[9] = a01 * s4 + a21 * c5;
    out[10] = a02 * s4 + a22 * c5;
    out[11] = a03 * s4 + a23 * c5;
    return out;
  }
  function rotateZ(out, a4, rad) {
    var s4 = Math.sin(rad);
    var c5 = Math.cos(rad);
    var a00 = a4[0];
    var a01 = a4[1];
    var a02 = a4[2];
    var a03 = a4[3];
    var a10 = a4[4];
    var a11 = a4[5];
    var a12 = a4[6];
    var a13 = a4[7];
    if (a4 !== out) {
      out[8] = a4[8];
      out[9] = a4[9];
      out[10] = a4[10];
      out[11] = a4[11];
      out[12] = a4[12];
      out[13] = a4[13];
      out[14] = a4[14];
      out[15] = a4[15];
    }
    out[0] = a00 * c5 + a10 * s4;
    out[1] = a01 * c5 + a11 * s4;
    out[2] = a02 * c5 + a12 * s4;
    out[3] = a03 * c5 + a13 * s4;
    out[4] = a10 * c5 - a00 * s4;
    out[5] = a11 * c5 - a01 * s4;
    out[6] = a12 * c5 - a02 * s4;
    out[7] = a13 * c5 - a03 * s4;
    return out;
  }
  function fromTranslation(out, v5) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v5[0];
    out[13] = v5[1];
    out[14] = v5[2];
    out[15] = 1;
    return out;
  }
  function fromScaling(out, v5) {
    out[0] = v5[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v5[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v5[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation(out, rad, axis) {
    var x4 = axis[0], y3 = axis[1], z4 = axis[2];
    var len2 = Math.sqrt(x4 * x4 + y3 * y3 + z4 * z4);
    var s4 = void 0, c5 = void 0, t4 = void 0;
    if (len2 < EPSILON2) {
      return null;
    }
    len2 = 1 / len2;
    x4 *= len2;
    y3 *= len2;
    z4 *= len2;
    s4 = Math.sin(rad);
    c5 = Math.cos(rad);
    t4 = 1 - c5;
    out[0] = x4 * x4 * t4 + c5;
    out[1] = y3 * x4 * t4 + z4 * s4;
    out[2] = z4 * x4 * t4 - y3 * s4;
    out[3] = 0;
    out[4] = x4 * y3 * t4 - z4 * s4;
    out[5] = y3 * y3 * t4 + c5;
    out[6] = z4 * y3 * t4 + x4 * s4;
    out[7] = 0;
    out[8] = x4 * z4 * t4 + y3 * s4;
    out[9] = y3 * z4 * t4 - x4 * s4;
    out[10] = z4 * z4 * t4 + c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    var s4 = Math.sin(rad);
    var c5 = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c5;
    out[6] = s4;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s4;
    out[10] = c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    var s4 = Math.sin(rad);
    var c5 = Math.cos(rad);
    out[0] = c5;
    out[1] = 0;
    out[2] = -s4;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s4;
    out[9] = 0;
    out[10] = c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    var s4 = Math.sin(rad);
    var c5 = Math.cos(rad);
    out[0] = c5;
    out[1] = s4;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s4;
    out[5] = c5;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation2(out, q4, v5) {
    var x4 = q4[0], y3 = q4[1], z4 = q4[2], w3 = q4[3];
    var x22 = x4 + x4;
    var y22 = y3 + y3;
    var z22 = z4 + z4;
    var xx = x4 * x22;
    var xy = x4 * y22;
    var xz = x4 * z22;
    var yy = y3 * y22;
    var yz = y3 * z22;
    var zz = z4 * z22;
    var wx2 = w3 * x22;
    var wy = w3 * y22;
    var wz = w3 * z22;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx2;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx2;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v5[0];
    out[13] = v5[1];
    out[14] = v5[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a4) {
    var translation = new ARRAY_TYPE2(3);
    var bx = -a4[0], by = -a4[1], bz = -a4[2], bw2 = a4[3], ax = a4[4], ay = a4[5], az = a4[6], aw = a4[7];
    var magnitude = bx * bx + by * by + bz * bz + bw2 * bw2;
    if (magnitude > 0) {
      translation[0] = (ax * bw2 + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw2 + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw2 + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw2 + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw2 + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw2 + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation2(out, a4, translation);
    return out;
  }
  function getTranslation2(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  function getRotation2(out, mat) {
    var trace = mat[0] + mat[5] + mat[10];
    var S3 = 0;
    if (trace > 0) {
      S3 = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S3;
      out[0] = (mat[6] - mat[9]) / S3;
      out[1] = (mat[8] - mat[2]) / S3;
      out[2] = (mat[1] - mat[4]) / S3;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
      S3 = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
      out[3] = (mat[6] - mat[9]) / S3;
      out[0] = 0.25 * S3;
      out[1] = (mat[1] + mat[4]) / S3;
      out[2] = (mat[8] + mat[2]) / S3;
    } else if (mat[5] > mat[10]) {
      S3 = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
      out[3] = (mat[8] - mat[2]) / S3;
      out[0] = (mat[1] + mat[4]) / S3;
      out[1] = 0.25 * S3;
      out[2] = (mat[6] + mat[9]) / S3;
    } else {
      S3 = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
      out[3] = (mat[1] - mat[4]) / S3;
      out[0] = (mat[8] + mat[2]) / S3;
      out[1] = (mat[6] + mat[9]) / S3;
      out[2] = 0.25 * S3;
    }
    return out;
  }
  function fromRotationTranslationScale(out, q4, v5, s4) {
    var x4 = q4[0], y3 = q4[1], z4 = q4[2], w3 = q4[3];
    var x22 = x4 + x4;
    var y22 = y3 + y3;
    var z22 = z4 + z4;
    var xx = x4 * x22;
    var xy = x4 * y22;
    var xz = x4 * z22;
    var yy = y3 * y22;
    var yz = y3 * z22;
    var zz = z4 * z22;
    var wx2 = w3 * x22;
    var wy = w3 * y22;
    var wz = w3 * z22;
    var sx = s4[0];
    var sy = s4[1];
    var sz = s4[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx2) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx2) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v5[0];
    out[13] = v5[1];
    out[14] = v5[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q4, v5, s4, o4) {
    var x4 = q4[0], y3 = q4[1], z4 = q4[2], w3 = q4[3];
    var x22 = x4 + x4;
    var y22 = y3 + y3;
    var z22 = z4 + z4;
    var xx = x4 * x22;
    var xy = x4 * y22;
    var xz = x4 * z22;
    var yy = y3 * y22;
    var yz = y3 * z22;
    var zz = z4 * z22;
    var wx2 = w3 * x22;
    var wy = w3 * y22;
    var wz = w3 * z22;
    var sx = s4[0];
    var sy = s4[1];
    var sz = s4[2];
    var ox = o4[0];
    var oy = o4[1];
    var oz = o4[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx2) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx2) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v5[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v5[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v5[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat(out, q4) {
    var x4 = q4[0], y3 = q4[1], z4 = q4[2], w3 = q4[3];
    var x22 = x4 + x4;
    var y22 = y3 + y3;
    var z22 = z4 + z4;
    var xx = x4 * x22;
    var yx = y3 * x22;
    var yy = y3 * y22;
    var zx = z4 * x22;
    var zy = z4 * y22;
    var zz = z4 * z22;
    var wx2 = w3 * x22;
    var wy = w3 * y22;
    var wz = w3 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx2;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx2;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl3 = 1 / (right - left);
    var tb2 = 1 / (top - bottom);
    var nf2 = 1 / (near - far);
    out[0] = near * 2 * rl3;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb2;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl3;
    out[9] = (top + bottom) * tb2;
    out[10] = (far + near) * nf2;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf2;
    out[15] = 0;
    return out;
  }
  function perspective2(out, fovy, aspect2, near, far) {
    var f3 = 1 / Math.tan(fovy / 2), nf2 = void 0;
    out[0] = f3 / aspect2;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f3;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf2 = 1 / (near - far);
      out[10] = (far + near) * nf2;
      out[14] = 2 * far * near * nf2;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov2, near, far) {
    var upTan = Math.tan(fov2.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov2.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov2.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov2.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function ortho(out, left, right, bottom, top, near, far) {
    var lr4 = 1 / (left - right);
    var bt4 = 1 / (bottom - top);
    var nf2 = 1 / (near - far);
    out[0] = -2 * lr4;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf2;
    out[11] = 0;
    out[12] = (left + right) * lr4;
    out[13] = (top + bottom) * bt4;
    out[14] = (far + near) * nf2;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up2) {
    var x0 = void 0, x1 = void 0, x22 = void 0, y0 = void 0, y1 = void 0, y22 = void 0, z0 = void 0, z1 = void 0, z22 = void 0, len2 = void 0;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up2[0];
    var upy = up2[1];
    var upz = up2[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON2 && Math.abs(eyey - centery) < EPSILON2 && Math.abs(eyez - centerz) < EPSILON2) {
      return identity2(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z22 = eyez - centerz;
    len2 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z22 * z22);
    z0 *= len2;
    z1 *= len2;
    z22 *= len2;
    x0 = upy * z22 - upz * z1;
    x1 = upz * z0 - upx * z22;
    x22 = upx * z1 - upy * z0;
    len2 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len2) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len2 = 1 / len2;
      x0 *= len2;
      x1 *= len2;
      x22 *= len2;
    }
    y0 = z1 * x22 - z22 * x1;
    y1 = z22 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len2 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len2) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len2 = 1 / len2;
      y0 *= len2;
      y1 *= len2;
      y22 *= len2;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z22;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z22 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up2) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up2[0], upy = up2[1], upz = up2[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z22 = eyez - target[2];
    var len2 = z0 * z0 + z1 * z1 + z22 * z22;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
      z0 *= len2;
      z1 *= len2;
      z22 *= len2;
    }
    var x0 = upy * z22 - upz * z1, x1 = upz * z0 - upx * z22, x22 = upx * z1 - upy * z0;
    len2 = x0 * x0 + x1 * x1 + x22 * x22;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
      x0 *= len2;
      x1 *= len2;
      x22 *= len2;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x22;
    out[3] = 0;
    out[4] = z1 * x22 - z22 * x1;
    out[5] = z22 * x0 - z0 * x22;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z22;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str(a4) {
    return "mat4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ", " + a4[9] + ", " + a4[10] + ", " + a4[11] + ", " + a4[12] + ", " + a4[13] + ", " + a4[14] + ", " + a4[15] + ")";
  }
  function frob(a4) {
    return Math.sqrt(Math.pow(a4[0], 2) + Math.pow(a4[1], 2) + Math.pow(a4[2], 2) + Math.pow(a4[3], 2) + Math.pow(a4[4], 2) + Math.pow(a4[5], 2) + Math.pow(a4[6], 2) + Math.pow(a4[7], 2) + Math.pow(a4[8], 2) + Math.pow(a4[9], 2) + Math.pow(a4[10], 2) + Math.pow(a4[11], 2) + Math.pow(a4[12], 2) + Math.pow(a4[13], 2) + Math.pow(a4[14], 2) + Math.pow(a4[15], 2));
  }
  function add3(out, a4, b3) {
    out[0] = a4[0] + b3[0];
    out[1] = a4[1] + b3[1];
    out[2] = a4[2] + b3[2];
    out[3] = a4[3] + b3[3];
    out[4] = a4[4] + b3[4];
    out[5] = a4[5] + b3[5];
    out[6] = a4[6] + b3[6];
    out[7] = a4[7] + b3[7];
    out[8] = a4[8] + b3[8];
    out[9] = a4[9] + b3[9];
    out[10] = a4[10] + b3[10];
    out[11] = a4[11] + b3[11];
    out[12] = a4[12] + b3[12];
    out[13] = a4[13] + b3[13];
    out[14] = a4[14] + b3[14];
    out[15] = a4[15] + b3[15];
    return out;
  }
  function subtract(out, a4, b3) {
    out[0] = a4[0] - b3[0];
    out[1] = a4[1] - b3[1];
    out[2] = a4[2] - b3[2];
    out[3] = a4[3] - b3[3];
    out[4] = a4[4] - b3[4];
    out[5] = a4[5] - b3[5];
    out[6] = a4[6] - b3[6];
    out[7] = a4[7] - b3[7];
    out[8] = a4[8] - b3[8];
    out[9] = a4[9] - b3[9];
    out[10] = a4[10] - b3[10];
    out[11] = a4[11] - b3[11];
    out[12] = a4[12] - b3[12];
    out[13] = a4[13] - b3[13];
    out[14] = a4[14] - b3[14];
    out[15] = a4[15] - b3[15];
    return out;
  }
  function multiplyScalar(out, a4, b3) {
    out[0] = a4[0] * b3;
    out[1] = a4[1] * b3;
    out[2] = a4[2] * b3;
    out[3] = a4[3] * b3;
    out[4] = a4[4] * b3;
    out[5] = a4[5] * b3;
    out[6] = a4[6] * b3;
    out[7] = a4[7] * b3;
    out[8] = a4[8] * b3;
    out[9] = a4[9] * b3;
    out[10] = a4[10] * b3;
    out[11] = a4[11] * b3;
    out[12] = a4[12] * b3;
    out[13] = a4[13] * b3;
    out[14] = a4[14] * b3;
    out[15] = a4[15] * b3;
    return out;
  }
  function multiplyScalarAndAdd(out, a4, b3, scale4) {
    out[0] = a4[0] + b3[0] * scale4;
    out[1] = a4[1] + b3[1] * scale4;
    out[2] = a4[2] + b3[2] * scale4;
    out[3] = a4[3] + b3[3] * scale4;
    out[4] = a4[4] + b3[4] * scale4;
    out[5] = a4[5] + b3[5] * scale4;
    out[6] = a4[6] + b3[6] * scale4;
    out[7] = a4[7] + b3[7] * scale4;
    out[8] = a4[8] + b3[8] * scale4;
    out[9] = a4[9] + b3[9] * scale4;
    out[10] = a4[10] + b3[10] * scale4;
    out[11] = a4[11] + b3[11] * scale4;
    out[12] = a4[12] + b3[12] * scale4;
    out[13] = a4[13] + b3[13] * scale4;
    out[14] = a4[14] + b3[14] * scale4;
    out[15] = a4[15] + b3[15] * scale4;
    return out;
  }
  function exactEquals2(a4, b3) {
    return a4[0] === b3[0] && a4[1] === b3[1] && a4[2] === b3[2] && a4[3] === b3[3] && a4[4] === b3[4] && a4[5] === b3[5] && a4[6] === b3[6] && a4[7] === b3[7] && a4[8] === b3[8] && a4[9] === b3[9] && a4[10] === b3[10] && a4[11] === b3[11] && a4[12] === b3[12] && a4[13] === b3[13] && a4[14] === b3[14] && a4[15] === b3[15];
  }
  function equals2(a4, b3) {
    var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
    var a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7];
    var a8 = a4[8], a9 = a4[9], a10 = a4[10], a11 = a4[11];
    var a12 = a4[12], a13 = a4[13], a14 = a4[14], a15 = a4[15];
    var b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3];
    var b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7];
    var b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11];
    var b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
    return Math.abs(a0 - b0) <= EPSILON2 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON2 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON2 * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON2 * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a42 - b4) <= EPSILON2 * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON2 * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON2 * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON2 * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON2 * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON2 * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON2 * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON2 * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON2 * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON2 * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON2 * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON2 * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul, sub;
  var init_mat42 = __esm({
    "node_modules/gl-matrix/lib/gl-matrix/mat4.js"() {
      init_common2();
      mul = multiply3;
      sub = subtract;
    }
  });

  // node_modules/gl-matrix/lib/gl-matrix.js
  var init_gl_matrix = __esm({
    "node_modules/gl-matrix/lib/gl-matrix.js"() {
      init_mat42();
    }
  });

  // node_modules/@lookingglass/webxr/dist/webxr.js
  var webxr_exports = {};
  __export(webxr_exports, {
    LookingGlassConfig: () => Xe2,
    LookingGlassWebXRPolyfill: () => $2
  });
  function F() {
    return U2 == null && (U2 = new we()), U2;
  }
  function z(n4) {
    const i5 = F();
    n4 != null && i5.updateViewControls(n4);
  }
  async function Ee() {
    const n4 = F();
    let i5 = 2;
    function e4() {
      if (n4.appCanvas != null)
        try {
          let t4 = n4.appCanvas.toDataURL();
          const o4 = document.createElement("a");
          o4.style.display = "none", o4.href = t4, o4.download = `hologram_qs${n4.quiltWidth}x${n4.quiltHeight}a${n4.aspect}.png`, document.body.appendChild(o4), o4.click(), document.body.removeChild(o4), window.URL.revokeObjectURL(t4);
        } catch (t4) {
          console.error("Error while capturing canvas data:", t4);
        } finally {
          n4.inlineView = i5;
        }
    }
    const s4 = document.getElementById("screenshotbutton");
    s4 && s4.addEventListener("click", () => {
      i5 = n4.inlineView;
      const t4 = V.getInstance();
      if (!t4) {
        console.warn("LookingGlassXRDevice not initialized");
        return;
      }
      n4.inlineView = 2, t4.captureScreenshot = true, setTimeout(() => {
        t4.screenshotCallback = e4;
      }, 100);
    });
  }
  function ye2() {
    var i5;
    const n4 = F();
    if (console.log(n4, "for debugging purposes"), n4.lkgCanvas == null)
      console.warn("window placement called without a valid XR Session!");
    else {
      let e4 = function() {
        let r4 = v5.d - v5.a, c5 = v5.w - v5.s;
        r4 && c5 && (r4 *= Math.sqrt(0.5), c5 *= Math.sqrt(0.5));
        const u4 = n4.trackballX, f3 = n4.trackballY, y3 = Math.cos(u4) * r4 - Math.sin(u4) * Math.cos(f3) * c5, S3 = -Math.sin(f3) * c5, _4 = -Math.sin(u4) * r4 - Math.cos(u4) * Math.cos(f3) * c5;
        n4.targetX = n4.targetX + y3 * n4.targetDiam * 0.03, n4.targetY = n4.targetY + S3 * n4.targetDiam * 0.03, n4.targetZ = n4.targetZ + _4 * n4.targetDiam * 0.03, requestAnimationFrame(e4);
      };
      const s4 = document.createElement("style");
      document.head.appendChild(s4), (i5 = s4.sheet) == null || i5.insertRule("#LookingGlassWebXRControls * { all: revert; font-family: sans-serif }");
      const t4 = document.createElement("div");
      t4.id = "LookingGlassWebXRControls", t4.style.position = "fixed", t4.style.zIndex = "1000", t4.style.padding = "15px", t4.style.width = "320px", t4.style.maxWidth = "calc(100vw - 18px)", t4.style.maxHeight = "calc(100vh - 18px)", t4.style.whiteSpace = "nowrap", t4.style.background = "rgba(0, 0, 0, 0.6)", t4.style.color = "white", t4.style.borderRadius = "10px", t4.style.right = "15px", t4.style.bottom = "15px", t4.style.flex = "row";
      const o4 = document.createElement("div");
      t4.appendChild(o4), o4.style.width = "100%", o4.style.textAlign = "center", o4.style.fontWeight = "bold", o4.style.marginBottom = "8px", o4.innerText = "Looking Glass Controls";
      const l4 = document.createElement("button");
      l4.style.display = "block", l4.style.margin = "auto", l4.style.width = "100%", l4.style.height = "35px", l4.style.padding = "4px", l4.style.marginBottom = "8px", l4.style.borderRadius = "8px", l4.id = "screenshotbutton", t4.appendChild(l4), l4.innerText = "Save Hologram";
      const h4 = document.createElement("button");
      h4.style.display = "block", h4.style.margin = "auto", h4.style.width = "100%", h4.style.height = "35px", h4.style.padding = "4px", h4.style.marginBottom = "8px", h4.style.borderRadius = "8px", h4.id = "copybutton", t4.appendChild(h4), h4.innerText = "Copy Config", h4.addEventListener("click", () => {
        ge(n4);
      });
      const p4 = document.createElement("div");
      t4.appendChild(p4), p4.style.width = "290px", p4.style.whiteSpace = "normal", p4.style.color = "rgba(255,255,255,0.7)", p4.style.fontSize = "14px", p4.style.margin = "5px 0", p4.innerHTML = "Click the popup and use WASD, mouse left/right drag, and scroll.";
      const M4 = document.createElement("div");
      t4.appendChild(M4);
      const x4 = (r4, c5, u4) => {
        const f3 = u4.stringify, y3 = document.createElement("div");
        y3.style.marginBottom = "8px", M4.appendChild(y3);
        const S3 = r4, _4 = n4[r4], w3 = document.createElement("label");
        y3.appendChild(w3), w3.innerText = u4.label, w3.setAttribute("for", S3), w3.style.width = "100px", w3.style.display = "inline-block", w3.style.textDecoration = "dotted underline 1px", w3.style.fontFamily = '"Courier New"', w3.style.fontSize = "13px", w3.style.fontWeight = "bold", w3.title = u4.title;
        const m4 = document.createElement("input");
        y3.appendChild(m4), Object.assign(m4, c5), m4.id = S3, m4.title = u4.title, m4.value = c5.value !== void 0 ? c5.value : _4;
        const I3 = (b3) => {
          n4[r4] = b3, P4(b3);
        };
        m4.oninput = () => {
          const b3 = c5.type === "range" ? parseFloat(m4.value) : c5.type === "checkbox" ? m4.checked : m4.value;
          I3(b3);
        };
        const A3 = (b3) => {
          let k4 = b3(n4[r4]);
          u4.fixRange && (k4 = u4.fixRange(k4), m4.max = Math.max(parseFloat(m4.max), k4).toString(), m4.min = Math.min(parseFloat(m4.min), k4).toString()), m4.value = k4, I3(k4);
        };
        c5.type === "range" && (m4.style.width = "110px", m4.style.height = "8px", m4.onwheel = (b3) => {
          A3((k4) => k4 + Math.sign(b3.deltaX - b3.deltaY) * c5.step);
        });
        let P4 = (b3) => {
        };
        if (f3) {
          const b3 = document.createElement("span");
          b3.style.fontFamily = '"Courier New"', b3.style.fontSize = "13px", b3.style.marginLeft = "3px", y3.appendChild(b3), P4 = (k4) => {
            b3.innerHTML = f3(k4);
          }, P4(_4);
        }
        return A3;
      };
      x4("fovy", {
        type: "range",
        min: 1 / 180 * Math.PI,
        max: 120.1 / 180 * Math.PI,
        step: 1 / 180 * Math.PI
      }, {
        label: "fov",
        title: "perspective fov (degrades stereo effect)",
        fixRange: (r4) => Math.max(1 / 180 * Math.PI, Math.min(r4, 120.1 / 180 * Math.PI)),
        stringify: (r4) => {
          const c5 = r4 / Math.PI * 180, u4 = Math.atan(Math.tan(r4 / 2) * n4.aspect) * 2 / Math.PI * 180;
          return `${c5.toFixed()}&deg;&times;${u4.toFixed()}&deg;`;
        }
      }), x4("depthiness", { type: "range", min: 0, max: 2, step: 0.01 }, {
        label: "depthiness",
        title: "exaggerates depth by multiplying the width of the view cone (as reported by the firmware) - can somewhat compensate for depthiness lost using higher fov.",
        fixRange: (r4) => Math.max(0, r4),
        stringify: (r4) => `${r4.toFixed(2)}x`
      }), x4("inlineView", { type: "range", min: 0, max: 2, step: 1 }, {
        label: "inline view",
        title: "what to show inline on the original canvas (swizzled = no overwrite)",
        fixRange: (r4) => Math.max(0, Math.min(r4, 2)),
        stringify: (r4) => r4 === 0 ? "swizzled" : r4 === 1 ? "center" : r4 === 2 ? "quilt" : "?"
      }), n4.lkgCanvas.oncontextmenu = (r4) => {
        r4.preventDefault();
      }, n4.lkgCanvas.addEventListener("wheel", (r4) => {
        const c5 = n4.targetDiam, u4 = 1.1, f3 = Math.log(c5) / Math.log(u4);
        return n4.targetDiam = Math.pow(u4, f3 + r4.deltaY * 0.01);
      }), n4.lkgCanvas.addEventListener("mousemove", (r4) => {
        const c5 = r4.movementX, u4 = -r4.movementY;
        if (r4.buttons & 2 || r4.buttons & 1 && (r4.shiftKey || r4.ctrlKey)) {
          const f3 = n4.trackballX, y3 = n4.trackballY, S3 = -Math.cos(f3) * c5 + Math.sin(f3) * Math.sin(y3) * u4, _4 = -Math.cos(y3) * u4, w3 = Math.sin(f3) * c5 + Math.cos(f3) * Math.sin(y3) * u4;
          n4.targetX = n4.targetX + S3 * n4.targetDiam * 1e-3, n4.targetY = n4.targetY + _4 * n4.targetDiam * 1e-3, n4.targetZ = n4.targetZ + w3 * n4.targetDiam * 1e-3;
        } else
          r4.buttons & 1 && (n4.trackballX = n4.trackballX - c5 * 0.01, n4.trackballY = n4.trackballY - u4 * 0.01);
      });
      const v5 = { w: 0, a: 0, s: 0, d: 0 };
      return n4.lkgCanvas.addEventListener("keydown", (r4) => {
        switch (r4.code) {
          case "KeyW":
            v5.w = 1;
            break;
          case "KeyA":
            v5.a = 1;
            break;
          case "KeyS":
            v5.s = 1;
            break;
          case "KeyD":
            v5.d = 1;
            break;
        }
      }), n4.lkgCanvas.addEventListener("keyup", (r4) => {
        switch (r4.code) {
          case "KeyW":
            v5.w = 0;
            break;
          case "KeyA":
            v5.a = 0;
            break;
          case "KeyS":
            v5.s = 0;
            break;
          case "KeyD":
            v5.d = 0;
            break;
        }
      }), requestAnimationFrame(e4), setTimeout(() => {
        Ee();
      }, 1e3), t4;
    }
  }
  function ge(n4) {
    const i5 = {
      targetX: n4.targetX,
      targetY: n4.targetY,
      targetZ: n4.targetZ,
      fovy: `${Math.round(n4.fovy / Math.PI * 180)} * Math.PI / 180`,
      targetDiam: n4.targetDiam,
      trackballX: n4.trackballX,
      trackballY: n4.trackballY,
      depthiness: n4.depthiness
    };
    let e4 = JSON.stringify(i5, null, 4).replace(/"/g, "").replace(/{/g, "").replace(/}/g, "");
    navigator.clipboard.writeText(e4);
  }
  async function Re(n4, i5, e4) {
    const s4 = await window.getScreenDetails();
    console.log(s4);
    const t4 = s4.screens.filter((o4) => o4.label.includes("LKG"))[0];
    if (console.log(t4, "monitors"), t4 === void 0) {
      console.log("no Looking Glass monitor detected - manually opening popup window"), K2(i5, n4, e4);
      return;
    } else {
      console.log("monitor ID", t4.label, "serial number", i5.calibration);
      const o4 = [
        `left=${t4.left}`,
        `top=${t4.top}`,
        `width=${t4.width}`,
        `height=${t4.height}`,
        "menubar=no",
        "toolbar=no",
        "location=no",
        "status=no",
        "resizable=yes",
        "scrollbars=no",
        "fullscreenEnabled=true"
      ].join(",");
      i5.popup = window.open("", "new", o4), i5.popup && (i5.popup.document.body.style.background = "black", i5.popup.document.body.style.transform = "1.0", j(i5), i5.popup.document.body.appendChild(n4), console.assert(e4), i5.popup.onbeforeunload = e4);
    }
  }
  function K2(n4, i5, e4) {
    n4.popup = window.open("", void 0, "width=640,height=360"), n4.popup && (n4.popup.document.title = "Looking Glass Window (fullscreen me on Looking Glass!)", n4.popup.document.body.style.background = "black", n4.popup.document.body.style.transform = "1.0", j(n4), n4.popup.document.body.appendChild(i5), console.assert(e4), n4.popup.onbeforeunload = e4);
  }
  function Te(n4, i5) {
    var e4;
    (e4 = i5.parentElement) == null || e4.removeChild(i5), n4.popup && (n4.popup.onbeforeunload = null, n4.popup.close(), n4.popup = null);
  }
  function j(n4) {
    n4.popup && n4.popup.document.addEventListener("keydown", (i5) => {
      i5.ctrlKey && (i5.key === "=" || i5.key === "-" || i5.key === "+") && i5.preventDefault();
    });
  }
  async function ke(n4) {
    return new Promise((i5) => {
      const e4 = new MutationObserver(function(s4) {
        s4.forEach(function(t4) {
          t4.addedNodes.forEach(function(o4) {
            const l4 = o4;
            l4.id === n4 && (i5(l4), e4.disconnect());
          });
        });
      });
      e4.observe(document.body, { subtree: false, childList: true }), setTimeout(() => {
        e4.disconnect(), i5(null);
      }, 5e3);
    });
  }
  function Fe(n4) {
    return new Promise((i5) => setTimeout(i5, n4));
  }
  var ce2, ue, R2, H, O2, we, U2, G, Ce2, B, xe2, N, V, Le2, _e2, Se, $2, Xe2;
  var init_webxr = __esm({
    "node_modules/@lookingglass/webxr/dist/webxr.js"() {
      init_api2();
      init_XRSystem();
      init_WebXRPolyfill();
      init_holoplaycore_module();
      init_holoplaycore_module();
      init_XRDevice();
      init_XRSpace();
      init_gl_matrix();
      init_XRWebGLLayer();
      ce2 = Object.defineProperty;
      ue = (n4, i5, e4) => i5 in n4 ? ce2(n4, i5, { enumerable: true, configurable: true, writable: true, value: e4 }) : n4[i5] = e4;
      R2 = (n4, i5, e4) => (ue(n4, typeof i5 != "symbol" ? i5 + "" : i5, e4), e4);
      H = 1.6;
      (function(n4) {
        n4[n4.Swizzled = 0] = "Swizzled", n4[n4.Center = 1] = "Center", n4[n4.Quilt = 2] = "Quilt";
      })(O2 || (O2 = {}));
      we = class extends EventTarget {
        constructor(e4) {
          super();
          R2(this, "_calibration", {
            configVersion: "1.0",
            pitch: { value: 45 },
            slope: { value: -5 },
            center: { value: -0.5 },
            viewCone: { value: 40 },
            invView: { value: 1 },
            verticalAngle: { value: 0 },
            DPI: { value: 338 },
            screenW: { value: 250 },
            screenH: { value: 250 },
            flipImageX: { value: 0 },
            flipImageY: { value: 0 },
            flipSubp: { value: 0 },
            serial: "LKG-DEFAULT-#####"
          });
          R2(this, "_viewControls", {
            tileHeight: 512,
            numViews: 48,
            trackballX: 0,
            trackballY: 0,
            targetX: 0,
            targetY: H,
            targetZ: -0.5,
            targetDiam: 2,
            fovy: 13 / 180 * Math.PI,
            depthiness: 1.25,
            inlineView: O2.Center,
            capturing: false,
            quiltResolution: 3840,
            popup: null,
            XRSession: null,
            lkgCanvas: null,
            appCanvas: null
          });
          R2(this, "LookingGlassDetected");
          this._viewControls = { ...this._viewControls, ...e4 }, this.syncCalibration();
        }
        syncCalibration() {
          new Client((e4) => {
            if (e4.devices.length < 1) {
              console.log("No Looking Glass devices found");
              return;
            }
            e4.devices.length > 1 && console.log("More than one Looking Glass device found... using the first one"), this.calibration = e4.devices[0].calibration;
          });
        }
        addEventListener(e4, s4, t4) {
          super.addEventListener(e4, s4, t4);
        }
        onConfigChange() {
          this.dispatchEvent(new Event("on-config-changed"));
        }
        get calibration() {
          return this._calibration;
        }
        set calibration(e4) {
          this._calibration = {
            ...this._calibration,
            ...e4
          }, this.onConfigChange();
        }
        updateViewControls(e4) {
          e4 != null && (this._viewControls = {
            ...this._viewControls,
            ...e4
          }, this.onConfigChange());
        }
        get tileHeight() {
          return Math.round(this.framebufferHeight / this.quiltHeight);
        }
        get quiltResolution() {
          return this._viewControls.quiltResolution;
        }
        set quiltResolution(e4) {
          this.updateViewControls({ quiltResolution: e4 });
        }
        get numViews() {
          return this.quiltWidth * this.quiltHeight;
        }
        get targetX() {
          return this._viewControls.targetX;
        }
        set targetX(e4) {
          this.updateViewControls({ targetX: e4 });
        }
        get targetY() {
          return this._viewControls.targetY;
        }
        set targetY(e4) {
          this.updateViewControls({ targetY: e4 });
        }
        get targetZ() {
          return this._viewControls.targetZ;
        }
        set targetZ(e4) {
          this.updateViewControls({ targetZ: e4 });
        }
        get trackballX() {
          return this._viewControls.trackballX;
        }
        set trackballX(e4) {
          this.updateViewControls({ trackballX: e4 });
        }
        get trackballY() {
          return this._viewControls.trackballY;
        }
        set trackballY(e4) {
          this.updateViewControls({ trackballY: e4 });
        }
        get targetDiam() {
          return this._viewControls.targetDiam;
        }
        set targetDiam(e4) {
          this.updateViewControls({ targetDiam: e4 });
        }
        get fovy() {
          return this._viewControls.fovy;
        }
        set fovy(e4) {
          this.updateViewControls({ fovy: e4 });
        }
        get depthiness() {
          return this._viewControls.depthiness;
        }
        set depthiness(e4) {
          this.updateViewControls({ depthiness: e4 });
        }
        get inlineView() {
          return this._viewControls.inlineView;
        }
        set inlineView(e4) {
          this.updateViewControls({ inlineView: e4 });
        }
        get capturing() {
          return this._viewControls.capturing;
        }
        set capturing(e4) {
          this.updateViewControls({ capturing: e4 });
        }
        get popup() {
          return this._viewControls.popup;
        }
        set popup(e4) {
          this.updateViewControls({ popup: e4 });
        }
        get XRSession() {
          return this._viewControls.XRSession;
        }
        set XRSession(e4) {
          this.updateViewControls({ XRSession: e4 });
        }
        get lkgCanvas() {
          return this._viewControls.lkgCanvas;
        }
        set lkgCanvas(e4) {
          this.updateViewControls({ lkgCanvas: e4 });
        }
        get appCanvas() {
          return this._viewControls.appCanvas;
        }
        set appCanvas(e4) {
          this.updateViewControls({ appCanvas: e4 });
        }
        get aspect() {
          return this._calibration.screenW.value / this._calibration.screenH.value;
        }
        get tileWidth() {
          return Math.round(this.framebufferWidth / this.quiltWidth);
        }
        get framebufferWidth() {
          return this._calibration.screenW.value < 7e3 ? this._viewControls.quiltResolution : 7680;
        }
        get quiltWidth() {
          return this.calibration.screenW.value == 1536 ? 8 : this.calibration.screenW.value == 3840 || this.calibration.screenW.value > 7e3 ? 5 : 8;
        }
        get quiltHeight() {
          return this.calibration.screenW.value == 1536 ? 6 : this.calibration.screenW.value == 3840 || this.calibration.screenW.value > 7e3 ? 9 : 6;
        }
        get framebufferHeight() {
          return this._calibration.screenW.value < 7e3 ? this._viewControls.quiltResolution : 4320;
        }
        get viewCone() {
          return this._calibration.viewCone.value * this.depthiness / 180 * Math.PI;
        }
        get tilt() {
          return this._calibration.screenH.value / (this._calibration.screenW.value * this._calibration.slope.value) * (this._calibration.flipImageX.value ? -1 : 1);
        }
        set tilt(e4) {
        }
        get subp() {
          return 1 / (this._calibration.screenW.value * 3);
        }
        get pitch() {
          const e4 = this._calibration.screenW.value / this._calibration.DPI.value;
          return this._calibration.pitch.value * e4 * Math.cos(Math.atan(1 / this._calibration.slope.value));
        }
      };
      U2 = null;
      Ce2 = (n4, i5) => {
        const e4 = F();
        if (e4.lkgCanvas == null) {
          console.warn("window placement called without a valid XR Session!");
          return;
        } else if (n4 == false)
          Te(e4, G);
        else {
          G == null && (G = ye2()), e4.lkgCanvas.style.position = "fixed", e4.lkgCanvas.style.bottom = "0", e4.lkgCanvas.style.left = "0", e4.lkgCanvas.width = e4.calibration.screenW.value, e4.lkgCanvas.height = e4.calibration.screenH.value, document.body.appendChild(G);
          const s4 = "getScreenDetails" in window;
          console.log(s4, "Screen placement API exists"), s4 ? Re(e4.lkgCanvas, e4, i5) : K2(e4, e4.lkgCanvas, i5);
        }
      };
      B = Symbol("LookingGlassXRWebGLLayer");
      xe2 = class extends XRWebGLLayer2 {
        constructor(i5, e4, s4) {
          super(i5, e4, s4);
          const t4 = F();
          t4.appCanvas = e4.canvas, t4.lkgCanvas = document.createElement("canvas"), t4.lkgCanvas.tabIndex = 0;
          const o4 = t4.lkgCanvas.getContext("2d", { alpha: false });
          t4.lkgCanvas.addEventListener("dblclick", function() {
            this.requestFullscreen();
          });
          const l4 = this[PRIVATE17].config, h4 = e4.createTexture();
          let p4, M4;
          const x4 = e4.createFramebuffer(), v5 = e4.getExtension("OES_vertex_array_object"), r4 = 34229, c5 = v5 ? v5.bindVertexArrayOES.bind(v5) : e4.bindVertexArray.bind(e4);
          (l4.depth || l4.stencil) && (l4.depth && l4.stencil ? M4 = {
            format: e4.DEPTH_STENCIL,
            attachment: e4.DEPTH_STENCIL_ATTACHMENT
          } : l4.depth ? M4 = {
            format: e4.DEPTH_COMPONENT16,
            attachment: e4.DEPTH_ATTACHMENT
          } : l4.stencil && (M4 = {
            format: e4.STENCIL_INDEX8,
            attachment: e4.STENCIL_ATTACHMENT
          }), p4 = e4.createRenderbuffer());
          const u4 = (a4, T3, g4, d4, C3) => {
            f3(a4, T3, C3.framebufferWidth, C3.framebufferHeight), g4 && y3(a4, g4, d4, C3.framebufferWidth, C3.framebufferHeight);
          }, f3 = (a4, T3, g4, d4) => {
            const C3 = a4.getParameter(a4.TEXTURE_BINDING_2D);
            a4.bindTexture(a4.TEXTURE_2D, T3), a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, g4, d4, 0, a4.RGBA, a4.UNSIGNED_BYTE, null), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_MIN_FILTER, a4.LINEAR), a4.bindTexture(a4.TEXTURE_2D, C3);
          }, y3 = (a4, T3, g4, d4, C3) => {
            const L3 = a4.getParameter(a4.RENDERBUFFER_BINDING);
            a4.bindRenderbuffer(a4.RENDERBUFFER, T3), a4.renderbufferStorage(a4.RENDERBUFFER, g4.format, d4, C3), a4.bindRenderbuffer(a4.RENDERBUFFER, L3);
          }, S3 = (a4, T3, g4, d4, C3, L3) => {
            const X4 = a4.getParameter(a4.FRAMEBUFFER_BINDING);
            a4.bindFramebuffer(a4.FRAMEBUFFER, T3), a4.framebufferTexture2D(a4.FRAMEBUFFER, a4.COLOR_ATTACHMENT0, a4.TEXTURE_2D, g4, 0), (L3.depth || L3.stencil) && a4.framebufferRenderbuffer(a4.FRAMEBUFFER, d4.attachment, a4.RENDERBUFFER, C3), a4.bindFramebuffer(a4.FRAMEBUFFER, X4);
          };
          u4(e4, h4, p4, M4, t4), t4.addEventListener("on-config-changed", () => u4(e4, h4, p4, M4, t4)), S3(e4, x4, h4, M4, p4, l4);
          const _4 = `
		attribute vec2 a_position;
		varying vec2 v_texcoord;
		void main() {
		  gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
		  v_texcoord = a_position;
		}
	  `;
          function w3(a4, T3, g4) {
            const d4 = a4.createShader(T3);
            return a4.shaderSource(d4, g4), a4.compileShader(d4), a4.getShaderParameter(d4, a4.COMPILE_STATUS) ? d4 : (console.warn(a4.getShaderInfoLog(d4)), null);
          }
          function m4(a4, T3, g4) {
            let d4 = a4.createProgram();
            const C3 = w3(a4, a4.VERTEX_SHADER, T3), L3 = w3(a4, a4.FRAGMENT_SHADER, g4);
            return C3 === null || L3 === null ? (console.error("There was a problem with shader construction"), null) : (a4.attachShader(d4, C3), a4.attachShader(d4, L3), a4.linkProgram(d4), a4.getProgramParameter(d4, a4.LINK_STATUS) ? d4 : (console.warn(a4.getProgramInfoLog(d4)), null));
          }
          let I3, A3, P4, b3;
          const k4 = (a4, T3, g4) => {
            const d4 = g4(T3);
            if (d4 === A3)
              return;
            A3 = d4;
            const C3 = w3(a4, a4.FRAGMENT_SHADER, d4);
            if (C3 === null)
              return;
            I3 && a4.deleteShader(I3), I3 = C3;
            const L3 = m4(a4, _4, d4);
            if (L3 === null) {
              console.warn("There was a problem with shader construction");
              return;
            }
            P4 = a4.getAttribLocation(L3, "a_position"), b3 = a4.getUniformLocation(L3, "u_viewType");
            const X4 = a4.getUniformLocation(L3, "u_texture"), le4 = a4.getParameter(a4.CURRENT_PROGRAM);
            a4.useProgram(L3), a4.uniform1i(X4, 0), a4.useProgram(le4), D3 && a4.deleteProgram(D3), D3 = L3;
          };
          console.log(Shader(t4));
          let D3 = m4(e4, _4, Shader(t4));
          D3 === null && console.warn("There was a problem with shader construction"), t4.addEventListener("on-config-changed", () => {
            k4(e4, t4, Shader);
          });
          const Y5 = v5 ? v5.createVertexArrayOES() : e4.createVertexArray(), Z6 = e4.createBuffer(), Q3 = e4.getParameter(e4.ARRAY_BUFFER_BINDING), J3 = e4.getParameter(r4);
          c5(Y5), e4.bindBuffer(e4.ARRAY_BUFFER, Z6), e4.bufferData(e4.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e4.STATIC_DRAW), e4.enableVertexAttribArray(P4), e4.vertexAttribPointer(P4, 2, e4.FLOAT, false, 0, 0), c5(J3), e4.bindBuffer(e4.ARRAY_BUFFER, Q3);
          const ee4 = () => {
            console.assert(this[B].LookingGlassEnabled), e4.bindFramebuffer(e4.FRAMEBUFFER, this.framebuffer);
            const a4 = e4.getParameter(e4.COLOR_CLEAR_VALUE), T3 = e4.getParameter(e4.DEPTH_CLEAR_VALUE), g4 = e4.getParameter(e4.STENCIL_CLEAR_VALUE);
            e4.clearColor(0, 0, 0, 0), e4.clearDepth(1), e4.clearStencil(0), e4.clear(e4.DEPTH_BUFFER_BIT | e4.COLOR_BUFFER_BIT | e4.STENCIL_BUFFER_BIT), e4.clearColor(a4[0], a4[1], a4[2], a4[3]), e4.clearDepth(T3), e4.clearStencil(g4);
          };
          function te3() {
            if (!t4.appCanvas || !t4.lkgCanvas)
              return;
            (t4.appCanvas.width !== t4.framebufferWidth || t4.appCanvas.height !== t4.framebufferHeight) && (t4.appCanvas.width, t4.appCanvas.height, t4.appCanvas.width = t4.framebufferWidth, t4.appCanvas.height = t4.framebufferHeight);
            const a4 = ie3();
            ae4(), re6(), se3(), oe4(), ne4(a4);
          }
          function ne4(a4) {
            e4.activeTexture(a4.activeTexture), e4.bindTexture(e4.TEXTURE_2D, a4.textureBinding), e4.useProgram(a4.program), e4.bindRenderbuffer(e4.RENDERBUFFER, a4.renderbufferBinding), e4.bindFramebuffer(e4.FRAMEBUFFER, a4.framebufferBinding), a4.scissorTest ? e4.enable(e4.SCISSOR_TEST) : e4.disable(e4.SCISSOR_TEST), a4.stencilTest ? e4.enable(e4.STENCIL_TEST) : e4.disable(e4.STENCIL_TEST), a4.depthTest ? e4.enable(e4.DEPTH_TEST) : e4.disable(e4.DEPTH_TEST), a4.blend ? e4.enable(e4.BLEND) : e4.disable(e4.BLEND), a4.cullFace ? e4.enable(e4.CULL_FACE) : e4.disable(e4.CULL_FACE), c5(a4.VAO);
          }
          function ie3() {
            return {
              VAO: e4.getParameter(e4.VERTEX_ARRAY_BINDING),
              cullFace: e4.getParameter(e4.CULL_FACE),
              blend: e4.getParameter(e4.BLEND),
              depthTest: e4.getParameter(e4.DEPTH_TEST),
              stencilTest: e4.getParameter(e4.STENCIL_TEST),
              scissorTest: e4.getParameter(e4.SCISSOR_TEST),
              viewport: e4.getParameter(e4.VIEWPORT),
              framebufferBinding: e4.getParameter(e4.FRAMEBUFFER_BINDING),
              renderbufferBinding: e4.getParameter(e4.RENDERBUFFER_BINDING),
              program: e4.getParameter(e4.CURRENT_PROGRAM),
              activeTexture: e4.getParameter(e4.ACTIVE_TEXTURE),
              textureBinding: e4.getParameter(e4.TEXTURE_BINDING_2D)
            };
          }
          function ae4() {
            e4.bindFramebuffer(e4.FRAMEBUFFER, null), e4.useProgram(D3), c5(Y5), e4.activeTexture(e4.TEXTURE0), e4.bindTexture(e4.TEXTURE_2D, h4), e4.disable(e4.BLEND), e4.disable(e4.CULL_FACE), e4.disable(e4.DEPTH_TEST), e4.disable(e4.STENCIL_TEST), e4.viewport(0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight);
          }
          function re6() {
            e4.uniform1i(b3, 0), e4.drawArrays(e4.TRIANGLES, 0, 6);
          }
          function se3() {
            if (!t4.lkgCanvas || !t4.appCanvas) {
              console.warn("Looking Glass Canvas is not defined");
              return;
            }
            o4 == null || o4.clearRect(0, 0, t4.lkgCanvas.width, t4.lkgCanvas.height), o4 == null || o4.drawImage(t4.appCanvas, 0, 0, t4.framebufferWidth, t4.framebufferHeight, 0, 0, t4.calibration.screenW.value, t4.calibration.screenH.value);
          }
          function oe4() {
            if (!t4.appCanvas) {
              console.warn("Looking Glass Canvas is not defined");
              return;
            }
            t4.inlineView !== 0 && (t4.capturing && t4.appCanvas.width !== t4.framebufferWidth && (t4.appCanvas.width = t4.framebufferWidth, t4.appCanvas.height = t4.framebufferHeight, e4.viewport(0, 0, t4.framebufferHeight, t4.framebufferWidth)), e4.uniform1i(b3, t4.inlineView), e4.drawArrays(e4.TRIANGLES, 0, 6));
          }
          window.addEventListener("unload", () => {
            t4.popup && t4.popup.close(), t4.popup = null;
          }), this[B] = {
            LookingGlassEnabled: false,
            framebuffer: x4,
            clearFramebuffer: ee4,
            blitTextureToDefaultFramebufferIfNeeded: te3,
            moveCanvasToWindow: Ce2
          };
        }
        get framebuffer() {
          return this[B].LookingGlassEnabled ? this[B].framebuffer : null;
        }
        get framebufferWidth() {
          return F().framebufferWidth;
        }
        get framebufferHeight() {
          return F().framebufferHeight;
        }
      };
      N = class extends XRDevice {
        constructor(i5) {
          super(i5), this.sessions = /* @__PURE__ */ new Map(), this.viewSpaces = [], this.basePoseMatrix = mat4_exports2.create(), this.inlineProjectionMatrix = mat4_exports2.create(), this.inlineInverseViewMatrix = mat4_exports2.create(), this.LookingGlassProjectionMatrices = [], this.LookingGlassInverseViewMatrices = [], this.captureScreenshot = false, this.screenshotCallback = null, N.instance || (N.instance = this);
        }
        static getInstance() {
          return N.instance;
        }
        onBaseLayerSet(i5, e4) {
          const s4 = this.sessions.get(i5);
          s4.baseLayer = e4;
          const t4 = F(), o4 = e4[B];
          o4.LookingGlassEnabled = s4.immersive, s4.immersive && (t4.XRSession = this.sessions.get(i5), t4.popup == null ? o4.moveCanvasToWindow(true, () => {
            this.endSession(i5);
          }) : console.warn("attempted to assign baselayer twice?"));
        }
        isSessionSupported(i5) {
          return i5 === "inline" || i5 === "immersive-vr";
        }
        isFeatureSupported(i5) {
          switch (i5) {
            case "viewer":
              return true;
            case "local":
              return true;
            case "local-floor":
              return true;
            case "bounded-floor":
              return false;
            case "unbounded":
              return false;
            default:
              return console.warn("LookingGlassXRDevice.isFeatureSupported: feature not understood:", i5), false;
          }
        }
        async requestSession(i5, e4) {
          if (!this.isSessionSupported(i5))
            return Promise.reject();
          const s4 = i5 !== "inline", t4 = new _e2(i5, e4);
          return this.sessions.set(t4.id, t4), s4 && this.dispatchEvent("@@webxr-polyfill/vr-present-start", t4.id), Promise.resolve(t4.id);
        }
        requestAnimationFrame(i5) {
          return this.global.requestAnimationFrame(i5);
        }
        cancelAnimationFrame(i5) {
          this.global.cancelAnimationFrame(i5);
        }
        onFrameStart(i5, e4) {
          const s4 = this.sessions.get(i5), t4 = F();
          if (s4.immersive) {
            const o4 = Math.tan(0.5 * t4.fovy), l4 = 0.5 * t4.targetDiam / o4, h4 = l4 - t4.targetDiam, p4 = this.basePoseMatrix;
            mat4_exports2.fromTranslation(p4, [t4.targetX, t4.targetY, t4.targetZ]), mat4_exports2.rotate(p4, p4, t4.trackballX, [0, 1, 0]), mat4_exports2.rotate(p4, p4, -t4.trackballY, [1, 0, 0]), mat4_exports2.translate(p4, p4, [0, 0, l4]);
            for (let x4 = 0; x4 < t4.numViews; ++x4) {
              const v5 = (x4 + 0.5) / t4.numViews - 0.5, r4 = Math.tan(t4.viewCone * v5), c5 = l4 * r4, u4 = this.LookingGlassInverseViewMatrices[x4] = this.LookingGlassInverseViewMatrices[x4] || mat4_exports2.create();
              mat4_exports2.translate(u4, p4, [c5, 0, 0]), mat4_exports2.invert(u4, u4);
              const f3 = Math.max(h4 + e4.depthNear, 0.01), y3 = h4 + e4.depthFar, S3 = f3 * o4, _4 = S3, w3 = -S3, m4 = f3 * -r4, I3 = t4.aspect * S3, A3 = m4 + I3, P4 = m4 - I3, b3 = this.LookingGlassProjectionMatrices[x4] = this.LookingGlassProjectionMatrices[x4] || mat4_exports2.create();
              mat4_exports2.set(b3, 2 * f3 / (A3 - P4), 0, 0, 0, 0, 2 * f3 / (_4 - w3), 0, 0, (A3 + P4) / (A3 - P4), (_4 + w3) / (_4 - w3), -(y3 + f3) / (y3 - f3), -1, 0, 0, -2 * y3 * f3 / (y3 - f3), 0);
            }
            s4.baseLayer[B].clearFramebuffer();
          } else {
            const o4 = s4.baseLayer.context, l4 = o4.drawingBufferWidth / o4.drawingBufferHeight;
            mat4_exports2.perspective(this.inlineProjectionMatrix, e4.inlineVerticalFieldOfView, l4, e4.depthNear, e4.depthFar), mat4_exports2.fromTranslation(this.basePoseMatrix, [0, H, 0]), mat4_exports2.invert(this.inlineInverseViewMatrix, this.basePoseMatrix);
          }
        }
        onFrameEnd(i5) {
          this.sessions.get(i5).baseLayer[B].blitTextureToDefaultFramebufferIfNeeded(), this.captureScreenshot && this.screenshotCallback && (this.screenshotCallback(), this.captureScreenshot = false);
        }
        async requestFrameOfReferenceTransform(i5, e4) {
          const s4 = mat4_exports2.create();
          switch (i5) {
            case "viewer":
            case "local":
              return mat4_exports2.fromTranslation(s4, [0, -H, 0]), s4;
            case "local-floor":
              return s4;
            default:
              throw new Error("XRReferenceSpaceType not understood");
          }
        }
        endSession(i5) {
          const e4 = this.sessions.get(i5);
          e4.immersive && e4.baseLayer && (e4.baseLayer[B].moveCanvasToWindow(false), this.dispatchEvent("@@webxr-polyfill/vr-present-end", i5)), e4.ended = true;
        }
        doesSessionSupportReferenceSpace(i5, e4) {
          const s4 = this.sessions.get(i5);
          return s4.ended ? false : s4.enabledFeatures.has(e4);
        }
        getViewSpaces(i5) {
          if (i5 === "immersive-vr") {
            const e4 = F();
            for (let s4 = this.viewSpaces.length; s4 < e4.numViews; ++s4)
              this.viewSpaces[s4] = new Se(s4);
            return this.viewSpaces.length = e4.numViews, this.viewSpaces;
          }
        }
        getViewport(i5, e4, s4, t4, o4) {
          if (o4 === void 0) {
            const h4 = this.sessions.get(i5).baseLayer.context;
            t4.x = 0, t4.y = 0, t4.width = h4.drawingBufferWidth, t4.height = h4.drawingBufferHeight;
          } else {
            const l4 = F(), h4 = o4 % l4.quiltWidth, p4 = Math.floor(o4 / l4.quiltWidth);
            t4.x = l4.framebufferWidth / l4.quiltWidth * h4, t4.y = l4.framebufferHeight / l4.quiltHeight * p4, t4.width = l4.framebufferWidth / l4.quiltWidth, t4.height = l4.framebufferHeight / l4.quiltHeight;
          }
          return true;
        }
        getProjectionMatrix(i5, e4) {
          return e4 === void 0 ? this.inlineProjectionMatrix : this.LookingGlassProjectionMatrices[e4] || mat4_exports2.create();
        }
        getBasePoseMatrix() {
          return this.basePoseMatrix;
        }
        getBaseViewMatrix() {
          return this.inlineInverseViewMatrix;
        }
        _getViewMatrixByIndex(i5) {
          return this.LookingGlassInverseViewMatrices[i5] = this.LookingGlassInverseViewMatrices[i5] || mat4_exports2.create();
        }
        getInputSources() {
          return [];
        }
        getInputPose(i5, e4, s4) {
          return null;
        }
        onWindowResize() {
        }
      };
      V = N;
      R2(V, "instance", null);
      Le2 = 0;
      _e2 = class {
        constructor(i5, e4) {
          R2(this, "mode");
          R2(this, "immersive");
          R2(this, "id");
          R2(this, "baseLayer");
          R2(this, "inlineVerticalFieldOfView");
          R2(this, "ended");
          R2(this, "enabledFeatures");
          this.mode = i5, this.immersive = i5 === "immersive-vr" || i5 === "immersive-ar", this.id = ++Le2, this.baseLayer = null, this.inlineVerticalFieldOfView = Math.PI * 0.5, this.ended = false, this.enabledFeatures = e4;
        }
      };
      Se = class extends XRSpace {
        constructor(e4) {
          super();
          R2(this, "viewIndex");
          this.viewIndex = e4;
        }
        get eye() {
          return "none";
        }
        _onPoseUpdate(e4) {
          this._inverseBaseMatrix = e4._getViewMatrixByIndex(this.viewIndex);
        }
      };
      $2 = class _$ extends WebXRPolyfill {
        constructor(e4) {
          super();
          R2(this, "vrButton");
          R2(this, "device");
          R2(this, "isPresenting", false);
          z(e4), this.loadPolyfill();
        }
        static async init(e4) {
          new _$(e4);
        }
        async loadPolyfill() {
          this.overrideDefaultVRButton(), console.warn('Looking Glass WebXR "polyfill" overriding native WebXR API.');
          for (const e4 in api_default)
            this.global[e4] = api_default[e4];
          this.global.XRWebGLLayer = xe2, this.injected = true, this.device = new V(this.global), this.xr = new XRSystem(Promise.resolve(this.device)), Object.defineProperty(this.global.navigator, "xr", {
            value: this.xr,
            configurable: true
          });
        }
        async overrideDefaultVRButton() {
          this.vrButton = await ke("VRButton"), this.vrButton && this.device ? (this.device.addEventListener("@@webxr-polyfill/vr-present-start", () => {
            this.isPresenting = true, this.updateVRButtonUI();
          }), this.device.addEventListener("@@webxr-polyfill/vr-present-end", () => {
            this.isPresenting = false, this.updateVRButtonUI();
          }), this.vrButton.addEventListener("click", (e4) => {
            this.updateVRButtonUI();
          }), this.updateVRButtonUI()) : console.warn("Unable to find VRButton");
        }
        async updateVRButtonUI() {
          if (this.vrButton) {
            await Fe(100), this.isPresenting ? this.vrButton.innerHTML = "EXIT LOOKING GLASS" : this.vrButton.innerHTML = "ENTER LOOKING GLASS";
            const e4 = 220;
            this.vrButton.style.width = `${e4}px`, this.vrButton.style.left = `calc(50% - ${e4 / 2}px)`;
          }
        }
        update(e4) {
          z(e4);
        }
      };
      Xe2 = F();
    }
  });

  // node_modules/@sermas/toolkit/avatar/looking-glass/index.js
  var looking_glass_exports = {};
  __export(looking_glass_exports, {
    LookingGlassAdapter: () => LookingGlassAdapter
  });
  var LookingGlassAdapter;
  var init_looking_glass = __esm({
    "node_modules/@sermas/toolkit/avatar/looking-glass/index.js"() {
      init_VRButton();
      LookingGlassAdapter = class {
        constructor() {
        }
        async init(renderer) {
          const lookingglass = await Promise.resolve().then(() => (init_webxr(), webxr_exports));
          console.log(lookingglass);
          const { LookingGlassWebXRPolyfill } = lookingglass;
          const lookingGlassWebXR = new LookingGlassWebXRPolyfill({
            tileHeight: 512,
            numViews: 45,
            targetY: 0,
            targetZ: 0,
            targetDiam: 3,
            fovy: 14 * Math.PI / 180
          });
          document.body.appendChild(VRButton.createButton(renderer));
        }
        async destroy() {
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/webavatar.js
  var logger6, AvatarModel, getAvatarDefaultConfig, createWebAvatar;
  var init_webavatar = __esm({
    "node_modules/@sermas/toolkit/avatar/webavatar.js"() {
      init_three_module();
      init_three_module();
      init_OrbitControls();
      init_stats_module();
      init_FBXLoader();
      init_GLTFLoader();
      init_logger();
      init_animations();
      init_events();
      init_TextureLoader2();
      init_webavatar_defaults();
      init_webavatar_handler();
      init_xr();
      init_webavatar_defaults();
      logger6 = new Logger("webavatar.api");
      AvatarModel = class {
        constructor(config) {
          this.config = config;
          this.stopped = false;
          this.clock = new Clock();
          this.filterMeshRegExp = void 0;
          this.meshes = {};
          this.animate = this.animate.bind(this);
          this.onWindowResize = this.onWindowResize.bind(this);
          if (this.config.animations?.filterMesh !== void 0 && this.config.animations?.filterMesh) {
            this.filterMeshRegExp = this.config.animations?.filterMesh;
          }
          this.xr = new WebAvatarXR(this);
        }
        getXR() {
          return this.xr;
        }
        toggleAudio(enabled) {
          this.handler?.toggleAudio(enabled);
        }
        getAnimation() {
          return this.animation;
        }
        getBlendShapes() {
          return this.animation?.getBlendShapes();
        }
        isStopped() {
          return this.stopped;
        }
        getConfig() {
          return this.config;
        }
        getScene() {
          return this.scene;
        }
        getRenderer() {
          return this.renderer;
        }
        getModel() {
          return this.model;
        }
        getCamera() {
          return this.camera;
        }
        getBackground() {
          return this.background;
        }
        setMirrorModeEnabled(enabled) {
          this.animation?.setMirrorModeEnabled(enabled);
        }
        setAnimationEnabled(enabled) {
          this.animation?.setAnimationEnabled(enabled);
        }
        setLookAtUser(enabled) {
          this.animation?.setLookAtUser(enabled);
        }
        getCameraConfig() {
          const { x: x4, y: y3, z: z4 } = this.camera.position;
          const { x: rx, y: ry2, z: rz } = this.camera.rotation;
          return {
            position: { x: x4, y: y3, z: z4 },
            rotation: { x: rx, y: ry2, z: rz }
          };
        }
        async init(toolkit) {
          logger6.debug("initializing avatar model");
          this.toolkit = toolkit;
          this.stopped = false;
          this.createScene();
          const model = await this.loadModel();
          if (!model) {
            logger6.warn(`Failed to load avatar model`);
            return this;
          }
          this.initializeCamera(model);
          if (this.filterMeshRegExp) {
            model.children = model.children.filter((c5) => !c5.name.match(this.filterMeshRegExp));
          }
          model.traverse((child) => {
            if (this.filterMeshRegExp && child.name.match(this.filterMeshRegExp)) {
              child.visible = false;
              return;
            }
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              this.meshes[child.name] = child;
            }
          });
          this.model = model;
          this.scene.add(model);
          this.skeleton = new SkeletonHelper(model);
          this.skeleton.visible = false;
          this.scene.add(this.skeleton);
          this.animation = new WebavatarAnimation(this);
          await this.animation.init();
          this.handler = new WebAvatarHandler(this);
          await this.handler.init();
          await this.xr.init();
          this.animate();
          this.renderer.setAnimationLoop(this.animate);
          logger6.debug("avatar initialized");
          this.handleEyesMotion.bind(this);
          this.toolkit?.on("detection.characterization", this.handleEyesMotion);
          return this;
        }
        handleEyesMotion(ev) {
          if (ev.detections?.length && ev.detections[0].detections?.face?.length) {
            const box = ev.detections[0].detections.face[0].boxRaw;
            this.animation?.moveEyes({
              x: -((box[2] + box[0]) / 2 - 0.5),
              y: -((box[3] + box[1]) / 2 - 0.5)
            });
          }
        }
        async startLookingGlass() {
          const m4 = await Promise.resolve().then(() => (init_looking_glass(), looking_glass_exports));
          const x4 = new m4.LookingGlassAdapter();
          x4.init(this.renderer);
        }
        printArmature() {
          this.model?.traverse((child) => {
            console.log(child.name, JSON.stringify(child.quaternion));
          });
        }
        createScene() {
          let container;
          if (!this.config.domId) {
            container = document.createElement("div");
            container.id = `webavatar-${Math.round(Math.random() * 1e4)}`;
            document.body.appendChild(container);
          } else {
            container = document.getElementById(this.config.domId);
            if (!container)
              throw new Error(`Element not found ${this.config.domId}`);
          }
          this.container = container;
          const containerSizes = {
            width: this.container.clientWidth,
            height: this.container.clientHeight
          };
          this.camera = new PerspectiveCamera(45, containerSizes.width / containerSizes.height, 0.1, 9);
          const backgroundColor = this.config.ui?.backgroundColor || "#BBBBBB";
          const fogColor = this.config.ui?.fogColor || "#64539E";
          const hemiLightColors = this.config.ui?.hemiLightColor || {};
          hemiLightColors.sky = hemiLightColors.sky || "#fff";
          hemiLightColors.ground = hemiLightColors.ground || "#000";
          this.scene = new Scene();
          this.scene.background = new Color(backgroundColor);
          this.scene.fog = new Fog(fogColor, 200, 1e3);
          const hemiLight = new HemisphereLight(hemiLightColors.sky, hemiLightColors.ground, 5);
          hemiLight.position.set(0, 200, 0);
          this.scene.add(hemiLight);
          this.renderer = new WebGLRenderer({
            antialias: true,
            alpha: false,
            logarithmicDepthBuffer: true
            // powerPreference: 'high-performance',
          });
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.setSize(containerSizes.width, containerSizes.height);
          this.renderer.shadowMap.enabled = true;
          this.renderer.xr.enabled = true;
          this.container.appendChild(this.renderer.domElement);
          this.controls = new OrbitControls(this.camera, this.renderer.domElement);
          this.controls.screenSpacePanning = true;
          window.addEventListener("resize", this.onWindowResize);
          if (this.config.showGui) {
            this.stats = new stats_module_default();
            this.container.appendChild(this.stats.dom);
          }
        }
        async setBackground(assetId) {
          const loader = new TextureLoader2();
          let url = assetId;
          if (this.toolkit) {
            url = await this.toolkit?.configureLoader("backgrounds", assetId, loader);
          }
          if (!url)
            return;
          logger6.debug(`Loading background from ${url}`);
          const image = await loader.load(url);
          this.scene.background = image;
          this.background = image;
        }
        initializeCamera(model) {
          const box = new Box3().setFromObject(model);
          const size = box.getSize(new Vector3()).length();
          const center = box.getCenter(new Vector3());
          this.controls.reset();
          model.position.x += model.position.x - center.x;
          model.position.y += model.position.y - center.y;
          model.position.z += model.position.z - center.z;
          this.controls.maxDistance = size * 10;
          this.camera.near = size / 100;
          this.camera.far = size * 100;
          this.camera.updateProjectionMatrix();
          const cameraConfig = this.isPortrait() ? this.config.cameraMobile : this.config.camera;
          this.setCameraConfig(cameraConfig);
          this.camera.updateMatrixWorld(true);
          this.controls.saveState();
        }
        setCameraConfig(cameraConfig) {
          if (!cameraConfig)
            return;
          if (cameraConfig.rotation)
            this.camera.rotation.set(cameraConfig.rotation?.x, cameraConfig.rotation?.y, cameraConfig.rotation?.z);
          if (cameraConfig.position)
            this.camera.position.set(cameraConfig.position?.x, cameraConfig.position?.y, cameraConfig.position?.z);
        }
        // load 3D model
        async loadModel() {
          const format = this.config.path.endsWith(".fbx") ? "fbx" : "glb";
          const loader = format === "fbx" ? new FBXLoader() : new GLTFLoader();
          let url = this.config.path;
          if (this.toolkit && this.config.id != "rpm") {
            url = await this.toolkit.configureLoader("avatars", this.config.id, loader);
          }
          if (url && url.startsWith("http") && url.indexOf("readyplayer") > -1) {
            if (url.indexOf("morphTargets") === -1) {
              const suffix = "morphTargets=ARKit,Oculus%20Visemes%2032";
              url = `${url}${url.indexOf("?") === -1 ? "?" : "&"}${suffix}`;
            }
          }
          if (!url) {
            logger6.warn(`Avatar not available, using default`);
            return void 0;
          }
          logger6.log(`loading ${format} from ${url}`);
          const model = await loader.loadAsync(url, (ev) => this.showLoadingProgress(ev.loaded, ev.total));
          sendStatus("");
          const gltf = model;
          if (gltf.parser !== void 0 && gltf.scene !== void 0) {
            return gltf.scene;
          }
          return model;
        }
        setPoses(results) {
          this.animation?.setPoses(results);
        }
        showLoadingProgress(loaded, total) {
          const hasTotal = total !== 0;
          if (!hasTotal) {
            sendStatus(`Loading model...`);
            return;
          }
          let percentage = Math.round(100 * loaded / total);
          percentage = percentage > 100 || percentage === Infinity ? 100 : percentage;
          sendStatus(`Loading model ${percentage}%`);
        }
        toggleSkeleton(show) {
          if (show === void 0) {
            show = !this.skeleton.visible;
          }
          this.skeleton.visible = show;
        }
        isPortrait() {
          return this.container.clientWidth < this.container.clientHeight;
        }
        onWindowResize() {
          this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
          if (this.isPortrait()) {
            if (!this.model)
              return;
            const cameraMobileConfig = this.config.cameraMobile;
            if (cameraMobileConfig) {
              if (cameraMobileConfig.rotation)
                this.camera.rotation.set(cameraMobileConfig.rotation.x, cameraMobileConfig.rotation.y, cameraMobileConfig.rotation.z);
              if (cameraMobileConfig.position)
                this.camera.position.set(cameraMobileConfig.position.x, cameraMobileConfig.position.y, cameraMobileConfig.position.z);
            }
            return;
          }
          const cameraConfig = this.config.camera;
          if (cameraConfig?.rotation)
            this.camera.rotation.set(cameraConfig.rotation?.x, cameraConfig.rotation?.y, cameraConfig.rotation?.z);
          if (cameraConfig?.position)
            this.camera.position.set(cameraConfig.position?.x, cameraConfig.position?.y, cameraConfig.position?.z);
        }
        async destroy() {
          this.stopped = true;
          window.removeEventListener("resize", this.onWindowResize);
          this.scene?.remove(...this.scene.children);
          this.renderer?.clear();
          this.renderer?.dispose();
          if (this.container) {
            while (this.container.lastChild)
              this.container.removeChild(this.container.lastChild);
          }
          await this.animation?.destroy();
          await this.handler?.destroy();
          await this.xr?.destroy();
          this.toolkit?.off("detection.characterization", this.handleEyesMotion);
          logger6.debug("avatar destroyed");
          this.toolkit?.emit("avatar.status", "removed");
        }
        animate(timestamp, frame) {
          if (this.stopped)
            return;
          const delta = this.clock.getDelta();
          if (this.renderer.xr && this.renderer.xr.isPresenting && frame) {
            this.xr?.animate(timestamp, frame);
          }
          if (this.animation)
            this.animation.animate(delta);
          if (this.renderer)
            this.renderer.render(this.scene, this.camera);
          if (this.stats)
            this.stats.update();
        }
      };
      getAvatarDefaultConfig = (config) => {
        config = config || {};
        const modelType = config.modelType || "readyplayerme";
        const rpmConfig = modelType === "readyplayerme" ? DefaultReadyPlayerMeAvatarConfig : {};
        const modelConfig = {
          ...DefaultAvatarConfig,
          ...rpmConfig,
          ...config || {}
        };
        return modelConfig;
      };
      createWebAvatar = (config, toolkit) => {
        const avatar = new AvatarModel(getAvatarDefaultConfig(config));
        return avatar.init(toolkit);
      };
    }
  });

  // node_modules/@sermas/toolkit/avatar/index.js
  var init_avatar = __esm({
    "node_modules/@sermas/toolkit/avatar/index.js"() {
      init_lipsync();
      init_webavatar_dto();
      init_webavatar();
    }
  });

  // node_modules/@sermas/toolkit/constants.js
  var DEFAULT_AVATAR_LANGUAGE, AUDIO_CLASSIFICATION_TOPIC, DefaultBackground;
  var init_constants2 = __esm({
    "node_modules/@sermas/toolkit/constants.js"() {
      DEFAULT_AVATAR_LANGUAGE = "en-GB";
      AUDIO_CLASSIFICATION_TOPIC = "detection/audio";
      DefaultBackground = {
        id: "default",
        name: "default",
        path: "backgrounds/default",
        type: "backgrounds"
      };
    }
  });

  // node_modules/@sermas/toolkit/detection/detection.dto.js
  var init_detection_dto2 = __esm({
    "node_modules/@sermas/toolkit/detection/detection.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/detection/camera.js
  var CameraHandler;
  var init_camera = __esm({
    "node_modules/@sermas/toolkit/detection/camera.js"() {
      init_logger();
      CameraHandler = class _CameraHandler {
        constructor() {
          this.logger = new Logger(_CameraHandler.name);
          this.defaultConfig = {
            width: 320,
            height: 280
          };
          this.stopped = false;
        }
        isSupported() {
          return "mediaDevices" in navigator && "getUserMedia" in navigator.mediaDevices;
        }
        async loadStream() {
          if (this.stream)
            return this.stream;
          try {
            this.stream = await navigator.mediaDevices.getUserMedia({
              video: true
            });
            return this.stream;
          } catch (e4) {
            this.logger.warn(`Failed to access camera`);
          }
          return void 0;
        }
        createCanvas() {
          if (this.canvas)
            return this.canvas;
          this.canvas = document.createElement("canvas");
          this.canvas.width = this.config.width;
          this.canvas.height = this.config.height;
          document.body.appendChild(this.canvas);
          return this.canvas;
        }
        async init(config) {
          if (!config.video)
            throw new Error(`video not set`);
          this.config = { ...this.defaultConfig, ...config };
          if (!this.isSupported())
            throw new Error("Camera not supported");
          this.stopped = false;
          this.createCanvas();
          if (!this.canvas) {
            throw new Error("Failed to load canvas");
          }
          const mediaStream = await this.loadStream();
          if (!mediaStream) {
            throw new Error(`Failed to load stream`);
          }
          const video = this.config.video;
          video.srcObject = mediaStream;
          let lastTime = -1;
          const onAnimationFrame = (currentTime = 0) => {
            if (this.stopped)
              return;
            if (currentTime !== lastTime) {
              lastTime = currentTime;
              this.config.onFrame(this.config.video);
            }
            if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
              this.config.video.requestVideoFrameCallback(onAnimationFrame);
            } else {
              requestAnimationFrame(onAnimationFrame);
            }
          };
          onAnimationFrame();
        }
        async destroy() {
          this.stopped = true;
          this.stream?.getVideoTracks().forEach((track) => track.stop());
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/detection/video.detection.js
  var import_eventemitter23, VideoDetection;
  var init_video_detection = __esm({
    "node_modules/@sermas/toolkit/detection/video.detection.js"() {
      import_eventemitter23 = __toESM(require_eventemitter2(), 1);
      init_logger();
      init_camera();
      VideoDetection = class _VideoDetection extends import_eventemitter23.default {
        constructor(toolkit) {
          super();
          this.toolkit = toolkit;
          this.logger = new Logger(_VideoDetection.name);
          this.camera = new CameraHandler();
          this.detectors = [];
          this.resultCache = {};
          this.rendering = false;
          this.lastDetection = {
            faceLandmark: performance.now(),
            holistic_v1: performance.now(),
            human: performance.now(),
            qrcode: performance.now()
          };
        }
        toggleRender(render) {
          this.config = this.config || {};
          this.config.render = render === void 0 ? !this.config.render : render;
          if (this.config.render)
            this.render();
        }
        async remove(type) {
          await Promise.all(this.detectors.map(async (d4, i5) => {
            if (d4.getType() !== type)
              return;
            this.detectors.splice(i5, 1);
            if (this.resultCache[d4.getType()])
              delete this.resultCache[d4.getType()];
            await d4.destroy();
          }));
          this.clearCanvas();
        }
        async add(instance) {
          await this.remove(instance.getType());
          this.detectors.push(instance);
          this.ensureDataCanvas();
          await instance.init(this.dataCanvas);
          instance.on("process", async (ev) => {
            this.emit(`${instance.getType()}`, ev);
            if (instance.publish && this.toolkit) {
              try {
                await instance.publish(ev, this.toolkit);
              } catch {
              }
            }
            if (!this.config.render)
              return;
            this.resultCache[instance.getType()] = {
              fn: () => {
                if (this.config.render && this.canvas)
                  instance.render(this.canvas, ev);
              },
              ts: /* @__PURE__ */ new Date()
            };
          });
        }
        async render() {
          if (this.rendering) {
            return;
          }
          this.logger.debug(`Detector rendering enabled`);
          const renderLoop = () => {
            if (!this.config.render) {
              this.rendering = false;
              this.resultCache = {};
              this.logger.debug(`Detector rendering disabled`);
              return;
            }
            this.clearCanvas();
            Object.values(this.resultCache).forEach((renderer) => renderer.fn());
            Object.entries(this.resultCache).forEach(([key, renderer]) => {
              if (Date.now() - renderer.ts.getTime() < 2e3)
                return;
              delete this.resultCache[key];
            });
            this.rendering = true;
          };
          this.renderingInterval = setInterval(renderLoop, 250);
        }
        checkCanvas() {
          if (!this.config.canvas)
            return;
          if (this.canvas)
            return;
          this.canvas = this.config.canvas;
        }
        async init(config) {
          this.config = config;
          if (this.config.render === true && !this.config.canvas) {
            this.logger.warn(`render=true but canvas not provided, no rendering will be performed`);
          }
          this.config.camera.onFrame = async (video) => {
            await this.onFrame(video);
          };
          await this.camera.init(config.camera);
          this.checkCanvas();
          this.emit("init");
        }
        skipDetection(detector) {
          const detectionThreshold = detector.getConfig()?.detectionThreshold || this.config.detectionThreshold;
          if (detectionThreshold === void 0 || detectionThreshold === 0) {
            return false;
          }
          const diff = performance.now() - this.lastDetection[detector.getType()];
          if (diff < detectionThreshold) {
            return true;
          }
          this.lastDetection[detector.getType()] = performance.now();
          return false;
        }
        clearCanvas() {
          if (!this.canvas || !this.config.render)
            return;
          this.canvas.getContext("2d")?.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        ensureDataCanvas() {
          if (this.dataCanvas)
            return;
          this.dataCanvas = document.createElement("canvas");
          this.dataCanvas.getContext("2d", { willReadFrequently: true });
          this.dataCanvas.width = this.config.camera.width;
          this.dataCanvas.height = this.config.camera.height;
        }
        async onFrame(video) {
          this.checkCanvas();
          this.ensureDataCanvas();
          this.dataCanvas.getContext("2d")?.drawImage(video, 0, 0);
          for (const detector of this.detectors) {
            try {
              if (this.skipDetection(detector))
                continue;
              await detector.process();
            } catch (e4) {
              this.logger.warn(`Failed to process frame: ${e4.message} `);
            }
          }
          this.dataCanvas.getContext("2d")?.clearRect(0, 0, this.dataCanvas.width, this.dataCanvas.height);
        }
        async destroy() {
          this.emit("destroy");
          await Promise.all(this.detectors.map(async (d4) => await d4.destroy()));
          this.detectors = [];
          await this.camera?.destroy();
          if (this.renderingInterval)
            clearInterval(this.renderingInterval);
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/detection/video/video.dto.js
  var import_eventemitter24;
  var init_video_dto = __esm({
    "node_modules/@sermas/toolkit/detection/video/video.dto.js"() {
      import_eventemitter24 = __toESM(require_eventemitter2(), 1);
    }
  });

  // node_modules/@sermas/toolkit/detection/video/base.detector.js
  var init_base_detector = __esm({
    "node_modules/@sermas/toolkit/detection/video/base.detector.js"() {
      init_logger();
      init_video_dto();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/human/human.detector.js
  var init_human_detector = __esm({
    "node_modules/@sermas/toolkit/detection/video/human/human.detector.js"() {
      init_toolkit();
      init_base_detector();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/human/human.dto.js
  var init_human_dto = __esm({
    "node_modules/@sermas/toolkit/detection/video/human/human.dto.js"() {
      init_video_dto();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/human/index.js
  var init_human = __esm({
    "node_modules/@sermas/toolkit/detection/video/human/index.js"() {
      init_human_detector();
      init_human_dto();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/mediapipe/v1/holistic/holistic.dto.js
  var init_holistic_dto = __esm({
    "node_modules/@sermas/toolkit/detection/video/mediapipe/v1/holistic/holistic.dto.js"() {
      init_video_dto();
    }
  });

  // node_modules/@mediapipe/holistic/holistic.js
  var require_holistic = __commonJS({
    "node_modules/@mediapipe/holistic/holistic.js"(exports2) {
      (function() {
        "use strict";
        var x4;
        function aa2(a4) {
          var b3 = 0;
          return function() {
            return b3 < a4.length ? { done: false, value: a4[b3++] } : { done: true };
          };
        }
        var ca3 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a4, b3, c5) {
          if (a4 == Array.prototype || a4 == Object.prototype)
            return a4;
          a4[b3] = c5.value;
          return a4;
        };
        function da3(a4) {
          a4 = ["object" == typeof globalThis && globalThis, a4, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
          for (var b3 = 0; b3 < a4.length; ++b3) {
            var c5 = a4[b3];
            if (c5 && c5.Math == Math)
              return c5;
          }
          throw Error("Cannot find global object");
        }
        var y3 = da3(this);
        function z4(a4, b3) {
          if (b3)
            a: {
              var c5 = y3;
              a4 = a4.split(".");
              for (var d4 = 0; d4 < a4.length - 1; d4++) {
                var e4 = a4[d4];
                if (!(e4 in c5))
                  break a;
                c5 = c5[e4];
              }
              a4 = a4[a4.length - 1];
              d4 = c5[a4];
              b3 = b3(d4);
              b3 != d4 && null != b3 && ca3(c5, a4, { configurable: true, writable: true, value: b3 });
            }
        }
        z4("Symbol", function(a4) {
          function b3(f3) {
            if (this instanceof b3)
              throw new TypeError("Symbol is not a constructor");
            return new c5(d4 + (f3 || "") + "_" + e4++, f3);
          }
          function c5(f3, g4) {
            this.h = f3;
            ca3(this, "description", { configurable: true, writable: true, value: g4 });
          }
          if (a4)
            return a4;
          c5.prototype.toString = function() {
            return this.h;
          };
          var d4 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e4 = 0;
          return b3;
        });
        z4("Symbol.iterator", function(a4) {
          if (a4)
            return a4;
          a4 = Symbol("Symbol.iterator");
          for (var b3 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c5 = 0; c5 < b3.length; c5++) {
            var d4 = y3[b3[c5]];
            "function" === typeof d4 && "function" != typeof d4.prototype[a4] && ca3(d4.prototype, a4, { configurable: true, writable: true, value: function() {
              return ea4(aa2(this));
            } });
          }
          return a4;
        });
        function ea4(a4) {
          a4 = { next: a4 };
          a4[Symbol.iterator] = function() {
            return this;
          };
          return a4;
        }
        function A3(a4) {
          var b3 = "undefined" != typeof Symbol && Symbol.iterator && a4[Symbol.iterator];
          return b3 ? b3.call(a4) : { next: aa2(a4) };
        }
        function B5(a4) {
          if (!(a4 instanceof Array)) {
            a4 = A3(a4);
            for (var b3, c5 = []; !(b3 = a4.next()).done; )
              c5.push(b3.value);
            a4 = c5;
          }
          return a4;
        }
        var fa3 = "function" == typeof Object.assign ? Object.assign : function(a4, b3) {
          for (var c5 = 1; c5 < arguments.length; c5++) {
            var d4 = arguments[c5];
            if (d4)
              for (var e4 in d4)
                Object.prototype.hasOwnProperty.call(d4, e4) && (a4[e4] = d4[e4]);
          }
          return a4;
        };
        z4("Object.assign", function(a4) {
          return a4 || fa3;
        });
        var ha3 = "function" == typeof Object.create ? Object.create : function(a4) {
          function b3() {
          }
          b3.prototype = a4;
          return new b3();
        }, ia2;
        if ("function" == typeof Object.setPrototypeOf)
          ia2 = Object.setPrototypeOf;
        else {
          var ja4;
          a: {
            var ka2 = { a: true }, la3 = {};
            try {
              la3.__proto__ = ka2;
              ja4 = la3.a;
              break a;
            } catch (a4) {
            }
            ja4 = false;
          }
          ia2 = ja4 ? function(a4, b3) {
            a4.__proto__ = b3;
            if (a4.__proto__ !== b3)
              throw new TypeError(a4 + " is not extensible");
            return a4;
          } : null;
        }
        var ma3 = ia2;
        function na3(a4, b3) {
          a4.prototype = ha3(b3.prototype);
          a4.prototype.constructor = a4;
          if (ma3)
            ma3(a4, b3);
          else
            for (var c5 in b3)
              if ("prototype" != c5)
                if (Object.defineProperties) {
                  var d4 = Object.getOwnPropertyDescriptor(b3, c5);
                  d4 && Object.defineProperty(a4, c5, d4);
                } else
                  a4[c5] = b3[c5];
          a4.ya = b3.prototype;
        }
        function oa3() {
          this.m = false;
          this.j = null;
          this.i = void 0;
          this.h = 1;
          this.v = this.s = 0;
          this.l = null;
        }
        function pa3(a4) {
          if (a4.m)
            throw new TypeError("Generator is already running");
          a4.m = true;
        }
        oa3.prototype.u = function(a4) {
          this.i = a4;
        };
        function qa3(a4, b3) {
          a4.l = { ma: b3, na: true };
          a4.h = a4.s || a4.v;
        }
        oa3.prototype.return = function(a4) {
          this.l = { return: a4 };
          this.h = this.v;
        };
        function C3(a4, b3, c5) {
          a4.h = c5;
          return { value: b3 };
        }
        function ra3(a4) {
          this.h = new oa3();
          this.i = a4;
        }
        function sa3(a4, b3) {
          pa3(a4.h);
          var c5 = a4.h.j;
          if (c5)
            return ta3(a4, "return" in c5 ? c5["return"] : function(d4) {
              return { value: d4, done: true };
            }, b3, a4.h.return);
          a4.h.return(b3);
          return ua3(a4);
        }
        function ta3(a4, b3, c5, d4) {
          try {
            var e4 = b3.call(a4.h.j, c5);
            if (!(e4 instanceof Object))
              throw new TypeError("Iterator result " + e4 + " is not an object");
            if (!e4.done)
              return a4.h.m = false, e4;
            var f3 = e4.value;
          } catch (g4) {
            return a4.h.j = null, qa3(a4.h, g4), ua3(a4);
          }
          a4.h.j = null;
          d4.call(a4.h, f3);
          return ua3(a4);
        }
        function ua3(a4) {
          for (; a4.h.h; )
            try {
              var b3 = a4.i(a4.h);
              if (b3)
                return a4.h.m = false, { value: b3.value, done: false };
            } catch (c5) {
              a4.h.i = void 0, qa3(a4.h, c5);
            }
          a4.h.m = false;
          if (a4.h.l) {
            b3 = a4.h.l;
            a4.h.l = null;
            if (b3.na)
              throw b3.ma;
            return { value: b3.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function va3(a4) {
          this.next = function(b3) {
            pa3(a4.h);
            a4.h.j ? b3 = ta3(a4, a4.h.j.next, b3, a4.h.u) : (a4.h.u(b3), b3 = ua3(a4));
            return b3;
          };
          this.throw = function(b3) {
            pa3(a4.h);
            a4.h.j ? b3 = ta3(a4, a4.h.j["throw"], b3, a4.h.u) : (qa3(a4.h, b3), b3 = ua3(a4));
            return b3;
          };
          this.return = function(b3) {
            return sa3(a4, b3);
          };
          this[Symbol.iterator] = function() {
            return this;
          };
        }
        function wa2(a4) {
          function b3(d4) {
            return a4.next(d4);
          }
          function c5(d4) {
            return a4.throw(d4);
          }
          return new Promise(function(d4, e4) {
            function f3(g4) {
              g4.done ? d4(g4.value) : Promise.resolve(g4.value).then(b3, c5).then(f3, e4);
            }
            f3(a4.next());
          });
        }
        function D3(a4) {
          return wa2(new va3(new ra3(a4)));
        }
        z4("Promise", function(a4) {
          function b3(g4) {
            this.i = 0;
            this.j = void 0;
            this.h = [];
            this.u = false;
            var h4 = this.l();
            try {
              g4(h4.resolve, h4.reject);
            } catch (k4) {
              h4.reject(k4);
            }
          }
          function c5() {
            this.h = null;
          }
          function d4(g4) {
            return g4 instanceof b3 ? g4 : new b3(function(h4) {
              h4(g4);
            });
          }
          if (a4)
            return a4;
          c5.prototype.i = function(g4) {
            if (null == this.h) {
              this.h = [];
              var h4 = this;
              this.j(function() {
                h4.m();
              });
            }
            this.h.push(g4);
          };
          var e4 = y3.setTimeout;
          c5.prototype.j = function(g4) {
            e4(g4, 0);
          };
          c5.prototype.m = function() {
            for (; this.h && this.h.length; ) {
              var g4 = this.h;
              this.h = [];
              for (var h4 = 0; h4 < g4.length; ++h4) {
                var k4 = g4[h4];
                g4[h4] = null;
                try {
                  k4();
                } catch (l4) {
                  this.l(l4);
                }
              }
            }
            this.h = null;
          };
          c5.prototype.l = function(g4) {
            this.j(function() {
              throw g4;
            });
          };
          b3.prototype.l = function() {
            function g4(l4) {
              return function(m4) {
                k4 || (k4 = true, l4.call(h4, m4));
              };
            }
            var h4 = this, k4 = false;
            return { resolve: g4(this.I), reject: g4(this.m) };
          };
          b3.prototype.I = function(g4) {
            if (g4 === this)
              this.m(new TypeError("A Promise cannot resolve to itself"));
            else if (g4 instanceof b3)
              this.L(g4);
            else {
              a:
                switch (typeof g4) {
                  case "object":
                    var h4 = null != g4;
                    break a;
                  case "function":
                    h4 = true;
                    break a;
                  default:
                    h4 = false;
                }
              h4 ? this.F(g4) : this.s(g4);
            }
          };
          b3.prototype.F = function(g4) {
            var h4 = void 0;
            try {
              h4 = g4.then;
            } catch (k4) {
              this.m(k4);
              return;
            }
            "function" == typeof h4 ? this.M(h4, g4) : this.s(g4);
          };
          b3.prototype.m = function(g4) {
            this.v(2, g4);
          };
          b3.prototype.s = function(g4) {
            this.v(1, g4);
          };
          b3.prototype.v = function(g4, h4) {
            if (0 != this.i)
              throw Error("Cannot settle(" + g4 + ", " + h4 + "): Promise already settled in state" + this.i);
            this.i = g4;
            this.j = h4;
            2 === this.i && this.K();
            this.H();
          };
          b3.prototype.K = function() {
            var g4 = this;
            e4(function() {
              if (g4.D()) {
                var h4 = y3.console;
                "undefined" !== typeof h4 && h4.error(g4.j);
              }
            }, 1);
          };
          b3.prototype.D = function() {
            if (this.u)
              return false;
            var g4 = y3.CustomEvent, h4 = y3.Event, k4 = y3.dispatchEvent;
            if ("undefined" === typeof k4)
              return true;
            "function" === typeof g4 ? g4 = new g4("unhandledrejection", { cancelable: true }) : "function" === typeof h4 ? g4 = new h4("unhandledrejection", { cancelable: true }) : (g4 = y3.document.createEvent("CustomEvent"), g4.initCustomEvent("unhandledrejection", false, true, g4));
            g4.promise = this;
            g4.reason = this.j;
            return k4(g4);
          };
          b3.prototype.H = function() {
            if (null != this.h) {
              for (var g4 = 0; g4 < this.h.length; ++g4)
                f3.i(this.h[g4]);
              this.h = null;
            }
          };
          var f3 = new c5();
          b3.prototype.L = function(g4) {
            var h4 = this.l();
            g4.T(h4.resolve, h4.reject);
          };
          b3.prototype.M = function(g4, h4) {
            var k4 = this.l();
            try {
              g4.call(h4, k4.resolve, k4.reject);
            } catch (l4) {
              k4.reject(l4);
            }
          };
          b3.prototype.then = function(g4, h4) {
            function k4(p4, n4) {
              return "function" == typeof p4 ? function(q4) {
                try {
                  l4(p4(q4));
                } catch (t4) {
                  m4(t4);
                }
              } : n4;
            }
            var l4, m4, r4 = new b3(function(p4, n4) {
              l4 = p4;
              m4 = n4;
            });
            this.T(k4(g4, l4), k4(h4, m4));
            return r4;
          };
          b3.prototype.catch = function(g4) {
            return this.then(void 0, g4);
          };
          b3.prototype.T = function(g4, h4) {
            function k4() {
              switch (l4.i) {
                case 1:
                  g4(l4.j);
                  break;
                case 2:
                  h4(l4.j);
                  break;
                default:
                  throw Error("Unexpected state: " + l4.i);
              }
            }
            var l4 = this;
            null == this.h ? f3.i(k4) : this.h.push(k4);
            this.u = true;
          };
          b3.resolve = d4;
          b3.reject = function(g4) {
            return new b3(function(h4, k4) {
              k4(g4);
            });
          };
          b3.race = function(g4) {
            return new b3(function(h4, k4) {
              for (var l4 = A3(g4), m4 = l4.next(); !m4.done; m4 = l4.next())
                d4(m4.value).T(h4, k4);
            });
          };
          b3.all = function(g4) {
            var h4 = A3(g4), k4 = h4.next();
            return k4.done ? d4([]) : new b3(function(l4, m4) {
              function r4(q4) {
                return function(t4) {
                  p4[q4] = t4;
                  n4--;
                  0 == n4 && l4(p4);
                };
              }
              var p4 = [], n4 = 0;
              do
                p4.push(void 0), n4++, d4(k4.value).T(r4(p4.length - 1), m4), k4 = h4.next();
              while (!k4.done);
            });
          };
          return b3;
        });
        function xa2(a4, b3) {
          a4 instanceof String && (a4 += "");
          var c5 = 0, d4 = false, e4 = { next: function() {
            if (!d4 && c5 < a4.length) {
              var f3 = c5++;
              return { value: b3(f3, a4[f3]), done: false };
            }
            d4 = true;
            return { done: true, value: void 0 };
          } };
          e4[Symbol.iterator] = function() {
            return e4;
          };
          return e4;
        }
        z4("Array.prototype.keys", function(a4) {
          return a4 ? a4 : function() {
            return xa2(this, function(b3) {
              return b3;
            });
          };
        });
        z4("Array.prototype.fill", function(a4) {
          return a4 ? a4 : function(b3, c5, d4) {
            var e4 = this.length || 0;
            0 > c5 && (c5 = Math.max(0, e4 + c5));
            if (null == d4 || d4 > e4)
              d4 = e4;
            d4 = Number(d4);
            0 > d4 && (d4 = Math.max(0, e4 + d4));
            for (c5 = Number(c5 || 0); c5 < d4; c5++)
              this[c5] = b3;
            return this;
          };
        });
        function G4(a4) {
          return a4 ? a4 : Array.prototype.fill;
        }
        z4("Int8Array.prototype.fill", G4);
        z4("Uint8Array.prototype.fill", G4);
        z4("Uint8ClampedArray.prototype.fill", G4);
        z4("Int16Array.prototype.fill", G4);
        z4("Uint16Array.prototype.fill", G4);
        z4("Int32Array.prototype.fill", G4);
        z4("Uint32Array.prototype.fill", G4);
        z4("Float32Array.prototype.fill", G4);
        z4("Float64Array.prototype.fill", G4);
        z4("Object.is", function(a4) {
          return a4 ? a4 : function(b3, c5) {
            return b3 === c5 ? 0 !== b3 || 1 / b3 === 1 / c5 : b3 !== b3 && c5 !== c5;
          };
        });
        z4("Array.prototype.includes", function(a4) {
          return a4 ? a4 : function(b3, c5) {
            var d4 = this;
            d4 instanceof String && (d4 = String(d4));
            var e4 = d4.length;
            c5 = c5 || 0;
            for (0 > c5 && (c5 = Math.max(c5 + e4, 0)); c5 < e4; c5++) {
              var f3 = d4[c5];
              if (f3 === b3 || Object.is(f3, b3))
                return true;
            }
            return false;
          };
        });
        z4("String.prototype.includes", function(a4) {
          return a4 ? a4 : function(b3, c5) {
            if (null == this)
              throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
            if (b3 instanceof RegExp)
              throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
            return -1 !== this.indexOf(b3, c5 || 0);
          };
        });
        var ya2 = this || self;
        function H4(a4, b3) {
          a4 = a4.split(".");
          var c5 = ya2;
          a4[0] in c5 || "undefined" == typeof c5.execScript || c5.execScript("var " + a4[0]);
          for (var d4; a4.length && (d4 = a4.shift()); )
            a4.length || void 0 === b3 ? c5[d4] && c5[d4] !== Object.prototype[d4] ? c5 = c5[d4] : c5 = c5[d4] = {} : c5[d4] = b3;
        }
        ;
        function za3(a4) {
          var b3;
          a: {
            if (b3 = ya2.navigator) {
              if (b3 = b3.userAgent)
                break a;
            }
            b3 = "";
          }
          return -1 != b3.indexOf(a4);
        }
        ;
        var Aa2 = Array.prototype.map ? function(a4, b3) {
          return Array.prototype.map.call(a4, b3, void 0);
        } : function(a4, b3) {
          for (var c5 = a4.length, d4 = Array(c5), e4 = "string" === typeof a4 ? a4.split("") : a4, f3 = 0; f3 < c5; f3++)
            f3 in e4 && (d4[f3] = b3.call(void 0, e4[f3], f3, a4));
          return d4;
        };
        var Ba2 = {}, Ca2 = null;
        function Da2(a4) {
          var b3 = a4.length, c5 = 3 * b3 / 4;
          c5 % 3 ? c5 = Math.floor(c5) : -1 != "=.".indexOf(a4[b3 - 1]) && (c5 = -1 != "=.".indexOf(a4[b3 - 2]) ? c5 - 2 : c5 - 1);
          var d4 = new Uint8Array(c5), e4 = 0;
          Ea2(a4, function(f3) {
            d4[e4++] = f3;
          });
          return e4 !== c5 ? d4.subarray(0, e4) : d4;
        }
        function Ea2(a4, b3) {
          function c5(k4) {
            for (; d4 < a4.length; ) {
              var l4 = a4.charAt(d4++), m4 = Ca2[l4];
              if (null != m4)
                return m4;
              if (!/^[\s\xa0]*$/.test(l4))
                throw Error("Unknown base64 encoding at char: " + l4);
            }
            return k4;
          }
          Fa2();
          for (var d4 = 0; ; ) {
            var e4 = c5(-1), f3 = c5(0), g4 = c5(64), h4 = c5(64);
            if (64 === h4 && -1 === e4)
              break;
            b3(e4 << 2 | f3 >> 4);
            64 != g4 && (b3(f3 << 4 & 240 | g4 >> 2), 64 != h4 && b3(g4 << 6 & 192 | h4));
          }
        }
        function Fa2() {
          if (!Ca2) {
            Ca2 = {};
            for (var a4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b3 = ["+/=", "+/", "-_=", "-_.", "-_"], c5 = 0; 5 > c5; c5++) {
              var d4 = a4.concat(b3[c5].split(""));
              Ba2[c5] = d4;
              for (var e4 = 0; e4 < d4.length; e4++) {
                var f3 = d4[e4];
                void 0 === Ca2[f3] && (Ca2[f3] = e4);
              }
            }
          }
        }
        ;
        var Ga3 = "undefined" !== typeof Uint8Array, Ha2 = !(za3("Trident") || za3("MSIE")) && "function" === typeof ya2.btoa;
        function Ia2(a4) {
          if (!Ha2) {
            var b3;
            void 0 === b3 && (b3 = 0);
            Fa2();
            b3 = Ba2[b3];
            for (var c5 = Array(Math.floor(a4.length / 3)), d4 = b3[64] || "", e4 = 0, f3 = 0; e4 < a4.length - 2; e4 += 3) {
              var g4 = a4[e4], h4 = a4[e4 + 1], k4 = a4[e4 + 2], l4 = b3[g4 >> 2];
              g4 = b3[(g4 & 3) << 4 | h4 >> 4];
              h4 = b3[(h4 & 15) << 2 | k4 >> 6];
              k4 = b3[k4 & 63];
              c5[f3++] = l4 + g4 + h4 + k4;
            }
            l4 = 0;
            k4 = d4;
            switch (a4.length - e4) {
              case 2:
                l4 = a4[e4 + 1], k4 = b3[(l4 & 15) << 2] || d4;
              case 1:
                a4 = a4[e4], c5[f3] = b3[a4 >> 2] + b3[(a4 & 3) << 4 | l4 >> 4] + k4 + d4;
            }
            return c5.join("");
          }
          for (b3 = ""; 10240 < a4.length; )
            b3 += String.fromCharCode.apply(null, a4.subarray(0, 10240)), a4 = a4.subarray(10240);
          b3 += String.fromCharCode.apply(
            null,
            a4
          );
          return btoa(b3);
        }
        var Ja4 = RegExp("[-_.]", "g");
        function Ka4(a4) {
          switch (a4) {
            case "-":
              return "+";
            case "_":
              return "/";
            case ".":
              return "=";
            default:
              return "";
          }
        }
        function La2(a4) {
          if (!Ha2)
            return Da2(a4);
          Ja4.test(a4) && (a4 = a4.replace(Ja4, Ka4));
          a4 = atob(a4);
          for (var b3 = new Uint8Array(a4.length), c5 = 0; c5 < a4.length; c5++)
            b3[c5] = a4.charCodeAt(c5);
          return b3;
        }
        var Na2;
        function Oa3() {
          return Na2 || (Na2 = new Uint8Array(0));
        }
        var Pa2 = {};
        var Qa4 = "function" === typeof Uint8Array.prototype.slice, I3 = 0, J3 = 0;
        function Ra3(a4) {
          var b3 = 0 > a4;
          a4 = Math.abs(a4);
          var c5 = a4 >>> 0;
          a4 = Math.floor((a4 - c5) / 4294967296);
          b3 && (c5 = A3(Sa3(c5, a4)), b3 = c5.next().value, a4 = c5.next().value, c5 = b3);
          I3 = c5 >>> 0;
          J3 = a4 >>> 0;
        }
        function Ta2(a4) {
          a4 = +a4;
          if (0 === a4)
            0 < 1 / a4 ? I3 = J3 = 0 : (J3 = 0, I3 = 2147483648);
          else if (isNaN(a4))
            J3 = 0, I3 = 2147483647;
          else {
            var b3 = 0 > a4 ? -2147483648 : 0;
            a4 = b3 ? -a4 : a4;
            if (34028234663852886e22 < a4)
              J3 = 0, I3 = (b3 | 2139095040) >>> 0;
            else if (11754943508222875e-54 > a4)
              a4 = Math.round(a4 / Math.pow(2, -149)), J3 = 0, I3 = (b3 | a4) >>> 0;
            else {
              var c5 = Math.floor(Math.log(a4) / Math.LN2);
              a4 *= Math.pow(2, -c5);
              a4 = Math.round(8388608 * a4);
              16777216 <= a4 && ++c5;
              J3 = 0;
              I3 = (b3 | c5 + 127 << 23 | a4 & 8388607) >>> 0;
            }
          }
        }
        var Ua2 = "function" === typeof BigInt;
        function Sa3(a4, b3) {
          b3 = ~b3;
          a4 ? a4 = ~a4 + 1 : b3 += 1;
          return [a4, b3];
        }
        ;
        function Va3(a4, b3) {
          this.i = a4 >>> 0;
          this.h = b3 >>> 0;
        }
        function Wa2(a4) {
          if (!a4)
            return Xa4 || (Xa4 = new Va3(0, 0));
          if (!/^-?\d+$/.test(a4))
            return null;
          if (16 > a4.length)
            Ra3(Number(a4));
          else if (Ua2)
            a4 = BigInt(a4), I3 = Number(a4 & BigInt(4294967295)) >>> 0, J3 = Number(a4 >> BigInt(32) & BigInt(4294967295));
          else {
            var b3 = +("-" === a4[0]);
            J3 = I3 = 0;
            for (var c5 = a4.length, d4 = b3, e4 = (c5 - b3) % 6 + b3; e4 <= c5; d4 = e4, e4 += 6)
              d4 = Number(a4.slice(d4, e4)), J3 *= 1e6, I3 = 1e6 * I3 + d4, 4294967296 <= I3 && (J3 += I3 / 4294967296 | 0, I3 %= 4294967296);
            b3 && (b3 = A3(Sa3(I3, J3)), a4 = b3.next().value, b3 = b3.next().value, I3 = a4, J3 = b3);
          }
          return new Va3(I3, J3);
        }
        var Xa4;
        function Ya4(a4, b3) {
          return Error("Invalid wire type: " + a4 + " (at position " + b3 + ")");
        }
        function Za4() {
          return Error("Failed to read varint, encoding is invalid.");
        }
        function $a2(a4, b3) {
          return Error("Tried to read past the end of the data " + b3 + " > " + a4);
        }
        ;
        function ab2() {
          throw Error("Invalid UTF8");
        }
        function bb2(a4, b3) {
          b3 = String.fromCharCode.apply(null, b3);
          return null == a4 ? b3 : a4 + b3;
        }
        var cb2 = void 0, db2, eb2 = "undefined" !== typeof TextDecoder, fb2, gb2 = "undefined" !== typeof TextEncoder;
        var hb2;
        function ib2(a4) {
          if (a4 !== Pa2)
            throw Error("illegal external caller");
        }
        function jb2(a4, b3) {
          ib2(b3);
          this.V = a4;
          if (null != a4 && 0 === a4.length)
            throw Error("ByteString should be constructed with non-empty values");
        }
        function kb2() {
          return hb2 || (hb2 = new jb2(null, Pa2));
        }
        function lb2(a4) {
          ib2(Pa2);
          var b3 = a4.V;
          b3 = null == b3 || Ga3 && null != b3 && b3 instanceof Uint8Array ? b3 : "string" === typeof b3 ? La2(b3) : null;
          return null == b3 ? b3 : a4.V = b3;
        }
        ;
        function mb2(a4) {
          if ("string" === typeof a4)
            return { buffer: La2(a4), C: false };
          if (Array.isArray(a4))
            return { buffer: new Uint8Array(a4), C: false };
          if (a4.constructor === Uint8Array)
            return { buffer: a4, C: false };
          if (a4.constructor === ArrayBuffer)
            return { buffer: new Uint8Array(a4), C: false };
          if (a4.constructor === jb2)
            return { buffer: lb2(a4) || Oa3(), C: true };
          if (a4 instanceof Uint8Array)
            return { buffer: new Uint8Array(a4.buffer, a4.byteOffset, a4.byteLength), C: false };
          throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
        }
        ;
        function nb2(a4, b3) {
          this.i = null;
          this.u = false;
          this.h = this.j = this.m = 0;
          ob2(this, a4, b3);
        }
        function ob2(a4, b3, c5) {
          c5 = void 0 === c5 ? {} : c5;
          a4.S = void 0 === c5.S ? false : c5.S;
          b3 && (b3 = mb2(b3), a4.i = b3.buffer, a4.u = b3.C, a4.m = 0, a4.j = a4.i.length, a4.h = a4.m);
        }
        nb2.prototype.reset = function() {
          this.h = this.m;
        };
        function pb2(a4, b3) {
          a4.h = b3;
          if (b3 > a4.j)
            throw $a2(a4.j, b3);
        }
        function qb2(a4) {
          var b3 = a4.i, c5 = a4.h, d4 = b3[c5++], e4 = d4 & 127;
          if (d4 & 128 && (d4 = b3[c5++], e4 |= (d4 & 127) << 7, d4 & 128 && (d4 = b3[c5++], e4 |= (d4 & 127) << 14, d4 & 128 && (d4 = b3[c5++], e4 |= (d4 & 127) << 21, d4 & 128 && (d4 = b3[c5++], e4 |= d4 << 28, d4 & 128 && b3[c5++] & 128 && b3[c5++] & 128 && b3[c5++] & 128 && b3[c5++] & 128 && b3[c5++] & 128)))))
            throw Za4();
          pb2(a4, c5);
          return e4;
        }
        nb2.prototype.l = function() {
          return qb2(this) >>> 0;
        };
        nb2.prototype.s = function() {
          var a4 = this.i, b3 = this.h, c5 = a4[b3], d4 = a4[b3 + 1];
          var e4 = a4[b3 + 2];
          a4 = a4[b3 + 3];
          pb2(this, this.h + 4);
          e4 = (c5 << 0 | d4 << 8 | e4 << 16 | a4 << 24) >>> 0;
          c5 = 2 * (e4 >> 31) + 1;
          d4 = e4 >>> 23 & 255;
          e4 &= 8388607;
          return 255 == d4 ? e4 ? NaN : Infinity * c5 : 0 == d4 ? c5 * Math.pow(2, -149) * e4 : c5 * Math.pow(2, d4 - 150) * (e4 + Math.pow(2, 23));
        };
        function rb2(a4, b3) {
          if (0 > b3)
            throw Error("Tried to read a negative byte length: " + b3);
          var c5 = a4.h, d4 = c5 + b3;
          if (d4 > a4.j)
            throw $a2(b3, a4.j - c5);
          a4.h = d4;
          return c5;
        }
        var sb2 = [];
        function tb2() {
          this.h = [];
        }
        tb2.prototype.length = function() {
          return this.h.length;
        };
        tb2.prototype.end = function() {
          var a4 = this.h;
          this.h = [];
          return a4;
        };
        function ub2(a4, b3, c5) {
          for (; 0 < c5 || 127 < b3; )
            a4.h.push(b3 & 127 | 128), b3 = (b3 >>> 7 | c5 << 25) >>> 0, c5 >>>= 7;
          a4.h.push(b3);
        }
        function vb2(a4, b3) {
          for (; 127 < b3; )
            a4.h.push(b3 & 127 | 128), b3 >>>= 7;
          a4.h.push(b3);
        }
        function wb2(a4, b3) {
          if (0 <= b3)
            vb2(a4, b3);
          else {
            for (var c5 = 0; 9 > c5; c5++)
              a4.h.push(b3 & 127 | 128), b3 >>= 7;
            a4.h.push(1);
          }
        }
        function xb2(a4) {
          var b3 = I3;
          a4.h.push(b3 >>> 0 & 255);
          a4.h.push(b3 >>> 8 & 255);
          a4.h.push(b3 >>> 16 & 255);
          a4.h.push(b3 >>> 24 & 255);
        }
        ;
        function yb2(a4, b3) {
          if (sb2.length) {
            var c5 = sb2.pop();
            ob2(c5, a4, b3);
            a4 = c5;
          } else
            a4 = new nb2(a4, b3);
          this.h = a4;
          this.j = this.h.h;
          this.i = this.l = -1;
          this.setOptions(b3);
        }
        yb2.prototype.setOptions = function(a4) {
          a4 = void 0 === a4 ? {} : a4;
          this.ca = void 0 === a4.ca ? false : a4.ca;
        };
        yb2.prototype.reset = function() {
          this.h.reset();
          this.j = this.h.h;
          this.i = this.l = -1;
        };
        function zb2(a4) {
          var b3 = a4.h;
          if (b3.h == b3.j)
            return false;
          a4.j = a4.h.h;
          var c5 = a4.h.l();
          b3 = c5 >>> 3;
          c5 &= 7;
          if (!(0 <= c5 && 5 >= c5))
            throw Ya4(c5, a4.j);
          if (1 > b3)
            throw Error("Invalid field number: " + b3 + " (at position " + a4.j + ")");
          a4.l = b3;
          a4.i = c5;
          return true;
        }
        function Ab2(a4) {
          switch (a4.i) {
            case 0:
              if (0 != a4.i)
                Ab2(a4);
              else
                a: {
                  a4 = a4.h;
                  for (var b3 = a4.h, c5 = b3 + 10, d4 = a4.i; b3 < c5; )
                    if (0 === (d4[b3++] & 128)) {
                      pb2(a4, b3);
                      break a;
                    }
                  throw Za4();
                }
              break;
            case 1:
              a4 = a4.h;
              pb2(a4, a4.h + 8);
              break;
            case 2:
              2 != a4.i ? Ab2(a4) : (b3 = a4.h.l(), a4 = a4.h, pb2(a4, a4.h + b3));
              break;
            case 5:
              a4 = a4.h;
              pb2(a4, a4.h + 4);
              break;
            case 3:
              b3 = a4.l;
              do {
                if (!zb2(a4))
                  throw Error("Unmatched start-group tag: stream EOF");
                if (4 == a4.i) {
                  if (a4.l != b3)
                    throw Error("Unmatched end-group tag");
                  break;
                }
                Ab2(a4);
              } while (1);
              break;
            default:
              throw Ya4(a4.i, a4.j);
          }
        }
        function Bb2(a4, b3, c5) {
          var d4 = a4.h.j, e4 = a4.h.l(), f3 = a4.h.h + e4, g4 = f3 - d4;
          0 >= g4 && (a4.h.j = f3, c5(b3, a4, void 0, void 0, void 0), g4 = f3 - a4.h.h);
          if (g4)
            throw Error("Message parsing ended unexpectedly. Expected to read " + (e4 + " bytes, instead read " + (e4 - g4) + " bytes, either the data ended unexpectedly or the message misreported its own length"));
          a4.h.h = f3;
          a4.h.j = d4;
        }
        function Cb2(a4, b3, c5) {
          var d4 = a4.h.l();
          for (d4 = a4.h.h + d4; a4.h.h < d4; )
            c5.push(b3.call(a4.h));
        }
        var Db2 = [];
        function Eb2() {
          this.j = [];
          this.i = 0;
          this.h = new tb2();
        }
        function Fb2(a4, b3) {
          0 !== b3.length && (a4.j.push(b3), a4.i += b3.length);
        }
        function Gb3(a4, b3) {
          L3(a4, b3, 2);
          b3 = a4.h.end();
          Fb2(a4, b3);
          b3.push(a4.i);
          return b3;
        }
        function Hb2(a4, b3) {
          var c5 = b3.pop();
          for (c5 = a4.i + a4.h.length() - c5; 127 < c5; )
            b3.push(c5 & 127 | 128), c5 >>>= 7, a4.i++;
          b3.push(c5);
          a4.i++;
        }
        function Ib2(a4, b3) {
          if (b3 = b3.R) {
            Fb2(a4, a4.h.end());
            for (var c5 = 0; c5 < b3.length; c5++)
              Fb2(a4, lb2(b3[c5]) || Oa3());
          }
        }
        function L3(a4, b3, c5) {
          vb2(a4.h, 8 * b3 + c5);
        }
        ;
        var N4 = "function" === typeof Symbol && "symbol" === typeof Symbol() ? Symbol() : void 0;
        function O5(a4, b3) {
          if (N4)
            return a4[N4] |= b3;
          if (void 0 !== a4.B)
            return a4.B |= b3;
          Object.defineProperties(a4, { B: { value: b3, configurable: true, writable: true, enumerable: false } });
          return b3;
        }
        function Jb3(a4, b3) {
          var c5 = P4(a4);
          (c5 & b3) !== b3 && (Object.isFrozen(a4) && (a4 = Array.prototype.slice.call(a4)), Q3(a4, c5 | b3));
          return a4;
        }
        function Kb2(a4, b3) {
          N4 ? a4[N4] && (a4[N4] &= ~b3) : void 0 !== a4.B && (a4.B &= ~b3);
        }
        function P4(a4) {
          var b3;
          N4 ? b3 = a4[N4] : b3 = a4.B;
          return null == b3 ? 0 : b3;
        }
        function Q3(a4, b3) {
          N4 ? a4[N4] = b3 : void 0 !== a4.B ? a4.B = b3 : Object.defineProperties(a4, { B: { value: b3, configurable: true, writable: true, enumerable: false } });
        }
        function Lb2(a4) {
          O5(a4, 1);
          return a4;
        }
        function R5(a4) {
          return !!(P4(a4) & 2);
        }
        function Mb2(a4, b3) {
          Q3(b3, (a4 | 0) & -51);
        }
        function Nb2(a4, b3) {
          Q3(b3, (a4 | 18) & -41);
        }
        ;
        var Ob2 = {};
        function Pb2(a4) {
          return null !== a4 && "object" === typeof a4 && !Array.isArray(a4) && a4.constructor === Object;
        }
        var Qb3, Rb2 = [];
        Q3(Rb2, 23);
        Qb3 = Object.freeze(Rb2);
        function Sb2(a4) {
          if (R5(a4.o))
            throw Error("Cannot mutate an immutable Message");
        }
        function Tb2(a4) {
          var b3 = a4.length;
          (b3 = b3 ? a4[b3 - 1] : void 0) && Pb2(b3) ? b3.g = 1 : (b3 = {}, a4.push((b3.g = 1, b3)));
        }
        ;
        function Ub2(a4) {
          if (null == a4)
            return a4;
          if ("number" === typeof a4 || "NaN" === a4 || "Infinity" === a4 || "-Infinity" === a4)
            return Number(a4);
        }
        function Vb2(a4, b3, c5) {
          var d4 = false;
          if (null != a4 && "object" === typeof a4 && !(d4 = Array.isArray(a4)) && a4.fa === Ob2)
            return a4;
          if (d4)
            return new b3(a4);
          if (c5)
            return new b3();
        }
        ;
        function Wb2(a4) {
          var b3 = a4.i + a4.G;
          return a4.A || (a4.A = a4.o[b3] = {});
        }
        function S3(a4, b3, c5) {
          return -1 === b3 ? null : b3 >= a4.i ? a4.A ? a4.A[b3] : void 0 : c5 && a4.A && (c5 = a4.A[b3], null != c5) ? c5 : a4.o[b3 + a4.G];
        }
        function T3(a4, b3, c5, d4) {
          Sb2(a4);
          U5(a4, b3, c5, d4);
        }
        function U5(a4, b3, c5, d4) {
          a4.j && (a4.j = void 0);
          b3 >= a4.i || d4 ? Wb2(a4)[b3] = c5 : (a4.o[b3 + a4.G] = c5, (a4 = a4.A) && b3 in a4 && delete a4[b3]);
        }
        function Xb3(a4, b3, c5, d4, e4) {
          var f3 = S3(a4, b3, d4);
          Array.isArray(f3) || (f3 = Qb3);
          var g4 = P4(f3);
          g4 & 1 || Lb2(f3);
          if (e4)
            g4 & 2 || O5(f3, 2), c5 & 1 || Object.freeze(f3);
          else {
            e4 = !(c5 & 2);
            var h4 = g4 & 2;
            c5 & 1 || !h4 ? e4 && g4 & 16 && !h4 && Kb2(f3, 16) : (f3 = Lb2(Array.prototype.slice.call(f3)), U5(a4, b3, f3, d4));
          }
          return f3;
        }
        function Yb3(a4, b3) {
          return Xb3(a4, b3, 0, false, R5(a4.o));
        }
        function Zb3(a4, b3) {
          var c5 = S3(a4, b3), d4 = Ub2(c5);
          null != d4 && d4 !== c5 && U5(a4, b3, d4);
          return d4;
        }
        function $b2(a4, b3) {
          var c5 = R5(a4.o), d4 = Xb3(a4, b3, 1, void 0, c5), e4 = P4(d4);
          if (!(e4 & 4)) {
            Object.isFrozen(d4) && (d4 = Lb2(d4.slice()), U5(a4, b3, d4));
            for (var f3 = 0, g4 = 0; f3 < d4.length; f3++) {
              var h4 = Ub2(d4[f3]);
              null != h4 && (d4[g4++] = h4);
            }
            g4 < f3 && (d4.length = g4);
            O5(d4, 5);
            c5 && (O5(d4, 2), Object.freeze(d4));
          }
          !c5 && (e4 & 2 || Object.isFrozen(d4)) && (d4 = Array.prototype.slice.call(d4), O5(d4, 5), c5 = d4, c5 = null == c5 ? Qb3 : Jb3(c5, 1), T3(a4, b3, c5));
          return d4;
        }
        function ac2(a4, b3, c5) {
          var d4 = void 0 === d4 ? false : d4;
          var e4 = S3(a4, c5, d4);
          b3 = Vb2(e4, b3);
          b3 !== e4 && null != b3 && (U5(a4, c5, b3, d4), O5(b3.o, P4(a4.o) & 18));
          e4 = b3;
          if (null == e4)
            return e4;
          R5(a4.o) || (b3 = bc3(e4), b3 !== e4 && (e4 = b3, U5(a4, c5, e4, d4)));
          return e4;
        }
        function cc2(a4, b3, c5, d4, e4) {
          a4.h || (a4.h = {});
          var f3 = a4.h[c5], g4 = Xb3(a4, c5, 3, void 0, e4);
          if (!f3) {
            var h4 = g4;
            f3 = [];
            var k4 = !!(P4(a4.o) & 16);
            g4 = R5(h4);
            var l4 = h4;
            !e4 && g4 && (h4 = Array.prototype.slice.call(h4));
            for (var m4 = g4, r4 = 0; r4 < h4.length; r4++) {
              var p4 = h4[r4];
              var n4 = b3, q4 = false;
              q4 = void 0 === q4 ? false : q4;
              p4 = Array.isArray(p4) ? new n4(p4) : q4 ? new n4() : void 0;
              if (void 0 !== p4) {
                n4 = p4.o;
                var t4 = q4 = P4(n4);
                g4 && (t4 |= 2);
                k4 && (t4 |= 16);
                t4 != q4 && Q3(n4, t4);
                n4 = t4;
                m4 = m4 || !!(2 & n4);
                f3.push(p4);
              }
            }
            a4.h[c5] = f3;
            k4 = P4(h4);
            b3 = k4 | 33;
            b3 = m4 ? b3 & -9 : b3 | 8;
            k4 != b3 && (m4 = h4, Object.isFrozen(m4) && (m4 = Array.prototype.slice.call(m4)), Q3(m4, b3), h4 = m4);
            l4 !== h4 && U5(
              a4,
              c5,
              h4
            );
            (e4 || d4 && g4) && O5(f3, 2);
            d4 && Object.freeze(f3);
            return f3;
          }
          e4 || (e4 = Object.isFrozen(f3), d4 && !e4 ? Object.freeze(f3) : !d4 && e4 && (f3 = Array.prototype.slice.call(f3), a4.h[c5] = f3));
          return f3;
        }
        function dc3(a4, b3, c5) {
          var d4 = R5(a4.o);
          b3 = cc2(a4, b3, c5, d4, d4);
          a4 = Xb3(a4, c5, 3, void 0, d4);
          if (!(d4 || P4(a4) & 8)) {
            for (d4 = 0; d4 < b3.length; d4++) {
              c5 = b3[d4];
              var e4 = bc3(c5);
              c5 !== e4 && (b3[d4] = e4, a4[d4] = e4.o);
            }
            O5(a4, 8);
          }
          return b3;
        }
        function V4(a4, b3, c5) {
          if (null != c5 && "number" !== typeof c5)
            throw Error("Value of float/double field must be a number|null|undefined, found " + typeof c5 + ": " + c5);
          T3(a4, b3, c5);
        }
        function ec3(a4, b3, c5, d4, e4) {
          Sb2(a4);
          var f3 = cc2(a4, c5, b3, false, false);
          c5 = null != d4 ? d4 : new c5();
          a4 = Xb3(a4, b3, 2, void 0, false);
          void 0 != e4 ? (f3.splice(e4, 0, c5), a4.splice(e4, 0, c5.o)) : (f3.push(c5), a4.push(c5.o));
          c5.C() && Kb2(a4, 8);
          return c5;
        }
        function fc2(a4, b3) {
          a4 = S3(a4, b3);
          return null == a4 ? 0 : a4;
        }
        function gc2(a4, b3) {
          return null == a4 ? b3 : a4;
        }
        function W4(a4, b3, c5) {
          c5 = void 0 === c5 ? 0 : c5;
          return gc2(Zb3(a4, b3), c5);
        }
        ;
        var hc2;
        function ic3(a4) {
          switch (typeof a4) {
            case "number":
              return isFinite(a4) ? a4 : String(a4);
            case "object":
              if (a4)
                if (Array.isArray(a4)) {
                  if (0 !== (P4(a4) & 128))
                    return a4 = Array.prototype.slice.call(a4), Tb2(a4), a4;
                } else {
                  if (Ga3 && null != a4 && a4 instanceof Uint8Array)
                    return Ia2(a4);
                  if (a4 instanceof jb2) {
                    var b3 = a4.V;
                    return null == b3 ? "" : "string" === typeof b3 ? b3 : a4.V = Ia2(b3);
                  }
                }
          }
          return a4;
        }
        ;
        function jc2(a4, b3, c5, d4) {
          if (null != a4) {
            if (Array.isArray(a4))
              a4 = kc3(a4, b3, c5, void 0 !== d4);
            else if (Pb2(a4)) {
              var e4 = {}, f3;
              for (f3 in a4)
                e4[f3] = jc2(a4[f3], b3, c5, d4);
              a4 = e4;
            } else
              a4 = b3(a4, d4);
            return a4;
          }
        }
        function kc3(a4, b3, c5, d4) {
          var e4 = P4(a4);
          d4 = d4 ? !!(e4 & 16) : void 0;
          a4 = Array.prototype.slice.call(a4);
          for (var f3 = 0; f3 < a4.length; f3++)
            a4[f3] = jc2(a4[f3], b3, c5, d4);
          c5(e4, a4);
          return a4;
        }
        function lc2(a4) {
          return a4.fa === Ob2 ? a4.toJSON() : ic3(a4);
        }
        function mc3(a4, b3) {
          a4 & 128 && Tb2(b3);
        }
        ;
        function nc3(a4, b3, c5) {
          c5 = void 0 === c5 ? Nb2 : c5;
          if (null != a4) {
            if (Ga3 && a4 instanceof Uint8Array)
              return a4.length ? new jb2(new Uint8Array(a4), Pa2) : kb2();
            if (Array.isArray(a4)) {
              var d4 = P4(a4);
              if (d4 & 2)
                return a4;
              if (b3 && !(d4 & 32) && (d4 & 16 || 0 === d4))
                return Q3(a4, d4 | 2), a4;
              a4 = kc3(a4, nc3, d4 & 4 ? Nb2 : c5, true);
              b3 = P4(a4);
              b3 & 4 && b3 & 2 && Object.freeze(a4);
              return a4;
            }
            return a4.fa === Ob2 ? oc2(a4) : a4;
          }
        }
        function pc2(a4, b3, c5, d4, e4, f3, g4) {
          if (a4 = a4.h && a4.h[c5]) {
            d4 = P4(a4);
            d4 & 2 ? d4 = a4 : (f3 = Aa2(a4, oc2), Nb2(d4, f3), Object.freeze(f3), d4 = f3);
            Sb2(b3);
            f3 = null == d4 ? Qb3 : Lb2([]);
            if (null != d4) {
              g4 = !!d4.length;
              for (a4 = 0; a4 < d4.length; a4++) {
                var h4 = d4[a4];
                g4 = g4 && !R5(h4.o);
                f3[a4] = h4.o;
              }
              f3 = Jb3(f3, (g4 ? 8 : 0) | 1);
              b3.h || (b3.h = {});
              b3.h[c5] = d4;
            } else
              b3.h && (b3.h[c5] = void 0);
            U5(b3, c5, f3, e4);
          } else
            T3(b3, c5, nc3(d4, f3, g4), e4);
        }
        function oc2(a4) {
          if (R5(a4.o))
            return a4;
          a4 = qc2(a4, true);
          O5(a4.o, 2);
          return a4;
        }
        function qc2(a4, b3) {
          var c5 = a4.o, d4 = [];
          O5(d4, 16);
          var e4 = a4.constructor.h;
          e4 && d4.push(e4);
          e4 = a4.A;
          if (e4) {
            d4.length = c5.length;
            d4.fill(void 0, d4.length, c5.length);
            var f3 = {};
            d4[d4.length - 1] = f3;
          }
          0 !== (P4(c5) & 128) && Tb2(d4);
          b3 = b3 || a4.C() ? Nb2 : Mb2;
          f3 = a4.constructor;
          hc2 = d4;
          d4 = new f3(d4);
          hc2 = void 0;
          a4.R && (d4.R = a4.R.slice());
          f3 = !!(P4(c5) & 16);
          for (var g4 = e4 ? c5.length - 1 : c5.length, h4 = 0; h4 < g4; h4++)
            pc2(a4, d4, h4 - a4.G, c5[h4], false, f3, b3);
          if (e4)
            for (var k4 in e4)
              pc2(a4, d4, +k4, e4[k4], true, f3, b3);
          return d4;
        }
        function bc3(a4) {
          if (!R5(a4.o))
            return a4;
          var b3 = qc2(a4, false);
          b3.j = a4;
          return b3;
        }
        ;
        function X4(a4, b3, c5) {
          null == a4 && (a4 = hc2);
          hc2 = void 0;
          var d4 = this.constructor.i || 0, e4 = 0 < d4, f3 = this.constructor.h, g4 = false;
          if (null == a4) {
            a4 = f3 ? [f3] : [];
            var h4 = 48;
            var k4 = true;
            e4 && (d4 = 0, h4 |= 128);
            Q3(a4, h4);
          } else {
            if (!Array.isArray(a4))
              throw Error();
            if (f3 && f3 !== a4[0])
              throw Error();
            var l4 = h4 = O5(a4, 0);
            if (k4 = 0 !== (16 & l4))
              (g4 = 0 !== (32 & l4)) || (l4 |= 32);
            if (e4)
              if (128 & l4)
                d4 = 0;
              else {
                if (0 < a4.length) {
                  var m4 = a4[a4.length - 1];
                  if (Pb2(m4) && "g" in m4) {
                    d4 = 0;
                    l4 |= 128;
                    delete m4.g;
                    var r4 = true, p4;
                    for (p4 in m4) {
                      r4 = false;
                      break;
                    }
                    r4 && a4.pop();
                  }
                }
              }
            else if (128 & l4)
              throw Error();
            h4 !== l4 && Q3(a4, l4);
          }
          this.G = (f3 ? 0 : -1) - d4;
          this.h = void 0;
          this.o = a4;
          a: {
            f3 = this.o.length;
            d4 = f3 - 1;
            if (f3 && (f3 = this.o[d4], Pb2(f3))) {
              this.A = f3;
              this.i = d4 - this.G;
              break a;
            }
            void 0 !== b3 && -1 < b3 ? (this.i = Math.max(b3, d4 + 1 - this.G), this.A = void 0) : this.i = Number.MAX_VALUE;
          }
          if (!e4 && this.A && "g" in this.A)
            throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');
          if (c5) {
            b3 = k4 && !g4 && true;
            e4 = this.i;
            var n4;
            for (k4 = 0; k4 < c5.length; k4++)
              g4 = c5[k4], g4 < e4 ? (g4 += this.G, (d4 = a4[g4]) ? rc3(d4, b3) : a4[g4] = Qb3) : (n4 || (n4 = Wb2(this)), (d4 = n4[g4]) ? rc3(d4, b3) : n4[g4] = Qb3);
          }
        }
        X4.prototype.toJSON = function() {
          return kc3(this.o, lc2, mc3);
        };
        X4.prototype.C = function() {
          return R5(this.o);
        };
        function rc3(a4, b3) {
          if (Array.isArray(a4)) {
            var c5 = P4(a4), d4 = 1;
            !b3 || c5 & 2 || (d4 |= 16);
            (c5 & d4) !== d4 && Q3(a4, c5 | d4);
          }
        }
        X4.prototype.fa = Ob2;
        X4.prototype.toString = function() {
          return this.o.toString();
        };
        function sc3(a4, b3, c5) {
          if (c5) {
            var d4 = {}, e4;
            for (e4 in c5) {
              var f3 = c5[e4], g4 = f3.qa;
              g4 || (d4.J = f3.wa || f3.oa.W, f3.ja ? (d4.aa = tc3(f3.ja), g4 = /* @__PURE__ */ function(h4) {
                return function(k4, l4, m4) {
                  return h4.J(k4, l4, m4, h4.aa);
                };
              }(d4)) : f3.ka ? (d4.Z = uc2(f3.da.P, f3.ka), g4 = /* @__PURE__ */ function(h4) {
                return function(k4, l4, m4) {
                  return h4.J(k4, l4, m4, h4.Z);
                };
              }(d4)) : g4 = d4.J, f3.qa = g4);
              g4(b3, a4, f3.da);
              d4 = { J: d4.J, aa: d4.aa, Z: d4.Z };
            }
          }
          Ib2(b3, a4);
        }
        var vc3 = Symbol();
        function wc3(a4, b3, c5) {
          return a4[vc3] || (a4[vc3] = function(d4, e4) {
            return b3(d4, e4, c5);
          });
        }
        function xc3(a4) {
          var b3 = a4[vc3];
          if (!b3) {
            var c5 = yc3(a4);
            b3 = function(d4, e4) {
              return zc2(d4, e4, c5);
            };
            a4[vc3] = b3;
          }
          return b3;
        }
        function Ac3(a4) {
          var b3 = a4.ja;
          if (b3)
            return xc3(b3);
          if (b3 = a4.va)
            return wc3(a4.da.P, b3, a4.ka);
        }
        function Bc3(a4) {
          var b3 = Ac3(a4), c5 = a4.da, d4 = a4.oa.U;
          return b3 ? function(e4, f3) {
            return d4(e4, f3, c5, b3);
          } : function(e4, f3) {
            return d4(e4, f3, c5);
          };
        }
        function Cc3(a4, b3) {
          var c5 = a4[b3];
          "function" == typeof c5 && 0 === c5.length && (c5 = c5(), a4[b3] = c5);
          return Array.isArray(c5) && (Dc2 in c5 || Ec3 in c5 || 0 < c5.length && "function" == typeof c5[0]) ? c5 : void 0;
        }
        function Fc2(a4, b3, c5, d4, e4, f3) {
          b3.P = a4[0];
          var g4 = 1;
          if (a4.length > g4 && "number" !== typeof a4[g4]) {
            var h4 = a4[g4++];
            c5(b3, h4);
          }
          for (; g4 < a4.length; ) {
            c5 = a4[g4++];
            for (var k4 = g4 + 1; k4 < a4.length && "number" !== typeof a4[k4]; )
              k4++;
            h4 = a4[g4++];
            k4 -= g4;
            switch (k4) {
              case 0:
                d4(b3, c5, h4);
                break;
              case 1:
                (k4 = Cc3(a4, g4)) ? (g4++, e4(b3, c5, h4, k4)) : d4(b3, c5, h4, a4[g4++]);
                break;
              case 2:
                k4 = g4++;
                k4 = Cc3(a4, k4);
                e4(b3, c5, h4, k4, a4[g4++]);
                break;
              case 3:
                f3(b3, c5, h4, a4[g4++], a4[g4++], a4[g4++]);
                break;
              case 4:
                f3(b3, c5, h4, a4[g4++], a4[g4++], a4[g4++], a4[g4++]);
                break;
              default:
                throw Error("unexpected number of binary field arguments: " + k4);
            }
          }
          return b3;
        }
        var Gc2 = Symbol();
        function tc3(a4) {
          var b3 = a4[Gc2];
          if (!b3) {
            var c5 = Hc2(a4);
            b3 = function(d4, e4) {
              return Ic3(d4, e4, c5);
            };
            a4[Gc2] = b3;
          }
          return b3;
        }
        function uc2(a4, b3) {
          var c5 = a4[Gc2];
          c5 || (c5 = function(d4, e4) {
            return sc3(d4, e4, b3);
          }, a4[Gc2] = c5);
          return c5;
        }
        var Ec3 = Symbol();
        function Jc2(a4, b3) {
          a4.push(b3);
        }
        function Kc2(a4, b3, c5) {
          a4.push(b3, c5.W);
        }
        function Lc3(a4, b3, c5, d4) {
          var e4 = tc3(d4), f3 = Hc2(d4).P, g4 = c5.W;
          a4.push(b3, function(h4, k4, l4) {
            return g4(h4, k4, l4, f3, e4);
          });
        }
        function Mc3(a4, b3, c5, d4, e4, f3) {
          var g4 = uc2(d4, f3), h4 = c5.W;
          a4.push(b3, function(k4, l4, m4) {
            return h4(k4, l4, m4, d4, g4);
          });
        }
        function Hc2(a4) {
          var b3 = a4[Ec3];
          if (b3)
            return b3;
          b3 = Fc2(a4, a4[Ec3] = [], Jc2, Kc2, Lc3, Mc3);
          Dc2 in a4 && Ec3 in a4 && (a4.length = 0);
          return b3;
        }
        var Dc2 = Symbol();
        function Nc2(a4, b3) {
          a4[0] = b3;
        }
        function Oc3(a4, b3, c5, d4) {
          var e4 = c5.U;
          a4[b3] = d4 ? function(f3, g4, h4) {
            return e4(f3, g4, h4, d4);
          } : e4;
        }
        function Pc3(a4, b3, c5, d4, e4) {
          var f3 = c5.U, g4 = xc3(d4), h4 = yc3(d4).P;
          a4[b3] = function(k4, l4, m4) {
            return f3(k4, l4, m4, h4, g4, e4);
          };
        }
        function Qc2(a4, b3, c5, d4, e4, f3, g4) {
          var h4 = c5.U, k4 = wc3(d4, e4, f3);
          a4[b3] = function(l4, m4, r4) {
            return h4(l4, m4, r4, d4, k4, g4);
          };
        }
        function yc3(a4) {
          var b3 = a4[Dc2];
          if (b3)
            return b3;
          b3 = Fc2(a4, a4[Dc2] = {}, Nc2, Oc3, Pc3, Qc2);
          Dc2 in a4 && Ec3 in a4 && (a4.length = 0);
          return b3;
        }
        function zc2(a4, b3, c5) {
          for (; zb2(b3) && 4 != b3.i; ) {
            var d4 = b3.l, e4 = c5[d4];
            if (!e4) {
              var f3 = c5[0];
              f3 && (f3 = f3[d4]) && (e4 = c5[d4] = Bc3(f3));
            }
            if (!e4 || !e4(b3, a4, d4)) {
              e4 = b3;
              d4 = a4;
              f3 = e4.j;
              Ab2(e4);
              var g4 = e4;
              if (!g4.ca) {
                e4 = g4.h.h - f3;
                g4.h.h = f3;
                g4 = g4.h;
                if (0 == e4)
                  e4 = kb2();
                else {
                  f3 = rb2(g4, e4);
                  if (g4.S && g4.u)
                    e4 = g4.i.subarray(f3, f3 + e4);
                  else {
                    g4 = g4.i;
                    var h4 = f3;
                    e4 = f3 + e4;
                    e4 = h4 === e4 ? Oa3() : Qa4 ? g4.slice(h4, e4) : new Uint8Array(g4.subarray(h4, e4));
                  }
                  e4 = 0 == e4.length ? kb2() : new jb2(e4, Pa2);
                }
                (f3 = d4.R) ? f3.push(e4) : d4.R = [e4];
              }
            }
          }
          return a4;
        }
        function Ic3(a4, b3, c5) {
          for (var d4 = c5.length, e4 = 1 == d4 % 2, f3 = e4 ? 1 : 0; f3 < d4; f3 += 2)
            (0, c5[f3 + 1])(b3, a4, c5[f3]);
          sc3(a4, b3, e4 ? c5[0] : void 0);
        }
        function Y5(a4, b3) {
          return { U: a4, W: b3 };
        }
        function Rc3(a4, b3, c5) {
          if (5 !== a4.i && 2 !== a4.i)
            return false;
          b3 = Yb3(b3, c5);
          2 == a4.i ? Cb2(a4, nb2.prototype.s, b3) : b3.push(a4.h.s());
          return true;
        }
        var Z6 = Y5(function(a4, b3, c5) {
          if (5 !== a4.i)
            return false;
          T3(b3, c5, a4.h.s());
          return true;
        }, function(a4, b3, c5) {
          b3 = Zb3(b3, c5);
          null != b3 && (L3(a4, c5, 5), a4 = a4.h, Ta2(b3), xb2(a4));
        }), Sc3 = Y5(Rc3, function(a4, b3, c5) {
          b3 = $b2(b3, c5);
          if (null != b3)
            for (var d4 = 0; d4 < b3.length; d4++) {
              var e4 = a4, f3 = b3[d4];
              null != f3 && (L3(e4, c5, 5), e4 = e4.h, Ta2(f3), xb2(e4));
            }
        }), Tc3 = Y5(Rc3, function(a4, b3, c5) {
          b3 = $b2(b3, c5);
          if (null != b3 && b3.length)
            for (L3(a4, c5, 2), vb2(a4.h, 4 * b3.length), c5 = 0; c5 < b3.length; c5++) {
              var d4 = a4.h;
              Ta2(b3[c5]);
              xb2(d4);
            }
        }), Uc3 = Y5(function(a4, b3, c5) {
          if (0 !== a4.i)
            return false;
          var d4 = a4.h, e4 = 0, f3 = a4 = 0, g4 = d4.i, h4 = d4.h;
          do {
            var k4 = g4[h4++];
            e4 |= (k4 & 127) << f3;
            f3 += 7;
          } while (32 > f3 && k4 & 128);
          32 < f3 && (a4 |= (k4 & 127) >> 4);
          for (f3 = 3; 32 > f3 && k4 & 128; f3 += 7)
            k4 = g4[h4++], a4 |= (k4 & 127) << f3;
          pb2(d4, h4);
          if (128 > k4) {
            d4 = e4 >>> 0;
            k4 = a4 >>> 0;
            if (a4 = k4 & 2147483648)
              d4 = ~d4 + 1 >>> 0, k4 = ~k4 >>> 0, 0 == d4 && (k4 = k4 + 1 >>> 0);
            d4 = 4294967296 * k4 + (d4 >>> 0);
          } else
            throw Za4();
          T3(b3, c5, a4 ? -d4 : d4);
          return true;
        }, function(a4, b3, c5) {
          b3 = S3(b3, c5);
          null != b3 && ("string" === typeof b3 && Wa2(b3), null != b3 && (L3(a4, c5, 0), "number" === typeof b3 ? (a4 = a4.h, Ra3(b3), ub2(a4, I3, J3)) : (c5 = Wa2(b3), ub2(a4.h, c5.i, c5.h))));
        }), Vc2 = Y5(function(a4, b3, c5) {
          if (0 !== a4.i)
            return false;
          T3(b3, c5, qb2(a4.h));
          return true;
        }, function(a4, b3, c5) {
          b3 = S3(b3, c5);
          null != b3 && null != b3 && (L3(a4, c5, 0), wb2(a4.h, b3));
        }), Wc2 = Y5(function(a4, b3, c5) {
          if (2 !== a4.i)
            return false;
          var d4 = a4.h.l();
          a4 = a4.h;
          var e4 = rb2(a4, d4);
          a4 = a4.i;
          if (eb2) {
            var f3 = a4, g4;
            (g4 = db2) || (g4 = db2 = new TextDecoder("utf-8", { fatal: true }));
            a4 = e4 + d4;
            f3 = 0 === e4 && a4 === f3.length ? f3 : f3.subarray(e4, a4);
            try {
              var h4 = g4.decode(f3);
            } catch (r4) {
              if (void 0 === cb2) {
                try {
                  g4.decode(new Uint8Array([128]));
                } catch (p4) {
                }
                try {
                  g4.decode(new Uint8Array([97])), cb2 = true;
                } catch (p4) {
                  cb2 = false;
                }
              }
              !cb2 && (db2 = void 0);
              throw r4;
            }
          } else {
            h4 = e4;
            d4 = h4 + d4;
            e4 = [];
            for (var k4 = null, l4, m4; h4 < d4; )
              l4 = a4[h4++], 128 > l4 ? e4.push(l4) : 224 > l4 ? h4 >= d4 ? ab2() : (m4 = a4[h4++], 194 > l4 || 128 !== (m4 & 192) ? (h4--, ab2()) : e4.push((l4 & 31) << 6 | m4 & 63)) : 240 > l4 ? h4 >= d4 - 1 ? ab2() : (m4 = a4[h4++], 128 !== (m4 & 192) || 224 === l4 && 160 > m4 || 237 === l4 && 160 <= m4 || 128 !== ((f3 = a4[h4++]) & 192) ? (h4--, ab2()) : e4.push((l4 & 15) << 12 | (m4 & 63) << 6 | f3 & 63)) : 244 >= l4 ? h4 >= d4 - 2 ? ab2() : (m4 = a4[h4++], 128 !== (m4 & 192) || 0 !== (l4 << 28) + (m4 - 144) >> 30 || 128 !== ((f3 = a4[h4++]) & 192) || 128 !== ((g4 = a4[h4++]) & 192) ? (h4--, ab2()) : (l4 = (l4 & 7) << 18 | (m4 & 63) << 12 | (f3 & 63) << 6 | g4 & 63, l4 -= 65536, e4.push((l4 >> 10 & 1023) + 55296, (l4 & 1023) + 56320))) : ab2(), 8192 <= e4.length && (k4 = bb2(k4, e4), e4.length = 0);
            h4 = bb2(k4, e4);
          }
          T3(b3, c5, h4);
          return true;
        }, function(a4, b3, c5) {
          b3 = S3(b3, c5);
          if (null != b3) {
            var d4 = false;
            d4 = void 0 === d4 ? false : d4;
            if (gb2) {
              if (d4 && /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(b3))
                throw Error("Found an unpaired surrogate");
              b3 = (fb2 || (fb2 = new TextEncoder())).encode(b3);
            } else {
              for (var e4 = 0, f3 = new Uint8Array(3 * b3.length), g4 = 0; g4 < b3.length; g4++) {
                var h4 = b3.charCodeAt(g4);
                if (128 > h4)
                  f3[e4++] = h4;
                else {
                  if (2048 > h4)
                    f3[e4++] = h4 >> 6 | 192;
                  else {
                    if (55296 <= h4 && 57343 >= h4) {
                      if (56319 >= h4 && g4 < b3.length) {
                        var k4 = b3.charCodeAt(++g4);
                        if (56320 <= k4 && 57343 >= k4) {
                          h4 = 1024 * (h4 - 55296) + k4 - 56320 + 65536;
                          f3[e4++] = h4 >> 18 | 240;
                          f3[e4++] = h4 >> 12 & 63 | 128;
                          f3[e4++] = h4 >> 6 & 63 | 128;
                          f3[e4++] = h4 & 63 | 128;
                          continue;
                        } else
                          g4--;
                      }
                      if (d4)
                        throw Error("Found an unpaired surrogate");
                      h4 = 65533;
                    }
                    f3[e4++] = h4 >> 12 | 224;
                    f3[e4++] = h4 >> 6 & 63 | 128;
                  }
                  f3[e4++] = h4 & 63 | 128;
                }
              }
              b3 = e4 === f3.length ? f3 : f3.subarray(0, e4);
            }
            L3(a4, c5, 2);
            vb2(a4.h, b3.length);
            Fb2(a4, a4.h.end());
            Fb2(a4, b3);
          }
        }), Xc2 = Y5(function(a4, b3, c5, d4, e4) {
          if (2 !== a4.i)
            return false;
          Sb2(b3);
          var f3 = S3(b3, c5);
          d4 = bc3(Vb2(f3, d4, true));
          f3 !== d4 && U5(b3, c5, d4);
          Bb2(a4, d4, e4);
          return true;
        }, function(a4, b3, c5, d4, e4) {
          b3 = ac2(b3, d4, c5);
          null != b3 && (c5 = Gb3(a4, c5), e4(b3, a4), Hb2(a4, c5));
        }), Yc2 = Y5(function(a4, b3, c5, d4, e4) {
          if (2 !== a4.i)
            return false;
          Bb2(a4, ec3(b3, c5, d4), e4);
          return true;
        }, function(a4, b3, c5, d4, e4) {
          b3 = dc3(b3, d4, c5);
          if (null != b3)
            for (d4 = 0; d4 < b3.length; d4++) {
              var f3 = Gb3(a4, c5);
              e4(b3[d4], a4);
              Hb2(a4, f3);
            }
        }), Zc2 = Y5(function(a4, b3, c5) {
          if (0 !== a4.i && 2 !== a4.i)
            return false;
          b3 = Yb3(b3, c5);
          2 == a4.i ? Cb2(a4, nb2.prototype.l, b3) : b3.push(a4.h.l());
          return true;
        }, function(a4, b3, c5) {
          b3 = Yb3(b3, c5);
          if (null != b3)
            for (var d4 = 0; d4 < b3.length; d4++) {
              var e4 = a4, f3 = b3[d4];
              null != f3 && (L3(e4, c5, 0), vb2(e4.h, f3));
            }
        }), $c2 = Y5(function(a4, b3, c5) {
          if (0 !== a4.i)
            return false;
          T3(b3, c5, qb2(a4.h));
          return true;
        }, function(a4, b3, c5) {
          b3 = S3(b3, c5);
          null != b3 && (b3 = parseInt(b3, 10), L3(a4, c5, 0), wb2(a4.h, b3));
        });
        function ad2(a4) {
          return function(b3, c5) {
            a: {
              if (Db2.length) {
                var d4 = Db2.pop();
                d4.setOptions(c5);
                ob2(d4.h, b3, c5);
                b3 = d4;
              } else
                b3 = new yb2(b3, c5);
              try {
                var e4 = yc3(a4);
                var f3 = zc2(new e4.P(), b3, e4);
                break a;
              } finally {
                e4 = b3.h, e4.i = null, e4.u = false, e4.m = 0, e4.j = 0, e4.h = 0, e4.S = false, b3.l = -1, b3.i = -1, 100 > Db2.length && Db2.push(b3);
              }
              f3 = void 0;
            }
            return f3;
          };
        }
        function bd3(a4) {
          return function() {
            var b3 = new Eb2();
            Ic3(this, b3, Hc2(a4));
            Fb2(b3, b3.h.end());
            for (var c5 = new Uint8Array(b3.i), d4 = b3.j, e4 = d4.length, f3 = 0, g4 = 0; g4 < e4; g4++) {
              var h4 = d4[g4];
              c5.set(h4, f3);
              f3 += h4.length;
            }
            b3.j = [c5];
            return c5;
          };
        }
        ;
        function cd2(a4) {
          X4.call(this, a4);
        }
        na3(cd2, X4);
        var dd2 = [cd2, 1, Vc2, 2, Z6, 3, Wc2, 4, Wc2];
        cd2.prototype.l = bd3(dd2);
        function ed2(a4) {
          X4.call(this, a4, -1, fd4);
        }
        na3(ed2, X4);
        ed2.prototype.addClassification = function(a4, b3) {
          ec3(this, 1, cd2, a4, b3);
          return this;
        };
        var fd4 = [1], gd3 = ad2([ed2, 1, Yc2, dd2]);
        function hd3(a4) {
          X4.call(this, a4);
        }
        na3(hd3, X4);
        var id2 = [hd3, 1, Z6, 2, Z6, 3, Z6, 4, Z6, 5, Z6];
        hd3.prototype.l = bd3(id2);
        function jd2(a4) {
          X4.call(this, a4, -1, kd2);
        }
        na3(jd2, X4);
        var kd2 = [1], ld2 = ad2([jd2, 1, Yc2, id2]);
        function md3(a4) {
          X4.call(this, a4, -1, nd2);
        }
        na3(md3, X4);
        md3.prototype.getRows = function() {
          return fc2(this, 1);
        };
        md3.prototype.getCols = function() {
          return fc2(this, 2);
        };
        md3.prototype.getPackedDataList = function() {
          return $b2(this, 3);
        };
        md3.prototype.getLayout = function() {
          return gc2(S3(this, 4), 0);
        };
        var nd2 = [3], od3 = [md3, 1, Vc2, 2, Vc2, 3, Tc3, 4, $c2];
        function pd2(a4) {
          X4.call(this, a4);
        }
        na3(pd2, X4);
        var qd = [pd2, 1, Z6, 2, Z6, 3, Z6, 4, Z6, 5, Z6, 6, Uc3], rd2 = ad2(qd);
        pd2.prototype.l = bd3(qd);
        function sd2(a4) {
          X4.call(this, a4, -1, td3);
        }
        na3(sd2, X4);
        sd2.prototype.getVertexType = function() {
          return gc2(S3(this, 1), 0);
        };
        sd2.prototype.getPrimitiveType = function() {
          return gc2(S3(this, 2), 0);
        };
        sd2.prototype.getVertexBufferList = function() {
          return $b2(this, 3);
        };
        sd2.prototype.getIndexBufferList = function() {
          return Yb3(this, 4);
        };
        var td3 = [3, 4], ud3 = [sd2, 1, $c2, 2, $c2, 3, Sc3, 4, Zc2];
        function vd(a4) {
          X4.call(this, a4);
        }
        na3(vd, X4);
        vd.prototype.getMesh = function() {
          return ac2(this, sd2, 1);
        };
        vd.prototype.getPoseTransformMatrix = function() {
          return ac2(this, md3, 2);
        };
        var wd = ad2([vd, 1, Xc2, ud3, 2, Xc2, od3]);
        var xd = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], yd2 = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [
          386,
          385
        ], [385, 384], [384, 398], [398, 362]], zd2 = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], Ad3 = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], Bd = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], Cd2 = [
          [10, 338],
          [338, 297],
          [297, 332],
          [332, 284],
          [284, 251],
          [251, 389],
          [389, 356],
          [356, 454],
          [454, 323],
          [323, 361],
          [361, 288],
          [288, 397],
          [397, 365],
          [365, 379],
          [379, 378],
          [378, 400],
          [400, 377],
          [377, 152],
          [152, 148],
          [148, 176],
          [176, 149],
          [149, 150],
          [150, 136],
          [136, 172],
          [172, 58],
          [58, 132],
          [132, 93],
          [93, 234],
          [234, 127],
          [127, 162],
          [162, 21],
          [21, 54],
          [54, 103],
          [103, 67],
          [67, 109],
          [109, 10]
        ], Dd3 = [].concat(B5(xd), B5(yd2), B5(zd2), B5(Ad3), B5(Bd), B5(Cd2));
        function Ed2(a4, b3, c5) {
          c5 = a4.createShader(0 === c5 ? a4.VERTEX_SHADER : a4.FRAGMENT_SHADER);
          a4.shaderSource(c5, b3);
          a4.compileShader(c5);
          if (!a4.getShaderParameter(c5, a4.COMPILE_STATUS))
            throw Error("Could not compile WebGL shader.\n\n" + a4.getShaderInfoLog(c5));
          return c5;
        }
        ;
        function Fd3(a4) {
          return dc3(a4, cd2, 1).map(function(b3) {
            return { index: fc2(b3, 1), score: W4(b3, 2), label: null != S3(b3, 3) ? gc2(S3(b3, 3), "") : void 0, displayName: null != S3(b3, 4) ? gc2(S3(b3, 4), "") : void 0 };
          });
        }
        ;
        function Gd2(a4) {
          return { x: W4(a4, 1), y: W4(a4, 2), z: W4(a4, 3), visibility: null != Zb3(a4, 4) ? W4(a4, 4) : void 0 };
        }
        function Hd(a4) {
          return dc3(ld2(a4), hd3, 1).map(Gd2);
        }
        ;
        function Id2(a4, b3) {
          this.i = a4;
          this.h = b3;
          this.m = 0;
        }
        function Jd2(a4, b3, c5) {
          Kd2(a4, b3);
          if ("function" === typeof a4.h.canvas.transferToImageBitmap)
            return Promise.resolve(a4.h.canvas.transferToImageBitmap());
          if (c5)
            return Promise.resolve(a4.h.canvas);
          if ("function" === typeof createImageBitmap)
            return createImageBitmap(a4.h.canvas);
          void 0 === a4.j && (a4.j = document.createElement("canvas"));
          return new Promise(function(d4) {
            a4.j.height = a4.h.canvas.height;
            a4.j.width = a4.h.canvas.width;
            a4.j.getContext("2d", {}).drawImage(a4.h.canvas, 0, 0, a4.h.canvas.width, a4.h.canvas.height);
            d4(a4.j);
          });
        }
        function Kd2(a4, b3) {
          var c5 = a4.h;
          if (void 0 === a4.s) {
            var d4 = Ed2(c5, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), e4 = Ed2(c5, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), f3 = c5.createProgram();
            c5.attachShader(f3, d4);
            c5.attachShader(f3, e4);
            c5.linkProgram(f3);
            if (!c5.getProgramParameter(f3, c5.LINK_STATUS))
              throw Error("Could not compile WebGL program.\n\n" + c5.getProgramInfoLog(f3));
            d4 = a4.s = f3;
            c5.useProgram(d4);
            e4 = c5.getUniformLocation(d4, "sampler0");
            a4.l = { O: c5.getAttribLocation(d4, "aVertex"), N: c5.getAttribLocation(d4, "aTex"), xa: e4 };
            a4.v = c5.createBuffer();
            c5.bindBuffer(c5.ARRAY_BUFFER, a4.v);
            c5.enableVertexAttribArray(a4.l.O);
            c5.vertexAttribPointer(a4.l.O, 2, c5.FLOAT, false, 0, 0);
            c5.bufferData(c5.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c5.STATIC_DRAW);
            c5.bindBuffer(c5.ARRAY_BUFFER, null);
            a4.u = c5.createBuffer();
            c5.bindBuffer(c5.ARRAY_BUFFER, a4.u);
            c5.enableVertexAttribArray(a4.l.N);
            c5.vertexAttribPointer(
              a4.l.N,
              2,
              c5.FLOAT,
              false,
              0,
              0
            );
            c5.bufferData(c5.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), c5.STATIC_DRAW);
            c5.bindBuffer(c5.ARRAY_BUFFER, null);
            c5.uniform1i(e4, 0);
          }
          d4 = a4.l;
          c5.useProgram(a4.s);
          c5.canvas.width = b3.width;
          c5.canvas.height = b3.height;
          c5.viewport(0, 0, b3.width, b3.height);
          c5.activeTexture(c5.TEXTURE0);
          a4.i.bindTexture2d(b3.glName);
          c5.enableVertexAttribArray(d4.O);
          c5.bindBuffer(c5.ARRAY_BUFFER, a4.v);
          c5.vertexAttribPointer(d4.O, 2, c5.FLOAT, false, 0, 0);
          c5.enableVertexAttribArray(d4.N);
          c5.bindBuffer(c5.ARRAY_BUFFER, a4.u);
          c5.vertexAttribPointer(
            d4.N,
            2,
            c5.FLOAT,
            false,
            0,
            0
          );
          c5.bindFramebuffer(c5.DRAW_FRAMEBUFFER ? c5.DRAW_FRAMEBUFFER : c5.FRAMEBUFFER, null);
          c5.clearColor(0, 0, 0, 0);
          c5.clear(c5.COLOR_BUFFER_BIT);
          c5.colorMask(true, true, true, true);
          c5.drawArrays(c5.TRIANGLE_FAN, 0, 4);
          c5.disableVertexAttribArray(d4.O);
          c5.disableVertexAttribArray(d4.N);
          c5.bindBuffer(c5.ARRAY_BUFFER, null);
          a4.i.bindTexture2d(0);
        }
        function Ld2(a4) {
          this.h = a4;
        }
        ;
        var Md = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
        function Nd3(a4, b3) {
          return b3 + a4;
        }
        function Od(a4, b3) {
          window[a4] = b3;
        }
        function Pd2(a4) {
          var b3 = document.createElement("script");
          b3.setAttribute("src", a4);
          b3.setAttribute("crossorigin", "anonymous");
          return new Promise(function(c5) {
            b3.addEventListener("load", function() {
              c5();
            }, false);
            b3.addEventListener("error", function() {
              c5();
            }, false);
            document.body.appendChild(b3);
          });
        }
        function Qd2() {
          return D3(function(a4) {
            switch (a4.h) {
              case 1:
                return a4.s = 2, C3(a4, WebAssembly.instantiate(Md), 4);
              case 4:
                a4.h = 3;
                a4.s = 0;
                break;
              case 2:
                return a4.s = 0, a4.l = null, a4.return(false);
              case 3:
                return a4.return(true);
            }
          });
        }
        function Rd(a4) {
          this.h = a4;
          this.listeners = {};
          this.l = {};
          this.L = {};
          this.s = {};
          this.v = {};
          this.M = this.u = this.ha = true;
          this.I = Promise.resolve();
          this.ga = "";
          this.D = {};
          this.locateFile = a4 && a4.locateFile || Nd3;
          if ("object" === typeof window)
            var b3 = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
          else if ("undefined" !== typeof location)
            b3 = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
          else
            throw Error("solutions can only be loaded on a web page or in a web worker");
          this.ia = b3;
          if (a4.options) {
            b3 = A3(Object.keys(a4.options));
            for (var c5 = b3.next(); !c5.done; c5 = b3.next()) {
              c5 = c5.value;
              var d4 = a4.options[c5].default;
              void 0 !== d4 && (this.l[c5] = "function" === typeof d4 ? d4() : d4);
            }
          }
        }
        x4 = Rd.prototype;
        x4.close = function() {
          this.j && this.j.delete();
          return Promise.resolve();
        };
        function Sd2(a4) {
          var b3, c5, d4, e4, f3, g4, h4, k4, l4, m4, r4;
          return D3(function(p4) {
            switch (p4.h) {
              case 1:
                if (!a4.ha)
                  return p4.return();
                b3 = void 0 === a4.h.files ? [] : "function" === typeof a4.h.files ? a4.h.files(a4.l) : a4.h.files;
                return C3(p4, Qd2(), 2);
              case 2:
                c5 = p4.i;
                if ("object" === typeof window)
                  return Od("createMediapipeSolutionsWasm", { locateFile: a4.locateFile }), Od("createMediapipeSolutionsPackedAssets", { locateFile: a4.locateFile }), g4 = b3.filter(function(n4) {
                    return void 0 !== n4.data;
                  }), h4 = b3.filter(function(n4) {
                    return void 0 === n4.data;
                  }), k4 = Promise.all(g4.map(function(n4) {
                    var q4 = Td2(a4, n4.url);
                    if (void 0 !== n4.path) {
                      var t4 = n4.path;
                      q4 = q4.then(function(w3) {
                        a4.overrideFile(t4, w3);
                        return Promise.resolve(w3);
                      });
                    }
                    return q4;
                  })), l4 = Promise.all(h4.map(function(n4) {
                    return void 0 === n4.simd || n4.simd && c5 || !n4.simd && !c5 ? Pd2(a4.locateFile(n4.url, a4.ia)) : Promise.resolve();
                  })).then(function() {
                    var n4, q4, t4;
                    return D3(function(w3) {
                      if (1 == w3.h)
                        return n4 = window.createMediapipeSolutionsWasm, q4 = window.createMediapipeSolutionsPackedAssets, t4 = a4, C3(w3, n4(q4), 2);
                      t4.i = w3.i;
                      w3.h = 0;
                    });
                  }), m4 = function() {
                    return D3(function(n4) {
                      a4.h.graph && a4.h.graph.url ? n4 = C3(
                        n4,
                        Td2(a4, a4.h.graph.url),
                        0
                      ) : (n4.h = 0, n4 = void 0);
                      return n4;
                    });
                  }(), C3(p4, Promise.all([l4, k4, m4]), 7);
                if ("function" !== typeof importScripts)
                  throw Error("solutions can only be loaded on a web page or in a web worker");
                d4 = b3.filter(function(n4) {
                  return void 0 === n4.simd || n4.simd && c5 || !n4.simd && !c5;
                }).map(function(n4) {
                  return a4.locateFile(n4.url, a4.ia);
                });
                importScripts.apply(null, B5(d4));
                e4 = a4;
                return C3(p4, createMediapipeSolutionsWasm(Module), 6);
              case 6:
                e4.i = p4.i;
                a4.m = new OffscreenCanvas(1, 1);
                a4.i.canvas = a4.m;
                f3 = a4.i.GL.createContext(a4.m, {
                  antialias: false,
                  alpha: false,
                  ua: "undefined" !== typeof WebGL2RenderingContext ? 2 : 1
                });
                a4.i.GL.makeContextCurrent(f3);
                p4.h = 4;
                break;
              case 7:
                a4.m = document.createElement("canvas");
                r4 = a4.m.getContext("webgl2", {});
                if (!r4 && (r4 = a4.m.getContext("webgl", {}), !r4))
                  return alert("Failed to create WebGL canvas context when passing video frame."), p4.return();
                a4.K = r4;
                a4.i.canvas = a4.m;
                a4.i.createContext(a4.m, true, true, {});
              case 4:
                a4.j = new a4.i.SolutionWasm(), a4.ha = false, p4.h = 0;
            }
          });
        }
        function Ud2(a4) {
          var b3, c5, d4, e4, f3, g4, h4, k4;
          return D3(function(l4) {
            if (1 == l4.h) {
              if (a4.h.graph && a4.h.graph.url && a4.ga === a4.h.graph.url)
                return l4.return();
              a4.u = true;
              if (!a4.h.graph || !a4.h.graph.url) {
                l4.h = 2;
                return;
              }
              a4.ga = a4.h.graph.url;
              return C3(l4, Td2(a4, a4.h.graph.url), 3);
            }
            2 != l4.h && (b3 = l4.i, a4.j.loadGraph(b3));
            c5 = A3(Object.keys(a4.D));
            for (d4 = c5.next(); !d4.done; d4 = c5.next())
              e4 = d4.value, a4.j.overrideFile(e4, a4.D[e4]);
            a4.D = {};
            if (a4.h.listeners)
              for (f3 = A3(a4.h.listeners), g4 = f3.next(); !g4.done; g4 = f3.next())
                h4 = g4.value, Vd2(a4, h4);
            k4 = a4.l;
            a4.l = {};
            a4.setOptions(k4);
            l4.h = 0;
          });
        }
        x4.reset = function() {
          var a4 = this;
          return D3(function(b3) {
            a4.j && (a4.j.reset(), a4.s = {}, a4.v = {});
            b3.h = 0;
          });
        };
        x4.setOptions = function(a4, b3) {
          var c5 = this;
          if (b3 = b3 || this.h.options) {
            for (var d4 = [], e4 = [], f3 = {}, g4 = A3(Object.keys(a4)), h4 = g4.next(); !h4.done; f3 = { X: f3.X, Y: f3.Y }, h4 = g4.next())
              if (h4 = h4.value, !(h4 in this.l && this.l[h4] === a4[h4])) {
                this.l[h4] = a4[h4];
                var k4 = b3[h4];
                void 0 !== k4 && (k4.onChange && (f3.X = k4.onChange, f3.Y = a4[h4], d4.push(/* @__PURE__ */ function(l4) {
                  return function() {
                    var m4;
                    return D3(function(r4) {
                      if (1 == r4.h)
                        return C3(r4, l4.X(l4.Y), 2);
                      m4 = r4.i;
                      true === m4 && (c5.u = true);
                      r4.h = 0;
                    });
                  };
                }(f3))), k4.graphOptionXref && (h4 = Object.assign(
                  {},
                  { calculatorName: "", calculatorIndex: 0 },
                  k4.graphOptionXref,
                  { valueNumber: 1 === k4.type ? a4[h4] : 0, valueBoolean: 0 === k4.type ? a4[h4] : false, valueString: 2 === k4.type ? a4[h4] : "" }
                ), e4.push(h4)));
              }
            if (0 !== d4.length || 0 !== e4.length)
              this.u = true, this.H = (void 0 === this.H ? [] : this.H).concat(e4), this.F = (void 0 === this.F ? [] : this.F).concat(d4);
          }
        };
        function Wd(a4) {
          var b3, c5, d4, e4, f3, g4, h4;
          return D3(function(k4) {
            switch (k4.h) {
              case 1:
                if (!a4.u)
                  return k4.return();
                if (!a4.F) {
                  k4.h = 2;
                  break;
                }
                b3 = A3(a4.F);
                c5 = b3.next();
              case 3:
                if (c5.done) {
                  k4.h = 5;
                  break;
                }
                d4 = c5.value;
                return C3(k4, d4(), 4);
              case 4:
                c5 = b3.next();
                k4.h = 3;
                break;
              case 5:
                a4.F = void 0;
              case 2:
                if (a4.H) {
                  e4 = new a4.i.GraphOptionChangeRequestList();
                  f3 = A3(a4.H);
                  for (g4 = f3.next(); !g4.done; g4 = f3.next())
                    h4 = g4.value, e4.push_back(h4);
                  a4.j.changeOptions(e4);
                  e4.delete();
                  a4.H = void 0;
                }
                a4.u = false;
                k4.h = 0;
            }
          });
        }
        x4.initialize = function() {
          var a4 = this;
          return D3(function(b3) {
            return 1 == b3.h ? C3(b3, Sd2(a4), 2) : 3 != b3.h ? C3(b3, Ud2(a4), 3) : C3(b3, Wd(a4), 0);
          });
        };
        function Td2(a4, b3) {
          var c5, d4;
          return D3(function(e4) {
            if (b3 in a4.L)
              return e4.return(a4.L[b3]);
            c5 = a4.locateFile(b3, "");
            d4 = fetch(c5).then(function(f3) {
              return f3.arrayBuffer();
            });
            a4.L[b3] = d4;
            return e4.return(d4);
          });
        }
        x4.overrideFile = function(a4, b3) {
          this.j ? this.j.overrideFile(a4, b3) : this.D[a4] = b3;
        };
        x4.clearOverriddenFiles = function() {
          this.D = {};
          this.j && this.j.clearOverriddenFiles();
        };
        x4.send = function(a4, b3) {
          var c5 = this, d4, e4, f3, g4, h4, k4, l4, m4, r4;
          return D3(function(p4) {
            switch (p4.h) {
              case 1:
                if (!c5.h.inputs)
                  return p4.return();
                d4 = 1e3 * (void 0 === b3 || null === b3 ? performance.now() : b3);
                return C3(p4, c5.I, 2);
              case 2:
                return C3(p4, c5.initialize(), 3);
              case 3:
                e4 = new c5.i.PacketDataList();
                f3 = A3(Object.keys(a4));
                for (g4 = f3.next(); !g4.done; g4 = f3.next())
                  if (h4 = g4.value, k4 = c5.h.inputs[h4]) {
                    a: {
                      var n4 = a4[h4];
                      switch (k4.type) {
                        case "video":
                          var q4 = c5.s[k4.stream];
                          q4 || (q4 = new Id2(c5.i, c5.K), c5.s[k4.stream] = q4);
                          0 === q4.m && (q4.m = q4.i.createTexture());
                          if ("undefined" !== typeof HTMLVideoElement && n4 instanceof HTMLVideoElement) {
                            var t4 = n4.videoWidth;
                            var w3 = n4.videoHeight;
                          } else
                            "undefined" !== typeof HTMLImageElement && n4 instanceof HTMLImageElement ? (t4 = n4.naturalWidth, w3 = n4.naturalHeight) : (t4 = n4.width, w3 = n4.height);
                          w3 = { glName: q4.m, width: t4, height: w3 };
                          t4 = q4.h;
                          t4.canvas.width = w3.width;
                          t4.canvas.height = w3.height;
                          t4.activeTexture(t4.TEXTURE0);
                          q4.i.bindTexture2d(q4.m);
                          t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, n4);
                          q4.i.bindTexture2d(0);
                          q4 = w3;
                          break a;
                        case "detections":
                          q4 = c5.s[k4.stream];
                          q4 || (q4 = new Ld2(c5.i), c5.s[k4.stream] = q4);
                          q4.data || (q4.data = new q4.h.DetectionListData());
                          q4.data.reset(n4.length);
                          for (w3 = 0; w3 < n4.length; ++w3) {
                            t4 = n4[w3];
                            var v5 = q4.data, E4 = v5.setBoundingBox, M4 = w3;
                            var K5 = t4.la;
                            var u4 = new pd2();
                            V4(u4, 1, K5.ra);
                            V4(u4, 2, K5.sa);
                            V4(u4, 3, K5.height);
                            V4(u4, 4, K5.width);
                            V4(u4, 5, K5.rotation);
                            T3(u4, 6, K5.pa);
                            K5 = u4.l();
                            E4.call(v5, M4, K5);
                            if (t4.ea)
                              for (v5 = 0; v5 < t4.ea.length; ++v5) {
                                u4 = t4.ea[v5];
                                E4 = q4.data;
                                M4 = E4.addNormalizedLandmark;
                                K5 = w3;
                                u4 = Object.assign({}, u4, { visibility: u4.visibility ? u4.visibility : 0 });
                                var F4 = new hd3();
                                V4(F4, 1, u4.x);
                                V4(F4, 2, u4.y);
                                V4(F4, 3, u4.z);
                                u4.visibility && V4(F4, 4, u4.visibility);
                                u4 = F4.l();
                                M4.call(
                                  E4,
                                  K5,
                                  u4
                                );
                              }
                            if (t4.ba)
                              for (v5 = 0; v5 < t4.ba.length; ++v5)
                                E4 = q4.data, M4 = E4.addClassification, K5 = w3, u4 = t4.ba[v5], F4 = new cd2(), V4(F4, 2, u4.score), u4.index && T3(F4, 1, u4.index), u4.label && T3(F4, 3, u4.label), u4.displayName && T3(F4, 4, u4.displayName), u4 = F4.l(), M4.call(E4, K5, u4);
                          }
                          q4 = q4.data;
                          break a;
                        default:
                          q4 = {};
                      }
                    }
                    l4 = q4;
                    m4 = k4.stream;
                    switch (k4.type) {
                      case "video":
                        e4.pushTexture2d(Object.assign({}, l4, { stream: m4, timestamp: d4 }));
                        break;
                      case "detections":
                        r4 = l4;
                        r4.stream = m4;
                        r4.timestamp = d4;
                        e4.pushDetectionList(r4);
                        break;
                      default:
                        throw Error("Unknown input config type: '" + k4.type + "'");
                    }
                  }
                c5.j.send(e4);
                return C3(p4, c5.I, 4);
              case 4:
                e4.delete(), p4.h = 0;
            }
          });
        };
        function Xd2(a4, b3, c5) {
          var d4, e4, f3, g4, h4, k4, l4, m4, r4, p4, n4, q4, t4, w3;
          return D3(function(v5) {
            switch (v5.h) {
              case 1:
                if (!c5)
                  return v5.return(b3);
                d4 = {};
                e4 = 0;
                f3 = A3(Object.keys(c5));
                for (g4 = f3.next(); !g4.done; g4 = f3.next())
                  h4 = g4.value, k4 = c5[h4], "string" !== typeof k4 && "texture" === k4.type && void 0 !== b3[k4.stream] && ++e4;
                1 < e4 && (a4.M = false);
                l4 = A3(Object.keys(c5));
                g4 = l4.next();
              case 2:
                if (g4.done) {
                  v5.h = 4;
                  break;
                }
                m4 = g4.value;
                r4 = c5[m4];
                if ("string" === typeof r4)
                  return t4 = d4, w3 = m4, C3(v5, Yd2(a4, m4, b3[r4]), 14);
                p4 = b3[r4.stream];
                if ("detection_list" === r4.type) {
                  if (p4) {
                    var E4 = p4.getRectList();
                    for (var M4 = p4.getLandmarksList(), K5 = p4.getClassificationsList(), u4 = [], F4 = 0; F4 < E4.size(); ++F4) {
                      var ba3 = rd2(E4.get(F4)), $d3 = W4(ba3, 1), ae4 = W4(ba3, 2), be5 = W4(ba3, 3), ce6 = W4(ba3, 4), de3 = W4(ba3, 5, 0), Ma3 = void 0;
                      Ma3 = void 0 === Ma3 ? 0 : Ma3;
                      ba3 = { la: { ra: $d3, sa: ae4, height: be5, width: ce6, rotation: de3, pa: gc2(S3(ba3, 6), Ma3) }, ea: Hd(M4.get(F4)), ba: Fd3(gd3(K5.get(F4))) };
                      u4.push(ba3);
                    }
                    E4 = u4;
                  } else
                    E4 = [];
                  d4[m4] = E4;
                  v5.h = 7;
                  break;
                }
                if ("proto_list" === r4.type) {
                  if (p4) {
                    E4 = Array(p4.size());
                    for (M4 = 0; M4 < p4.size(); M4++)
                      E4[M4] = p4.get(M4);
                    p4.delete();
                  } else
                    E4 = [];
                  d4[m4] = E4;
                  v5.h = 7;
                  break;
                }
                if (void 0 === p4) {
                  v5.h = 3;
                  break;
                }
                if ("float_list" === r4.type) {
                  d4[m4] = p4;
                  v5.h = 7;
                  break;
                }
                if ("proto" === r4.type) {
                  d4[m4] = p4;
                  v5.h = 7;
                  break;
                }
                if ("texture" !== r4.type)
                  throw Error("Unknown output config type: '" + r4.type + "'");
                n4 = a4.v[m4];
                n4 || (n4 = new Id2(a4.i, a4.K), a4.v[m4] = n4);
                return C3(v5, Jd2(n4, p4, a4.M), 13);
              case 13:
                q4 = v5.i, d4[m4] = q4;
              case 7:
                r4.transform && d4[m4] && (d4[m4] = r4.transform(d4[m4]));
                v5.h = 3;
                break;
              case 14:
                t4[w3] = v5.i;
              case 3:
                g4 = l4.next();
                v5.h = 2;
                break;
              case 4:
                return v5.return(d4);
            }
          });
        }
        function Yd2(a4, b3, c5) {
          var d4;
          return D3(function(e4) {
            return "number" === typeof c5 || c5 instanceof Uint8Array || c5 instanceof a4.i.Uint8BlobList ? e4.return(c5) : c5 instanceof a4.i.Texture2dDataOut ? (d4 = a4.v[b3], d4 || (d4 = new Id2(a4.i, a4.K), a4.v[b3] = d4), e4.return(Jd2(d4, c5, a4.M))) : e4.return(void 0);
          });
        }
        function Vd2(a4, b3) {
          for (var c5 = b3.name || "$", d4 = [].concat(B5(b3.wants)), e4 = new a4.i.StringList(), f3 = A3(b3.wants), g4 = f3.next(); !g4.done; g4 = f3.next())
            e4.push_back(g4.value);
          f3 = a4.i.PacketListener.implement({ onResults: function(h4) {
            for (var k4 = {}, l4 = 0; l4 < b3.wants.length; ++l4)
              k4[d4[l4]] = h4.get(l4);
            var m4 = a4.listeners[c5];
            m4 && (a4.I = Xd2(a4, k4, b3.outs).then(function(r4) {
              r4 = m4(r4);
              for (var p4 = 0; p4 < b3.wants.length; ++p4) {
                var n4 = k4[d4[p4]];
                "object" === typeof n4 && n4.hasOwnProperty && n4.hasOwnProperty("delete") && n4.delete();
              }
              r4 && (a4.I = r4);
            }));
          } });
          a4.j.attachMultiListener(e4, f3);
          e4.delete();
        }
        x4.onResults = function(a4, b3) {
          this.listeners[b3 || "$"] = a4;
        };
        H4("Solution", Rd);
        H4("OptionType", { BOOL: 0, NUMBER: 1, ta: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
        function Zd3(a4) {
          return a4.map(ee4);
        }
        function ee4(a4) {
          a4 = wd(a4);
          var b3 = a4.getMesh();
          if (!b3)
            return a4;
          var c5 = new Float32Array(b3.getVertexBufferList());
          b3.getVertexBufferList = function() {
            return c5;
          };
          var d4 = new Uint32Array(b3.getIndexBufferList());
          b3.getIndexBufferList = function() {
            return d4;
          };
          return a4;
        }
        ;
        function fe5(a4) {
          var b3 = this;
          a4 = a4 || {};
          this.h = new Rd({
            locateFile: a4.locateFile,
            files: [{ url: "holistic_solution_packed_assets_loader.js" }, { simd: false, url: "holistic_solution_wasm_bin.js" }, { simd: true, url: "holistic_solution_simd_wasm_bin.js" }],
            graph: { url: "holistic.binarypb" },
            inputs: { image: { type: "video", stream: "input_frames_gpu" } },
            listeners: [{ wants: "left_hand_landmarks right_hand_landmarks face_landmarks pose_landmarks world_landmarks segmentation_mask image_transformed multi_face_geometry".split(" "), outs: { image: {
              type: "texture",
              stream: "image_transformed"
            }, leftHandLandmarks: { type: "proto", stream: "left_hand_landmarks", transform: Hd }, rightHandLandmarks: { type: "proto", stream: "right_hand_landmarks", transform: Hd }, faceLandmarks: { type: "proto", stream: "face_landmarks", transform: Hd }, poseLandmarks: { type: "proto", stream: "pose_landmarks", transform: Hd }, za: { type: "proto", stream: "world_landmarks", transform: Hd }, segmentationMask: { type: "texture", stream: "segmentation_mask" }, multiFaceGeometry: { type: "proto_list", stream: "multi_face_geometry", transform: Zd3 } } }],
            options: {
              useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "object" !== typeof window || void 0 === window.navigator ? false : "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document },
              enableFaceGeometry: { type: 0, graphOptionXref: { calculatorName: "EnableFaceGeometryConstant", calculatorType: "ConstantSidePacketCalculator", fieldName: "bool_value" } },
              selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } },
              modelComplexity: { type: 1, default: 1, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorModelComplexity", fieldName: "int_value" }, onChange: function(c5) {
                var d4, e4, f3, g4;
                return D3(function(h4) {
                  if (1 == h4.h) {
                    d4 = "";
                    switch (c5) {
                      case 1:
                        d4 = "pose_landmark_full.tflite";
                        break;
                      case 2:
                        d4 = "pose_landmark_heavy.tflite";
                        break;
                      default:
                        d4 = "pose_landmark_lite.tflite";
                    }
                    e4 = "third_party/mediapipe/modules/pose_landmark/" + d4;
                    f3 = b3.h.locateFile(d4, "");
                    return C3(h4, fetch(f3), 3);
                  }
                  if (2 != h4.h)
                    return C3(h4, h4.i.arrayBuffer(), 2);
                  g4 = h4.i;
                  b3.h.overrideFile(e4, g4);
                  return C3(h4, b3.h.reset(), 0);
                });
              } },
              smoothLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorSmoothLandmarks", fieldName: "bool_value" } },
              enableSegmentation: { type: 0, graphOptionXref: {
                calculatorType: "ConstantSidePacketCalculator",
                calculatorName: "ConstantSidePacketCalculatorEnableSegmentation",
                fieldName: "bool_value"
              } },
              smoothSegmentation: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorSmoothSegmentation", fieldName: "bool_value" } },
              refineFaceLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorRefineFaceLandmarks", fieldName: "bool_value" } },
              minDetectionConfidence: { type: 1, graphOptionXref: {
                calculatorType: "TensorsToDetectionsCalculator",
                calculatorName: "holisticlandmarkgpu__poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",
                fieldName: "min_score_thresh"
              } },
              minTrackingConfidence: { type: 1, graphOptionXref: { calculatorType: "ThresholdingCalculator", calculatorName: "holisticlandmarkgpu__poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator", fieldName: "threshold" } },
              cameraNear: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "near" } },
              cameraFar: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "far" } },
              cameraVerticalFovDegrees: {
                type: 1,
                graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "vertical_fov_degrees" }
              }
            }
          });
        }
        x4 = fe5.prototype;
        x4.close = function() {
          this.h.close();
          return Promise.resolve();
        };
        x4.onResults = function(a4) {
          this.h.onResults(a4);
        };
        x4.initialize = function() {
          var a4 = this;
          return D3(function(b3) {
            return C3(b3, a4.h.initialize(), 0);
          });
        };
        x4.reset = function() {
          this.h.reset();
        };
        x4.send = function(a4) {
          var b3 = this;
          return D3(function(c5) {
            return C3(c5, b3.h.send(a4), 0);
          });
        };
        x4.setOptions = function(a4) {
          this.h.setOptions(a4);
        };
        H4("Holistic", fe5);
        H4("FACE_GEOMETRY", { Layout: { COLUMN_MAJOR: 0, ROW_MAJOR: 1, 0: "COLUMN_MAJOR", 1: "ROW_MAJOR" }, PrimitiveType: { TRIANGLE: 0, 0: "TRIANGLE" }, VertexType: { VERTEX_PT: 0, 0: "VERTEX_PT" }, DEFAULT_CAMERA_PARAMS: { verticalFovDegrees: 63, near: 1, far: 1e4 } });
        H4("FACEMESH_LIPS", xd);
        H4("FACEMESH_LEFT_EYE", yd2);
        H4("FACEMESH_LEFT_EYEBROW", zd2);
        H4("FACEMESH_LEFT_IRIS", [[474, 475], [475, 476], [476, 477], [477, 474]]);
        H4("FACEMESH_RIGHT_EYE", Ad3);
        H4("FACEMESH_RIGHT_EYEBROW", Bd);
        H4("FACEMESH_RIGHT_IRIS", [[469, 470], [470, 471], [471, 472], [472, 469]]);
        H4("FACEMESH_FACE_OVAL", Cd2);
        H4("FACEMESH_CONTOURS", Dd3);
        H4("FACEMESH_TESSELATION", [
          [127, 34],
          [34, 139],
          [139, 127],
          [11, 0],
          [0, 37],
          [37, 11],
          [232, 231],
          [231, 120],
          [120, 232],
          [72, 37],
          [37, 39],
          [39, 72],
          [128, 121],
          [121, 47],
          [47, 128],
          [232, 121],
          [121, 128],
          [128, 232],
          [104, 69],
          [69, 67],
          [67, 104],
          [175, 171],
          [171, 148],
          [148, 175],
          [118, 50],
          [50, 101],
          [101, 118],
          [73, 39],
          [39, 40],
          [40, 73],
          [9, 151],
          [151, 108],
          [108, 9],
          [48, 115],
          [115, 131],
          [131, 48],
          [194, 204],
          [204, 211],
          [211, 194],
          [74, 40],
          [40, 185],
          [185, 74],
          [80, 42],
          [42, 183],
          [183, 80],
          [40, 92],
          [92, 186],
          [186, 40],
          [230, 229],
          [229, 118],
          [118, 230],
          [202, 212],
          [
            212,
            214
          ],
          [214, 202],
          [83, 18],
          [18, 17],
          [17, 83],
          [76, 61],
          [61, 146],
          [146, 76],
          [160, 29],
          [29, 30],
          [30, 160],
          [56, 157],
          [157, 173],
          [173, 56],
          [106, 204],
          [204, 194],
          [194, 106],
          [135, 214],
          [214, 192],
          [192, 135],
          [203, 165],
          [165, 98],
          [98, 203],
          [21, 71],
          [71, 68],
          [68, 21],
          [51, 45],
          [45, 4],
          [4, 51],
          [144, 24],
          [24, 23],
          [23, 144],
          [77, 146],
          [146, 91],
          [91, 77],
          [205, 50],
          [50, 187],
          [187, 205],
          [201, 200],
          [200, 18],
          [18, 201],
          [91, 106],
          [106, 182],
          [182, 91],
          [90, 91],
          [91, 181],
          [181, 90],
          [85, 84],
          [84, 17],
          [17, 85],
          [206, 203],
          [203, 36],
          [36, 206],
          [148, 171],
          [171, 140],
          [140, 148],
          [
            92,
            40
          ],
          [40, 39],
          [39, 92],
          [193, 189],
          [189, 244],
          [244, 193],
          [159, 158],
          [158, 28],
          [28, 159],
          [247, 246],
          [246, 161],
          [161, 247],
          [236, 3],
          [3, 196],
          [196, 236],
          [54, 68],
          [68, 104],
          [104, 54],
          [193, 168],
          [168, 8],
          [8, 193],
          [117, 228],
          [228, 31],
          [31, 117],
          [189, 193],
          [193, 55],
          [55, 189],
          [98, 97],
          [97, 99],
          [99, 98],
          [126, 47],
          [47, 100],
          [100, 126],
          [166, 79],
          [79, 218],
          [218, 166],
          [155, 154],
          [154, 26],
          [26, 155],
          [209, 49],
          [49, 131],
          [131, 209],
          [135, 136],
          [136, 150],
          [150, 135],
          [47, 126],
          [126, 217],
          [217, 47],
          [223, 52],
          [52, 53],
          [53, 223],
          [45, 51],
          [51, 134],
          [134, 45],
          [211, 170],
          [
            170,
            140
          ],
          [140, 211],
          [67, 69],
          [69, 108],
          [108, 67],
          [43, 106],
          [106, 91],
          [91, 43],
          [230, 119],
          [119, 120],
          [120, 230],
          [226, 130],
          [130, 247],
          [247, 226],
          [63, 53],
          [53, 52],
          [52, 63],
          [238, 20],
          [20, 242],
          [242, 238],
          [46, 70],
          [70, 156],
          [156, 46],
          [78, 62],
          [62, 96],
          [96, 78],
          [46, 53],
          [53, 63],
          [63, 46],
          [143, 34],
          [34, 227],
          [227, 143],
          [123, 117],
          [117, 111],
          [111, 123],
          [44, 125],
          [125, 19],
          [19, 44],
          [236, 134],
          [134, 51],
          [51, 236],
          [216, 206],
          [206, 205],
          [205, 216],
          [154, 153],
          [153, 22],
          [22, 154],
          [39, 37],
          [37, 167],
          [167, 39],
          [200, 201],
          [201, 208],
          [208, 200],
          [36, 142],
          [142, 100],
          [
            100,
            36
          ],
          [57, 212],
          [212, 202],
          [202, 57],
          [20, 60],
          [60, 99],
          [99, 20],
          [28, 158],
          [158, 157],
          [157, 28],
          [35, 226],
          [226, 113],
          [113, 35],
          [160, 159],
          [159, 27],
          [27, 160],
          [204, 202],
          [202, 210],
          [210, 204],
          [113, 225],
          [225, 46],
          [46, 113],
          [43, 202],
          [202, 204],
          [204, 43],
          [62, 76],
          [76, 77],
          [77, 62],
          [137, 123],
          [123, 116],
          [116, 137],
          [41, 38],
          [38, 72],
          [72, 41],
          [203, 129],
          [129, 142],
          [142, 203],
          [64, 98],
          [98, 240],
          [240, 64],
          [49, 102],
          [102, 64],
          [64, 49],
          [41, 73],
          [73, 74],
          [74, 41],
          [212, 216],
          [216, 207],
          [207, 212],
          [42, 74],
          [74, 184],
          [184, 42],
          [169, 170],
          [170, 211],
          [211, 169],
          [
            170,
            149
          ],
          [149, 176],
          [176, 170],
          [105, 66],
          [66, 69],
          [69, 105],
          [122, 6],
          [6, 168],
          [168, 122],
          [123, 147],
          [147, 187],
          [187, 123],
          [96, 77],
          [77, 90],
          [90, 96],
          [65, 55],
          [55, 107],
          [107, 65],
          [89, 90],
          [90, 180],
          [180, 89],
          [101, 100],
          [100, 120],
          [120, 101],
          [63, 105],
          [105, 104],
          [104, 63],
          [93, 137],
          [137, 227],
          [227, 93],
          [15, 86],
          [86, 85],
          [85, 15],
          [129, 102],
          [102, 49],
          [49, 129],
          [14, 87],
          [87, 86],
          [86, 14],
          [55, 8],
          [8, 9],
          [9, 55],
          [100, 47],
          [47, 121],
          [121, 100],
          [145, 23],
          [23, 22],
          [22, 145],
          [88, 89],
          [89, 179],
          [179, 88],
          [6, 122],
          [122, 196],
          [196, 6],
          [88, 95],
          [95, 96],
          [96, 88],
          [138, 172],
          [172, 136],
          [136, 138],
          [215, 58],
          [58, 172],
          [172, 215],
          [115, 48],
          [48, 219],
          [219, 115],
          [42, 80],
          [80, 81],
          [81, 42],
          [195, 3],
          [3, 51],
          [51, 195],
          [43, 146],
          [146, 61],
          [61, 43],
          [171, 175],
          [175, 199],
          [199, 171],
          [81, 82],
          [82, 38],
          [38, 81],
          [53, 46],
          [46, 225],
          [225, 53],
          [144, 163],
          [163, 110],
          [110, 144],
          [52, 65],
          [65, 66],
          [66, 52],
          [229, 228],
          [228, 117],
          [117, 229],
          [34, 127],
          [127, 234],
          [234, 34],
          [107, 108],
          [108, 69],
          [69, 107],
          [109, 108],
          [108, 151],
          [151, 109],
          [48, 64],
          [64, 235],
          [235, 48],
          [62, 78],
          [78, 191],
          [191, 62],
          [129, 209],
          [209, 126],
          [126, 129],
          [111, 35],
          [35, 143],
          [
            143,
            111
          ],
          [117, 123],
          [123, 50],
          [50, 117],
          [222, 65],
          [65, 52],
          [52, 222],
          [19, 125],
          [125, 141],
          [141, 19],
          [221, 55],
          [55, 65],
          [65, 221],
          [3, 195],
          [195, 197],
          [197, 3],
          [25, 7],
          [7, 33],
          [33, 25],
          [220, 237],
          [237, 44],
          [44, 220],
          [70, 71],
          [71, 139],
          [139, 70],
          [122, 193],
          [193, 245],
          [245, 122],
          [247, 130],
          [130, 33],
          [33, 247],
          [71, 21],
          [21, 162],
          [162, 71],
          [170, 169],
          [169, 150],
          [150, 170],
          [188, 174],
          [174, 196],
          [196, 188],
          [216, 186],
          [186, 92],
          [92, 216],
          [2, 97],
          [97, 167],
          [167, 2],
          [141, 125],
          [125, 241],
          [241, 141],
          [164, 167],
          [167, 37],
          [37, 164],
          [72, 38],
          [38, 12],
          [12, 72],
          [38, 82],
          [82, 13],
          [13, 38],
          [63, 68],
          [68, 71],
          [71, 63],
          [226, 35],
          [35, 111],
          [111, 226],
          [101, 50],
          [50, 205],
          [205, 101],
          [206, 92],
          [92, 165],
          [165, 206],
          [209, 198],
          [198, 217],
          [217, 209],
          [165, 167],
          [167, 97],
          [97, 165],
          [220, 115],
          [115, 218],
          [218, 220],
          [133, 112],
          [112, 243],
          [243, 133],
          [239, 238],
          [238, 241],
          [241, 239],
          [214, 135],
          [135, 169],
          [169, 214],
          [190, 173],
          [173, 133],
          [133, 190],
          [171, 208],
          [208, 32],
          [32, 171],
          [125, 44],
          [44, 237],
          [237, 125],
          [86, 87],
          [87, 178],
          [178, 86],
          [85, 86],
          [86, 179],
          [179, 85],
          [84, 85],
          [85, 180],
          [180, 84],
          [83, 84],
          [84, 181],
          [181, 83],
          [201, 83],
          [83, 182],
          [182, 201],
          [137, 93],
          [93, 132],
          [132, 137],
          [76, 62],
          [62, 183],
          [183, 76],
          [61, 76],
          [76, 184],
          [184, 61],
          [57, 61],
          [61, 185],
          [185, 57],
          [212, 57],
          [57, 186],
          [186, 212],
          [214, 207],
          [207, 187],
          [187, 214],
          [34, 143],
          [143, 156],
          [156, 34],
          [79, 239],
          [239, 237],
          [237, 79],
          [123, 137],
          [137, 177],
          [177, 123],
          [44, 1],
          [1, 4],
          [4, 44],
          [201, 194],
          [194, 32],
          [32, 201],
          [64, 102],
          [102, 129],
          [129, 64],
          [213, 215],
          [215, 138],
          [138, 213],
          [59, 166],
          [166, 219],
          [219, 59],
          [242, 99],
          [99, 97],
          [97, 242],
          [2, 94],
          [94, 141],
          [141, 2],
          [75, 59],
          [59, 235],
          [235, 75],
          [24, 110],
          [110, 228],
          [
            228,
            24
          ],
          [25, 130],
          [130, 226],
          [226, 25],
          [23, 24],
          [24, 229],
          [229, 23],
          [22, 23],
          [23, 230],
          [230, 22],
          [26, 22],
          [22, 231],
          [231, 26],
          [112, 26],
          [26, 232],
          [232, 112],
          [189, 190],
          [190, 243],
          [243, 189],
          [221, 56],
          [56, 190],
          [190, 221],
          [28, 56],
          [56, 221],
          [221, 28],
          [27, 28],
          [28, 222],
          [222, 27],
          [29, 27],
          [27, 223],
          [223, 29],
          [30, 29],
          [29, 224],
          [224, 30],
          [247, 30],
          [30, 225],
          [225, 247],
          [238, 79],
          [79, 20],
          [20, 238],
          [166, 59],
          [59, 75],
          [75, 166],
          [60, 75],
          [75, 240],
          [240, 60],
          [147, 177],
          [177, 215],
          [215, 147],
          [20, 79],
          [79, 166],
          [166, 20],
          [187, 147],
          [147, 213],
          [213, 187],
          [112, 233],
          [233, 244],
          [244, 112],
          [233, 128],
          [128, 245],
          [245, 233],
          [128, 114],
          [114, 188],
          [188, 128],
          [114, 217],
          [217, 174],
          [174, 114],
          [131, 115],
          [115, 220],
          [220, 131],
          [217, 198],
          [198, 236],
          [236, 217],
          [198, 131],
          [131, 134],
          [134, 198],
          [177, 132],
          [132, 58],
          [58, 177],
          [143, 35],
          [35, 124],
          [124, 143],
          [110, 163],
          [163, 7],
          [7, 110],
          [228, 110],
          [110, 25],
          [25, 228],
          [356, 389],
          [389, 368],
          [368, 356],
          [11, 302],
          [302, 267],
          [267, 11],
          [452, 350],
          [350, 349],
          [349, 452],
          [302, 303],
          [303, 269],
          [269, 302],
          [357, 343],
          [343, 277],
          [277, 357],
          [452, 453],
          [453, 357],
          [357, 452],
          [333, 332],
          [
            332,
            297
          ],
          [297, 333],
          [175, 152],
          [152, 377],
          [377, 175],
          [347, 348],
          [348, 330],
          [330, 347],
          [303, 304],
          [304, 270],
          [270, 303],
          [9, 336],
          [336, 337],
          [337, 9],
          [278, 279],
          [279, 360],
          [360, 278],
          [418, 262],
          [262, 431],
          [431, 418],
          [304, 408],
          [408, 409],
          [409, 304],
          [310, 415],
          [415, 407],
          [407, 310],
          [270, 409],
          [409, 410],
          [410, 270],
          [450, 348],
          [348, 347],
          [347, 450],
          [422, 430],
          [430, 434],
          [434, 422],
          [313, 314],
          [314, 17],
          [17, 313],
          [306, 307],
          [307, 375],
          [375, 306],
          [387, 388],
          [388, 260],
          [260, 387],
          [286, 414],
          [414, 398],
          [398, 286],
          [335, 406],
          [406, 418],
          [418, 335],
          [364, 367],
          [
            367,
            416
          ],
          [416, 364],
          [423, 358],
          [358, 327],
          [327, 423],
          [251, 284],
          [284, 298],
          [298, 251],
          [281, 5],
          [5, 4],
          [4, 281],
          [373, 374],
          [374, 253],
          [253, 373],
          [307, 320],
          [320, 321],
          [321, 307],
          [425, 427],
          [427, 411],
          [411, 425],
          [421, 313],
          [313, 18],
          [18, 421],
          [321, 405],
          [405, 406],
          [406, 321],
          [320, 404],
          [404, 405],
          [405, 320],
          [315, 16],
          [16, 17],
          [17, 315],
          [426, 425],
          [425, 266],
          [266, 426],
          [377, 400],
          [400, 369],
          [369, 377],
          [322, 391],
          [391, 269],
          [269, 322],
          [417, 465],
          [465, 464],
          [464, 417],
          [386, 257],
          [257, 258],
          [258, 386],
          [466, 260],
          [260, 388],
          [388, 466],
          [456, 399],
          [399, 419],
          [419, 456],
          [284, 332],
          [332, 333],
          [333, 284],
          [417, 285],
          [285, 8],
          [8, 417],
          [346, 340],
          [340, 261],
          [261, 346],
          [413, 441],
          [441, 285],
          [285, 413],
          [327, 460],
          [460, 328],
          [328, 327],
          [355, 371],
          [371, 329],
          [329, 355],
          [392, 439],
          [439, 438],
          [438, 392],
          [382, 341],
          [341, 256],
          [256, 382],
          [429, 420],
          [420, 360],
          [360, 429],
          [364, 394],
          [394, 379],
          [379, 364],
          [277, 343],
          [343, 437],
          [437, 277],
          [443, 444],
          [444, 283],
          [283, 443],
          [275, 440],
          [440, 363],
          [363, 275],
          [431, 262],
          [262, 369],
          [369, 431],
          [297, 338],
          [338, 337],
          [337, 297],
          [273, 375],
          [375, 321],
          [321, 273],
          [450, 451],
          [
            451,
            349
          ],
          [349, 450],
          [446, 342],
          [342, 467],
          [467, 446],
          [293, 334],
          [334, 282],
          [282, 293],
          [458, 461],
          [461, 462],
          [462, 458],
          [276, 353],
          [353, 383],
          [383, 276],
          [308, 324],
          [324, 325],
          [325, 308],
          [276, 300],
          [300, 293],
          [293, 276],
          [372, 345],
          [345, 447],
          [447, 372],
          [352, 345],
          [345, 340],
          [340, 352],
          [274, 1],
          [1, 19],
          [19, 274],
          [456, 248],
          [248, 281],
          [281, 456],
          [436, 427],
          [427, 425],
          [425, 436],
          [381, 256],
          [256, 252],
          [252, 381],
          [269, 391],
          [391, 393],
          [393, 269],
          [200, 199],
          [199, 428],
          [428, 200],
          [266, 330],
          [330, 329],
          [329, 266],
          [287, 273],
          [273, 422],
          [422, 287],
          [250, 462],
          [
            462,
            328
          ],
          [328, 250],
          [258, 286],
          [286, 384],
          [384, 258],
          [265, 353],
          [353, 342],
          [342, 265],
          [387, 259],
          [259, 257],
          [257, 387],
          [424, 431],
          [431, 430],
          [430, 424],
          [342, 353],
          [353, 276],
          [276, 342],
          [273, 335],
          [335, 424],
          [424, 273],
          [292, 325],
          [325, 307],
          [307, 292],
          [366, 447],
          [447, 345],
          [345, 366],
          [271, 303],
          [303, 302],
          [302, 271],
          [423, 266],
          [266, 371],
          [371, 423],
          [294, 455],
          [455, 460],
          [460, 294],
          [279, 278],
          [278, 294],
          [294, 279],
          [271, 272],
          [272, 304],
          [304, 271],
          [432, 434],
          [434, 427],
          [427, 432],
          [272, 407],
          [407, 408],
          [408, 272],
          [394, 430],
          [430, 431],
          [431, 394],
          [395, 369],
          [369, 400],
          [400, 395],
          [334, 333],
          [333, 299],
          [299, 334],
          [351, 417],
          [417, 168],
          [168, 351],
          [352, 280],
          [280, 411],
          [411, 352],
          [325, 319],
          [319, 320],
          [320, 325],
          [295, 296],
          [296, 336],
          [336, 295],
          [319, 403],
          [403, 404],
          [404, 319],
          [330, 348],
          [348, 349],
          [349, 330],
          [293, 298],
          [298, 333],
          [333, 293],
          [323, 454],
          [454, 447],
          [447, 323],
          [15, 16],
          [16, 315],
          [315, 15],
          [358, 429],
          [429, 279],
          [279, 358],
          [14, 15],
          [15, 316],
          [316, 14],
          [285, 336],
          [336, 9],
          [9, 285],
          [329, 349],
          [349, 350],
          [350, 329],
          [374, 380],
          [380, 252],
          [252, 374],
          [318, 402],
          [402, 403],
          [403, 318],
          [6, 197],
          [
            197,
            419
          ],
          [419, 6],
          [318, 319],
          [319, 325],
          [325, 318],
          [367, 364],
          [364, 365],
          [365, 367],
          [435, 367],
          [367, 397],
          [397, 435],
          [344, 438],
          [438, 439],
          [439, 344],
          [272, 271],
          [271, 311],
          [311, 272],
          [195, 5],
          [5, 281],
          [281, 195],
          [273, 287],
          [287, 291],
          [291, 273],
          [396, 428],
          [428, 199],
          [199, 396],
          [311, 271],
          [271, 268],
          [268, 311],
          [283, 444],
          [444, 445],
          [445, 283],
          [373, 254],
          [254, 339],
          [339, 373],
          [282, 334],
          [334, 296],
          [296, 282],
          [449, 347],
          [347, 346],
          [346, 449],
          [264, 447],
          [447, 454],
          [454, 264],
          [336, 296],
          [296, 299],
          [299, 336],
          [338, 10],
          [10, 151],
          [151, 338],
          [278, 439],
          [
            439,
            455
          ],
          [455, 278],
          [292, 407],
          [407, 415],
          [415, 292],
          [358, 371],
          [371, 355],
          [355, 358],
          [340, 345],
          [345, 372],
          [372, 340],
          [346, 347],
          [347, 280],
          [280, 346],
          [442, 443],
          [443, 282],
          [282, 442],
          [19, 94],
          [94, 370],
          [370, 19],
          [441, 442],
          [442, 295],
          [295, 441],
          [248, 419],
          [419, 197],
          [197, 248],
          [263, 255],
          [255, 359],
          [359, 263],
          [440, 275],
          [275, 274],
          [274, 440],
          [300, 383],
          [383, 368],
          [368, 300],
          [351, 412],
          [412, 465],
          [465, 351],
          [263, 467],
          [467, 466],
          [466, 263],
          [301, 368],
          [368, 389],
          [389, 301],
          [395, 378],
          [378, 379],
          [379, 395],
          [412, 351],
          [351, 419],
          [419, 412],
          [436, 426],
          [426, 322],
          [322, 436],
          [2, 164],
          [164, 393],
          [393, 2],
          [370, 462],
          [462, 461],
          [461, 370],
          [164, 0],
          [0, 267],
          [267, 164],
          [302, 11],
          [11, 12],
          [12, 302],
          [268, 12],
          [12, 13],
          [13, 268],
          [293, 300],
          [300, 301],
          [301, 293],
          [446, 261],
          [261, 340],
          [340, 446],
          [330, 266],
          [266, 425],
          [425, 330],
          [426, 423],
          [423, 391],
          [391, 426],
          [429, 355],
          [355, 437],
          [437, 429],
          [391, 327],
          [327, 326],
          [326, 391],
          [440, 457],
          [457, 438],
          [438, 440],
          [341, 382],
          [382, 362],
          [362, 341],
          [459, 457],
          [457, 461],
          [461, 459],
          [434, 430],
          [430, 394],
          [394, 434],
          [414, 463],
          [463, 362],
          [362, 414],
          [396, 369],
          [369, 262],
          [262, 396],
          [354, 461],
          [461, 457],
          [457, 354],
          [316, 403],
          [403, 402],
          [402, 316],
          [315, 404],
          [404, 403],
          [403, 315],
          [314, 405],
          [405, 404],
          [404, 314],
          [313, 406],
          [406, 405],
          [405, 313],
          [421, 418],
          [418, 406],
          [406, 421],
          [366, 401],
          [401, 361],
          [361, 366],
          [306, 408],
          [408, 407],
          [407, 306],
          [291, 409],
          [409, 408],
          [408, 291],
          [287, 410],
          [410, 409],
          [409, 287],
          [432, 436],
          [436, 410],
          [410, 432],
          [434, 416],
          [416, 411],
          [411, 434],
          [264, 368],
          [368, 383],
          [383, 264],
          [309, 438],
          [438, 457],
          [457, 309],
          [352, 376],
          [376, 401],
          [401, 352],
          [274, 275],
          [275, 4],
          [4, 274],
          [421, 428],
          [
            428,
            262
          ],
          [262, 421],
          [294, 327],
          [327, 358],
          [358, 294],
          [433, 416],
          [416, 367],
          [367, 433],
          [289, 455],
          [455, 439],
          [439, 289],
          [462, 370],
          [370, 326],
          [326, 462],
          [2, 326],
          [326, 370],
          [370, 2],
          [305, 460],
          [460, 455],
          [455, 305],
          [254, 449],
          [449, 448],
          [448, 254],
          [255, 261],
          [261, 446],
          [446, 255],
          [253, 450],
          [450, 449],
          [449, 253],
          [252, 451],
          [451, 450],
          [450, 252],
          [256, 452],
          [452, 451],
          [451, 256],
          [341, 453],
          [453, 452],
          [452, 341],
          [413, 464],
          [464, 463],
          [463, 413],
          [441, 413],
          [413, 414],
          [414, 441],
          [258, 442],
          [442, 441],
          [441, 258],
          [257, 443],
          [443, 442],
          [442, 257],
          [259, 444],
          [444, 443],
          [443, 259],
          [260, 445],
          [445, 444],
          [444, 260],
          [467, 342],
          [342, 445],
          [445, 467],
          [459, 458],
          [458, 250],
          [250, 459],
          [289, 392],
          [392, 290],
          [290, 289],
          [290, 328],
          [328, 460],
          [460, 290],
          [376, 433],
          [433, 435],
          [435, 376],
          [250, 290],
          [290, 392],
          [392, 250],
          [411, 416],
          [416, 433],
          [433, 411],
          [341, 463],
          [463, 464],
          [464, 341],
          [453, 464],
          [464, 465],
          [465, 453],
          [357, 465],
          [465, 412],
          [412, 357],
          [343, 412],
          [412, 399],
          [399, 343],
          [360, 363],
          [363, 440],
          [440, 360],
          [437, 399],
          [399, 456],
          [456, 437],
          [420, 456],
          [456, 363],
          [363, 420],
          [401, 435],
          [435, 288],
          [288, 401],
          [
            372,
            383
          ],
          [383, 353],
          [353, 372],
          [339, 255],
          [255, 249],
          [249, 339],
          [448, 261],
          [261, 255],
          [255, 448],
          [133, 243],
          [243, 190],
          [190, 133],
          [133, 155],
          [155, 112],
          [112, 133],
          [33, 246],
          [246, 247],
          [247, 33],
          [33, 130],
          [130, 25],
          [25, 33],
          [398, 384],
          [384, 286],
          [286, 398],
          [362, 398],
          [398, 414],
          [414, 362],
          [362, 463],
          [463, 341],
          [341, 362],
          [263, 359],
          [359, 467],
          [467, 263],
          [263, 249],
          [249, 255],
          [255, 263],
          [466, 467],
          [467, 260],
          [260, 466],
          [75, 60],
          [60, 166],
          [166, 75],
          [238, 239],
          [239, 79],
          [79, 238],
          [162, 127],
          [127, 139],
          [139, 162],
          [72, 11],
          [11, 37],
          [37, 72],
          [121, 232],
          [
            232,
            120
          ],
          [120, 121],
          [73, 72],
          [72, 39],
          [39, 73],
          [114, 128],
          [128, 47],
          [47, 114],
          [233, 232],
          [232, 128],
          [128, 233],
          [103, 104],
          [104, 67],
          [67, 103],
          [152, 175],
          [175, 148],
          [148, 152],
          [119, 118],
          [118, 101],
          [101, 119],
          [74, 73],
          [73, 40],
          [40, 74],
          [107, 9],
          [9, 108],
          [108, 107],
          [49, 48],
          [48, 131],
          [131, 49],
          [32, 194],
          [194, 211],
          [211, 32],
          [184, 74],
          [74, 185],
          [185, 184],
          [191, 80],
          [80, 183],
          [183, 191],
          [185, 40],
          [40, 186],
          [186, 185],
          [119, 230],
          [230, 118],
          [118, 119],
          [210, 202],
          [202, 214],
          [214, 210],
          [84, 83],
          [83, 17],
          [17, 84],
          [77, 76],
          [76, 146],
          [146, 77],
          [161, 160],
          [160, 30],
          [30, 161],
          [190, 56],
          [56, 173],
          [173, 190],
          [182, 106],
          [106, 194],
          [194, 182],
          [138, 135],
          [135, 192],
          [192, 138],
          [129, 203],
          [203, 98],
          [98, 129],
          [54, 21],
          [21, 68],
          [68, 54],
          [5, 51],
          [51, 4],
          [4, 5],
          [145, 144],
          [144, 23],
          [23, 145],
          [90, 77],
          [77, 91],
          [91, 90],
          [207, 205],
          [205, 187],
          [187, 207],
          [83, 201],
          [201, 18],
          [18, 83],
          [181, 91],
          [91, 182],
          [182, 181],
          [180, 90],
          [90, 181],
          [181, 180],
          [16, 85],
          [85, 17],
          [17, 16],
          [205, 206],
          [206, 36],
          [36, 205],
          [176, 148],
          [148, 140],
          [140, 176],
          [165, 92],
          [92, 39],
          [39, 165],
          [245, 193],
          [193, 244],
          [244, 245],
          [27, 159],
          [159, 28],
          [28, 27],
          [
            30,
            247
          ],
          [247, 161],
          [161, 30],
          [174, 236],
          [236, 196],
          [196, 174],
          [103, 54],
          [54, 104],
          [104, 103],
          [55, 193],
          [193, 8],
          [8, 55],
          [111, 117],
          [117, 31],
          [31, 111],
          [221, 189],
          [189, 55],
          [55, 221],
          [240, 98],
          [98, 99],
          [99, 240],
          [142, 126],
          [126, 100],
          [100, 142],
          [219, 166],
          [166, 218],
          [218, 219],
          [112, 155],
          [155, 26],
          [26, 112],
          [198, 209],
          [209, 131],
          [131, 198],
          [169, 135],
          [135, 150],
          [150, 169],
          [114, 47],
          [47, 217],
          [217, 114],
          [224, 223],
          [223, 53],
          [53, 224],
          [220, 45],
          [45, 134],
          [134, 220],
          [32, 211],
          [211, 140],
          [140, 32],
          [109, 67],
          [67, 108],
          [108, 109],
          [146, 43],
          [43, 91],
          [91, 146],
          [231, 230],
          [230, 120],
          [120, 231],
          [113, 226],
          [226, 247],
          [247, 113],
          [105, 63],
          [63, 52],
          [52, 105],
          [241, 238],
          [238, 242],
          [242, 241],
          [124, 46],
          [46, 156],
          [156, 124],
          [95, 78],
          [78, 96],
          [96, 95],
          [70, 46],
          [46, 63],
          [63, 70],
          [116, 143],
          [143, 227],
          [227, 116],
          [116, 123],
          [123, 111],
          [111, 116],
          [1, 44],
          [44, 19],
          [19, 1],
          [3, 236],
          [236, 51],
          [51, 3],
          [207, 216],
          [216, 205],
          [205, 207],
          [26, 154],
          [154, 22],
          [22, 26],
          [165, 39],
          [39, 167],
          [167, 165],
          [199, 200],
          [200, 208],
          [208, 199],
          [101, 36],
          [36, 100],
          [100, 101],
          [43, 57],
          [57, 202],
          [202, 43],
          [242, 20],
          [20, 99],
          [99, 242],
          [56, 28],
          [
            28,
            157
          ],
          [157, 56],
          [124, 35],
          [35, 113],
          [113, 124],
          [29, 160],
          [160, 27],
          [27, 29],
          [211, 204],
          [204, 210],
          [210, 211],
          [124, 113],
          [113, 46],
          [46, 124],
          [106, 43],
          [43, 204],
          [204, 106],
          [96, 62],
          [62, 77],
          [77, 96],
          [227, 137],
          [137, 116],
          [116, 227],
          [73, 41],
          [41, 72],
          [72, 73],
          [36, 203],
          [203, 142],
          [142, 36],
          [235, 64],
          [64, 240],
          [240, 235],
          [48, 49],
          [49, 64],
          [64, 48],
          [42, 41],
          [41, 74],
          [74, 42],
          [214, 212],
          [212, 207],
          [207, 214],
          [183, 42],
          [42, 184],
          [184, 183],
          [210, 169],
          [169, 211],
          [211, 210],
          [140, 170],
          [170, 176],
          [176, 140],
          [104, 105],
          [105, 69],
          [69, 104],
          [193, 122],
          [122, 168],
          [168, 193],
          [50, 123],
          [123, 187],
          [187, 50],
          [89, 96],
          [96, 90],
          [90, 89],
          [66, 65],
          [65, 107],
          [107, 66],
          [179, 89],
          [89, 180],
          [180, 179],
          [119, 101],
          [101, 120],
          [120, 119],
          [68, 63],
          [63, 104],
          [104, 68],
          [234, 93],
          [93, 227],
          [227, 234],
          [16, 15],
          [15, 85],
          [85, 16],
          [209, 129],
          [129, 49],
          [49, 209],
          [15, 14],
          [14, 86],
          [86, 15],
          [107, 55],
          [55, 9],
          [9, 107],
          [120, 100],
          [100, 121],
          [121, 120],
          [153, 145],
          [145, 22],
          [22, 153],
          [178, 88],
          [88, 179],
          [179, 178],
          [197, 6],
          [6, 196],
          [196, 197],
          [89, 88],
          [88, 96],
          [96, 89],
          [135, 138],
          [138, 136],
          [136, 135],
          [138, 215],
          [215, 172],
          [172, 138],
          [
            218,
            115
          ],
          [115, 219],
          [219, 218],
          [41, 42],
          [42, 81],
          [81, 41],
          [5, 195],
          [195, 51],
          [51, 5],
          [57, 43],
          [43, 61],
          [61, 57],
          [208, 171],
          [171, 199],
          [199, 208],
          [41, 81],
          [81, 38],
          [38, 41],
          [224, 53],
          [53, 225],
          [225, 224],
          [24, 144],
          [144, 110],
          [110, 24],
          [105, 52],
          [52, 66],
          [66, 105],
          [118, 229],
          [229, 117],
          [117, 118],
          [227, 34],
          [34, 234],
          [234, 227],
          [66, 107],
          [107, 69],
          [69, 66],
          [10, 109],
          [109, 151],
          [151, 10],
          [219, 48],
          [48, 235],
          [235, 219],
          [183, 62],
          [62, 191],
          [191, 183],
          [142, 129],
          [129, 126],
          [126, 142],
          [116, 111],
          [111, 143],
          [143, 116],
          [118, 117],
          [117, 50],
          [50, 118],
          [223, 222],
          [
            222,
            52
          ],
          [52, 223],
          [94, 19],
          [19, 141],
          [141, 94],
          [222, 221],
          [221, 65],
          [65, 222],
          [196, 3],
          [3, 197],
          [197, 196],
          [45, 220],
          [220, 44],
          [44, 45],
          [156, 70],
          [70, 139],
          [139, 156],
          [188, 122],
          [122, 245],
          [245, 188],
          [139, 71],
          [71, 162],
          [162, 139],
          [149, 170],
          [170, 150],
          [150, 149],
          [122, 188],
          [188, 196],
          [196, 122],
          [206, 216],
          [216, 92],
          [92, 206],
          [164, 2],
          [2, 167],
          [167, 164],
          [242, 141],
          [141, 241],
          [241, 242],
          [0, 164],
          [164, 37],
          [37, 0],
          [11, 72],
          [72, 12],
          [12, 11],
          [12, 38],
          [38, 13],
          [13, 12],
          [70, 63],
          [63, 71],
          [71, 70],
          [31, 226],
          [226, 111],
          [111, 31],
          [36, 101],
          [101, 205],
          [205, 36],
          [203, 206],
          [206, 165],
          [165, 203],
          [126, 209],
          [209, 217],
          [217, 126],
          [98, 165],
          [165, 97],
          [97, 98],
          [237, 220],
          [220, 218],
          [218, 237],
          [237, 239],
          [239, 241],
          [241, 237],
          [210, 214],
          [214, 169],
          [169, 210],
          [140, 171],
          [171, 32],
          [32, 140],
          [241, 125],
          [125, 237],
          [237, 241],
          [179, 86],
          [86, 178],
          [178, 179],
          [180, 85],
          [85, 179],
          [179, 180],
          [181, 84],
          [84, 180],
          [180, 181],
          [182, 83],
          [83, 181],
          [181, 182],
          [194, 201],
          [201, 182],
          [182, 194],
          [177, 137],
          [137, 132],
          [132, 177],
          [184, 76],
          [76, 183],
          [183, 184],
          [185, 61],
          [61, 184],
          [184, 185],
          [186, 57],
          [57, 185],
          [185, 186],
          [216, 212],
          [
            212,
            186
          ],
          [186, 216],
          [192, 214],
          [214, 187],
          [187, 192],
          [139, 34],
          [34, 156],
          [156, 139],
          [218, 79],
          [79, 237],
          [237, 218],
          [147, 123],
          [123, 177],
          [177, 147],
          [45, 44],
          [44, 4],
          [4, 45],
          [208, 201],
          [201, 32],
          [32, 208],
          [98, 64],
          [64, 129],
          [129, 98],
          [192, 213],
          [213, 138],
          [138, 192],
          [235, 59],
          [59, 219],
          [219, 235],
          [141, 242],
          [242, 97],
          [97, 141],
          [97, 2],
          [2, 141],
          [141, 97],
          [240, 75],
          [75, 235],
          [235, 240],
          [229, 24],
          [24, 228],
          [228, 229],
          [31, 25],
          [25, 226],
          [226, 31],
          [230, 23],
          [23, 229],
          [229, 230],
          [231, 22],
          [22, 230],
          [230, 231],
          [232, 26],
          [26, 231],
          [231, 232],
          [233, 112],
          [112, 232],
          [232, 233],
          [244, 189],
          [189, 243],
          [243, 244],
          [189, 221],
          [221, 190],
          [190, 189],
          [222, 28],
          [28, 221],
          [221, 222],
          [223, 27],
          [27, 222],
          [222, 223],
          [224, 29],
          [29, 223],
          [223, 224],
          [225, 30],
          [30, 224],
          [224, 225],
          [113, 247],
          [247, 225],
          [225, 113],
          [99, 60],
          [60, 240],
          [240, 99],
          [213, 147],
          [147, 215],
          [215, 213],
          [60, 20],
          [20, 166],
          [166, 60],
          [192, 187],
          [187, 213],
          [213, 192],
          [243, 112],
          [112, 244],
          [244, 243],
          [244, 233],
          [233, 245],
          [245, 244],
          [245, 128],
          [128, 188],
          [188, 245],
          [188, 114],
          [114, 174],
          [174, 188],
          [134, 131],
          [131, 220],
          [220, 134],
          [174, 217],
          [217, 236],
          [236, 174],
          [236, 198],
          [198, 134],
          [134, 236],
          [215, 177],
          [177, 58],
          [58, 215],
          [156, 143],
          [143, 124],
          [124, 156],
          [25, 110],
          [110, 7],
          [7, 25],
          [31, 228],
          [228, 25],
          [25, 31],
          [264, 356],
          [356, 368],
          [368, 264],
          [0, 11],
          [11, 267],
          [267, 0],
          [451, 452],
          [452, 349],
          [349, 451],
          [267, 302],
          [302, 269],
          [269, 267],
          [350, 357],
          [357, 277],
          [277, 350],
          [350, 452],
          [452, 357],
          [357, 350],
          [299, 333],
          [333, 297],
          [297, 299],
          [396, 175],
          [175, 377],
          [377, 396],
          [280, 347],
          [347, 330],
          [330, 280],
          [269, 303],
          [303, 270],
          [270, 269],
          [151, 9],
          [9, 337],
          [337, 151],
          [344, 278],
          [278, 360],
          [360, 344],
          [424, 418],
          [
            418,
            431
          ],
          [431, 424],
          [270, 304],
          [304, 409],
          [409, 270],
          [272, 310],
          [310, 407],
          [407, 272],
          [322, 270],
          [270, 410],
          [410, 322],
          [449, 450],
          [450, 347],
          [347, 449],
          [432, 422],
          [422, 434],
          [434, 432],
          [18, 313],
          [313, 17],
          [17, 18],
          [291, 306],
          [306, 375],
          [375, 291],
          [259, 387],
          [387, 260],
          [260, 259],
          [424, 335],
          [335, 418],
          [418, 424],
          [434, 364],
          [364, 416],
          [416, 434],
          [391, 423],
          [423, 327],
          [327, 391],
          [301, 251],
          [251, 298],
          [298, 301],
          [275, 281],
          [281, 4],
          [4, 275],
          [254, 373],
          [373, 253],
          [253, 254],
          [375, 307],
          [307, 321],
          [321, 375],
          [280, 425],
          [425, 411],
          [411, 280],
          [200, 421],
          [
            421,
            18
          ],
          [18, 200],
          [335, 321],
          [321, 406],
          [406, 335],
          [321, 320],
          [320, 405],
          [405, 321],
          [314, 315],
          [315, 17],
          [17, 314],
          [423, 426],
          [426, 266],
          [266, 423],
          [396, 377],
          [377, 369],
          [369, 396],
          [270, 322],
          [322, 269],
          [269, 270],
          [413, 417],
          [417, 464],
          [464, 413],
          [385, 386],
          [386, 258],
          [258, 385],
          [248, 456],
          [456, 419],
          [419, 248],
          [298, 284],
          [284, 333],
          [333, 298],
          [168, 417],
          [417, 8],
          [8, 168],
          [448, 346],
          [346, 261],
          [261, 448],
          [417, 413],
          [413, 285],
          [285, 417],
          [326, 327],
          [327, 328],
          [328, 326],
          [277, 355],
          [355, 329],
          [329, 277],
          [309, 392],
          [392, 438],
          [438, 309],
          [381, 382],
          [
            382,
            256
          ],
          [256, 381],
          [279, 429],
          [429, 360],
          [360, 279],
          [365, 364],
          [364, 379],
          [379, 365],
          [355, 277],
          [277, 437],
          [437, 355],
          [282, 443],
          [443, 283],
          [283, 282],
          [281, 275],
          [275, 363],
          [363, 281],
          [395, 431],
          [431, 369],
          [369, 395],
          [299, 297],
          [297, 337],
          [337, 299],
          [335, 273],
          [273, 321],
          [321, 335],
          [348, 450],
          [450, 349],
          [349, 348],
          [359, 446],
          [446, 467],
          [467, 359],
          [283, 293],
          [293, 282],
          [282, 283],
          [250, 458],
          [458, 462],
          [462, 250],
          [300, 276],
          [276, 383],
          [383, 300],
          [292, 308],
          [308, 325],
          [325, 292],
          [283, 276],
          [276, 293],
          [293, 283],
          [264, 372],
          [372, 447],
          [447, 264],
          [346, 352],
          [352, 340],
          [340, 346],
          [354, 274],
          [274, 19],
          [19, 354],
          [363, 456],
          [456, 281],
          [281, 363],
          [426, 436],
          [436, 425],
          [425, 426],
          [380, 381],
          [381, 252],
          [252, 380],
          [267, 269],
          [269, 393],
          [393, 267],
          [421, 200],
          [200, 428],
          [428, 421],
          [371, 266],
          [266, 329],
          [329, 371],
          [432, 287],
          [287, 422],
          [422, 432],
          [290, 250],
          [250, 328],
          [328, 290],
          [385, 258],
          [258, 384],
          [384, 385],
          [446, 265],
          [265, 342],
          [342, 446],
          [386, 387],
          [387, 257],
          [257, 386],
          [422, 424],
          [424, 430],
          [430, 422],
          [445, 342],
          [342, 276],
          [276, 445],
          [422, 273],
          [273, 424],
          [424, 422],
          [306, 292],
          [292, 307],
          [307, 306],
          [
            352,
            366
          ],
          [366, 345],
          [345, 352],
          [268, 271],
          [271, 302],
          [302, 268],
          [358, 423],
          [423, 371],
          [371, 358],
          [327, 294],
          [294, 460],
          [460, 327],
          [331, 279],
          [279, 294],
          [294, 331],
          [303, 271],
          [271, 304],
          [304, 303],
          [436, 432],
          [432, 427],
          [427, 436],
          [304, 272],
          [272, 408],
          [408, 304],
          [395, 394],
          [394, 431],
          [431, 395],
          [378, 395],
          [395, 400],
          [400, 378],
          [296, 334],
          [334, 299],
          [299, 296],
          [6, 351],
          [351, 168],
          [168, 6],
          [376, 352],
          [352, 411],
          [411, 376],
          [307, 325],
          [325, 320],
          [320, 307],
          [285, 295],
          [295, 336],
          [336, 285],
          [320, 319],
          [319, 404],
          [404, 320],
          [329, 330],
          [330, 349],
          [349, 329],
          [334, 293],
          [293, 333],
          [333, 334],
          [366, 323],
          [323, 447],
          [447, 366],
          [316, 15],
          [15, 315],
          [315, 316],
          [331, 358],
          [358, 279],
          [279, 331],
          [317, 14],
          [14, 316],
          [316, 317],
          [8, 285],
          [285, 9],
          [9, 8],
          [277, 329],
          [329, 350],
          [350, 277],
          [253, 374],
          [374, 252],
          [252, 253],
          [319, 318],
          [318, 403],
          [403, 319],
          [351, 6],
          [6, 419],
          [419, 351],
          [324, 318],
          [318, 325],
          [325, 324],
          [397, 367],
          [367, 365],
          [365, 397],
          [288, 435],
          [435, 397],
          [397, 288],
          [278, 344],
          [344, 439],
          [439, 278],
          [310, 272],
          [272, 311],
          [311, 310],
          [248, 195],
          [195, 281],
          [281, 248],
          [375, 273],
          [273, 291],
          [291, 375],
          [175, 396],
          [396, 199],
          [199, 175],
          [312, 311],
          [311, 268],
          [268, 312],
          [276, 283],
          [283, 445],
          [445, 276],
          [390, 373],
          [373, 339],
          [339, 390],
          [295, 282],
          [282, 296],
          [296, 295],
          [448, 449],
          [449, 346],
          [346, 448],
          [356, 264],
          [264, 454],
          [454, 356],
          [337, 336],
          [336, 299],
          [299, 337],
          [337, 338],
          [338, 151],
          [151, 337],
          [294, 278],
          [278, 455],
          [455, 294],
          [308, 292],
          [292, 415],
          [415, 308],
          [429, 358],
          [358, 355],
          [355, 429],
          [265, 340],
          [340, 372],
          [372, 265],
          [352, 346],
          [346, 280],
          [280, 352],
          [295, 442],
          [442, 282],
          [282, 295],
          [354, 19],
          [19, 370],
          [370, 354],
          [285, 441],
          [441, 295],
          [295, 285],
          [
            195,
            248
          ],
          [248, 197],
          [197, 195],
          [457, 440],
          [440, 274],
          [274, 457],
          [301, 300],
          [300, 368],
          [368, 301],
          [417, 351],
          [351, 465],
          [465, 417],
          [251, 301],
          [301, 389],
          [389, 251],
          [394, 395],
          [395, 379],
          [379, 394],
          [399, 412],
          [412, 419],
          [419, 399],
          [410, 436],
          [436, 322],
          [322, 410],
          [326, 2],
          [2, 393],
          [393, 326],
          [354, 370],
          [370, 461],
          [461, 354],
          [393, 164],
          [164, 267],
          [267, 393],
          [268, 302],
          [302, 12],
          [12, 268],
          [312, 268],
          [268, 13],
          [13, 312],
          [298, 293],
          [293, 301],
          [301, 298],
          [265, 446],
          [446, 340],
          [340, 265],
          [280, 330],
          [330, 425],
          [425, 280],
          [322, 426],
          [426, 391],
          [391, 322],
          [
            420,
            429
          ],
          [429, 437],
          [437, 420],
          [393, 391],
          [391, 326],
          [326, 393],
          [344, 440],
          [440, 438],
          [438, 344],
          [458, 459],
          [459, 461],
          [461, 458],
          [364, 434],
          [434, 394],
          [394, 364],
          [428, 396],
          [396, 262],
          [262, 428],
          [274, 354],
          [354, 457],
          [457, 274],
          [317, 316],
          [316, 402],
          [402, 317],
          [316, 315],
          [315, 403],
          [403, 316],
          [315, 314],
          [314, 404],
          [404, 315],
          [314, 313],
          [313, 405],
          [405, 314],
          [313, 421],
          [421, 406],
          [406, 313],
          [323, 366],
          [366, 361],
          [361, 323],
          [292, 306],
          [306, 407],
          [407, 292],
          [306, 291],
          [291, 408],
          [408, 306],
          [291, 287],
          [287, 409],
          [409, 291],
          [287, 432],
          [432, 410],
          [410, 287],
          [427, 434],
          [434, 411],
          [411, 427],
          [372, 264],
          [264, 383],
          [383, 372],
          [459, 309],
          [309, 457],
          [457, 459],
          [366, 352],
          [352, 401],
          [401, 366],
          [1, 274],
          [274, 4],
          [4, 1],
          [418, 421],
          [421, 262],
          [262, 418],
          [331, 294],
          [294, 358],
          [358, 331],
          [435, 433],
          [433, 367],
          [367, 435],
          [392, 289],
          [289, 439],
          [439, 392],
          [328, 462],
          [462, 326],
          [326, 328],
          [94, 2],
          [2, 370],
          [370, 94],
          [289, 305],
          [305, 455],
          [455, 289],
          [339, 254],
          [254, 448],
          [448, 339],
          [359, 255],
          [255, 446],
          [446, 359],
          [254, 253],
          [253, 449],
          [449, 254],
          [253, 252],
          [252, 450],
          [450, 253],
          [252, 256],
          [256, 451],
          [451, 252],
          [
            256,
            341
          ],
          [341, 452],
          [452, 256],
          [414, 413],
          [413, 463],
          [463, 414],
          [286, 441],
          [441, 414],
          [414, 286],
          [286, 258],
          [258, 441],
          [441, 286],
          [258, 257],
          [257, 442],
          [442, 258],
          [257, 259],
          [259, 443],
          [443, 257],
          [259, 260],
          [260, 444],
          [444, 259],
          [260, 467],
          [467, 445],
          [445, 260],
          [309, 459],
          [459, 250],
          [250, 309],
          [305, 289],
          [289, 290],
          [290, 305],
          [305, 290],
          [290, 460],
          [460, 305],
          [401, 376],
          [376, 435],
          [435, 401],
          [309, 250],
          [250, 392],
          [392, 309],
          [376, 411],
          [411, 433],
          [433, 376],
          [453, 341],
          [341, 464],
          [464, 453],
          [357, 453],
          [453, 465],
          [465, 357],
          [343, 357],
          [357, 412],
          [412, 343],
          [437, 343],
          [343, 399],
          [399, 437],
          [344, 360],
          [360, 440],
          [440, 344],
          [420, 437],
          [437, 456],
          [456, 420],
          [360, 420],
          [420, 363],
          [363, 360],
          [361, 401],
          [401, 288],
          [288, 361],
          [265, 372],
          [372, 353],
          [353, 265],
          [390, 339],
          [339, 249],
          [249, 390],
          [339, 448],
          [448, 255],
          [255, 339]
        ]);
        H4("HAND_CONNECTIONS", [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]]);
        H4("POSE_CONNECTIONS", [[0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]]);
        H4("POSE_LANDMARKS", { NOSE: 0, LEFT_EYE_INNER: 1, LEFT_EYE: 2, LEFT_EYE_OUTER: 3, RIGHT_EYE_INNER: 4, RIGHT_EYE: 5, RIGHT_EYE_OUTER: 6, LEFT_EAR: 7, RIGHT_EAR: 8, LEFT_RIGHT: 9, RIGHT_LEFT: 10, LEFT_SHOULDER: 11, RIGHT_SHOULDER: 12, LEFT_ELBOW: 13, RIGHT_ELBOW: 14, LEFT_WRIST: 15, RIGHT_WRIST: 16, LEFT_PINKY: 17, RIGHT_PINKY: 18, LEFT_INDEX: 19, RIGHT_INDEX: 20, LEFT_THUMB: 21, RIGHT_THUMB: 22, LEFT_HIP: 23, RIGHT_HIP: 24, LEFT_KNEE: 25, RIGHT_KNEE: 26, LEFT_ANKLE: 27, RIGHT_ANKLE: 28, LEFT_HEEL: 29, RIGHT_HEEL: 30, LEFT_FOOT_INDEX: 31, RIGHT_FOOT_INDEX: 32 });
        H4("POSE_LANDMARKS_LEFT", { LEFT_EYE_INNER: 1, LEFT_EYE: 2, LEFT_EYE_OUTER: 3, LEFT_EAR: 7, LEFT_RIGHT: 9, LEFT_SHOULDER: 11, LEFT_ELBOW: 13, LEFT_WRIST: 15, LEFT_PINKY: 17, LEFT_INDEX: 19, LEFT_THUMB: 21, LEFT_HIP: 23, LEFT_KNEE: 25, LEFT_ANKLE: 27, LEFT_HEEL: 29, LEFT_FOOT_INDEX: 31 });
        H4("POSE_LANDMARKS_RIGHT", { RIGHT_EYE_INNER: 4, RIGHT_EYE: 5, RIGHT_EYE_OUTER: 6, RIGHT_EAR: 8, RIGHT_LEFT: 10, RIGHT_SHOULDER: 12, RIGHT_ELBOW: 14, RIGHT_WRIST: 16, RIGHT_PINKY: 18, RIGHT_INDEX: 20, RIGHT_THUMB: 22, RIGHT_HIP: 24, RIGHT_KNEE: 26, RIGHT_ANKLE: 28, RIGHT_HEEL: 30, RIGHT_FOOT_INDEX: 32 });
        H4("POSE_LANDMARKS_NEUTRAL", { NOSE: 0 });
        H4("matrixDataToMatrix", function(a4) {
          for (var b3 = a4.getCols(), c5 = a4.getRows(), d4 = a4.getPackedDataList(), e4 = [], f3 = 0; f3 < c5; f3++)
            e4.push(Array(b3));
          for (f3 = 0; f3 < c5; f3++)
            for (var g4 = 0; g4 < b3; g4++) {
              var h4 = 1 === a4.getLayout() ? f3 * b3 + g4 : g4 * c5 + f3;
              e4[f3][g4] = d4[h4];
            }
          return e4;
        });
        H4("VERSION", "0.5.1675471629");
      }).call(exports2);
    }
  });

  // node_modules/@sermas/toolkit/detection/video/mediapipe/v1/holistic/holistic.detector.js
  var import_holistic, FACEMESH_FACE_OVAL, FACEMESH_LEFT_EYE, FACEMESH_LEFT_EYEBROW, FACEMESH_LIPS, FACEMESH_RIGHT_EYE, FACEMESH_RIGHT_EYEBROW, FACEMESH_TESSELATION, HAND_CONNECTIONS, POSE_CONNECTIONS, POSE_LANDMARKS_LEFT, POSE_LANDMARKS_RIGHT;
  var init_holistic_detector = __esm({
    "node_modules/@sermas/toolkit/detection/video/mediapipe/v1/holistic/holistic.detector.js"() {
      init_base_detector();
      import_holistic = __toESM(require_holistic(), 1);
      ({ FACEMESH_FACE_OVAL, FACEMESH_LEFT_EYE, FACEMESH_LEFT_EYEBROW, FACEMESH_LIPS, FACEMESH_RIGHT_EYE, FACEMESH_RIGHT_EYEBROW, FACEMESH_TESSELATION, HAND_CONNECTIONS, POSE_CONNECTIONS, POSE_LANDMARKS_LEFT, POSE_LANDMARKS_RIGHT } = import_holistic.default);
    }
  });

  // node_modules/@sermas/toolkit/detection/video/mediapipe/v1/holistic/index.js
  var init_holistic = __esm({
    "node_modules/@sermas/toolkit/detection/video/mediapipe/v1/holistic/index.js"() {
      init_holistic_dto();
      init_holistic_detector();
    }
  });

  // node_modules/@mediapipe/tasks-audio/audio_bundle.mjs
  function e2(e4) {
    t: {
      for (var n4 = ["CLOSURE_FLAGS"], r4 = t2, o4 = 0; o4 < n4.length; o4++)
        if (null == (r4 = r4[n4[o4]])) {
          n4 = null;
          break t;
        }
      n4 = r4;
    }
    return null != (e4 = n4 && n4[e4]) && e4;
  }
  function n2() {
    throw Error("Invalid UTF8");
  }
  function r2(t4, e4) {
    return e4 = String.fromCharCode.apply(null, e4), null == t4 ? e4 : t4 + e4;
  }
  function c2(t4) {
    if (u2)
      t4 = (a2 ||= new TextEncoder()).encode(t4);
    else {
      let n4 = 0;
      const r4 = new Uint8Array(3 * t4.length);
      for (let o4 = 0; o4 < t4.length; o4++) {
        var e4 = t4.charCodeAt(o4);
        if (128 > e4)
          r4[n4++] = e4;
        else {
          if (2048 > e4)
            r4[n4++] = e4 >> 6 | 192;
          else {
            if (55296 <= e4 && 57343 >= e4) {
              if (56319 >= e4 && o4 < t4.length) {
                const i5 = t4.charCodeAt(++o4);
                if (56320 <= i5 && 57343 >= i5) {
                  e4 = 1024 * (e4 - 55296) + i5 - 56320 + 65536, r4[n4++] = e4 >> 18 | 240, r4[n4++] = e4 >> 12 & 63 | 128, r4[n4++] = e4 >> 6 & 63 | 128, r4[n4++] = 63 & e4 | 128;
                  continue;
                }
                o4--;
              }
              e4 = 65533;
            }
            r4[n4++] = e4 >> 12 | 224, r4[n4++] = e4 >> 6 & 63 | 128;
          }
          r4[n4++] = 63 & e4 | 128;
        }
      }
      t4 = n4 === r4.length ? r4 : r4.subarray(0, n4);
    }
    return t4;
  }
  function g2(t4) {
    return !!h2 && (!!l2 && l2.brands.some(({ brand: e4 }) => e4 && -1 != e4.indexOf(t4)));
  }
  function p2(e4) {
    var n4;
    return (n4 = t2.navigator) && (n4 = n4.userAgent) || (n4 = ""), -1 != n4.indexOf(e4);
  }
  function m() {
    return !!h2 && (!!l2 && 0 < l2.brands.length);
  }
  function y() {
    return m() ? g2("Chromium") : (p2("Chrome") || p2("CriOS")) && !(!m() && p2("Edge")) || p2("Silk");
  }
  function _(t4) {
    var e4 = t4.length, n4 = 3 * e4 / 4;
    n4 % 3 ? n4 = Math.floor(n4) : -1 != "=.".indexOf(t4[e4 - 1]) && (n4 = -1 != "=.".indexOf(t4[e4 - 2]) ? n4 - 2 : n4 - 1);
    var r4 = new Uint8Array(n4), o4 = 0;
    return function(t5, e5) {
      function n5(e6) {
        for (; r5 < t5.length; ) {
          var n6 = t5.charAt(r5++), o6 = w[n6];
          if (null != o6)
            return o6;
          if (!/^[\s\xa0]*$/.test(n6))
            throw Error("Unknown base64 encoding at char: " + n6);
        }
        return e6;
      }
      A();
      for (var r5 = 0; ; ) {
        var o5 = n5(-1), i5 = n5(0), s4 = n5(64), a4 = n5(64);
        if (64 === a4 && -1 === o5)
          break;
        e5(o5 << 2 | i5 >> 4), 64 != s4 && (e5(i5 << 4 & 240 | s4 >> 2), 64 != a4 && e5(s4 << 6 & 192 | a4));
      }
    }(t4, function(t5) {
      r4[o4++] = t5;
    }), o4 !== n4 ? r4.subarray(0, o4) : r4;
  }
  function A() {
    if (!w) {
      w = {};
      for (var t4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e4 = ["+/=", "+/", "-_=", "-_.", "-_"], n4 = 0; 5 > n4; n4++) {
        var r4 = t4.concat(e4[n4].split(""));
        b[n4] = r4;
        for (var o4 = 0; o4 < r4.length; o4++) {
          var i5 = r4[o4];
          void 0 === w[i5] && (w[i5] = o4);
        }
      }
    }
  }
  function T(t4) {
    if (!E2) {
      var e4;
      void 0 === e4 && (e4 = 0), A(), e4 = b[e4];
      var n4 = Array(Math.floor(t4.length / 3)), r4 = e4[64] || "";
      let u4 = 0, c5 = 0;
      for (; u4 < t4.length - 2; u4 += 3) {
        var o4 = t4[u4], i5 = t4[u4 + 1], s4 = t4[u4 + 2], a4 = e4[o4 >> 2];
        o4 = e4[(3 & o4) << 4 | i5 >> 4], i5 = e4[(15 & i5) << 2 | s4 >> 6], s4 = e4[63 & s4], n4[c5++] = a4 + o4 + i5 + s4;
      }
      switch (a4 = 0, s4 = r4, t4.length - u4) {
        case 2:
          s4 = e4[(15 & (a4 = t4[u4 + 1])) << 2] || r4;
        case 1:
          t4 = t4[u4], n4[c5] = e4[t4 >> 2] + e4[(3 & t4) << 4 | a4 >> 4] + s4 + r4;
      }
      return n4.join("");
    }
    for (e4 = "", n4 = 0, r4 = t4.length - 10240; n4 < r4; )
      e4 += String.fromCharCode.apply(null, t4.subarray(n4, n4 += 10240));
    return e4 += String.fromCharCode.apply(null, n4 ? t4.subarray(n4) : t4), btoa(e4);
  }
  function O3(t4) {
    return P[t4] || "";
  }
  function L(t4) {
    if (!E2)
      return _(t4);
    I.test(t4) && (t4 = t4.replace(I, O3)), t4 = atob(t4);
    const e4 = new Uint8Array(t4.length);
    for (let n4 = 0; n4 < t4.length; n4++)
      e4[n4] = t4.charCodeAt(n4);
    return e4;
  }
  function x(t4) {
    return S && null != t4 && t4 instanceof Uint8Array;
  }
  function F2() {
    return B2 ||= new Uint8Array(0);
  }
  function k(t4) {
    if (t4 !== U3)
      throw Error("illegal external caller");
  }
  function V2() {
    return j2 ||= new M(null, U3);
  }
  function N2(t4) {
    k(U3);
    var e4 = t4.g;
    return null == (e4 = null == e4 || x(e4) ? e4 : "string" == typeof e4 ? L(e4) : null) ? e4 : t4.g = e4;
  }
  function D(t4, e4) {
    return Error(`Invalid wire type: ${t4} (at position ${e4})`);
  }
  function C() {
    return Error("Failed to read varint, encoding is invalid.");
  }
  function G2(t4, e4) {
    return Error(`Tried to read past the end of the data ${e4} > ${t4}`);
  }
  function $3(t4) {
    if ("string" == typeof t4)
      return { buffer: L(t4), v: false };
    if (Array.isArray(t4))
      return { buffer: new Uint8Array(t4), v: false };
    if (t4.constructor === Uint8Array)
      return { buffer: t4, v: false };
    if (t4.constructor === ArrayBuffer)
      return { buffer: new Uint8Array(t4), v: false };
    if (t4.constructor === M)
      return { buffer: N2(t4) || F2(), v: true };
    if (t4 instanceof Uint8Array)
      return { buffer: new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength), v: false };
    throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
  }
  function z2() {
    return "function" == typeof BigInt;
  }
  function J(t4) {
    const e4 = 0 > t4;
    let n4 = (t4 = Math.abs(t4)) >>> 0;
    if (t4 = Math.floor((t4 - n4) / 4294967296), e4) {
      const [e5, r4] = et2(n4, t4);
      t4 = r4, n4 = e5;
    }
    H2 = n4 >>> 0, q2 = t4 >>> 0;
  }
  function K3(t4) {
    const e4 = R3 ||= new DataView(new ArrayBuffer(8));
    e4.setFloat32(0, +t4, true), q2 = 0, H2 = e4.getUint32(0, true);
  }
  function Y(t4, e4) {
    return 4294967296 * e4 + (t4 >>> 0);
  }
  function X(t4, e4) {
    const n4 = 2147483648 & e4;
    return n4 && (e4 = ~e4 >>> 0, 0 == (t4 = 1 + ~t4 >>> 0) && (e4 = e4 + 1 >>> 0)), t4 = Y(t4, e4), n4 ? -t4 : t4;
  }
  function Q(t4, e4) {
    if (t4 >>>= 0, 2097151 >= (e4 >>>= 0))
      var n4 = "" + (4294967296 * e4 + t4);
    else
      z2() ? n4 = "" + (BigInt(e4) << BigInt(32) | BigInt(t4)) : (t4 = (16777215 & t4) + 6777216 * (n4 = 16777215 & (t4 >>> 24 | e4 << 8)) + 6710656 * (e4 = e4 >> 16 & 65535), n4 += 8147497 * e4, e4 *= 2, 1e7 <= t4 && (n4 += Math.floor(t4 / 1e7), t4 %= 1e7), 1e7 <= n4 && (e4 += Math.floor(n4 / 1e7), n4 %= 1e7), n4 = e4 + Z2(n4) + Z2(t4));
    return n4;
  }
  function Z2(t4) {
    return t4 = String(t4), "0000000".slice(t4.length) + t4;
  }
  function tt2(t4) {
    if (16 > t4.length)
      J(Number(t4));
    else if (z2())
      t4 = BigInt(t4), H2 = Number(t4 & BigInt(4294967295)) >>> 0, q2 = Number(t4 >> BigInt(32) & BigInt(4294967295));
    else {
      const e4 = +("-" === t4[0]);
      q2 = H2 = 0;
      const n4 = t4.length;
      for (let r4 = e4, o4 = (n4 - e4) % 6 + e4; o4 <= n4; r4 = o4, o4 += 6) {
        const e5 = Number(t4.slice(r4, o4));
        q2 *= 1e6, H2 = 1e6 * H2 + e5, 4294967296 <= H2 && (q2 += Math.trunc(H2 / 4294967296), q2 >>>= 0, H2 >>>= 0);
      }
      if (e4) {
        const [t5, e5] = et2(H2, q2);
        H2 = t5, q2 = e5;
      }
    }
  }
  function et2(t4, e4) {
    return e4 = ~e4, t4 ? t4 = 1 + ~t4 : e4 += 1, [t4, e4];
  }
  function nt2(t4, e4) {
    let n4, r4 = 0, o4 = 0, i5 = 0;
    const s4 = t4.i;
    let a4 = t4.g;
    do {
      n4 = s4[a4++], r4 |= (127 & n4) << i5, i5 += 7;
    } while (32 > i5 && 128 & n4);
    for (32 < i5 && (o4 |= (127 & n4) >> 4), i5 = 3; 32 > i5 && 128 & n4; i5 += 7)
      n4 = s4[a4++], o4 |= (127 & n4) << i5;
    if (ct2(t4, a4), 128 > n4)
      return e4(r4 >>> 0, o4 >>> 0);
    throw C();
  }
  function rt(t4) {
    let e4 = 0, n4 = t4.g;
    const r4 = n4 + 10, o4 = t4.i;
    for (; n4 < r4; ) {
      const r5 = o4[n4++];
      if (e4 |= r5, 0 == (128 & r5))
        return ct2(t4, n4), !!(127 & e4);
    }
    throw C();
  }
  function ot(t4) {
    const e4 = t4.i;
    let n4 = t4.g, r4 = e4[n4++], o4 = 127 & r4;
    if (128 & r4 && (r4 = e4[n4++], o4 |= (127 & r4) << 7, 128 & r4 && (r4 = e4[n4++], o4 |= (127 & r4) << 14, 128 & r4 && (r4 = e4[n4++], o4 |= (127 & r4) << 21, 128 & r4 && (r4 = e4[n4++], o4 |= r4 << 28, 128 & r4 && 128 & e4[n4++] && 128 & e4[n4++] && 128 & e4[n4++] && 128 & e4[n4++] && 128 & e4[n4++])))))
      throw C();
    return ct2(t4, n4), o4;
  }
  function it2(t4) {
    var e4 = t4.i;
    const n4 = t4.g, r4 = e4[n4], o4 = e4[n4 + 1], i5 = e4[n4 + 2];
    return e4 = e4[n4 + 3], ct2(t4, t4.g + 4), (r4 << 0 | o4 << 8 | i5 << 16 | e4 << 24) >>> 0;
  }
  function st2(t4) {
    var e4 = it2(t4);
    t4 = 2 * (e4 >> 31) + 1;
    const n4 = e4 >>> 23 & 255;
    return e4 &= 8388607, 255 == n4 ? e4 ? NaN : 1 / 0 * t4 : 0 == n4 ? t4 * Math.pow(2, -149) * e4 : t4 * Math.pow(2, n4 - 150) * (e4 + Math.pow(2, 23));
  }
  function at2(t4) {
    return ot(t4);
  }
  function ut2(t4, e4, { C: n4 = false } = {}) {
    t4.C = n4, e4 && (e4 = $3(e4), t4.i = e4.buffer, t4.m = e4.v, t4.s = 0, t4.j = t4.i.length, t4.g = t4.s);
  }
  function ct2(t4, e4) {
    if (t4.g = e4, e4 > t4.j)
      throw G2(t4.j, e4);
  }
  function lt(t4, e4) {
    if (0 > e4)
      throw Error(`Tried to read a negative byte length: ${e4}`);
    const n4 = t4.g, r4 = n4 + e4;
    if (r4 > t4.j)
      throw G2(e4, t4.j - n4);
    return t4.g = r4, n4;
  }
  function ht2(t4, e4) {
    if (0 == e4)
      return V2();
    var n4 = lt(t4, e4);
    return t4.C && t4.m ? n4 = t4.i.subarray(n4, n4 + e4) : (t4 = t4.i, n4 = n4 === (e4 = n4 + e4) ? F2() : W2 ? t4.slice(n4, e4) : new Uint8Array(t4.subarray(n4, e4))), 0 == n4.length ? V2() : new M(n4, U3);
  }
  function dt2(t4) {
    var e4 = t4.g;
    if (e4.g == e4.j)
      return false;
    t4.j = t4.g.g;
    var n4 = ot(t4.g) >>> 0;
    if (e4 = n4 >>> 3, !(0 <= (n4 &= 7) && 5 >= n4))
      throw D(n4, t4.j);
    if (1 > e4)
      throw Error(`Invalid field number: ${e4} (at position ${t4.j})`);
    return t4.m = e4, t4.i = n4, true;
  }
  function gt(t4) {
    switch (t4.i) {
      case 0:
        0 != t4.i ? gt(t4) : rt(t4.g);
        break;
      case 1:
        ct2(t4 = t4.g, t4.g + 8);
        break;
      case 2:
        if (2 != t4.i)
          gt(t4);
        else {
          var e4 = ot(t4.g) >>> 0;
          ct2(t4 = t4.g, t4.g + e4);
        }
        break;
      case 5:
        ct2(t4 = t4.g, t4.g + 4);
        break;
      case 3:
        for (e4 = t4.m; ; ) {
          if (!dt2(t4))
            throw Error("Unmatched start-group tag: stream EOF");
          if (4 == t4.i) {
            if (t4.m != e4)
              throw Error("Unmatched end-group tag");
            break;
          }
          gt(t4);
        }
        break;
      default:
        throw D(t4.i, t4.j);
    }
  }
  function pt2(t4, e4, n4) {
    const r4 = t4.g.j, o4 = ot(t4.g) >>> 0, i5 = t4.g.g + o4;
    let s4 = i5 - r4;
    if (0 >= s4 && (t4.g.j = i5, n4(e4, t4, void 0, void 0, void 0), s4 = i5 - t4.g.g), s4)
      throw Error(`Message parsing ended unexpectedly. Expected to read ${o4} bytes, instead read ${o4 - s4} bytes, either the data ended unexpectedly or the message misreported its own length`);
    t4.g.g = i5, t4.g.j = r4;
  }
  function mt(t4) {
    var e4 = ot(t4.g) >>> 0, a4 = lt(t4 = t4.g, e4);
    if (t4 = t4.i, s2) {
      var u4, c5 = t4;
      (u4 = i2) || (u4 = i2 = new TextDecoder("utf-8", { fatal: true })), e4 = a4 + e4, c5 = 0 === a4 && e4 === c5.length ? c5 : c5.subarray(a4, e4);
      try {
        var l4 = u4.decode(c5);
      } catch (t5) {
        if (void 0 === o2) {
          try {
            u4.decode(new Uint8Array([128]));
          } catch (t6) {
          }
          try {
            u4.decode(new Uint8Array([97])), o2 = true;
          } catch (t6) {
            o2 = false;
          }
        }
        throw !o2 && (i2 = void 0), t5;
      }
    } else {
      e4 = (l4 = a4) + e4, a4 = [];
      let o4, i5 = null;
      for (; l4 < e4; ) {
        var h4 = t4[l4++];
        128 > h4 ? a4.push(h4) : 224 > h4 ? l4 >= e4 ? n2() : (o4 = t4[l4++], 194 > h4 || 128 != (192 & o4) ? (l4--, n2()) : a4.push((31 & h4) << 6 | 63 & o4)) : 240 > h4 ? l4 >= e4 - 1 ? n2() : (o4 = t4[l4++], 128 != (192 & o4) || 224 === h4 && 160 > o4 || 237 === h4 && 160 <= o4 || 128 != (192 & (u4 = t4[l4++])) ? (l4--, n2()) : a4.push((15 & h4) << 12 | (63 & o4) << 6 | 63 & u4)) : 244 >= h4 ? l4 >= e4 - 2 ? n2() : (o4 = t4[l4++], 128 != (192 & o4) || 0 != o4 - 144 + (h4 << 28) >> 30 || 128 != (192 & (u4 = t4[l4++])) || 128 != (192 & (c5 = t4[l4++])) ? (l4--, n2()) : (h4 = (7 & h4) << 18 | (63 & o4) << 12 | (63 & u4) << 6 | 63 & c5, h4 -= 65536, a4.push(55296 + (h4 >> 10 & 1023), 56320 + (1023 & h4)))) : n2(), 8192 <= a4.length && (i5 = r2(i5, a4), a4.length = 0);
      }
      l4 = r2(i5, a4);
    }
    return l4;
  }
  function yt(t4) {
    const e4 = ot(t4.g) >>> 0;
    return ht2(t4.g, e4);
  }
  function vt(t4, e4, n4) {
    var r4 = ot(t4.g) >>> 0;
    for (r4 = t4.g.g + r4; t4.g.g < r4; )
      n4.push(e4(t4.g));
  }
  function wt2(t4) {
    return t4 ? /^\d+$/.test(t4) ? (tt2(t4), new _t(H2, q2)) : null : At ||= new _t(0, 0);
  }
  function St(t4) {
    return t4 ? /^-?\d+$/.test(t4) ? (tt2(t4), new Et(H2, q2)) : null : Tt2 ||= new Et(0, 0);
  }
  function It(t4, e4, n4) {
    for (; 0 < n4 || 127 < e4; )
      t4.g.push(127 & e4 | 128), e4 = (e4 >>> 7 | n4 << 25) >>> 0, n4 >>>= 7;
    t4.g.push(e4);
  }
  function Pt(t4, e4) {
    for (; 127 < e4; )
      t4.g.push(127 & e4 | 128), e4 >>>= 7;
    t4.g.push(e4);
  }
  function Ot2(t4, e4) {
    if (0 <= e4)
      Pt(t4, e4);
    else {
      for (let n4 = 0; 9 > n4; n4++)
        t4.g.push(127 & e4 | 128), e4 >>= 7;
      t4.g.push(1);
    }
  }
  function Lt(t4, e4) {
    t4.g.push(e4 >>> 0 & 255), t4.g.push(e4 >>> 8 & 255), t4.g.push(e4 >>> 16 & 255), t4.g.push(e4 >>> 24 & 255);
  }
  function xt2(t4, e4) {
    0 !== e4.length && (t4.j.push(e4), t4.i += e4.length);
  }
  function Bt2(t4, e4, n4) {
    Pt(t4.g, 8 * e4 + n4);
  }
  function Ft(t4, e4) {
    return Bt2(t4, e4, 2), e4 = t4.g.end(), xt2(t4, e4), e4.push(t4.i), e4;
  }
  function Ut(t4, e4) {
    var n4 = e4.pop();
    for (n4 = t4.i + t4.g.length() - n4; 127 < n4; )
      e4.push(127 & n4 | 128), n4 >>>= 7, t4.i++;
    e4.push(n4), t4.i++;
  }
  function jt2(t4, e4, n4) {
    Bt2(t4, e4, 2), Pt(t4.g, n4.length), xt2(t4, t4.g.end()), xt2(t4, n4);
  }
  function Nt2(t4) {
    return Array.prototype.slice.call(t4);
  }
  function Ct(t4, e4, n4) {
    return n4 ? t4 | e4 : t4 & ~e4;
  }
  function Wt2(t4, e4) {
    zt(e4, -14591 & (0 | t4));
  }
  function Rt2(t4, e4) {
    zt(e4, -14557 & (34 | t4));
  }
  function Ht2(t4) {
    return 0 === (t4 = t4 >> 14 & 1023) ? 536870912 : t4;
  }
  function Yt2(t4) {
    return !(!t4 || "object" != typeof t4 || t4.g !== Kt2);
  }
  function Xt2(t4) {
    return null !== t4 && "object" == typeof t4 && !Array.isArray(t4) && t4.constructor === Object;
  }
  function Qt(t4, e4, n4) {
    if (null != t4) {
      if ("string" == typeof t4)
        t4 = t4 ? new M(t4, U3) : V2();
      else if (t4.constructor !== M)
        if (x(t4))
          t4 = t4.length ? new M(n4 ? t4 : new Uint8Array(t4), U3) : V2();
        else {
          if (!e4)
            throw Error();
          t4 = void 0;
        }
    }
    return t4;
  }
  function Zt2(t4, e4, n4) {
    if (!Array.isArray(t4) || t4.length)
      return false;
    const r4 = Gt(t4);
    return !!(1 & r4) || !(!e4 || !(Array.isArray(e4) ? e4.includes(n4) : e4.has(n4))) && (zt(t4, 1 | r4), true);
  }
  function ee2(t4) {
    if (2 & t4)
      throw Error();
  }
  function oe2(t4, e4) {
    (e4 = ne ? e4[ne] : void 0) && (t4[ne] = Nt2(e4));
  }
  function ie() {
    const t4 = Error("int32");
    return t4.__closure__error__context__984382 || (t4.__closure__error__context__984382 = {}), t4.__closure__error__context__984382.severity = "warning", t4;
  }
  function se(t4) {
    return null == t4 || "number" == typeof t4 ? t4 : "NaN" === t4 || "Infinity" === t4 || "-Infinity" === t4 ? Number(t4) : void 0;
  }
  function ae2(t4) {
    if (null != t4 && "boolean" != typeof t4) {
      var e4 = typeof t4;
      throw Error(`Expected boolean but got ${"object" != e4 ? e4 : t4 ? Array.isArray(t4) ? "array" : e4 : "null"}: ${t4}`);
    }
    return t4;
  }
  function ce3(t4) {
    const e4 = typeof t4;
    return "number" === e4 ? Number.isFinite(t4) : "string" === e4 && ue2.test(t4);
  }
  function le2(t4) {
    if (null == t4)
      return t4;
    if ("string" == typeof t4) {
      if (!t4)
        return;
      t4 = +t4;
    }
    return "number" == typeof t4 && Number.isFinite(t4) ? 0 | t4 : void 0;
  }
  function he(t4) {
    return "-" !== t4[0] && (20 > t4.length || 20 === t4.length && 184467 > Number(t4.substring(0, 6)));
  }
  function fe2(t4) {
    return t4 = Math.trunc(t4), Number.isSafeInteger(t4) || (J(t4), t4 = X(H2, q2)), t4;
  }
  function de(t4) {
    var e4 = Math.trunc(Number(t4));
    if (Number.isSafeInteger(e4))
      return String(e4);
    if (-1 !== (e4 = t4.indexOf(".")) && (t4 = t4.substring(0, e4)), !("-" === t4[0] ? 20 > t4.length || 20 === t4.length && -922337 < Number(t4.substring(0, 7)) : 19 > t4.length || 19 === t4.length && 922337 > Number(t4.substring(0, 6))))
      if (tt2(t4), t4 = H2, 2147483648 & (e4 = q2))
        if (z2())
          t4 = "" + (BigInt(0 | e4) << BigInt(32) | BigInt(t4 >>> 0));
        else {
          const [n4, r4] = et2(t4, e4);
          t4 = "-" + Q(n4, r4);
        }
      else
        t4 = Q(t4, e4);
    return t4;
  }
  function ge2(t4) {
    if ("string" != typeof t4)
      throw Error();
    return t4;
  }
  function pe(t4) {
    if (null != t4 && "string" != typeof t4)
      throw Error();
    return t4;
  }
  function me2(t4) {
    return null == t4 || "string" == typeof t4 ? t4 : void 0;
  }
  function ye3(t4, e4, n4) {
    if (null != t4 && "object" == typeof t4 && t4.B === Jt)
      return t4;
    if (Array.isArray(t4)) {
      var r4 = Gt(t4), o4 = r4;
      return 0 === o4 && (o4 |= 32 & n4), (o4 |= 2 & n4) !== r4 && zt(t4, o4), new e4(t4);
    }
  }
  function _e3(t4) {
    switch (typeof t4) {
      case "boolean":
        return be2 ||= [0, void 0, true];
      case "number":
        return 0 < t4 ? void 0 : 0 === t4 ? we2 ||= [0, void 0] : [-t4, void 0];
      case "string":
        return [0, t4];
      case "object":
        return t4;
    }
  }
  function Ae(t4, e4, n4) {
    if (null == t4 && (t4 = ve), ve = void 0, null == t4) {
      var r4 = 96;
      n4 ? (t4 = [n4], r4 |= 512) : t4 = [], e4 && (r4 = -16760833 & r4 | (1023 & e4) << 14);
    } else {
      if (!Array.isArray(t4))
        throw Error();
      if (2048 & (r4 = Gt(t4)))
        throw Error();
      if (64 & r4)
        return t4;
      if (r4 |= 64, n4 && (r4 |= 512, n4 !== t4[0]))
        throw Error();
      t: {
        const o4 = (n4 = t4).length;
        if (o4) {
          const t5 = o4 - 1;
          if (Xt2(n4[t5])) {
            if (1024 <= (e4 = t5 - (+!!(512 & (r4 |= 256)) - 1)))
              throw Error();
            r4 = -16760833 & r4 | (1023 & e4) << 14;
            break t;
          }
        }
        if (e4) {
          if (1024 < (e4 = Math.max(e4, o4 - (+!!(512 & r4) - 1))))
            throw Error();
          r4 = -16760833 & r4 | (1023 & e4) << 14;
        }
      }
    }
    return zt(t4, r4), t4;
  }
  function Se2(t4, e4, n4, r4, o4) {
    if (null != t4) {
      if (Array.isArray(t4))
        t4 = Zt2(t4, void 0, 0) ? void 0 : o4 && 2 & Gt(t4) ? t4 : Ee2(t4, e4, n4, void 0 !== r4, o4);
      else if (Xt2(t4)) {
        const i5 = {};
        for (let s4 in t4)
          i5[s4] = Se2(t4[s4], e4, n4, r4, o4);
        t4 = i5;
      } else
        t4 = e4(t4, r4);
      return t4;
    }
  }
  function Ee2(t4, e4, n4, r4, o4) {
    const i5 = r4 || n4 ? Gt(t4) : 0;
    r4 = r4 ? !!(32 & i5) : void 0;
    const s4 = Nt2(t4);
    for (let t5 = 0; t5 < s4.length; t5++)
      s4[t5] = Se2(s4[t5], e4, n4, r4, o4);
    return n4 && (oe2(s4, t4), n4(i5, s4)), s4;
  }
  function Te2(t4) {
    return t4.B === Jt ? t4.toJSON() : function(t5) {
      switch (typeof t5) {
        case "number":
          return isFinite(t5) ? t5 : String(t5);
        case "boolean":
          return t5 ? 1 : 0;
        case "object":
          if (t5)
            if (Array.isArray(t5)) {
              if (Zt2(t5, void 0, 0))
                return;
            } else {
              if (x(t5))
                return T(t5);
              if (t5 instanceof M) {
                const e4 = t5.g;
                return null == e4 ? "" : "string" == typeof e4 ? e4 : t5.g = T(e4);
              }
            }
      }
      return t5;
    }(t4);
  }
  function Ie(t4, e4, n4 = Rt2) {
    if (null != t4) {
      if (S && t4 instanceof Uint8Array)
        return e4 ? t4 : new Uint8Array(t4);
      if (Array.isArray(t4)) {
        var r4 = Gt(t4);
        return 2 & r4 ? t4 : (e4 &&= 0 === r4 || !!(32 & r4) && !(64 & r4 || !(16 & r4)), e4 ? zt(t4, -12293 & (34 | r4)) : Ee2(t4, Ie, 4 & r4 ? Rt2 : n4, true, true));
      }
      return t4.B === Jt && (n4 = t4.l, t4 = 2 & (r4 = $t(n4)) ? t4 : Oe2(t4, n4, r4, true)), t4;
    }
  }
  function Pe(t4) {
    const e4 = t4.l;
    return Oe2(t4, e4, $t(e4), false);
  }
  function Oe2(t4, e4, n4, r4) {
    return t4 = t4.constructor, ve = e4 = Le3(e4, n4, r4), e4 = new t4(e4), ve = void 0, e4;
  }
  function Le3(t4, e4, n4) {
    const r4 = n4 || 2 & e4 ? Rt2 : Wt2, o4 = !!(32 & e4);
    return t4 = function(t5, e5, n5) {
      const r5 = Nt2(t5);
      var o5 = r5.length;
      const i5 = 256 & e5 ? r5[o5 - 1] : void 0;
      for (o5 += i5 ? -1 : 0, e5 = 512 & e5 ? 1 : 0; e5 < o5; e5++)
        r5[e5] = n5(r5[e5]);
      if (i5) {
        e5 = r5[e5] = {};
        for (const t6 in i5)
          e5[t6] = n5(i5[t6]);
      }
      return oe2(r5, t5), r5;
    }(t4, e4, (t5) => Ie(t5, o4, r4)), Mt(t4, 32 | (n4 ? 2 : 0)), t4;
  }
  function xe3(t4) {
    const e4 = t4.l, n4 = $t(e4);
    return 2 & n4 ? Oe2(t4, e4, n4, false) : t4;
  }
  function Be2(t4, e4) {
    return Fe2(t4 = t4.l, $t(t4), e4);
  }
  function Fe2(t4, e4, n4, r4) {
    if (-1 === n4)
      return null;
    if (n4 >= Ht2(e4)) {
      if (256 & e4)
        return t4[t4.length - 1][n4];
    } else {
      var o4 = t4.length;
      if (r4 && 256 & e4 && null != (r4 = t4[o4 - 1][n4]))
        return r4;
      if ((e4 = n4 + (+!!(512 & e4) - 1)) < o4)
        return t4[e4];
    }
  }
  function Ue(t4, e4, n4, r4) {
    const o4 = t4.l;
    let i5 = $t(o4);
    return ee2(i5), je2(o4, i5, e4, n4, r4), t4;
  }
  function je2(t4, e4, n4, r4, o4) {
    const i5 = Ht2(e4);
    if (n4 >= i5 || o4) {
      let s4 = e4;
      if (256 & e4)
        o4 = t4[t4.length - 1];
      else {
        if (null == r4)
          return s4;
        o4 = t4[i5 + (+!!(512 & e4) - 1)] = {}, s4 |= 256;
      }
      return o4[n4] = r4, n4 < i5 && (t4[n4 + (+!!(512 & e4) - 1)] = void 0), s4 !== e4 && zt(t4, s4), s4;
    }
    return t4[n4 + (+!!(512 & e4) - 1)] = r4, 256 & e4 && (n4 in (t4 = t4[t4.length - 1]) && delete t4[n4]), e4;
  }
  function ke2(t4, e4, n4, r4, o4) {
    var i5 = 2 & e4;
    let s4 = Fe2(t4, e4, n4, o4);
    Array.isArray(s4) || (s4 = qt);
    const a4 = !(2 & r4);
    r4 = !(1 & r4);
    const u4 = !!(32 & e4);
    let c5 = Gt(s4);
    return 0 !== c5 || !u4 || i5 || a4 ? 1 & c5 || (c5 |= 1, zt(s4, c5)) : (c5 |= 33, zt(s4, c5)), i5 ? (t4 = false, 2 & c5 || (Mt(s4, 34), t4 = !!(4 & c5)), (r4 || t4) && Object.freeze(s4)) : (i5 = !!(2 & c5) || !!(2048 & c5), r4 && i5 ? (s4 = Nt2(s4), r4 = 1, u4 && !a4 && (r4 |= 32), zt(s4, r4), je2(t4, e4, n4, s4, o4)) : a4 && 32 & c5 && !i5 && Dt(s4, 32)), s4;
  }
  function Ve2(t4) {
    t4 = t4.l;
    let e4 = $t(t4);
    const n4 = Fe2(t4, e4, 1), r4 = Qt(n4, true, !!(34 & e4));
    return null != r4 && r4 !== n4 && je2(t4, e4, 1, r4), r4;
  }
  function Ne(t4, e4) {
    return t4 = Fe2(t4, e4, 1), Array.isArray(t4) ? t4 : qt;
  }
  function Me(t4, e4, n4) {
    return 0 === t4 && (t4 = Ze(t4, e4, n4)), Ct(t4, 1, true);
  }
  function De2(t4) {
    return !!(2 & t4) && !!(4 & t4) || !!(2048 & t4);
  }
  function Ce3(t4, e4, n4) {
    {
      const s4 = t4.l;
      let a4 = $t(s4);
      if (ee2(a4), null == n4)
        je2(s4, a4, e4);
      else {
        var r4, o4 = t4 = Gt(n4), i5 = !!(2 & t4) || Object.isFrozen(n4);
        if ((r4 = !i5) && (r4 = false), !(4 & t4))
          for (t4 = 21, i5 && (n4 = Nt2(n4), o4 = 0, t4 = Ze(t4, a4, true)), i5 = 0; i5 < n4.length; i5++)
            n4[i5] = ge2(n4[i5]);
        r4 && (n4 = Nt2(n4), o4 = 0, t4 = Ze(t4, a4, true)), t4 !== o4 && zt(n4, t4), je2(s4, a4, e4, n4);
      }
    }
  }
  function Ge2(t4, e4) {
    t4 = t4.l;
    let n4 = $t(t4);
    ee2(n4), je2(t4, n4, 2, "" === e4 ? void 0 : e4);
  }
  function $e(t4, e4, n4, r4) {
    const o4 = $t(t4);
    ee2(o4), t4 = ke2(t4, o4, e4, 2), r4 = n4(r4, !!(4 & (e4 = Gt(t4))) && !!(4096 & e4)), t4.push(r4);
  }
  function ze(t4) {
    return t4;
  }
  function We(t4, e4) {
    return Re2(t4 = t4.l, $t(t4), ao2) === e4 ? e4 : -1;
  }
  function Re2(t4, e4, n4) {
    let r4 = 0;
    for (let o4 = 0; o4 < n4.length; o4++) {
      const i5 = n4[o4];
      null != Fe2(t4, e4, i5) && (0 !== r4 && (e4 = je2(t4, e4, r4)), r4 = i5);
    }
    return r4;
  }
  function He(t4, e4, n4, r4) {
    let o4 = $t(t4);
    ee2(o4);
    const i5 = Fe2(t4, o4, n4, r4);
    let s4;
    if (null != i5 && i5.B === Jt)
      return (e4 = xe3(i5)) !== i5 && je2(t4, o4, n4, e4, r4), e4.l;
    if (Array.isArray(i5)) {
      const t5 = Gt(i5);
      s4 = 2 & t5 ? Le3(i5, t5, false) : i5, s4 = Ae(s4, e4[0], e4[1]);
    } else
      s4 = Ae(void 0, e4[0], e4[1]);
    return s4 !== i5 && je2(t4, o4, n4, s4, r4), s4;
  }
  function qe(t4, e4, n4, r4) {
    t4 = t4.l;
    let o4 = $t(t4);
    const i5 = Fe2(t4, o4, n4, r4);
    return (e4 = ye3(i5, e4, o4)) !== i5 && null != e4 && je2(t4, o4, n4, e4, r4), e4;
  }
  function Je2(t4, e4, n4) {
    if (null == (e4 = qe(t4, e4, n4, false)))
      return e4;
    t4 = t4.l;
    let r4 = $t(t4);
    if (!(2 & r4)) {
      const o4 = xe3(e4);
      o4 !== e4 && je2(t4, r4, n4, e4 = o4, false);
    }
    return e4;
  }
  function Ke2(t4, e4, n4, r4, o4) {
    var i5 = !!(2 & e4), s4 = i5 ? 1 : 2;
    const a4 = 1 === s4;
    s4 = 2 === s4, r4 = !!r4, o4 &&= !i5, i5 = Ne(t4, e4);
    var u4 = Gt(i5);
    const c5 = !!(4 & u4);
    if (!c5) {
      var l4, h4 = i5, f3 = e4;
      (l4 = !!(2 & (u4 = Me(u4, e4, r4)))) && (f3 = Ct(f3, 2, true));
      let t5 = !l4, o5 = true, s5 = 0, a5 = 0;
      for (; s5 < h4.length; s5++) {
        const e5 = ye3(h4[s5], n4, f3);
        if (e5 instanceof n4) {
          if (!l4) {
            const n5 = !!(2 & Gt(e5.l));
            t5 &&= !n5, o5 &&= n5;
          }
          h4[a5++] = e5;
        }
      }
      a5 < s5 && (h4.length = a5), u4 = Ct(u4, 4, true), u4 = Ct(u4, 16, o5), u4 = Ct(u4, 8, t5), zt(h4, u4), l4 && Object.freeze(h4);
    }
    if (n4 = !!(8 & u4) || a4 && !i5.length, o4 && !n4) {
      for (De2(u4) && (i5 = Nt2(i5), u4 = Ze(u4, e4, r4), e4 = je2(t4, e4, 1, i5)), o4 = i5, n4 = u4, h4 = 0; h4 < o4.length; h4++)
        (u4 = o4[h4]) !== (f3 = xe3(u4)) && (o4[h4] = f3);
      n4 = Ct(n4, 8, true), n4 = Ct(n4, 16, !o4.length), zt(o4, n4), u4 = n4;
    }
    return De2(u4) || (o4 = u4, a4 ? u4 = Ct(u4, !i5.length || 16 & u4 && (!c5 || 32 & u4) ? 2 : 2048, true) : r4 || (u4 = Ct(u4, 32, false)), u4 !== o4 && zt(i5, u4), a4 && Object.freeze(i5)), s4 && De2(u4) && (i5 = Nt2(i5), u4 = Ze(u4, e4, r4), zt(i5, u4), je2(t4, e4, 1, i5)), i5;
  }
  function Ye(t4, e4) {
    t4 = t4.l;
    const n4 = $t(t4);
    return Ke2(t4, n4, e4, false, !(2 & n4));
  }
  function Xe3(t4, e4, n4, r4, o4) {
    return null == r4 && (r4 = void 0), Ue(t4, n4, r4, o4);
  }
  function Qe(t4, e4, n4) {
    var r4 = Rr2;
    null == n4 && (n4 = void 0), t4 = t4.l;
    let o4 = $t(t4);
    ee2(o4), (r4 = Re2(t4, o4, r4)) && r4 !== e4 && null != n4 && (o4 = je2(t4, o4, r4)), je2(t4, o4, e4, n4);
  }
  function Ze(t4, e4, n4) {
    return t4 = Ct(t4, 2, !!(2 & e4)), t4 = Ct(t4, 32, !!(32 & e4) && n4), Ct(t4, 2048, false);
  }
  function tn2(t4, e4) {
    var n4 = Br2;
    t4 = t4.l;
    const r4 = $t(t4);
    ee2(r4), t4 = Ke2(t4, r4, n4, true), e4 = null != e4 ? e4 : new n4(), t4.push(e4), 2 & Gt(e4.l) ? Dt(t4, 8) : Dt(t4, 16);
  }
  function en(t4) {
    return null == (t4 = Be2(t4, 2)) ? t4 : ce3(t4) ? "number" == typeof t4 ? fe2(t4) : de(t4) : void 0;
  }
  function nn2(t4) {
    return t4 ?? 0;
  }
  function rn2(t4, e4, n4) {
    $e(t4.l, e4, ge2, n4);
  }
  function on(t4, e4, n4) {
    e4.g ? e4.j(t4, e4.g, e4.i, n4, true) : e4.j(t4, e4.i, n4, true);
  }
  function an(t4, e4, n4) {
    var r4 = f ? void 0 : t4.constructor.u;
    const o4 = $t(n4 ? t4.l : e4);
    if (!(t4 = e4.length))
      return e4;
    let i5, s4;
    if (Xt2(n4 = e4[t4 - 1])) {
      t: {
        var a4 = n4;
        let t5 = {}, e5 = false;
        for (var u4 in a4) {
          let n5 = a4[u4];
          if (Array.isArray(n5)) {
            let t6 = n5;
            (Zt2(n5, r4, +u4) || Yt2(n5) && 0 === n5.size) && (n5 = null), n5 != t6 && (e5 = true);
          }
          null != n5 ? t5[u4] = n5 : e5 = true;
        }
        if (e5) {
          for (var c5 in t5) {
            a4 = t5;
            break t;
          }
          a4 = null;
        }
      }
      a4 != n4 && (i5 = true), t4--;
    }
    for (u4 = +!!(512 & o4) - 1; 0 < t4 && (n4 = e4[c5 = t4 - 1], c5 -= u4, null == n4 || Zt2(n4, r4, c5) || Yt2(n4) && 0 === n4.size); t4--)
      s4 = true;
    return i5 || s4 ? (e4 = Array.prototype.slice.call(e4, 0, t4), a4 && e4.push(a4), e4) : e4;
  }
  function un2(t4) {
    return Array.isArray(t4) ? t4[0] instanceof Vt2 ? t4 : [ir, t4] : [t4, void 0];
  }
  function cn2(t4, e4) {
    if (Array.isArray(e4)) {
      var n4 = Gt(e4);
      if (4 & n4)
        return e4;
      for (var r4 = 0, o4 = 0; r4 < e4.length; r4++) {
        const n5 = t4(e4[r4]);
        null != n5 && (e4[o4++] = n5);
      }
      return o4 < r4 && (e4.length = o4), zt(e4, -12289 & (5 | n4)), 2 & n4 && Object.freeze(e4), e4;
    }
  }
  function hn2(t4) {
    let e4 = t4[ln2];
    if (!e4) {
      const n4 = bn2(t4), r4 = Bn2(t4), o4 = r4.j;
      e4 = o4 ? (t5, e5) => o4(t5, e5, r4) : (t5, e5) => {
        for (; dt2(e5) && 4 != e5.i; ) {
          var o5 = e5.m, i5 = r4[o5];
          if (!i5) {
            var s4 = r4.D;
            s4 && (s4 = s4[o5]) && (i5 = r4[o5] = fn2(s4));
          }
          i5 && i5(e5, t5, o5) || (o5 = (i5 = e5).j, gt(i5), i5.I ? i5 = void 0 : (s4 = i5.g.g - o5, i5.g.g = o5, i5 = ht2(i5.g, s4)), o5 = t5, i5 && (ne ||= Symbol(), (s4 = o5[ne]) ? s4.push(i5) : o5[ne] = [i5]));
        }
        n4 === gn2 || n4 === pn2 || n4.s || (t5[re2 ||= Symbol()] = n4);
      }, t4[ln2] = e4;
    }
    return e4;
  }
  function fn2(t4) {
    const e4 = (t4 = un2(t4))[0].g;
    if (t4 = t4[1]) {
      const n4 = hn2(t4), r4 = Bn2(t4).A;
      return (t5, o4, i5) => e4(t5, o4, i5, r4, n4);
    }
    return e4;
  }
  function yn2(t4, e4, n4) {
    const r4 = n4[1];
    let o4;
    if (r4) {
      const n5 = r4[mn2];
      o4 = n5 ? n5.A : _e3(r4[0]), t4[e4] = n5 ?? r4;
    }
    o4 && o4 === be2 ? (t4.g || (t4.g = /* @__PURE__ */ new Set())).add(e4) : n4[0] && (t4.i || (t4.i = /* @__PURE__ */ new Set())).add(e4);
  }
  function vn(t4, e4) {
    return [t4.j, !e4 || 0 < e4[0] ? void 0 : e4];
  }
  function bn2(t4) {
    var e4 = t4[mn2];
    if (e4)
      return e4;
    if (!(e4 = _n(t4, t4[mn2] = new dn2(), vn, vn, yn2)).D && !e4.i && !e4.g) {
      let n4 = true;
      for (let t5 in e4)
        isNaN(t5) || (n4 = false);
      n4 ? (_e3(t4[0]) === be2 ? pn2 ? e4 = pn2 : ((e4 = new dn2()).A = _e3(true), e4 = pn2 = e4) : e4 = gn2 ||= new dn2(), e4 = t4[mn2] = e4) : e4.s = true;
    }
    return e4;
  }
  function wn(t4, e4, n4) {
    t4[e4] = n4;
  }
  function _n(t4, e4, n4, r4, o4 = wn) {
    e4.A = _e3(t4[0]);
    let i5 = 0;
    var s4 = t4[++i5];
    s4 && s4.constructor === Object && (e4.D = s4, "function" == typeof (s4 = t4[++i5]) && (e4.j = s4, e4.m = t4[++i5], s4 = t4[++i5]));
    const a4 = {};
    for (; Array.isArray(s4) && "number" == typeof s4[0] && 0 < s4[0]; ) {
      for (var u4 = 0; u4 < s4.length; u4++)
        a4[s4[u4]] = s4;
      s4 = t4[++i5];
    }
    for (u4 = 1; void 0 !== s4; ) {
      let h4;
      "number" == typeof s4 && (u4 += s4, s4 = t4[++i5]);
      var c5 = void 0;
      if (s4 instanceof Vt2 ? h4 = s4 : (h4 = sr2, i5--), h4.J) {
        s4 = t4[++i5], c5 = t4;
        var l4 = i5;
        "function" == typeof s4 && (s4 = s4(), c5[l4] = s4), c5 = s4;
      }
      for (l4 = u4 + 1, "number" == typeof (s4 = t4[++i5]) && 0 > s4 && (l4 -= s4, s4 = t4[++i5]); u4 < l4; u4++) {
        const t5 = a4[u4];
        o4(e4, u4, c5 ? r4(h4, c5, t5) : n4(h4, t5));
      }
    }
    return e4;
  }
  function Sn(t4) {
    let e4 = t4[An];
    if (!e4) {
      const n4 = Pn(t4);
      e4 = (t5, e5) => jn(t5, e5, n4), t4[An] = e4;
    }
    return e4;
  }
  function Tn2(t4) {
    return t4.i;
  }
  function In(t4, e4) {
    let n4, r4;
    const o4 = t4.i;
    return (t5, i5, s4) => o4(t5, i5, s4, r4 ||= Pn(e4).A, n4 ||= Sn(e4));
  }
  function Pn(t4) {
    let e4 = t4[En];
    return e4 || (e4 = _n(t4, t4[En] = {}, Tn2, In), Fn2(t4), e4);
  }
  function Ln2(t4, e4) {
    const n4 = t4.g;
    return e4 ? (t5, r4, o4) => n4(t5, r4, o4, e4) : n4;
  }
  function xn2(t4, e4, n4) {
    const r4 = t4.g;
    let o4, i5;
    return (t5, s4, a4) => r4(t5, s4, a4, i5 ||= Bn2(e4).A, o4 ||= hn2(e4), n4);
  }
  function Bn2(t4) {
    let e4 = t4[On];
    return e4 || (bn2(t4), e4 = _n(t4, t4[On] = {}, Ln2, xn2), Fn2(t4), e4);
  }
  function Fn2(t4) {
    On in t4 && mn2 in t4 && En in t4 && (t4.length = 0);
  }
  function Un2(t4, e4) {
    var n4 = t4[e4];
    if (n4)
      return n4;
    if ((n4 = t4.D) && (n4 = n4[e4])) {
      var r4 = (n4 = un2(n4))[0].i;
      if (n4 = n4[1]) {
        const e5 = Sn(n4), o4 = Pn(n4).A;
        n4 = (n4 = t4.m) ? n4(o4, e5) : (t5, n5, i5) => r4(t5, n5, i5, o4, e5);
      } else
        n4 = r4;
      return t4[e4] = n4;
    }
  }
  function jn(t4, e4, n4) {
    for (var r4 = $t(t4), o4 = +!!(512 & r4) - 1, i5 = t4.length, s4 = 512 & r4 ? 1 : 0, a4 = i5 + (256 & r4 ? -1 : 0); s4 < a4; s4++) {
      const r5 = t4[s4];
      if (null == r5)
        continue;
      const i6 = s4 - o4, a5 = Un2(n4, i6);
      a5 && a5(e4, r5, i6);
    }
    if (256 & r4) {
      r4 = t4[i5 - 1];
      for (let t5 in r4)
        o4 = +t5, Number.isNaN(o4) || null != (i5 = r4[t5]) && (a4 = Un2(n4, o4)) && a4(e4, i5, o4);
    }
    if (t4 = ne ? t4[ne] : void 0)
      for (xt2(e4, e4.g.end()), n4 = 0; n4 < t4.length; n4++)
        xt2(e4, N2(t4[n4]) || F2());
  }
  function kn2(t4, e4) {
    return new Vt2(t4, e4, false, false);
  }
  function Vn2(t4, e4) {
    return new Vt2(t4, e4, true, false);
  }
  function Nn2(t4, e4, n4) {
    je2(t4, $t(t4), e4, n4);
  }
  function Mn2(t4, e4, n4) {
    t:
      if (null != e4) {
        if (ce3(e4)) {
          if ("string" == typeof e4) {
            e4 = de(e4);
            break t;
          }
          if ("number" == typeof e4) {
            e4 = fe2(e4);
            break t;
          }
        }
        e4 = void 0;
      }
    null != e4 && ("string" == typeof e4 && St(e4), null != e4 && (Bt2(t4, n4, 0), "number" == typeof e4 ? (t4 = t4.g, J(e4), It(t4, H2, q2)) : (n4 = St(e4), It(t4.g, n4.i, n4.g))));
  }
  function Dn2(t4, e4, n4) {
    null != (e4 = le2(e4)) && null != e4 && (Bt2(t4, n4, 0), Ot2(t4.g, e4));
  }
  function Cn2(t4, e4, n4) {
    null != (e4 = null == e4 || "boolean" == typeof e4 ? e4 : "number" == typeof e4 ? !!e4 : void 0) && (Bt2(t4, n4, 0), t4.g.g.push(e4 ? 1 : 0));
  }
  function Gn2(t4, e4, n4) {
    null != (e4 = me2(e4)) && jt2(t4, n4, c2(e4));
  }
  function $n2(t4, e4, n4, r4, o4) {
    null != (e4 = e4 instanceof sn ? e4.l : Array.isArray(e4) ? Ae(e4, r4[0], r4[1]) : void 0) && (n4 = Ft(t4, n4), o4(e4, t4), Ut(t4, n4));
  }
  function zn2(t4, e4, n4) {
    null != (e4 = null == e4 || "string" == typeof e4 || x(e4) || e4 instanceof M ? e4 : void 0) && jt2(t4, n4, $3(e4).buffer);
  }
  function fr2(t4, e4) {
    return (n4, r4) => {
      t: {
        if (bt.length) {
          const t5 = bt.pop();
          t5.o(r4), ut2(t5.g, n4, r4), n4 = t5;
        } else
          n4 = new class {
            constructor(t5, e5) {
              if (ft2.length) {
                const n5 = ft2.pop();
                ut2(n5, t5, e5), t5 = n5;
              } else
                t5 = new class {
                  constructor(t6, e6) {
                    this.i = null, this.m = false, this.g = this.j = this.s = 0, ut2(this, t6, e6);
                  }
                  clear() {
                    this.i = null, this.m = false, this.g = this.j = this.s = 0, this.C = false;
                  }
                }(t5, e5);
              this.g = t5, this.j = this.g.g, this.i = this.m = -1, this.o(e5);
            }
            o({ I: t5 = false } = {}) {
              this.I = t5;
            }
          }(n4, r4);
        try {
          const r5 = new t4(), i5 = r5.l;
          hn2(e4)(i5, n4);
          var o4 = r5;
          break t;
        } finally {
          n4.g.clear(), n4.m = -1, n4.i = -1, 100 > bt.length && bt.push(n4);
        }
        o4 = void 0;
      }
      return o4;
    };
  }
  async function ho2(t4) {
    if ("function" != typeof importScripts) {
      const e4 = document.createElement("script");
      return e4.src = t4.toString(), e4.crossOrigin = "anonymous", new Promise((t5, n4) => {
        e4.addEventListener("load", () => {
          t5();
        }, false), e4.addEventListener("error", (t6) => {
          n4(t6);
        }, false), document.body.appendChild(e4);
      });
    }
    importScripts(t4.toString());
  }
  function fo2(t4, e4, n4) {
    t4.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n4(e4 = t4.h.stringToNewUTF8(e4)), t4.h._free(e4);
  }
  function go2(t4, e4, n4) {
    t4.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
    const r4 = new Uint32Array(e4.length);
    for (let n5 = 0; n5 < e4.length; n5++)
      r4[n5] = t4.h.stringToNewUTF8(e4[n5]);
    e4 = t4.h._malloc(4 * r4.length), t4.h.HEAPU32.set(r4, e4 >> 2), n4(e4);
    for (const e5 of r4)
      t4.h._free(e5);
    t4.h._free(e4);
  }
  function po2(t4, e4, n4) {
    t4.h.simpleListeners = t4.h.simpleListeners || {}, t4.h.simpleListeners[e4] = n4;
  }
  function mo2(t4, e4, n4) {
    let r4 = [];
    t4.h.simpleListeners = t4.h.simpleListeners || {}, t4.h.simpleListeners[e4] = (t5, e5, o4) => {
      e5 ? (n4(r4, o4), r4 = []) : r4.push(t5);
    };
  }
  async function bo2(t4, e4, n4) {
    return t4 = await (async (t5, e5, n5, r4) => {
      if (e5 && await ho2(e5), !self.ModuleFactory)
        throw Error("ModuleFactory not set.");
      if (n5 && (await ho2(n5), !self.ModuleFactory))
        throw Error("ModuleFactory not set.");
      return self.Module && r4 && ((e5 = self.Module).locateFile = r4.locateFile, r4.mainScriptUrlOrBlob && (e5.mainScriptUrlOrBlob = r4.mainScriptUrlOrBlob)), r4 = await self.ModuleFactory(self.Module || r4), self.ModuleFactory = self.Module = void 0, new t5(r4, null);
    })(t4, e4.wasmLoaderPath, e4.assetLoaderPath, { locateFile: (t5) => t5.endsWith(".wasm") ? e4.wasmBinaryPath.toString() : e4.assetBinaryPath && t5.endsWith(".data") ? e4.assetBinaryPath.toString() : t5 }), await t4.o(n4), t4;
  }
  async function wo2(t4, e4, n4) {
    return bo2(t4, e4, n4);
  }
  function _o2(t4, e4) {
    const n4 = Je2(t4.baseOptions, Hr2, 1) || new Hr2();
    "string" == typeof e4 ? (Ue(n4, 2, pe(e4)), Ue(n4, 1)) : e4 instanceof Uint8Array && (Ue(n4, 1, Qt(e4, false, false)), Ue(n4, 2)), Xe3(t4.baseOptions, 0, 1, n4);
  }
  function Ao2(t4, e4) {
    const n4 = e4.baseOptions || {};
    if (e4.baseOptions?.modelAssetBuffer && e4.baseOptions?.modelAssetPath)
      throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
    if (!(Je2(t4.baseOptions, Hr2, 1)?.g() || Je2(t4.baseOptions, Hr2, 1)?.i() || e4.baseOptions?.modelAssetBuffer || e4.baseOptions?.modelAssetPath))
      throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
    return function(t5, e5) {
      let n5 = Je2(t5.baseOptions, Wr2, 3);
      if (!n5) {
        var r4 = n5 = new Wr2();
        Qe(r4, 4, new wr2());
      }
      "delegate" in e5 && ("GPU" === e5.delegate ? Qe(e5 = n5, 2, r4 = new yr2()) : Qe(e5 = n5, 4, r4 = new wr2())), Xe3(t5.baseOptions, 0, 3, n5);
    }(t4, n4), n4.modelAssetPath ? fetch(n4.modelAssetPath.toString()).then((t5) => {
      if (t5.ok)
        return t5.arrayBuffer();
      throw Error(`Failed to fetch model: ${n4.modelAssetPath} (${t5.status})`);
    }).then((e5) => {
      try {
        t4.g.h.FS_unlink("/model.dat");
      } catch {
      }
      t4.g.h.FS_createDataFile("/", "model.dat", new Uint8Array(e5), true, false, false), _o2(t4, "/model.dat"), t4.H();
    }) : (_o2(t4, n4.modelAssetBuffer), t4.H(), Promise.resolve());
  }
  function So2(t4) {
    try {
      const e4 = t4.j.length;
      if (1 === e4)
        throw Error(t4.j[0].message);
      if (1 < e4)
        throw Error("Encountered multiple errors: " + t4.j.map((t5) => t5.message).join(", "));
    } finally {
      t4.j = [];
    }
  }
  function Eo2(t4, e4) {
    t4.s = Math.max(t4.s, e4);
  }
  async function Io2(t4, e4, n4) {
    return wo2(t4, e4, n4);
  }
  function Oo2(t4) {
    const e4 = { classifications: Ye(t4, to2).map((t5) => function(t6, e5 = -1, n4 = "") {
      return { categories: t6.map((t7) => {
        var e6 = nn2(le2(Be2(t7, 1))) ?? -1;
        const n5 = t7.l;
        let r4 = $t(n5);
        const o4 = Fe2(n5, r4, 2), i5 = se(o4);
        return null != i5 && i5 !== o4 && je2(n5, r4, 2, i5), { index: e6, score: i5 ?? 0 ?? 0, categoryName: me2(Be2(t7, 3)) ?? "" ?? "", displayName: me2(Be2(t7, 4)) ?? "" ?? "" };
      }), headIndex: e5, headName: n4 };
    }(Je2(t5, Gr2, 4)?.g() ?? [], nn2(le2(Be2(t5, 2))), me2(Be2(t5, 3)) ?? "")) };
    return null != en(t4) && (e4.timestampMs = nn2(en(t4))), e4;
  }
  function xo2(t4) {
    return { embeddings: Ye(t4, so2).map((t5) => {
      const e4 = { headIndex: nn2(le2(Be2(t5, 3))) ?? -1, headName: me2(Be2(t5, 4)) ?? "" ?? "" };
      if (void 0 !== qe(t5, oo2, We(t5, 1))) {
        var n4 = void 0;
        t5 = Je2(t5, oo2, We(t5, 1)).l;
        let s4 = $t(t5);
        const a4 = 2 & s4 ? 1 : 2;
        n4 = !!n4;
        let u4 = Ne(t5, s4);
        var r4 = Gt(u4);
        if (!(4 & r4)) {
          (4 & r4 || Object.isFrozen(u4)) && (u4 = Nt2(u4), r4 = Ze(r4, s4, n4), s4 = je2(t5, s4, 1, u4));
          for (var o4 = 0, i5 = 0; o4 < u4.length; o4++) {
            const t6 = se(u4[o4]);
            null != t6 && (u4[i5++] = t6);
          }
          i5 < o4 && (u4.length = i5), r4 = Ct(r4 = Me(r4, s4, n4), 20, true), r4 = Ct(r4, 4096, false), r4 = Ct(r4, 8192, false), zt(u4, r4), 2 & r4 && Object.freeze(u4);
        }
        De2(r4) || (o4 = r4, (i5 = 1 === a4) ? r4 = Ct(r4, 2, true) : n4 || (r4 = Ct(r4, 32, false)), r4 !== o4 && zt(u4, r4), i5 && Object.freeze(u4)), 2 === a4 && De2(r4) && (u4 = Nt2(u4), r4 = Ze(r4, s4, n4), zt(u4, r4), je2(t5, s4, 1, u4)), e4.floatEmbedding = u4.slice();
      } else
        n4 = new Uint8Array(0), e4.quantizedEmbedding = Je2(t5, io2, We(t5, 2))?.K()?.i() ?? n4;
      return e4;
    }), timestampMs: nn2(en(t4)) };
  }
  async function jo2() {
    if (void 0 === Fo2)
      try {
        await WebAssembly.instantiate(Uo), Fo2 = true;
      } catch {
        Fo2 = false;
      }
    return Fo2;
  }
  async function ko2(t4, e4 = "") {
    const n4 = await jo2() ? "wasm_internal" : "wasm_nosimd_internal";
    return { wasmLoaderPath: `${e4}/${t4}_${n4}.js`, wasmBinaryPath: `${e4}/${t4}_${n4}.wasm` };
  }
  var t2, o2, i2, s2, a2, u2, l2, h2, f, d2, v, b, w, S, E2, I, P, B2, U3, j2, M, W2, R3, H2, q2, ft2, bt, _t, At, Et, Tt2, kt2, Vt2, Mt, Dt, Gt, $t, zt, qt, Jt, Kt2, te, ne, re2, ue2, ve, be2, we2, sn, ln2, dn2, gn2, pn2, mn2, An, En, On, Wn2, Rn2, Hn, qn, Jn2, Kn2, Yn, Xn2, Qn2, Zn2, tr2, er2, nr, rr, or, ir, sr2, ar, ur2, cr2, lr2, hr2, dr, gr2, pr, mr2, yr2, vr2, br2, wr2, _r2, Ar, Sr, Er, Tr2, Ir, Pr, Or, Lr2, xr2, Br2, Fr2, Ur2, jr, kr2, Vr2, Nr2, Mr2, Dr2, Cr, Gr2, $r2, zr2, Wr2, Rr2, Hr2, qr2, Jr, Kr, Yr, Xr, Qr, Zr, to2, eo2, no2, ro2, oo2, io2, so2, ao2, uo2, co2, lo2, yo2, vo2, To2, Po2, Lo2, Bo, Fo2, Uo, Vo;
  var init_audio_bundle = __esm({
    "node_modules/@mediapipe/tasks-audio/audio_bundle.mjs"() {
      t2 = "undefined" != typeof self ? self : {};
      s2 = "undefined" != typeof TextDecoder;
      u2 = "undefined" != typeof TextEncoder;
      h2 = e2(610401301);
      f = e2(188588736);
      d2 = t2.navigator;
      l2 = d2 && d2.userAgentData || null;
      v = !m() && (p2("Trident") || p2("MSIE"));
      !p2("Android") || y(), y(), p2("Safari") && (y() || !m() && p2("Coast") || !m() && p2("Opera") || !m() && p2("Edge") || (m() ? g2("Microsoft Edge") : p2("Edg/")) || m() && g2("Opera"));
      b = {};
      w = null;
      S = "undefined" != typeof Uint8Array;
      E2 = !v && "function" == typeof btoa;
      I = /[-_.]/g;
      P = { "-": "+", _: "/", ".": "=" };
      U3 = {};
      M = class {
        constructor(t4, e4) {
          if (k(e4), this.g = t4, null != t4 && 0 === t4.length)
            throw Error("ByteString should be constructed with non-empty values");
        }
        i() {
          const t4 = N2(this);
          return t4 ? new Uint8Array(t4) : F2();
        }
      };
      W2 = "function" == typeof Uint8Array.prototype.slice;
      H2 = 0;
      q2 = 0;
      ft2 = [];
      bt = [];
      _t = class {
        constructor(t4, e4) {
          this.i = t4 >>> 0, this.g = e4 >>> 0;
        }
      };
      Et = class {
        constructor(t4, e4) {
          this.i = t4 >>> 0, this.g = e4 >>> 0;
        }
      };
      Vt2 = class {
        constructor(t4, e4, n4, r4) {
          this.g = t4, this.i = e4, this.j = n4, this.J = r4;
        }
      };
      Mt = (kt2 = "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol() : void 0) ? (t4, e4) => {
        t4[kt2] |= e4;
      } : (t4, e4) => {
        void 0 !== t4.g ? t4.g |= e4 : Object.defineProperties(t4, { g: { value: e4, configurable: true, writable: true, enumerable: false } });
      };
      Dt = kt2 ? (t4, e4) => {
        t4[kt2] &= ~e4;
      } : (t4, e4) => {
        void 0 !== t4.g && (t4.g &= ~e4);
      };
      Gt = kt2 ? (t4) => 0 | t4[kt2] : (t4) => 0 | t4.g;
      $t = kt2 ? (t4) => t4[kt2] : (t4) => t4.g;
      zt = kt2 ? (t4, e4) => (t4[kt2] = e4, t4) : (t4, e4) => (void 0 !== t4.g ? t4.g = e4 : Object.defineProperties(t4, { g: { value: e4, configurable: true, writable: true, enumerable: false } }), t4);
      Jt = {};
      Kt2 = {};
      te = [];
      zt(te, 55), qt = Object.freeze(te);
      Object.freeze(new class {
      }()), Object.freeze(new class {
      }());
      ue2 = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
      sn = class {
        constructor(t4, e4) {
          this.l = Ae(t4, e4);
        }
        toJSON() {
          return an(this, Ee2(this.l, Te2, void 0, void 0, false), true);
        }
        v() {
          return !!(2 & Gt(this.l));
        }
      };
      sn.prototype.B = Jt, sn.prototype.toString = function() {
        return an(this, this.l, false).toString();
      };
      ln2 = Symbol();
      dn2 = class {
      };
      mn2 = Symbol();
      An = Symbol();
      En = Symbol();
      On = Symbol();
      Rn2 = kn2(function(t4, e4, n4) {
        if (1 !== t4.i)
          return false;
        var r4 = t4.g;
        t4 = it2(r4);
        const o4 = it2(r4);
        r4 = 2 * (o4 >> 31) + 1;
        const i5 = o4 >>> 20 & 2047;
        return t4 = 4294967296 * (1048575 & o4) + t4, Nn2(e4, n4, 2047 == i5 ? t4 ? NaN : 1 / 0 * r4 : 0 == i5 ? r4 * Math.pow(2, -1074) * t4 : r4 * Math.pow(2, i5 - 1075) * (t4 + 4503599627370496)), true;
      }, function(t4, e4, n4) {
        null != (e4 = se(e4)) && (Bt2(t4, n4, 1), t4 = t4.g, (n4 = R3 ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +e4, true), H2 = n4.getUint32(0, true), q2 = n4.getUint32(4, true), Lt(t4, H2), Lt(t4, q2));
      });
      Hn = kn2(function(t4, e4, n4) {
        return 5 === t4.i && (Nn2(e4, n4, st2(t4.g)), true);
      }, function(t4, e4, n4) {
        null != (e4 = se(e4)) && (Bt2(t4, n4, 5), t4 = t4.g, K3(e4), Lt(t4, H2));
      });
      qn = Vn2(function(t4, e4, n4) {
        return (5 === t4.i || 2 === t4.i) && (e4 = ke2(e4, $t(e4), n4, 2, false), 2 == t4.i ? vt(t4, st2, e4) : e4.push(st2(t4.g)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = cn2(se, e4)) && e4.length) {
          Bt2(t4, n4, 2), Pt(t4.g, 4 * e4.length);
          for (let r4 = 0; r4 < e4.length; r4++)
            n4 = t4.g, K3(e4[r4]), Lt(n4, H2);
        }
      });
      Jn2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, nt2(t4.g, X)), true);
      }, Mn2);
      Kn2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, 0 === (t4 = nt2(t4.g, X)) ? void 0 : t4), true);
      }, Mn2);
      Yn = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, nt2(t4.g, Y)), true);
      }, function(t4, e4, n4) {
        t:
          if (null != e4) {
            if (ce3(e4)) {
              if ("string" == typeof e4) {
                var r4 = Math.trunc(Number(e4));
                Number.isSafeInteger(r4) && 0 <= r4 ? e4 = String(r4) : (-1 !== (r4 = e4.indexOf(".")) && (e4 = e4.substring(0, r4)), he(e4) || (tt2(e4), e4 = Q(H2, q2)));
                break t;
              }
              if ("number" == typeof e4) {
                e4 = 0 <= (e4 = Math.trunc(e4)) && Number.isSafeInteger(e4) ? e4 : function(t5) {
                  if (0 > t5) {
                    J(t5);
                    const e5 = Q(H2, q2);
                    return t5 = Number(e5), Number.isSafeInteger(t5) ? t5 : e5;
                  }
                  return he(String(t5)) ? t5 : (J(t5), Y(H2, q2));
                }(e4);
                break t;
              }
            }
            e4 = void 0;
          }
        null != e4 && ("string" == typeof e4 && wt2(e4), null != e4 && (Bt2(t4, n4, 0), "number" == typeof e4 ? (t4 = t4.g, J(e4), It(t4, H2, q2)) : (n4 = wt2(e4), It(t4.g, n4.i, n4.g))));
      });
      Xn2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, ot(t4.g)), true);
      }, Dn2);
      Qn2 = Vn2(function(t4, e4, n4) {
        return (0 === t4.i || 2 === t4.i) && (e4 = ke2(e4, $t(e4), n4, 2, false), 2 == t4.i ? vt(t4, ot, e4) : e4.push(ot(t4.g)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = cn2(le2, e4)) && e4.length) {
          n4 = Ft(t4, n4);
          for (let n5 = 0; n5 < e4.length; n5++)
            Ot2(t4.g, e4[n5]);
          Ut(t4, n4);
        }
      });
      Zn2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, 0 === (t4 = ot(t4.g)) ? void 0 : t4), true);
      }, Dn2);
      tr2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, rt(t4.g)), true);
      }, Cn2);
      er2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, false === (t4 = rt(t4.g)) ? void 0 : t4), true);
      }, Cn2);
      nr = Vn2(function(t4, e4, n4) {
        return 2 === t4.i && ($e(e4, n4, ze, t4 = mt(t4)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = cn2(me2, e4)))
          for (let s4 = 0; s4 < e4.length; s4++) {
            var r4 = t4, o4 = n4, i5 = e4[s4];
            null != i5 && jt2(r4, o4, c2(i5));
          }
      });
      rr = kn2(function(t4, e4, n4) {
        return 2 === t4.i && (Nn2(e4, n4, "" === (t4 = mt(t4)) ? void 0 : t4), true);
      }, Gn2);
      or = kn2(function(t4, e4, n4) {
        return 2 === t4.i && (Nn2(e4, n4, mt(t4)), true);
      }, Gn2);
      ir = new Vt2(function(t4, e4, n4, r4, o4) {
        return 2 === t4.i && (pt2(t4, He(e4, r4, n4, true), o4), true);
      }, $n2, false, true);
      sr2 = new Vt2(function(t4, e4, n4, r4, o4) {
        return 2 === t4.i && (pt2(t4, He(e4, r4, n4), o4), true);
      }, $n2, false, true);
      Wn2 = new Vt2(function(t4, e4, n4, r4, o4) {
        if (2 !== t4.i)
          return false;
        r4 = Ae(void 0, r4[0], r4[1]);
        let i5 = $t(e4);
        ee2(i5);
        let s4 = ke2(e4, i5, n4, 3);
        return i5 = $t(e4), 4 & Gt(s4) && (s4 = Nt2(s4), zt(s4, -2079 & (1 | Gt(s4))), je2(e4, i5, n4, s4)), s4.push(r4), pt2(t4, r4, o4), true;
      }, function(t4, e4, n4, r4, o4) {
        if (Array.isArray(e4))
          for (let i5 = 0; i5 < e4.length; i5++)
            $n2(t4, e4[i5], n4, r4, o4);
      }, true, true);
      ar = new Vt2(function(t4, e4, n4, r4, o4, i5) {
        if (2 !== t4.i)
          return false;
        let s4 = $t(e4);
        return ee2(s4), (i5 = Re2(e4, s4, i5)) && n4 !== i5 && je2(e4, s4, i5), pt2(t4, e4 = He(e4, r4, n4), o4), true;
      }, $n2, false, true);
      ur2 = kn2(function(t4, e4, n4) {
        return 2 === t4.i && (Nn2(e4, n4, yt(t4)), true);
      }, zn2);
      cr2 = kn2(function(t4, e4, n4) {
        return 0 === t4.i && (Nn2(e4, n4, ot(t4.g)), true);
      }, function(t4, e4, n4) {
        null != (e4 = le2(e4)) && (e4 = parseInt(e4, 10), Bt2(t4, n4, 0), Ot2(t4.g, e4));
      });
      lr2 = Vn2(function(t4, e4, n4) {
        return (0 === t4.i || 2 === t4.i) && (e4 = ke2(e4, $t(e4), n4, 2, false), 2 == t4.i ? vt(t4, at2, e4) : e4.push(ot(t4.g)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = cn2(le2, e4)) && e4.length) {
          n4 = Ft(t4, n4);
          for (let n5 = 0; n5 < e4.length; n5++)
            Ot2(t4.g, e4[n5]);
          Ut(t4, n4);
        }
      });
      hr2 = class {
        constructor(t4, e4) {
          this.i = t4, this.g = e4, this.j = Xe3, this.defaultValue = void 0;
        }
      };
      dr = [0, rr, kn2(function(t4, e4, n4) {
        return 2 === t4.i && (Nn2(e4, n4, (t4 = yt(t4)) === V2() ? void 0 : t4), true);
      }, function(t4, e4, n4) {
        if (null != e4) {
          if (e4 instanceof sn) {
            const r4 = e4.P;
            return void (r4 && (e4 = r4(e4), null != e4 && jt2(t4, n4, $3(e4).buffer)));
          }
          if (Array.isArray(e4))
            return;
        }
        zn2(t4, e4, n4);
      })];
      gr2 = [0, or];
      pr = [0, Xn2, cr2, tr2, -1, Qn2, cr2, -1];
      mr2 = [0, tr2, -1];
      yr2 = class extends sn {
        constructor() {
          super();
        }
      };
      yr2.u = [6];
      vr2 = [0, tr2, or, tr2, cr2, -1, lr2, or, -1, mr2, cr2];
      br2 = [0, or, -2];
      wr2 = class extends sn {
        constructor() {
          super();
        }
      };
      _r2 = [0];
      Ar = [0, Xn2, tr2, -3];
      Sr = class extends sn {
        constructor(t4) {
          super(t4, 2);
        }
      };
      Er = {};
      Tr2 = [-2, Er, tr2];
      Er[336783863] = [0, or, tr2, -1, Xn2, [0, [1, 2, 3, 4, 5], ar, _r2, ar, vr2, ar, br2, ar, Ar, ar, pr], gr2];
      Ir = [0, rr, er2];
      Pr = [0, Kn2, -1, er2, -3, Kn2, Qn2, rr, Zn2, Kn2, -1, er2, Zn2, er2, -2, rr];
      Or = [-1, {}];
      Lr2 = [0, or, 1, Or];
      xr2 = [0, or, nr, Or];
      Br2 = class extends sn {
        constructor(t4) {
          super(t4, 500);
        }
        o(t4) {
          return Xe3(this, 0, 7, t4);
        }
      };
      Br2.u = [3, 4, 5, 6, 8, 13, 17, 1005];
      Ur2 = [-500, rr, -1, nr, -3, Tr2, Wn2, dr, Zn2, -1, Lr2, xr2, Wn2, Ir, rr, Pr, Zn2, nr, 987, nr];
      jr = [0, rr, -1, Or];
      kr2 = [-500, or, -1, [-1, {}], 998, or];
      Vr2 = [-500, or, nr, -1, [-2, {}, tr2], 997, nr, -1];
      Nr2 = [-500, or, nr, Or, 998, nr];
      Mr2 = class extends sn {
        constructor() {
          super(void 0, 500);
        }
        o(t4) {
          return Xe3(this, 0, 1001, t4);
        }
      };
      Mr2.u = [1, 6, 7, 9, 10, 15, 16, 17, 14, 1002], Mr2.prototype.g = (Fr2 = [-500, Wn2, Ur2, 4, Wn2, kr2, Wn2, Vr2, Zn2, Wn2, Nr2, nr, Zn2, Lr2, xr2, Wn2, jr, nr, -2, Pr, rr, -1, er2, 979, Or, Wn2, dr], function() {
        const t4 = new class {
          constructor() {
            this.j = [], this.i = 0, this.g = new class {
              constructor() {
                this.g = [];
              }
              length() {
                return this.g.length;
              }
              end() {
                const t5 = this.g;
                return this.g = [], t5;
              }
            }();
          }
        }();
        jn(this.l, t4, Pn(Fr2)), xt2(t4, t4.g.end());
        const e4 = new Uint8Array(t4.i), n4 = t4.j, r4 = n4.length;
        let o4 = 0;
        for (let t5 = 0; t5 < r4; t5++) {
          const r5 = n4[t5];
          e4.set(r5, o4), o4 += r5.length;
        }
        return t4.j = [e4], e4;
      });
      Dr2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      Cr = [0, Xn2, Hn, or, -1];
      Gr2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
        g() {
          return Ye(this, Dr2);
        }
      };
      Gr2.u = [1];
      $r2 = [0, Wn2, Cr];
      zr2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      zr2.u = [4, 5];
      Wr2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      Rr2 = [1, 2, 3, 4, 5];
      Hr2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
        g() {
          return null != Ve2(this);
        }
        i() {
          return null != me2(Be2(this, 2));
        }
      };
      qr2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      Jr = [0, [0, ur2, or, [0, Xn2, Jn2, -1], [0, Yn, Jn2]], tr2, [0, Rr2, ar, Ar, ar, vr2, ar, pr, ar, _r2, ar, br2], cr2];
      Kr = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      Yr = new hr2(451755788, Kr);
      Er[451755788] = [0, Jr, [0, or, Xn2, Hn, nr, -1], Rn2];
      Xr = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      Qr = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      Zr = new hr2(487277289, Qr);
      Er[487277289] = [0, Jr, [0, tr2, -1]];
      to2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      eo2 = [0, 1, Xn2, or, $r2];
      no2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      no2.u = [1];
      ro2 = fr2(no2, [0, Wn2, eo2, Jn2]);
      oo2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      oo2.u = [1];
      io2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
        K() {
          const t4 = Ve2(this);
          return null == t4 ? V2() : t4;
        }
      };
      so2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      ao2 = [1, 2];
      uo2 = [0, ao2, ar, [0, qn], ar, [0, ur2], Xn2, or];
      co2 = class extends sn {
        constructor(t4) {
          super(t4);
        }
      };
      co2.u = [1];
      lo2 = fr2(co2, [0, Wn2, uo2, Jn2]);
      yo2 = /* @__PURE__ */ function(t4) {
        return class extends t4 {
          N() {
            this.h._registerModelResourcesGraphService();
          }
        };
      }(class {
        constructor(t4, e4) {
          this.j = true, this.h = t4, this.g = null, this.i = 0, this.m = "function" == typeof this.h._addIntToInputStream, void 0 !== e4 ? this.h.canvas = e4 : ((t4 = "undefined" == typeof OffscreenCanvas) || (t4 = (t4 = navigator.userAgent).includes("Safari") && !t4.includes("Chrome")), t4 ? (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.h.canvas = document.createElement("canvas")) : this.h.canvas = new OffscreenCanvas(1, 1));
        }
        async initializeGraph(t4) {
          const e4 = await (await fetch(t4)).arrayBuffer();
          t4 = !(t4.endsWith(".pbtxt") || t4.endsWith(".textproto")), this.setGraph(new Uint8Array(e4), t4);
        }
        setGraphFromString(t4) {
          this.setGraph(new TextEncoder().encode(t4), false);
        }
        setGraph(t4, e4) {
          const n4 = t4.length, r4 = this.h._malloc(n4);
          this.h.HEAPU8.set(t4, r4), e4 ? this.h._changeBinaryGraph(n4, r4) : this.h._changeTextGraph(n4, r4), this.h._free(r4);
        }
        configureAudio(t4, e4, n4, r4, o4) {
          this.h._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), fo2(this, r4 || "input_audio", (r5) => {
            fo2(this, o4 = o4 || "audio_header", (o5) => {
              this.h._configureAudio(r5, o5, t4, e4, n4);
            });
          });
        }
        setAutoResizeCanvas(t4) {
          this.j = t4;
        }
        setAutoRenderToScreen(t4) {
          this.h._setAutoRenderToScreen(t4);
        }
        setGpuBufferVerticalFlip(t4) {
          this.h.gpuOriginForWebTexturesIsBottomLeft = t4;
        }
        attachErrorListener(t4) {
          this.h.errorListener = t4;
        }
        attachEmptyPacketListener(t4, e4) {
          this.h.emptyPacketListeners = this.h.emptyPacketListeners || {}, this.h.emptyPacketListeners[t4] = e4;
        }
        addAudioToStream(t4, e4, n4) {
          this.addAudioToStreamWithShape(t4, 0, 0, e4, n4);
        }
        addAudioToStreamWithShape(t4, e4, n4, r4, o4) {
          const i5 = 4 * t4.length;
          this.i !== i5 && (this.g && this.h._free(this.g), this.g = this.h._malloc(i5), this.i = i5), this.h.HEAPF32.set(t4, this.g / 4), fo2(this, r4, (t5) => {
            this.h._addAudioToInputStream(this.g, e4, n4, t5, o4);
          });
        }
        addGpuBufferToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            if (!this.h.canvas)
              throw Error("No OpenGL canvas configured.");
            e5 ? this.h._bindTextureToStream(e5) : this.h._bindTextureToCanvas();
            const r4 = this.h.canvas.getContext("webgl2") || this.h.canvas.getContext("webgl");
            if (!r4)
              throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
            this.h.gpuOriginForWebTexturesIsBottomLeft && r4.pixelStorei(r4.UNPACK_FLIP_Y_WEBGL, true), r4.texImage2D(r4.TEXTURE_2D, 0, r4.RGBA, r4.RGBA, r4.UNSIGNED_BYTE, t4), this.h.gpuOriginForWebTexturesIsBottomLeft && r4.pixelStorei(r4.UNPACK_FLIP_Y_WEBGL, false);
            const [o4, i5] = void 0 !== t4.videoWidth ? [t4.videoWidth, t4.videoHeight] : void 0 !== t4.naturalWidth ? [t4.naturalWidth, t4.naturalHeight] : void 0 !== t4.displayWidth ? [t4.displayWidth, t4.displayHeight] : [t4.width, t4.height];
            !this.j || o4 === this.h.canvas.width && i5 === this.h.canvas.height || (this.h.canvas.width = o4, this.h.canvas.height = i5);
            const [s4, a4] = [o4, i5];
            this.h._addBoundTextureToStream(e5, s4, a4, n4);
          });
        }
        addBoolToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            this.h._addBoolToInputStream(t4, e5, n4);
          });
        }
        addDoubleToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            this.h._addDoubleToInputStream(t4, e5, n4);
          });
        }
        addFloatToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            this.h._addFloatToInputStream(t4, e5, n4);
          });
        }
        addIntToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            this.h._addIntToInputStream(t4, e5, n4);
          });
        }
        addStringToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            fo2(this, t4, (t5) => {
              this.h._addStringToInputStream(t5, e5, n4);
            });
          });
        }
        addStringRecordToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            go2(this, Object.keys(t4), (r4) => {
              go2(this, Object.values(t4), (o4) => {
                this.h._addFlatHashMapToInputStream(r4, o4, Object.keys(t4).length, e5, n4);
              });
            });
          });
        }
        addProtoToStream(t4, e4, n4, r4) {
          fo2(this, n4, (n5) => {
            fo2(this, e4, (e5) => {
              const o4 = this.h._malloc(t4.length);
              this.h.HEAPU8.set(t4, o4), this.h._addProtoToInputStream(o4, t4.length, e5, n5, r4), this.h._free(o4);
            });
          });
        }
        addEmptyPacketToStream(t4, e4) {
          fo2(this, t4, (t5) => {
            this.h._addEmptyPacketToInputStream(t5, e4);
          });
        }
        addBoolVectorToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            const r4 = this.h._allocateBoolVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new bool vector on heap.");
            for (const e6 of t4)
              this.h._addBoolVectorEntry(r4, e6);
            this.h._addBoolVectorToInputStream(r4, e5, n4);
          });
        }
        addDoubleVectorToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            const r4 = this.h._allocateDoubleVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new double vector on heap.");
            for (const e6 of t4)
              this.h._addDoubleVectorEntry(r4, e6);
            this.h._addDoubleVectorToInputStream(r4, e5, n4);
          });
        }
        addFloatVectorToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            const r4 = this.h._allocateFloatVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new float vector on heap.");
            for (const e6 of t4)
              this.h._addFloatVectorEntry(r4, e6);
            this.h._addFloatVectorToInputStream(r4, e5, n4);
          });
        }
        addIntVectorToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            const r4 = this.h._allocateIntVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new int vector on heap.");
            for (const e6 of t4)
              this.h._addIntVectorEntry(r4, e6);
            this.h._addIntVectorToInputStream(r4, e5, n4);
          });
        }
        addStringVectorToStream(t4, e4, n4) {
          fo2(this, e4, (e5) => {
            const r4 = this.h._allocateStringVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new string vector on heap.");
            for (const e6 of t4)
              fo2(this, e6, (t5) => {
                this.h._addStringVectorEntry(r4, t5);
              });
            this.h._addStringVectorToInputStream(r4, e5, n4);
          });
        }
        addBoolToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            this.h._addBoolToInputSidePacket(t4, e5);
          });
        }
        addDoubleToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            this.h._addDoubleToInputSidePacket(t4, e5);
          });
        }
        addFloatToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            this.h._addFloatToInputSidePacket(t4, e5);
          });
        }
        addIntToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            this.h._addIntToInputSidePacket(t4, e5);
          });
        }
        addStringToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            fo2(this, t4, (t5) => {
              this.h._addStringToInputSidePacket(t5, e5);
            });
          });
        }
        addProtoToInputSidePacket(t4, e4, n4) {
          fo2(this, n4, (n5) => {
            fo2(this, e4, (e5) => {
              const r4 = this.h._malloc(t4.length);
              this.h.HEAPU8.set(t4, r4), this.h._addProtoToInputSidePacket(r4, t4.length, e5, n5), this.h._free(r4);
            });
          });
        }
        addBoolVectorToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            const n4 = this.h._allocateBoolVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new bool vector on heap.");
            for (const e6 of t4)
              this.h._addBoolVectorEntry(n4, e6);
            this.h._addBoolVectorToInputSidePacket(n4, e5);
          });
        }
        addDoubleVectorToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            const n4 = this.h._allocateDoubleVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new double vector on heap.");
            for (const e6 of t4)
              this.h._addDoubleVectorEntry(n4, e6);
            this.h._addDoubleVectorToInputSidePacket(n4, e5);
          });
        }
        addFloatVectorToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            const n4 = this.h._allocateFloatVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new float vector on heap.");
            for (const e6 of t4)
              this.h._addFloatVectorEntry(n4, e6);
            this.h._addFloatVectorToInputSidePacket(n4, e5);
          });
        }
        addIntVectorToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            const n4 = this.h._allocateIntVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new int vector on heap.");
            for (const e6 of t4)
              this.h._addIntVectorEntry(n4, e6);
            this.h._addIntVectorToInputSidePacket(n4, e5);
          });
        }
        addStringVectorToInputSidePacket(t4, e4) {
          fo2(this, e4, (e5) => {
            const n4 = this.h._allocateStringVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new string vector on heap.");
            for (const e6 of t4)
              fo2(this, e6, (t5) => {
                this.h._addStringVectorEntry(n4, t5);
              });
            this.h._addStringVectorToInputSidePacket(n4, e5);
          });
        }
        attachBoolListener(t4, e4) {
          po2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachBoolListener(t5);
          });
        }
        attachBoolVectorListener(t4, e4) {
          mo2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachBoolVectorListener(t5);
          });
        }
        attachIntListener(t4, e4) {
          po2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachIntListener(t5);
          });
        }
        attachIntVectorListener(t4, e4) {
          mo2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachIntVectorListener(t5);
          });
        }
        attachDoubleListener(t4, e4) {
          po2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachDoubleListener(t5);
          });
        }
        attachDoubleVectorListener(t4, e4) {
          mo2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachDoubleVectorListener(t5);
          });
        }
        attachFloatListener(t4, e4) {
          po2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachFloatListener(t5);
          });
        }
        attachFloatVectorListener(t4, e4) {
          mo2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachFloatVectorListener(t5);
          });
        }
        attachStringListener(t4, e4) {
          po2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachStringListener(t5);
          });
        }
        attachStringVectorListener(t4, e4) {
          mo2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachStringVectorListener(t5);
          });
        }
        attachProtoListener(t4, e4, n4) {
          po2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachProtoListener(t5, n4 || false);
          });
        }
        attachProtoVectorListener(t4, e4, n4) {
          mo2(this, t4, e4), fo2(this, t4, (t5) => {
            this.h._attachProtoVectorListener(t5, n4 || false);
          });
        }
        attachAudioListener(t4, e4, n4) {
          this.h._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), po2(this, t4, (t5, n5) => {
            t5 = new Float32Array(t5.buffer, t5.byteOffset, t5.length / 4), e4(t5, n5);
          }), fo2(this, t4, (t5) => {
            this.h._attachAudioListener(t5, n4 || false);
          });
        }
        finishProcessing() {
          this.h._waitUntilIdle();
        }
        closeGraph() {
          this.h._closeGraph(), this.h.simpleListeners = void 0, this.h.emptyPacketListeners = void 0;
        }
      });
      vo2 = class extends yo2 {
      };
      To2 = class {
        constructor(t4) {
          this.g = t4, this.j = [], this.s = 0, this.g.setAutoRenderToScreen(false);
        }
        setGraph(t4, e4) {
          this.g.attachErrorListener((t5, e5) => {
            this.j.push(Error(e5));
          }), this.g.N(), this.g.setGraph(t4, e4), So2(this);
        }
        finishProcessing() {
          this.g.finishProcessing(), So2(this);
        }
        close() {
          this.g.closeGraph();
        }
      };
      To2.prototype.close = To2.prototype.close;
      Po2 = class extends To2 {
        constructor() {
          super(...arguments), this.G = 48e3;
        }
        O(t4) {
          this.G = t4;
        }
      };
      Po2.prototype.setDefaultSampleRate = Po2.prototype.O;
      Lo2 = class extends Po2 {
        constructor(t4, e4) {
          super(new vo2(t4, e4)), this.m = [], Xe3(t4 = this.i = new Kr(), 0, 1, e4 = new qr2());
        }
        get baseOptions() {
          return Je2(this.i, qr2, 1);
        }
        set baseOptions(t4) {
          Xe3(this.i, 0, 1, t4);
        }
        o(t4) {
          var e4 = this.i, n4 = Je2(this.i, zr2, 2);
          if (n4 = n4 ? Pe(n4) : new zr2(), void 0 !== t4.displayNamesLocale ? Ue(n4, 1, pe(t4.displayNamesLocale)) : void 0 === t4.displayNamesLocale && Ue(n4, 1), void 0 !== t4.maxResults) {
            var r4 = t4.maxResults;
            if (null != r4) {
              if ("number" != typeof r4)
                throw ie();
              if (!Number.isFinite(r4))
                throw ie();
              r4 |= 0;
            }
            Ue(n4, 2, r4);
          } else
            "maxResults" in t4 && Ue(n4, 2);
          if (void 0 !== t4.scoreThreshold) {
            if (null != (r4 = t4.scoreThreshold) && "number" != typeof r4)
              throw Error(`Value of float/double field must be a number, found ${typeof r4}: ${r4}`);
            Ue(n4, 3, r4);
          } else
            "scoreThreshold" in t4 && Ue(n4, 3);
          return void 0 !== t4.categoryAllowlist ? Ce3(n4, 4, t4.categoryAllowlist) : "categoryAllowlist" in t4 && Ue(n4, 4), void 0 !== t4.categoryDenylist ? Ce3(n4, 5, t4.categoryDenylist) : "categoryDenylist" in t4 && Ue(n4, 5), Xe3(e4, 0, 2, n4), Ao2(this, t4);
        }
        L(t4, e4) {
          return this.F(t4, e4 ?? this.G, this.s + 1);
        }
        F(t4, e4, n4) {
          return this.g.addDoubleToStream(e4, "sample_rate", n4), this.g.addAudioToStreamWithShape(t4, 1, t4.length, "audio_in", n4), this.m = [], this.finishProcessing(), [...this.m];
        }
        H() {
          var t4 = new Mr2();
          rn2(t4, 10, "audio_in"), rn2(t4, 10, "sample_rate"), rn2(t4, 15, "timestamped_classifications");
          const e4 = new Sr();
          on(e4, Yr, this.i);
          const n4 = new Br2();
          Ge2(n4, pe("mediapipe.tasks.audio.audio_classifier.AudioClassifierGraph")), rn2(n4, 3, "AUDIO:audio_in"), rn2(n4, 3, "SAMPLE_RATE:sample_rate"), rn2(n4, 4, "TIMESTAMPED_CLASSIFICATIONS:timestamped_classifications"), n4.o(e4), tn2(t4, n4), this.g.attachProtoVectorListener("timestamped_classifications", (t5, e5) => {
            !function(t6, e6) {
              e6.forEach((e7) => {
                e7 = ro2(e7), t6.m.push(Oo2(e7));
              });
            }(this, t5), Eo2(this, e5);
          }), this.g.attachEmptyPacketListener("timestamped_classifications", (t5) => {
            Eo2(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Lo2.prototype.classify = Lo2.prototype.L, Lo2.prototype.setOptions = Lo2.prototype.o, Lo2.createFromModelPath = function(t4, e4) {
        return wo2(Lo2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Lo2.createFromModelBuffer = function(t4, e4) {
        return Io2(Lo2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Lo2.createFromOptions = function(t4, e4) {
        return Io2(Lo2, t4, e4);
      };
      Bo = class extends Po2 {
        constructor(t4, e4) {
          super(new vo2(t4, e4)), this.m = [], Xe3(t4 = this.i = new Qr(), 0, 1, e4 = new qr2());
        }
        get baseOptions() {
          return Je2(this.i, qr2, 1);
        }
        set baseOptions(t4) {
          Xe3(this.i, 0, 1, t4);
        }
        o(t4) {
          var e4 = this.i, n4 = Je2(this.i, Xr, 2);
          return n4 = n4 ? Pe(n4) : new Xr(), void 0 !== t4.l2Normalize ? Ue(n4, 1, ae2(t4.l2Normalize)) : "l2Normalize" in t4 && Ue(n4, 1), void 0 !== t4.quantize ? Ue(n4, 2, ae2(t4.quantize)) : "quantize" in t4 && Ue(n4, 2), Xe3(e4, 0, 2, n4), Ao2(this, t4);
        }
        M(t4, e4) {
          return this.F(t4, e4 ?? this.G, this.s + 1);
        }
        F(t4, e4, n4) {
          return this.g.addDoubleToStream(e4, "sample_rate", n4), this.g.addAudioToStreamWithShape(t4, 1, t4.length, "audio_in", n4), this.m = [], this.finishProcessing(), this.m;
        }
        H() {
          var t4 = new Mr2();
          rn2(t4, 10, "audio_in"), rn2(t4, 10, "sample_rate"), rn2(t4, 15, "embeddings_out"), rn2(t4, 15, "timestamped_embeddings_out");
          const e4 = new Sr();
          on(e4, Zr, this.i);
          const n4 = new Br2();
          Ge2(n4, pe("mediapipe.tasks.audio.audio_embedder.AudioEmbedderGraph")), rn2(n4, 3, "AUDIO:audio_in"), rn2(n4, 3, "SAMPLE_RATE:sample_rate"), rn2(n4, 4, "EMBEDDINGS:embeddings_out"), rn2(n4, 4, "TIMESTAMPED_EMBEDDINGS:timestamped_embeddings_out"), n4.o(e4), tn2(t4, n4), this.g.attachProtoListener("embeddings_out", (t5, e5) => {
            t5 = lo2(t5), this.m.push(xo2(t5)), Eo2(this, e5);
          }), this.g.attachEmptyPacketListener("embeddings_out", (t5) => {
            Eo2(this, t5);
          }), this.g.attachProtoVectorListener("timestamped_embeddings_out", (t5, e5) => {
            for (const e6 of t5)
              t5 = lo2(e6), this.m.push(xo2(t5));
            Eo2(this, e5);
          }), this.g.attachEmptyPacketListener("timestamped_embeddings_out", (t5) => {
            Eo2(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Bo.prototype.embed = Bo.prototype.M, Bo.prototype.setOptions = Bo.prototype.o, Bo.createFromModelPath = function(t4, e4) {
        return Io2(Bo, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Bo.createFromModelBuffer = function(t4, e4) {
        return Io2(Bo, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Bo.createFromOptions = function(t4, e4) {
        return Io2(Bo, t4, e4);
      };
      Uo = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
      Vo = class {
      };
      Vo.forVisionTasks = function(t4) {
        return ko2("vision", t4);
      }, Vo.forTextTasks = function(t4) {
        return ko2("text", t4);
      }, Vo.forGenAiTasks = function(t4) {
        return ko2("genai", t4);
      }, Vo.forAudioTasks = function(t4) {
        return ko2("audio", t4);
      }, Vo.isSimdSupported = function() {
        return jo2();
      };
    }
  });

  // node_modules/@mediapipe/tasks-vision/vision_bundle.mjs
  function e3(e4) {
    t: {
      for (var n4 = ["CLOSURE_FLAGS"], r4 = t3, s4 = 0; s4 < n4.length; s4++)
        if (null == (r4 = r4[n4[s4]])) {
          n4 = null;
          break t;
        }
      n4 = r4;
    }
    return null != (e4 = n4 && n4[e4]) && e4;
  }
  function n3() {
    throw Error("Invalid UTF8");
  }
  function r3(t4, e4) {
    return e4 = String.fromCharCode.apply(null, e4), null == t4 ? e4 : t4 + e4;
  }
  function c3(t4) {
    if (h3)
      t4 = (a3 ||= new TextEncoder()).encode(t4);
    else {
      let n4 = 0;
      const r4 = new Uint8Array(3 * t4.length);
      for (let s4 = 0; s4 < t4.length; s4++) {
        var e4 = t4.charCodeAt(s4);
        if (128 > e4)
          r4[n4++] = e4;
        else {
          if (2048 > e4)
            r4[n4++] = e4 >> 6 | 192;
          else {
            if (55296 <= e4 && 57343 >= e4) {
              if (56319 >= e4 && s4 < t4.length) {
                const i5 = t4.charCodeAt(++s4);
                if (56320 <= i5 && 57343 >= i5) {
                  e4 = 1024 * (e4 - 55296) + i5 - 56320 + 65536, r4[n4++] = e4 >> 18 | 240, r4[n4++] = e4 >> 12 & 63 | 128, r4[n4++] = e4 >> 6 & 63 | 128, r4[n4++] = 63 & e4 | 128;
                  continue;
                }
                s4--;
              }
              e4 = 65533;
            }
            r4[n4++] = e4 >> 12 | 224, r4[n4++] = e4 >> 6 & 63 | 128;
          }
          r4[n4++] = 63 & e4 | 128;
        }
      }
      t4 = n4 === r4.length ? r4 : r4.subarray(0, n4);
    }
    return t4;
  }
  function p3(t4) {
    return !!l3 && (!!u3 && u3.brands.some(({ brand: e4 }) => e4 && -1 != e4.indexOf(t4)));
  }
  function g3(e4) {
    var n4;
    return (n4 = t3.navigator) && (n4 = n4.userAgent) || (n4 = ""), -1 != n4.indexOf(e4);
  }
  function m2() {
    return !!l3 && (!!u3 && 0 < u3.brands.length);
  }
  function y2() {
    return m2() ? p3("Chromium") : (g3("Chrome") || g3("CriOS")) && !(!m2() && g3("Edge")) || g3("Silk");
  }
  function w2(t4) {
    var e4 = t4.length, n4 = 3 * e4 / 4;
    n4 % 3 ? n4 = Math.floor(n4) : -1 != "=.".indexOf(t4[e4 - 1]) && (n4 = -1 != "=.".indexOf(t4[e4 - 2]) ? n4 - 2 : n4 - 1);
    var r4 = new Uint8Array(n4), s4 = 0;
    return function(t5, e5) {
      function n5(e6) {
        for (; r5 < t5.length; ) {
          var n6 = t5.charAt(r5++), s6 = E3[n6];
          if (null != s6)
            return s6;
          if (!/^[\s\xa0]*$/.test(n6))
            throw Error("Unknown base64 encoding at char: " + n6);
        }
        return e6;
      }
      T2();
      for (var r5 = 0; ; ) {
        var s5 = n5(-1), i5 = n5(0), o4 = n5(64), a4 = n5(64);
        if (64 === a4 && -1 === s5)
          break;
        e5(s5 << 2 | i5 >> 4), 64 != o4 && (e5(i5 << 4 & 240 | o4 >> 2), 64 != a4 && e5(o4 << 6 & 192 | a4));
      }
    }(t4, function(t5) {
      r4[s4++] = t5;
    }), s4 !== n4 ? r4.subarray(0, s4) : r4;
  }
  function T2() {
    if (!E3) {
      E3 = {};
      for (var t4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e4 = ["+/=", "+/", "-_=", "-_.", "-_"], n4 = 0; 5 > n4; n4++) {
        var r4 = t4.concat(e4[n4].split(""));
        v2[n4] = r4;
        for (var s4 = 0; s4 < r4.length; s4++) {
          var i5 = r4[s4];
          void 0 === E3[i5] && (E3[i5] = s4);
        }
      }
    }
  }
  function k2(t4) {
    if (!b2) {
      var e4;
      void 0 === e4 && (e4 = 0), T2(), e4 = v2[e4];
      var n4 = Array(Math.floor(t4.length / 3)), r4 = e4[64] || "";
      let h4 = 0, c5 = 0;
      for (; h4 < t4.length - 2; h4 += 3) {
        var s4 = t4[h4], i5 = t4[h4 + 1], o4 = t4[h4 + 2], a4 = e4[s4 >> 2];
        s4 = e4[(3 & s4) << 4 | i5 >> 4], i5 = e4[(15 & i5) << 2 | o4 >> 6], o4 = e4[63 & o4], n4[c5++] = a4 + s4 + i5 + o4;
      }
      switch (a4 = 0, o4 = r4, t4.length - h4) {
        case 2:
          o4 = e4[(15 & (a4 = t4[h4 + 1])) << 2] || r4;
        case 1:
          t4 = t4[h4], n4[c5] = e4[t4 >> 2] + e4[(3 & t4) << 4 | a4 >> 4] + o4 + r4;
      }
      return n4.join("");
    }
    for (e4 = "", n4 = 0, r4 = t4.length - 10240; n4 < r4; )
      e4 += String.fromCharCode.apply(null, t4.subarray(n4, n4 += 10240));
    return e4 += String.fromCharCode.apply(null, n4 ? t4.subarray(n4) : t4), btoa(e4);
  }
  function L2(t4) {
    return S2[t4] || "";
  }
  function F3(t4) {
    if (!b2)
      return w2(t4);
    x2.test(t4) && (t4 = t4.replace(x2, L2)), t4 = atob(t4);
    const e4 = new Uint8Array(t4.length);
    for (let n4 = 0; n4 < t4.length; n4++)
      e4[n4] = t4.charCodeAt(n4);
    return e4;
  }
  function R4(t4) {
    return A2 && null != t4 && t4 instanceof Uint8Array;
  }
  function P2() {
    return M2 ||= new Uint8Array(0);
  }
  function I2(t4) {
    if (t4 !== O4)
      throw Error("illegal external caller");
  }
  function D2() {
    return C2 ||= new U4(null, O4);
  }
  function N3(t4) {
    I2(O4);
    var e4 = t4.g;
    return null == (e4 = null == e4 || R4(e4) ? e4 : "string" == typeof e4 ? F3(e4) : null) ? e4 : t4.g = e4;
  }
  function B3(t4, e4) {
    return Error(`Invalid wire type: ${t4} (at position ${e4})`);
  }
  function G3() {
    return Error("Failed to read varint, encoding is invalid.");
  }
  function j3(t4, e4) {
    return Error(`Tried to read past the end of the data ${e4} > ${t4}`);
  }
  function V3(t4) {
    if ("string" == typeof t4)
      return { buffer: F3(t4), N: false };
    if (Array.isArray(t4))
      return { buffer: new Uint8Array(t4), N: false };
    if (t4.constructor === Uint8Array)
      return { buffer: t4, N: false };
    if (t4.constructor === ArrayBuffer)
      return { buffer: new Uint8Array(t4), N: false };
    if (t4.constructor === U4)
      return { buffer: N3(t4) || P2(), N: true };
    if (t4 instanceof Uint8Array)
      return { buffer: new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength), N: false };
    throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
  }
  function X2() {
    return "function" == typeof BigInt;
  }
  function Y2(t4) {
    const e4 = 0 > t4;
    let n4 = (t4 = Math.abs(t4)) >>> 0;
    if (t4 = Math.floor((t4 - n4) / 4294967296), e4) {
      const [e5, r4] = nt3(n4, t4);
      t4 = r4, n4 = e5;
    }
    z3 = n4 >>> 0, K4 = t4 >>> 0;
  }
  function $4(t4) {
    const e4 = W3 ||= new DataView(new ArrayBuffer(8));
    e4.setFloat32(0, +t4, true), K4 = 0, z3 = e4.getUint32(0, true);
  }
  function q3(t4, e4) {
    return 4294967296 * e4 + (t4 >>> 0);
  }
  function J2(t4, e4) {
    const n4 = 2147483648 & e4;
    return n4 && (e4 = ~e4 >>> 0, 0 == (t4 = 1 + ~t4 >>> 0) && (e4 = e4 + 1 >>> 0)), t4 = q3(t4, e4), n4 ? -t4 : t4;
  }
  function Z3(t4, e4) {
    if (t4 >>>= 0, 2097151 >= (e4 >>>= 0))
      var n4 = "" + (4294967296 * e4 + t4);
    else
      X2() ? n4 = "" + (BigInt(e4) << BigInt(32) | BigInt(t4)) : (t4 = (16777215 & t4) + 6777216 * (n4 = 16777215 & (t4 >>> 24 | e4 << 8)) + 6710656 * (e4 = e4 >> 16 & 65535), n4 += 8147497 * e4, e4 *= 2, 1e7 <= t4 && (n4 += Math.floor(t4 / 1e7), t4 %= 1e7), 1e7 <= n4 && (e4 += Math.floor(n4 / 1e7), n4 %= 1e7), n4 = e4 + Q2(n4) + Q2(t4));
    return n4;
  }
  function Q2(t4) {
    return t4 = String(t4), "0000000".slice(t4.length) + t4;
  }
  function tt3() {
    var t4 = z3, e4 = K4;
    if (2147483648 & e4)
      if (X2())
        t4 = "" + (BigInt(0 | e4) << BigInt(32) | BigInt(t4 >>> 0));
      else {
        const [n4, r4] = nt3(t4, e4);
        t4 = "-" + Z3(n4, r4);
      }
    else
      t4 = Z3(t4, e4);
    return t4;
  }
  function et3(t4) {
    if (16 > t4.length)
      Y2(Number(t4));
    else if (X2())
      t4 = BigInt(t4), z3 = Number(t4 & BigInt(4294967295)) >>> 0, K4 = Number(t4 >> BigInt(32) & BigInt(4294967295));
    else {
      const e4 = +("-" === t4[0]);
      K4 = z3 = 0;
      const n4 = t4.length;
      for (let r4 = e4, s4 = (n4 - e4) % 6 + e4; s4 <= n4; r4 = s4, s4 += 6) {
        const e5 = Number(t4.slice(r4, s4));
        K4 *= 1e6, z3 = 1e6 * z3 + e5, 4294967296 <= z3 && (K4 += Math.trunc(z3 / 4294967296), K4 >>>= 0, z3 >>>= 0);
      }
      if (e4) {
        const [t5, e5] = nt3(z3, K4);
        z3 = t5, K4 = e5;
      }
    }
  }
  function nt3(t4, e4) {
    return e4 = ~e4, t4 ? t4 = 1 + ~t4 : e4 += 1, [t4, e4];
  }
  function rt2(t4, e4) {
    let n4, r4 = 0, s4 = 0, i5 = 0;
    const o4 = t4.h;
    let a4 = t4.g;
    do {
      n4 = o4[a4++], r4 |= (127 & n4) << i5, i5 += 7;
    } while (32 > i5 && 128 & n4);
    for (32 < i5 && (s4 |= (127 & n4) >> 4), i5 = 3; 32 > i5 && 128 & n4; i5 += 7)
      n4 = o4[a4++], s4 |= (127 & n4) << i5;
    if (lt2(t4, a4), 128 > n4)
      return e4(r4 >>> 0, s4 >>> 0);
    throw G3();
  }
  function st3(t4) {
    let e4 = 0, n4 = t4.g;
    const r4 = n4 + 10, s4 = t4.h;
    for (; n4 < r4; ) {
      const r5 = s4[n4++];
      if (e4 |= r5, 0 == (128 & r5))
        return lt2(t4, n4), !!(127 & e4);
    }
    throw G3();
  }
  function it3(t4) {
    const e4 = t4.h;
    let n4 = t4.g, r4 = e4[n4++], s4 = 127 & r4;
    if (128 & r4 && (r4 = e4[n4++], s4 |= (127 & r4) << 7, 128 & r4 && (r4 = e4[n4++], s4 |= (127 & r4) << 14, 128 & r4 && (r4 = e4[n4++], s4 |= (127 & r4) << 21, 128 & r4 && (r4 = e4[n4++], s4 |= r4 << 28, 128 & r4 && 128 & e4[n4++] && 128 & e4[n4++] && 128 & e4[n4++] && 128 & e4[n4++] && 128 & e4[n4++])))))
      throw G3();
    return lt2(t4, n4), s4;
  }
  function ot2(t4) {
    return it3(t4) >>> 0;
  }
  function at3(t4) {
    var e4 = t4.h;
    const n4 = t4.g, r4 = e4[n4], s4 = e4[n4 + 1], i5 = e4[n4 + 2];
    return e4 = e4[n4 + 3], lt2(t4, t4.g + 4), (r4 << 0 | s4 << 8 | i5 << 16 | e4 << 24) >>> 0;
  }
  function ht3(t4) {
    var e4 = at3(t4);
    t4 = 2 * (e4 >> 31) + 1;
    const n4 = e4 >>> 23 & 255;
    return e4 &= 8388607, 255 == n4 ? e4 ? NaN : 1 / 0 * t4 : 0 == n4 ? t4 * Math.pow(2, -149) * e4 : t4 * Math.pow(2, n4 - 150) * (e4 + Math.pow(2, 23));
  }
  function ct3(t4) {
    return it3(t4);
  }
  function ut3(t4, e4, { ca: n4 = false } = {}) {
    t4.ca = n4, e4 && (e4 = V3(e4), t4.h = e4.buffer, t4.m = e4.N, t4.j = 0, t4.l = t4.h.length, t4.g = t4.j);
  }
  function lt2(t4, e4) {
    if (t4.g = e4, e4 > t4.l)
      throw j3(t4.l, e4);
  }
  function dt3(t4, e4) {
    if (0 > e4)
      throw Error(`Tried to read a negative byte length: ${e4}`);
    const n4 = t4.g, r4 = n4 + e4;
    if (r4 > t4.l)
      throw j3(e4, t4.l - n4);
    return t4.g = r4, n4;
  }
  function ft3(t4, e4) {
    if (0 == e4)
      return D2();
    var n4 = dt3(t4, e4);
    return t4.ca && t4.m ? n4 = t4.h.subarray(n4, n4 + e4) : (t4 = t4.h, n4 = n4 === (e4 = n4 + e4) ? P2() : H3 ? t4.slice(n4, e4) : new Uint8Array(t4.subarray(n4, e4))), 0 == n4.length ? D2() : new U4(n4, O4);
  }
  function gt2(t4) {
    var e4 = t4.g;
    if (e4.g == e4.l)
      return false;
    t4.l = t4.g.g;
    var n4 = ot2(t4.g);
    if (e4 = n4 >>> 3, !(0 <= (n4 &= 7) && 5 >= n4))
      throw B3(n4, t4.l);
    if (1 > e4)
      throw Error(`Invalid field number: ${e4} (at position ${t4.l})`);
    return t4.m = e4, t4.h = n4, true;
  }
  function mt2(t4) {
    switch (t4.h) {
      case 0:
        0 != t4.h ? mt2(t4) : st3(t4.g);
        break;
      case 1:
        lt2(t4 = t4.g, t4.g + 8);
        break;
      case 2:
        if (2 != t4.h)
          mt2(t4);
        else {
          var e4 = ot2(t4.g);
          lt2(t4 = t4.g, t4.g + e4);
        }
        break;
      case 5:
        lt2(t4 = t4.g, t4.g + 4);
        break;
      case 3:
        for (e4 = t4.m; ; ) {
          if (!gt2(t4))
            throw Error("Unmatched start-group tag: stream EOF");
          if (4 == t4.h) {
            if (t4.m != e4)
              throw Error("Unmatched end-group tag");
            break;
          }
          mt2(t4);
        }
        break;
      default:
        throw B3(t4.h, t4.l);
    }
  }
  function yt2(t4, e4, n4) {
    const r4 = t4.g.l, s4 = ot2(t4.g), i5 = t4.g.g + s4;
    let o4 = i5 - r4;
    if (0 >= o4 && (t4.g.l = i5, n4(e4, t4, void 0, void 0, void 0), o4 = i5 - t4.g.g), o4)
      throw Error(`Message parsing ended unexpectedly. Expected to read ${s4} bytes, instead read ${s4 - o4} bytes, either the data ended unexpectedly or the message misreported its own length`);
    return t4.g.g = i5, t4.g.l = r4, e4;
  }
  function _t2(t4) {
    var e4 = ot2(t4.g), a4 = dt3(t4 = t4.g, e4);
    if (t4 = t4.h, o3) {
      var h4, c5 = t4;
      (h4 = i3) || (h4 = i3 = new TextDecoder("utf-8", { fatal: true })), e4 = a4 + e4, c5 = 0 === a4 && e4 === c5.length ? c5 : c5.subarray(a4, e4);
      try {
        var u4 = h4.decode(c5);
      } catch (t5) {
        if (void 0 === s3) {
          try {
            h4.decode(new Uint8Array([128]));
          } catch (t6) {
          }
          try {
            h4.decode(new Uint8Array([97])), s3 = true;
          } catch (t6) {
            s3 = false;
          }
        }
        throw !s3 && (i3 = void 0), t5;
      }
    } else {
      e4 = (u4 = a4) + e4, a4 = [];
      let s4, i5 = null;
      for (; u4 < e4; ) {
        var l4 = t4[u4++];
        128 > l4 ? a4.push(l4) : 224 > l4 ? u4 >= e4 ? n3() : (s4 = t4[u4++], 194 > l4 || 128 != (192 & s4) ? (u4--, n3()) : a4.push((31 & l4) << 6 | 63 & s4)) : 240 > l4 ? u4 >= e4 - 1 ? n3() : (s4 = t4[u4++], 128 != (192 & s4) || 224 === l4 && 160 > s4 || 237 === l4 && 160 <= s4 || 128 != (192 & (h4 = t4[u4++])) ? (u4--, n3()) : a4.push((15 & l4) << 12 | (63 & s4) << 6 | 63 & h4)) : 244 >= l4 ? u4 >= e4 - 2 ? n3() : (s4 = t4[u4++], 128 != (192 & s4) || 0 != s4 - 144 + (l4 << 28) >> 30 || 128 != (192 & (h4 = t4[u4++])) || 128 != (192 & (c5 = t4[u4++])) ? (u4--, n3()) : (l4 = (7 & l4) << 18 | (63 & s4) << 12 | (63 & h4) << 6 | 63 & c5, l4 -= 65536, a4.push(55296 + (l4 >> 10 & 1023), 56320 + (1023 & l4)))) : n3(), 8192 <= a4.length && (i5 = r3(i5, a4), a4.length = 0);
      }
      u4 = r3(i5, a4);
    }
    return u4;
  }
  function vt2(t4) {
    const e4 = ot2(t4.g);
    return ft3(t4.g, e4);
  }
  function Et2(t4, e4, n4) {
    var r4 = ot2(t4.g);
    for (r4 = t4.g.g + r4; t4.g.g < r4; )
      n4.push(e4(t4.g));
  }
  function Tt3(t4) {
    return t4 ? /^\d+$/.test(t4) ? (et3(t4), new At2(z3, K4)) : null : bt2 ||= new At2(0, 0);
  }
  function kt3(t4) {
    return t4 ? /^-?\d+$/.test(t4) ? (et3(t4), new xt3(z3, K4)) : null : St2 ||= new xt3(0, 0);
  }
  function Lt2(t4, e4, n4) {
    for (; 0 < n4 || 127 < e4; )
      t4.g.push(127 & e4 | 128), e4 = (e4 >>> 7 | n4 << 25) >>> 0, n4 >>>= 7;
    t4.g.push(e4);
  }
  function Ft2(t4, e4) {
    for (; 127 < e4; )
      t4.g.push(127 & e4 | 128), e4 >>>= 7;
    t4.g.push(e4);
  }
  function Rt3(t4, e4) {
    if (0 <= e4)
      Ft2(t4, e4);
    else {
      for (let n4 = 0; 9 > n4; n4++)
        t4.g.push(127 & e4 | 128), e4 >>= 7;
      t4.g.push(1);
    }
  }
  function Mt2(t4, e4) {
    t4.g.push(e4 >>> 0 & 255), t4.g.push(e4 >>> 8 & 255), t4.g.push(e4 >>> 16 & 255), t4.g.push(e4 >>> 24 & 255);
  }
  function Pt2(t4, e4) {
    0 !== e4.length && (t4.l.push(e4), t4.h += e4.length);
  }
  function Ot3(t4, e4, n4) {
    Ft2(t4.g, 8 * e4 + n4);
  }
  function Ct2(t4, e4) {
    return Ot3(t4, e4, 2), e4 = t4.g.end(), Pt2(t4, e4), e4.push(t4.h), e4;
  }
  function It2(t4, e4) {
    var n4 = e4.pop();
    for (n4 = t4.h + t4.g.length() - n4; 127 < n4; )
      e4.push(127 & n4 | 128), n4 >>>= 7, t4.h++;
    e4.push(n4), t4.h++;
  }
  function Dt2(t4, e4, n4) {
    Ot3(t4, e4, 2), Ft2(t4.g, n4.length), Pt2(t4, t4.g.end()), Pt2(t4, n4);
  }
  function Nt3(t4, e4, n4, r4) {
    null != n4 && (e4 = Ct2(t4, e4), r4(n4, t4), It2(t4, e4));
  }
  function Bt3(t4) {
    return Array.prototype.slice.call(t4);
  }
  function Gt2(t4) {
    return "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol() : t4;
  }
  function Wt3(t4, e4, n4) {
    return n4 ? t4 | e4 : t4 & ~e4;
  }
  function $t2(t4) {
    return Xt3(t4, 34), t4;
  }
  function qt2(t4, e4) {
    Yt3(e4, -14591 & (0 | t4));
  }
  function Jt2(t4, e4) {
    Yt3(e4, -14557 & (34 | t4));
  }
  function Zt3(t4) {
    return 0 === (t4 = t4 >> 14 & 1023) ? 536870912 : t4;
  }
  function ne2(t4) {
    return !(!t4 || "object" != typeof t4 || t4.Ja !== ee3);
  }
  function re3(t4) {
    return null !== t4 && "object" == typeof t4 && !Array.isArray(t4) && t4.constructor === Object;
  }
  function se2(t4, e4, n4) {
    if (null != t4) {
      if ("string" == typeof t4)
        t4 = t4 ? new U4(t4, O4) : D2();
      else if (t4.constructor !== U4)
        if (R4(t4))
          t4 = t4.length ? new U4(n4 ? t4 : new Uint8Array(t4), O4) : D2();
        else {
          if (!e4)
            throw Error();
          t4 = void 0;
        }
    }
    return t4;
  }
  function ie2(t4, e4, n4) {
    if (!Array.isArray(t4) || t4.length)
      return false;
    const r4 = zt2(t4);
    return !!(1 & r4) || !(!e4 || !(Array.isArray(e4) ? e4.includes(n4) : e4.has(n4))) && (Yt3(t4, 1 | r4), true);
  }
  function ae3(t4) {
    if (2 & t4)
      throw Error();
  }
  function le3(t4, e4) {
    (e4 = ce4 ? e4[ce4] : void 0) && (t4[ce4] = Bt3(e4));
  }
  function de2(t4) {
    return (t4 = Error(t4)).__closure__error__context__984382 || (t4.__closure__error__context__984382 = {}), t4.__closure__error__context__984382.severity = "warning", t4;
  }
  function fe3(t4) {
    return null == t4 || "number" == typeof t4 ? t4 : "NaN" === t4 || "Infinity" === t4 || "-Infinity" === t4 ? Number(t4) : void 0;
  }
  function pe2(t4) {
    return null == t4 || "boolean" == typeof t4 ? t4 : "number" == typeof t4 ? !!t4 : void 0;
  }
  function me3(t4) {
    const e4 = typeof t4;
    return "number" === e4 ? Number.isFinite(t4) : "string" === e4 && ge3.test(t4);
  }
  function ye4(t4) {
    if (null == t4)
      return t4;
    if ("string" == typeof t4) {
      if (!t4)
        return;
      t4 = +t4;
    }
    return "number" == typeof t4 && Number.isFinite(t4) ? 0 | t4 : void 0;
  }
  function _e4(t4) {
    if (null == t4)
      return t4;
    if ("string" == typeof t4) {
      if (!t4)
        return;
      t4 = +t4;
    }
    return "number" == typeof t4 && Number.isFinite(t4) ? t4 >>> 0 : void 0;
  }
  function ve2(t4) {
    return "-" !== t4[0] && (20 > t4.length || 20 === t4.length && 184467 > Number(t4.substring(0, 6)));
  }
  function Ee3(t4) {
    return "-" === t4[0] ? 20 > t4.length || 20 === t4.length && -922337 < Number(t4.substring(0, 7)) : 19 > t4.length || 19 === t4.length && 922337 > Number(t4.substring(0, 6));
  }
  function we3(t4) {
    return t4 = Math.trunc(t4), Number.isSafeInteger(t4) || (Y2(t4), t4 = J2(z3, K4)), t4;
  }
  function Te3(t4) {
    var e4 = Math.trunc(Number(t4));
    return Number.isSafeInteger(e4) ? String(e4) : (-1 !== (e4 = t4.indexOf(".")) && (t4 = t4.substring(0, e4)), Ee3(t4) || (et3(t4), t4 = tt3()), t4);
  }
  function Ae2(t4) {
    return null == t4 ? t4 : me3(t4) ? "number" == typeof t4 ? we3(t4) : Te3(t4) : void 0;
  }
  function be3(t4) {
    if ("string" != typeof t4)
      throw Error();
    return t4;
  }
  function ke3(t4) {
    if (null != t4 && "string" != typeof t4)
      throw Error();
    return t4;
  }
  function xe4(t4) {
    return null == t4 || "string" == typeof t4 ? t4 : void 0;
  }
  function Se3(t4, e4, n4, r4) {
    if (null != t4 && "object" == typeof t4 && t4.X === te2)
      return t4;
    if (!Array.isArray(t4))
      return n4 ? 2 & r4 ? (t4 = e4[Vt3]) ? e4 = t4 : ($t2((t4 = new e4()).u), e4 = e4[Vt3] = t4) : e4 = new e4() : e4 = void 0, e4;
    let s4 = n4 = zt2(t4);
    return 0 === s4 && (s4 |= 32 & r4), s4 |= 2 & r4, s4 !== n4 && Yt3(t4, s4), new e4(t4);
  }
  function Le4(t4, e4, n4) {
    if (e4) {
      var r4 = !!r4;
      if (!me3(e4 = t4))
        throw de2("int64");
      "string" == typeof e4 ? r4 = Te3(e4) : r4 ? (r4 = Math.trunc(e4), Number.isSafeInteger(r4) ? r4 = String(r4) : Ee3(e4 = String(r4)) ? r4 = e4 : (Y2(r4), r4 = tt3())) : r4 = we3(e4);
    } else
      r4 = Ae2(t4);
    return "string" == typeof (n4 = null == (t4 = r4) ? n4 ? 0 : void 0 : t4) && (r4 = +n4, Number.isSafeInteger(r4)) ? r4 : n4;
  }
  function Pe2(t4) {
    switch (typeof t4) {
      case "boolean":
        return Re3 ||= [0, void 0, true];
      case "number":
        return 0 < t4 ? void 0 : 0 === t4 ? Me2 ||= [0, void 0] : [-t4, void 0];
      case "string":
        return [0, t4];
      case "object":
        return t4;
    }
  }
  function Oe3(t4, e4) {
    return Ce4(t4, e4[0], e4[1]);
  }
  function Ce4(t4, e4, n4) {
    if (null == t4 && (t4 = Fe3), Fe3 = void 0, null == t4) {
      var r4 = 96;
      n4 ? (t4 = [n4], r4 |= 512) : t4 = [], e4 && (r4 = -16760833 & r4 | (1023 & e4) << 14);
    } else {
      if (!Array.isArray(t4))
        throw Error();
      if (2048 & (r4 = zt2(t4)))
        throw Error();
      if (64 & r4)
        return t4;
      if (r4 |= 64, n4 && (r4 |= 512, n4 !== t4[0]))
        throw Error();
      t: {
        const s4 = (n4 = t4).length;
        if (s4) {
          const t5 = s4 - 1;
          if (re3(n4[t5])) {
            if (1024 <= (e4 = t5 - (+!!(512 & (r4 |= 256)) - 1)))
              throw Error();
            r4 = -16760833 & r4 | (1023 & e4) << 14;
            break t;
          }
        }
        if (e4) {
          if (1024 < (e4 = Math.max(e4, s4 - (+!!(512 & r4) - 1))))
            throw Error();
          r4 = -16760833 & r4 | (1023 & e4) << 14;
        }
      }
    }
    return Yt3(t4, r4), t4;
  }
  function Be3(t4) {
    return t4;
  }
  function Ge3(t4) {
    if (2 & t4.L)
      throw Error("Cannot mutate an immutable Map");
  }
  function Ve3(t4, e4, n4, r4, s4, i5) {
    return t4 = Se3(t4, r4, n4, i5), s4 && (t4 = tn3(t4)), t4;
  }
  function Xe4(t4) {
    return t4;
  }
  function He2(t4) {
    return [t4, this.get(t4)];
  }
  function ze2() {
    return We2 ||= new je3($t2([]), void 0, void 0, void 0, Ie2);
  }
  function Ke3(t4, e4, n4, r4, s4) {
    if (null != t4) {
      if (Array.isArray(t4))
        t4 = ie2(t4, void 0, 0) ? void 0 : s4 && 2 & zt2(t4) ? t4 : Ye2(t4, e4, n4, void 0 !== r4, s4);
      else if (re3(t4)) {
        const i5 = {};
        for (let o4 in t4)
          i5[o4] = Ke3(t4[o4], e4, n4, r4, s4);
        t4 = i5;
      } else
        t4 = e4(t4, r4);
      return t4;
    }
  }
  function Ye2(t4, e4, n4, r4, s4) {
    const i5 = r4 || n4 ? zt2(t4) : 0;
    r4 = r4 ? !!(32 & i5) : void 0;
    const o4 = Bt3(t4);
    for (let t5 = 0; t5 < o4.length; t5++)
      o4[t5] = Ke3(o4[t5], e4, n4, r4, s4);
    return n4 && (le3(o4, t4), n4(i5, o4)), o4;
  }
  function $e2(t4) {
    return Ke3(t4, qe2, void 0, void 0, false);
  }
  function qe2(t4) {
    return t4.X === te2 ? t4.toJSON() : t4 instanceof je3 ? t4.oa($e2) : function(t5) {
      switch (typeof t5) {
        case "number":
          return isFinite(t5) ? t5 : String(t5);
        case "boolean":
          return t5 ? 1 : 0;
        case "object":
          if (t5)
            if (Array.isArray(t5)) {
              if (ie2(t5, void 0, 0))
                return;
            } else {
              if (R4(t5))
                return k2(t5);
              if (t5 instanceof U4) {
                const e4 = t5.g;
                return null == e4 ? "" : "string" == typeof e4 ? e4 : t5.g = k2(e4);
              }
              if (t5 instanceof je3)
                return t5.oa();
            }
      }
      return t5;
    }(t4);
  }
  function Je3(t4, e4, n4 = Jt2) {
    if (null != t4) {
      if (A2 && t4 instanceof Uint8Array)
        return e4 ? t4 : new Uint8Array(t4);
      if (Array.isArray(t4)) {
        var r4 = zt2(t4);
        return 2 & r4 ? t4 : (e4 &&= 0 === r4 || !!(32 & r4) && !(64 & r4 || !(16 & r4)), e4 ? Yt3(t4, -12293 & (34 | r4)) : Ye2(t4, Je3, 4 & r4 ? Jt2 : n4, true, true));
      }
      return t4.X === te2 ? (n4 = t4.u, t4 = 2 & (r4 = Kt3(n4)) ? t4 : Ze2(t4, n4, r4, true)) : t4 instanceof je3 && !(2 & t4.L) && (n4 = $t2(t4.Y(Je3)), t4 = new je3(n4, t4.U, t4.S, t4.Z)), t4;
    }
  }
  function Ze2(t4, e4, n4, r4) {
    return t4 = t4.constructor, Fe3 = e4 = Qe2(e4, n4, r4), e4 = new t4(e4), Fe3 = void 0, e4;
  }
  function Qe2(t4, e4, n4) {
    const r4 = n4 || 2 & e4 ? Jt2 : qt2, s4 = !!(32 & e4);
    return t4 = function(t5, e5, n5) {
      const r5 = Bt3(t5);
      var s5 = r5.length;
      const i5 = 256 & e5 ? r5[s5 - 1] : void 0;
      for (s5 += i5 ? -1 : 0, e5 = 512 & e5 ? 1 : 0; e5 < s5; e5++)
        r5[e5] = n5(r5[e5]);
      if (i5) {
        e5 = r5[e5] = {};
        for (const t6 in i5)
          e5[t6] = n5(i5[t6]);
      }
      return le3(r5, t5), r5;
    }(t4, e4, (t5) => Je3(t5, s4, r4)), Xt3(t4, 32 | (n4 ? 2 : 0)), t4;
  }
  function tn3(t4) {
    const e4 = t4.u, n4 = Kt3(e4);
    return 2 & n4 ? Ze2(t4, e4, n4, false) : t4;
  }
  function en2(t4, e4) {
    return nn3(t4 = t4.u, Kt3(t4), e4);
  }
  function nn3(t4, e4, n4, r4) {
    if (-1 === n4)
      return null;
    if (n4 >= Zt3(e4)) {
      if (256 & e4)
        return t4[t4.length - 1][n4];
    } else {
      var s4 = t4.length;
      if (r4 && 256 & e4 && null != (r4 = t4[s4 - 1][n4]))
        return r4;
      if ((e4 = n4 + (+!!(512 & e4) - 1)) < s4)
        return t4[e4];
    }
  }
  function rn3(t4, e4, n4, r4) {
    const s4 = t4.u;
    let i5 = Kt3(s4);
    return ae3(i5), sn2(s4, i5, e4, n4, r4), t4;
  }
  function sn2(t4, e4, n4, r4, s4) {
    const i5 = Zt3(e4);
    if (n4 >= i5 || s4) {
      let o4 = e4;
      if (256 & e4)
        s4 = t4[t4.length - 1];
      else {
        if (null == r4)
          return o4;
        s4 = t4[i5 + (+!!(512 & e4) - 1)] = {}, o4 |= 256;
      }
      return s4[n4] = r4, n4 < i5 && (t4[n4 + (+!!(512 & e4) - 1)] = void 0), o4 !== e4 && Yt3(t4, o4), o4;
    }
    return t4[n4 + (+!!(512 & e4) - 1)] = r4, 256 & e4 && (n4 in (t4 = t4[t4.length - 1]) && delete t4[n4]), e4;
  }
  function on2(t4, e4, n4, r4, s4) {
    var i5 = 2 & e4;
    let o4 = nn3(t4, e4, n4, s4);
    Array.isArray(o4) || (o4 = Qt2);
    const a4 = !(2 & r4);
    r4 = !(1 & r4);
    const h4 = !!(32 & e4);
    let c5 = zt2(o4);
    return 0 !== c5 || !h4 || i5 || a4 ? 1 & c5 || (c5 |= 1, Yt3(o4, c5)) : (c5 |= 33, Yt3(o4, c5)), i5 ? (t4 = false, 2 & c5 || ($t2(o4), t4 = !!(4 & c5)), (r4 || t4) && Object.freeze(o4)) : (i5 = !!(2 & c5) || !!(2048 & c5), r4 && i5 ? (o4 = Bt3(o4), r4 = 1, h4 && !a4 && (r4 |= 32), Yt3(o4, r4), sn2(t4, e4, n4, o4, s4)) : a4 && 32 & c5 && !i5 && Ht3(o4, 32)), o4;
  }
  function an2(t4, e4) {
    t4 = t4.u;
    let n4 = Kt3(t4);
    const r4 = nn3(t4, n4, e4), s4 = fe3(r4);
    return null != s4 && s4 !== r4 && sn2(t4, n4, e4, s4), s4;
  }
  function hn3(t4) {
    t4 = t4.u;
    let e4 = Kt3(t4);
    const n4 = nn3(t4, e4, 1), r4 = se2(n4, true, !!(34 & e4));
    return null != r4 && r4 !== n4 && sn2(t4, e4, 1, r4), r4;
  }
  function cn3(t4, e4, n4) {
    t4 = t4.u;
    let r4 = Kt3(t4);
    const s4 = 2 & r4 ? 1 : 2;
    let i5 = un3(t4, r4, e4);
    var o4 = zt2(i5);
    if (!(4 & o4)) {
      (4 & o4 || Object.isFrozen(i5)) && (i5 = Bt3(i5), o4 = Sn2(o4, r4, false), r4 = sn2(t4, r4, e4, i5));
      var a4 = 0;
      let s5 = 0;
      for (; a4 < i5.length; a4++) {
        const t5 = n4(i5[a4]);
        null != t5 && (i5[s5++] = t5);
      }
      s5 < a4 && (i5.length = s5), o4 = Wt3(o4 = ln3(o4, r4, false), 20, true), o4 = Wt3(o4, 4096, false), o4 = Wt3(o4, 8192, false), Yt3(i5, o4), 2 & o4 && Object.freeze(i5);
    }
    return dn3(o4) || (n4 = o4, (o4 = (a4 = 1 === s4) ? Wt3(o4, 2, true) : Wt3(o4, 32, false)) !== n4 && Yt3(i5, o4), a4 && Object.freeze(i5)), 2 === s4 && dn3(o4) && (i5 = Bt3(i5), o4 = Sn2(o4, r4, false), Yt3(i5, o4), sn2(t4, r4, e4, i5)), i5;
  }
  function un3(t4, e4, n4) {
    return t4 = nn3(t4, e4, n4), Array.isArray(t4) ? t4 : Qt2;
  }
  function ln3(t4, e4, n4) {
    return 0 === t4 && (t4 = Sn2(t4, e4, n4)), Wt3(t4, 1, true);
  }
  function dn3(t4) {
    return !!(2 & t4) && !!(4 & t4) || !!(2048 & t4);
  }
  function fn3(t4) {
    t4 = Bt3(t4);
    for (let e4 = 0; e4 < t4.length; e4++) {
      const n4 = t4[e4] = Bt3(t4[e4]);
      Array.isArray(n4[1]) && (n4[1] = $t2(n4[1]));
    }
    return t4;
  }
  function pn3(t4, e4, n4) {
    {
      const o4 = t4.u;
      let a4 = Kt3(o4);
      if (ae3(a4), null == n4)
        sn2(o4, a4, e4);
      else {
        var r4, s4 = t4 = zt2(n4), i5 = !!(2 & t4) || Object.isFrozen(n4);
        if ((r4 = !i5) && (r4 = false), !(4 & t4))
          for (t4 = 21, i5 && (n4 = Bt3(n4), s4 = 0, t4 = Sn2(t4, a4, true)), i5 = 0; i5 < n4.length; i5++)
            n4[i5] = be3(n4[i5]);
        r4 && (n4 = Bt3(n4), s4 = 0, t4 = Sn2(t4, a4, true)), t4 !== s4 && Yt3(n4, t4), sn2(o4, a4, e4, n4);
      }
    }
  }
  function gn3(t4, e4, n4, r4) {
    t4 = t4.u;
    let s4 = Kt3(t4);
    ae3(s4), sn2(t4, s4, e4, ("0" === r4 ? 0 === Number(n4) : n4 === r4) ? void 0 : n4);
  }
  function mn3(t4, e4, n4, r4) {
    const s4 = Kt3(t4);
    ae3(s4), t4 = on2(t4, s4, e4, 2), r4 = n4(r4, !!(4 & (e4 = zt2(t4))) && !!(4096 & e4)), t4.push(r4);
  }
  function yn3(t4) {
    return t4;
  }
  function _n2(t4, e4) {
    return vn2(t4 = t4.u, Kt3(t4), di2) === e4 ? e4 : -1;
  }
  function vn2(t4, e4, n4) {
    let r4 = 0;
    for (let s4 = 0; s4 < n4.length; s4++) {
      const i5 = n4[s4];
      null != nn3(t4, e4, i5) && (0 !== r4 && (e4 = sn2(t4, e4, r4)), r4 = i5);
    }
    return r4;
  }
  function En2(t4, e4, n4, r4) {
    let s4 = Kt3(t4);
    ae3(s4);
    const i5 = nn3(t4, s4, n4, r4);
    let o4;
    if (null != i5 && i5.X === te2)
      return (e4 = tn3(i5)) !== i5 && sn2(t4, s4, n4, e4, r4), e4.u;
    if (Array.isArray(i5)) {
      const t5 = zt2(i5);
      o4 = 2 & t5 ? Qe2(i5, t5, false) : i5, o4 = Oe3(o4, e4);
    } else
      o4 = Oe3(void 0, e4);
    return o4 !== i5 && sn2(t4, s4, n4, o4, r4), o4;
  }
  function wn2(t4, e4, n4, r4) {
    t4 = t4.u;
    let s4 = Kt3(t4);
    const i5 = nn3(t4, s4, n4, r4);
    return (e4 = Se3(i5, e4, false, s4)) !== i5 && null != e4 && sn2(t4, s4, n4, e4, r4), e4;
  }
  function Tn3(t4, e4, n4, r4 = false) {
    if (null == (e4 = wn2(t4, e4, n4, r4)))
      return e4;
    t4 = t4.u;
    let s4 = Kt3(t4);
    if (!(2 & s4)) {
      const i5 = tn3(e4);
      i5 !== e4 && sn2(t4, s4, n4, e4 = i5, r4);
    }
    return e4;
  }
  function An2(t4, e4, n4, r4, s4, i5) {
    var o4 = !!(2 & e4), a4 = o4 ? 1 : 2;
    const h4 = 1 === a4;
    a4 = 2 === a4, s4 = !!s4, i5 &&= !o4, o4 = un3(t4, e4, r4);
    var c5 = zt2(o4);
    const u4 = !!(4 & c5);
    if (!u4) {
      var l4 = o4, d4 = e4;
      const t5 = !!(2 & (c5 = ln3(c5, e4, s4)));
      t5 && (d4 = Wt3(d4, 2, true));
      let r5 = !t5, i6 = true, a5 = 0, h5 = 0;
      for (; a5 < l4.length; a5++) {
        const e5 = Se3(l4[a5], n4, false, d4);
        if (e5 instanceof n4) {
          if (!t5) {
            const t6 = !!(2 & zt2(e5.u));
            r5 &&= !t6, i6 &&= t6;
          }
          l4[h5++] = e5;
        }
      }
      h5 < a5 && (l4.length = h5), c5 = Wt3(c5, 4, true), c5 = Wt3(c5, 16, i6), c5 = Wt3(c5, 8, r5), Yt3(l4, c5), t5 && Object.freeze(l4);
    }
    if (n4 = !!(8 & c5) || h4 && !o4.length, i5 && !n4) {
      for (dn3(c5) && (o4 = Bt3(o4), c5 = Sn2(c5, e4, s4), e4 = sn2(t4, e4, r4, o4)), i5 = o4, n4 = c5, l4 = 0; l4 < i5.length; l4++)
        (c5 = i5[l4]) !== (d4 = tn3(c5)) && (i5[l4] = d4);
      n4 = Wt3(n4, 8, true), n4 = Wt3(n4, 16, !i5.length), Yt3(i5, n4), c5 = n4;
    }
    return dn3(c5) || (i5 = c5, h4 ? c5 = Wt3(c5, !o4.length || 16 & c5 && (!u4 || 32 & c5) ? 2 : 2048, true) : s4 || (c5 = Wt3(c5, 32, false)), c5 !== i5 && Yt3(o4, c5), h4 && Object.freeze(o4)), a4 && dn3(c5) && (o4 = Bt3(o4), c5 = Sn2(c5, e4, s4), Yt3(o4, c5), sn2(t4, e4, r4, o4)), o4;
  }
  function bn3(t4, e4, n4) {
    t4 = t4.u;
    const r4 = Kt3(t4);
    return An2(t4, r4, e4, n4, false, !(2 & r4));
  }
  function kn3(t4, e4, n4, r4, s4) {
    return null == r4 && (r4 = void 0), rn3(t4, n4, r4, s4);
  }
  function xn3(t4, e4, n4, r4) {
    null == r4 && (r4 = void 0), t4 = t4.u;
    let s4 = Kt3(t4);
    ae3(s4), (n4 = vn2(t4, s4, n4)) && n4 !== e4 && null != r4 && (s4 = sn2(t4, s4, n4)), sn2(t4, s4, e4, r4);
  }
  function Sn2(t4, e4, n4) {
    return t4 = Wt3(t4, 2, !!(2 & e4)), t4 = Wt3(t4, 32, !!(32 & e4) && n4), Wt3(t4, 2048, false);
  }
  function Ln3(t4, e4, n4, r4) {
    t4 = t4.u;
    const s4 = Kt3(t4);
    ae3(s4), e4 = An2(t4, s4, n4, e4, true), n4 = null != r4 ? r4 : new n4(), e4.push(n4), 2 & zt2(n4.u) ? Ht3(e4, 8) : Ht3(e4, 16);
  }
  function Fn3(t4, e4) {
    return ye4(en2(t4, e4));
  }
  function Rn3(t4, e4) {
    return xe4(en2(t4, e4));
  }
  function Mn3(t4) {
    return t4 ?? 0;
  }
  function Pn2(t4, e4) {
    return Mn3(an2(t4, e4));
  }
  function On2(t4, e4, n4) {
    if (null != n4 && "boolean" != typeof n4)
      throw t4 = typeof n4, Error(`Expected boolean but got ${"object" != t4 ? t4 : n4 ? Array.isArray(n4) ? "array" : t4 : "null"}: ${n4}`);
    rn3(t4, e4, n4);
  }
  function Cn3(t4, e4, n4) {
    if (null != n4) {
      if ("number" != typeof n4)
        throw de2("int32");
      if (!Number.isFinite(n4))
        throw de2("int32");
      n4 |= 0;
    }
    rn3(t4, e4, n4);
  }
  function In2(t4, e4, n4) {
    if (null != n4 && "number" != typeof n4)
      throw Error(`Value of float/double field must be a number, found ${typeof n4}: ${n4}`);
    rn3(t4, e4, n4);
  }
  function Dn3(t4, e4, n4) {
    e4.g ? e4.m(t4, e4.g, e4.h, n4, true) : e4.m(t4, e4.h, n4, true);
  }
  function Un3(t4, e4, n4) {
    var r4 = d3 ? void 0 : t4.constructor.A;
    const s4 = Kt3(n4 ? t4.u : e4);
    if (!(t4 = e4.length))
      return e4;
    let i5, o4;
    if (re3(n4 = e4[t4 - 1])) {
      t: {
        var a4 = n4;
        let t5 = {}, e5 = false;
        for (var h4 in a4) {
          let n5 = a4[h4];
          if (Array.isArray(n5)) {
            let t6 = n5;
            (ie2(n5, r4, +h4) || ne2(n5) && 0 === n5.size) && (n5 = null), n5 != t6 && (e5 = true);
          }
          null != n5 ? t5[h4] = n5 : e5 = true;
        }
        if (e5) {
          for (var c5 in t5) {
            a4 = t5;
            break t;
          }
          a4 = null;
        }
      }
      a4 != n4 && (i5 = true), t4--;
    }
    for (h4 = +!!(512 & s4) - 1; 0 < t4 && (n4 = e4[c5 = t4 - 1], c5 -= h4, null == n4 || ie2(n4, r4, c5) || ne2(n4) && 0 === n4.size); t4--)
      o4 = true;
    return i5 || o4 ? (e4 = Array.prototype.slice.call(e4, 0, t4), a4 && e4.push(a4), e4) : e4;
  }
  function Bn3(t4) {
    return Array.isArray(t4) ? t4[0] instanceof Ut2 ? t4 : [Gr3, t4] : [t4, void 0];
  }
  function Gn3(t4, e4) {
    if (Array.isArray(e4)) {
      var n4 = zt2(e4);
      if (4 & n4)
        return e4;
      for (var r4 = 0, s4 = 0; r4 < e4.length; r4++) {
        const n5 = t4(e4[r4]);
        null != n5 && (e4[s4++] = n5);
      }
      return s4 < r4 && (e4.length = s4), Yt3(e4, -12289 & (5 | n4)), 2 & n4 && Object.freeze(e4), e4;
    }
  }
  function Vn3(t4) {
    let e4 = t4[jn2];
    if (!e4) {
      const n4 = qn2(t4), r4 = hr3(t4), s4 = r4.l;
      e4 = s4 ? (t5, e5) => s4(t5, e5, r4) : (t5, e5) => {
        for (; gt2(e5) && 4 != e5.h; ) {
          var s5 = e5.m, i5 = r4[s5];
          if (!i5) {
            var o4 = r4.ea;
            o4 && (o4 = o4[s5]) && (i5 = r4[s5] = Xn3(o4));
          }
          i5 && i5(e5, t5, s5) || (s5 = (i5 = e5).l, mt2(i5), i5.ia ? i5 = void 0 : (o4 = i5.g.g - s5, i5.g.g = s5, i5 = ft3(i5.g, o4)), s5 = t5, i5 && (ce4 ||= Symbol(), (o4 = s5[ce4]) ? o4.push(i5) : s5[ce4] = [i5]));
        }
        n4 === Wn3 || n4 === zn3 || n4.j || (t5[ue3 ||= Symbol()] = n4);
      }, t4[jn2] = e4;
    }
    return e4;
  }
  function Xn3(t4) {
    const e4 = (t4 = Bn3(t4))[0].g;
    if (t4 = t4[1]) {
      const n4 = Vn3(t4), r4 = hr3(t4).T;
      return (t5, s4, i5) => e4(t5, s4, i5, r4, n4);
    }
    return e4;
  }
  function Yn2(t4, e4, n4) {
    const r4 = n4[1];
    let s4;
    if (r4) {
      const n5 = r4[Kn3];
      s4 = n5 ? n5.T : Pe2(r4[0]), t4[e4] = n5 ?? r4;
    }
    s4 && s4 === Re3 ? (t4.g || (t4.g = /* @__PURE__ */ new Set())).add(e4) : n4[0] && (t4.h || (t4.h = /* @__PURE__ */ new Set())).add(e4);
  }
  function $n3(t4, e4) {
    return [t4.l, !e4 || 0 < e4[0] ? void 0 : e4];
  }
  function qn2(t4) {
    var e4 = t4[Kn3];
    if (e4)
      return e4;
    if (!(e4 = Zn3(t4, t4[Kn3] = new Hn2(), $n3, $n3, Yn2)).ea && !e4.h && !e4.g) {
      let n4 = true;
      for (let t5 in e4)
        isNaN(t5) || (n4 = false);
      n4 ? (Pe2(t4[0]) === Re3 ? zn3 ? e4 = zn3 : ((e4 = new Hn2()).T = Pe2(true), e4 = zn3 = e4) : e4 = Wn3 ||= new Hn2(), e4 = t4[Kn3] = e4) : e4.j = true;
    }
    return e4;
  }
  function Jn3(t4, e4, n4) {
    t4[e4] = n4;
  }
  function Zn3(t4, e4, n4, r4, s4 = Jn3) {
    e4.T = Pe2(t4[0]);
    let i5 = 0;
    var o4 = t4[++i5];
    o4 && o4.constructor === Object && (e4.ea = o4, "function" == typeof (o4 = t4[++i5]) && (e4.l = o4, e4.m = t4[++i5], o4 = t4[++i5]));
    const a4 = {};
    for (; Array.isArray(o4) && "number" == typeof o4[0] && 0 < o4[0]; ) {
      for (var h4 = 0; h4 < o4.length; h4++)
        a4[o4[h4]] = o4;
      o4 = t4[++i5];
    }
    for (h4 = 1; void 0 !== o4; ) {
      let l4;
      "number" == typeof o4 && (h4 += o4, o4 = t4[++i5]);
      var c5 = void 0;
      if (o4 instanceof Ut2 ? l4 = o4 : (l4 = jr2, i5--), l4.pa) {
        o4 = t4[++i5], c5 = t4;
        var u4 = i5;
        "function" == typeof o4 && (o4 = o4(), c5[u4] = o4), c5 = o4;
      }
      for (u4 = h4 + 1, "number" == typeof (o4 = t4[++i5]) && 0 > o4 && (u4 -= o4, o4 = t4[++i5]); h4 < u4; h4++) {
        const t5 = a4[h4];
        s4(e4, h4, c5 ? r4(l4, c5, t5) : n4(l4, t5));
      }
    }
    return e4;
  }
  function tr3(t4) {
    let e4 = t4[Qn3];
    if (!e4) {
      const n4 = sr3(t4);
      e4 = (t5, e5) => lr3(t5, e5, n4), t4[Qn3] = e4;
    }
    return e4;
  }
  function nr2(t4) {
    return t4.h;
  }
  function rr2(t4, e4) {
    let n4, r4;
    const s4 = t4.h;
    return (t5, i5, o4) => s4(t5, i5, o4, r4 ||= sr3(e4).T, n4 ||= tr3(e4));
  }
  function sr3(t4) {
    let e4 = t4[er3];
    return e4 || (e4 = Zn3(t4, t4[er3] = {}, nr2, rr2), cr3(t4), e4);
  }
  function or2(t4, e4) {
    const n4 = t4.g;
    return e4 ? (t5, r4, s4) => n4(t5, r4, s4, e4) : n4;
  }
  function ar2(t4, e4, n4) {
    const r4 = t4.g;
    let s4, i5;
    return (t5, o4, a4) => r4(t5, o4, a4, i5 ||= hr3(e4).T, s4 ||= Vn3(e4), n4);
  }
  function hr3(t4) {
    let e4 = t4[ir2];
    return e4 || (qn2(t4), e4 = Zn3(t4, t4[ir2] = {}, or2, ar2), cr3(t4), e4);
  }
  function cr3(t4) {
    ir2 in t4 && Kn3 in t4 && er3 in t4 && (t4.length = 0);
  }
  function ur3(t4, e4) {
    var n4 = t4[e4];
    if (n4)
      return n4;
    if ((n4 = t4.ea) && (n4 = n4[e4])) {
      var r4 = (n4 = Bn3(n4))[0].h;
      if (n4 = n4[1]) {
        const e5 = tr3(n4), s4 = sr3(n4).T;
        n4 = (n4 = t4.m) ? n4(s4, e5) : (t5, n5, i5) => r4(t5, n5, i5, s4, e5);
      } else
        n4 = r4;
      return t4[e4] = n4;
    }
  }
  function lr3(t4, e4, n4) {
    for (var r4 = Kt3(t4), s4 = +!!(512 & r4) - 1, i5 = t4.length, o4 = 512 & r4 ? 1 : 0, a4 = i5 + (256 & r4 ? -1 : 0); o4 < a4; o4++) {
      const r5 = t4[o4];
      if (null == r5)
        continue;
      const i6 = o4 - s4, a5 = ur3(n4, i6);
      a5 && a5(e4, r5, i6);
    }
    if (256 & r4) {
      r4 = t4[i5 - 1];
      for (let t5 in r4)
        s4 = +t5, Number.isNaN(s4) || null != (i5 = r4[t5]) && (a4 = ur3(n4, s4)) && a4(e4, i5, s4);
    }
    if (t4 = ce4 ? t4[ce4] : void 0)
      for (Pt2(e4, e4.g.end()), n4 = 0; n4 < t4.length; n4++)
        Pt2(e4, N3(t4[n4]) || P2());
  }
  function dr2(t4, e4) {
    return new Ut2(t4, e4, false, false);
  }
  function fr3(t4, e4) {
    return new Ut2(t4, e4, true, false);
  }
  function pr2(t4, e4) {
    return new Ut2(t4, e4, false, true);
  }
  function gr3(t4, e4, n4) {
    sn2(t4, Kt3(t4), e4, n4);
  }
  function yr3(t4, e4, n4) {
    t:
      if (null != e4) {
        if (me3(e4)) {
          if ("string" == typeof e4) {
            e4 = Te3(e4);
            break t;
          }
          if ("number" == typeof e4) {
            e4 = we3(e4);
            break t;
          }
        }
        e4 = void 0;
      }
    null != e4 && ("string" == typeof e4 && kt3(e4), null != e4 && (Ot3(t4, n4, 0), "number" == typeof e4 ? (t4 = t4.g, Y2(e4), Lt2(t4, z3, K4)) : (n4 = kt3(e4), Lt2(t4.g, n4.h, n4.g))));
  }
  function _r3(t4, e4, n4) {
    null != (e4 = ye4(e4)) && null != e4 && (Ot3(t4, n4, 0), Rt3(t4.g, e4));
  }
  function vr3(t4, e4, n4) {
    null != (e4 = pe2(e4)) && (Ot3(t4, n4, 0), t4.g.g.push(e4 ? 1 : 0));
  }
  function Er2(t4, e4, n4) {
    null != (e4 = xe4(e4)) && Dt2(t4, n4, c3(e4));
  }
  function wr3(t4, e4, n4, r4, s4) {
    Nt3(t4, n4, e4 instanceof Nn3 ? e4.u : Array.isArray(e4) ? Oe3(e4, r4) : void 0, s4);
  }
  function Tr3(t4, e4, n4) {
    null != (e4 = null == e4 || "string" == typeof e4 || R4(e4) || e4 instanceof U4 ? e4 : void 0) && Dt2(t4, n4, V3(e4).buffer);
  }
  function Ar2(t4, e4, n4) {
    return (5 === t4.h || 2 === t4.h) && (e4 = on2(e4, Kt3(e4), n4, 2, false), 2 == t4.h ? Et2(t4, ht3, e4) : e4.push(ht3(t4.g)), true);
  }
  function Yr2(t4, e4) {
    return new Kr2(t4, e4);
  }
  function $r3(t4, e4) {
    return (n4, r4) => {
      t: {
        if (wt3.length) {
          const t5 = wt3.pop();
          t5.o(r4), ut3(t5.g, n4, r4), n4 = t5;
        } else
          n4 = new class {
            constructor(t5, e5) {
              if (pt3.length) {
                const n5 = pt3.pop();
                ut3(n5, t5, e5), t5 = n5;
              } else
                t5 = new class {
                  constructor(t6, e6) {
                    this.h = null, this.m = false, this.g = this.l = this.j = 0, ut3(this, t6, e6);
                  }
                  clear() {
                    this.h = null, this.m = false, this.g = this.l = this.j = 0, this.ca = false;
                  }
                }(t5, e5);
              this.g = t5, this.l = this.g.g, this.h = this.m = -1, this.o(e5);
            }
            o({ ia: t5 = false } = {}) {
              this.ia = t5;
            }
          }(n4, r4);
        try {
          const r5 = new t4(), i5 = r5.u;
          Vn3(e4)(i5, n4);
          var s4 = r5;
          break t;
        } finally {
          n4.g.clear(), n4.m = -1, n4.h = -1, 100 > wt3.length && wt3.push(n4);
        }
        s4 = void 0;
      }
      return s4;
    };
  }
  function qr3(t4) {
    return function() {
      const e4 = new class {
        constructor() {
          this.l = [], this.h = 0, this.g = new class {
            constructor() {
              this.g = [];
            }
            length() {
              return this.g.length;
            }
            end() {
              const t5 = this.g;
              return this.g = [], t5;
            }
          }();
        }
      }();
      lr3(this.u, e4, sr3(t4)), Pt2(e4, e4.g.end());
      const n4 = new Uint8Array(e4.h), r4 = e4.l, s4 = r4.length;
      let i5 = 0;
      for (let t5 = 0; t5 < s4; t5++) {
        const e5 = r4[t5];
        n4.set(e5, i5), i5 += e5.length;
      }
      return e4.l = [n4], n4;
    };
  }
  function ms2(t4, e4) {
    gn3(t4, 2, ke3(e4), "");
  }
  function ys2(t4, e4) {
    mn3(t4.u, 3, be3, e4);
  }
  function _s2(t4, e4) {
    mn3(t4.u, 4, be3, e4);
  }
  function ks2(t4, e4) {
    Ln3(t4, 1, vs2, e4);
  }
  function xs2(t4, e4) {
    mn3(t4.u, 10, be3, e4);
  }
  function Ss2(t4, e4) {
    mn3(t4.u, 15, be3, e4);
  }
  function Ao3(t4, e4) {
    return e4 = e4 ? e4.clone() : new mi2(), void 0 !== t4.displayNamesLocale ? rn3(e4, 1, ke3(t4.displayNamesLocale)) : void 0 === t4.displayNamesLocale && rn3(e4, 1), void 0 !== t4.maxResults ? Cn3(e4, 2, t4.maxResults) : "maxResults" in t4 && rn3(e4, 2), void 0 !== t4.scoreThreshold ? In2(e4, 3, t4.scoreThreshold) : "scoreThreshold" in t4 && rn3(e4, 3), void 0 !== t4.categoryAllowlist ? pn3(e4, 4, t4.categoryAllowlist) : "categoryAllowlist" in t4 && rn3(e4, 4), void 0 !== t4.categoryDenylist ? pn3(e4, 5, t4.categoryDenylist) : "categoryDenylist" in t4 && rn3(e4, 5), e4;
  }
  function bo3(t4, e4 = -1, n4 = "") {
    return { categories: t4.map((t5) => ({ index: Mn3(Fn3(t5, 1)) ?? -1, score: Pn2(t5, 2) ?? 0, categoryName: Rn3(t5, 3) ?? "" ?? "", displayName: Rn3(t5, 4) ?? "" ?? "" })), headIndex: e4, headName: n4 };
  }
  function ko3(t4) {
    var e4 = cn3(t4, 3, fe3), n4 = cn3(t4, 2, ye4), r4 = cn3(t4, 1, xe4), s4 = cn3(t4, 9, xe4);
    const i5 = { categories: [], keypoints: [] };
    for (let t5 = 0; t5 < e4.length; t5++)
      i5.categories.push({ score: e4[t5], index: n4[t5] ?? -1, categoryName: r4[t5] ?? "", displayName: s4[t5] ?? "" });
    if ((e4 = Tn3(t4, Hs, 4)?.h()) && (i5.boundingBox = { originX: Fn3(e4, 1) ?? 0, originY: Fn3(e4, 2) ?? 0, width: Fn3(e4, 3) ?? 0, height: Fn3(e4, 4) ?? 0, angle: 0 }), Tn3(t4, Hs, 4)?.g().length)
      for (const e5 of Tn3(t4, Hs, 4).g())
        i5.keypoints.push({ x: an2(e5, 1) ?? 0, y: an2(e5, 2) ?? 0, score: an2(e5, 4) ?? 0, label: Rn3(e5, 3) ?? "" });
    return i5;
  }
  function xo3(t4) {
    const e4 = [];
    for (const n4 of bn3(t4, Zs, 1))
      e4.push({ x: Pn2(n4, 1) ?? 0, y: Pn2(n4, 2) ?? 0, z: Pn2(n4, 3) ?? 0, visibility: Pn2(n4, 4) ?? 0 });
    return e4;
  }
  function So3(t4) {
    const e4 = [];
    for (const n4 of bn3(t4, Ys, 1))
      e4.push({ x: Pn2(n4, 1) ?? 0, y: Pn2(n4, 2) ?? 0, z: Pn2(n4, 3) ?? 0, visibility: Pn2(n4, 4) ?? 0 });
    return e4;
  }
  function Lo3(t4) {
    return Array.from(t4, (t5) => 127 < t5 ? t5 - 256 : t5);
  }
  function Fo3(t4, e4) {
    if (t4.length !== e4.length)
      throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t4.length} vs. ${e4.length}).`);
    let n4 = 0, r4 = 0, s4 = 0;
    for (let i5 = 0; i5 < t4.length; i5++)
      n4 += t4[i5] * e4[i5], r4 += t4[i5] * t4[i5], s4 += e4[i5] * e4[i5];
    if (0 >= r4 || 0 >= s4)
      throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
    return n4 / Math.sqrt(r4 * s4);
  }
  async function Po3() {
    if (void 0 === Ro)
      try {
        await WebAssembly.instantiate(Mo), Ro = true;
      } catch {
        Ro = false;
      }
    return Ro;
  }
  async function Oo3(t4, e4 = "") {
    const n4 = await Po3() ? "wasm_internal" : "wasm_nosimd_internal";
    return { wasmLoaderPath: `${e4}/${t4}_${n4}.js`, wasmBinaryPath: `${e4}/${t4}_${n4}.wasm` };
  }
  function Io3() {
    const t4 = navigator.userAgent;
    return t4.includes("Safari") && !t4.includes("Chrome");
  }
  async function Do2(t4) {
    if ("function" != typeof importScripts) {
      const e4 = document.createElement("script");
      return e4.src = t4.toString(), e4.crossOrigin = "anonymous", new Promise((t5, n4) => {
        e4.addEventListener("load", () => {
          t5();
        }, false), e4.addEventListener("error", (t6) => {
          n4(t6);
        }, false), document.body.appendChild(e4);
      });
    }
    importScripts(t4.toString());
  }
  function No(t4) {
    return void 0 !== t4.videoWidth ? [t4.videoWidth, t4.videoHeight] : void 0 !== t4.naturalWidth ? [t4.naturalWidth, t4.naturalHeight] : void 0 !== t4.displayWidth ? [t4.displayWidth, t4.displayHeight] : [t4.width, t4.height];
  }
  function Uo2(t4, e4, n4) {
    t4.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n4(e4 = t4.i.stringToNewUTF8(e4)), t4.i._free(e4);
  }
  function Bo2(t4, e4, n4) {
    if (!t4.i.canvas)
      throw Error("No OpenGL canvas configured.");
    if (n4 ? t4.i._bindTextureToStream(n4) : t4.i._bindTextureToCanvas(), !(n4 = t4.i.canvas.getContext("webgl2") || t4.i.canvas.getContext("webgl")))
      throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
    t4.i.gpuOriginForWebTexturesIsBottomLeft && n4.pixelStorei(n4.UNPACK_FLIP_Y_WEBGL, true), n4.texImage2D(n4.TEXTURE_2D, 0, n4.RGBA, n4.RGBA, n4.UNSIGNED_BYTE, e4), t4.i.gpuOriginForWebTexturesIsBottomLeft && n4.pixelStorei(n4.UNPACK_FLIP_Y_WEBGL, false);
    const [r4, s4] = No(e4);
    return !t4.l || r4 === t4.i.canvas.width && s4 === t4.i.canvas.height || (t4.i.canvas.width = r4, t4.i.canvas.height = s4), [r4, s4];
  }
  function Go(t4, e4, n4) {
    t4.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
    const r4 = new Uint32Array(e4.length);
    for (let n5 = 0; n5 < e4.length; n5++)
      r4[n5] = t4.i.stringToNewUTF8(e4[n5]);
    e4 = t4.i._malloc(4 * r4.length), t4.i.HEAPU32.set(r4, e4 >> 2), n4(e4);
    for (const e5 of r4)
      t4.i._free(e5);
    t4.i._free(e4);
  }
  function jo3(t4, e4, n4) {
    t4.i.simpleListeners = t4.i.simpleListeners || {}, t4.i.simpleListeners[e4] = n4;
  }
  function Vo2(t4, e4, n4) {
    let r4 = [];
    t4.i.simpleListeners = t4.i.simpleListeners || {}, t4.i.simpleListeners[e4] = (t5, e5, s4) => {
      e5 ? (n4(r4, s4), r4 = []) : r4.push(t5);
    };
  }
  async function Xo2(t4, e4, n4, r4) {
    return t4 = await (async (t5, e5, n5, r5, s4) => {
      if (e5 && await Do2(e5), !self.ModuleFactory)
        throw Error("ModuleFactory not set.");
      if (n5 && (await Do2(n5), !self.ModuleFactory))
        throw Error("ModuleFactory not set.");
      return self.Module && s4 && ((e5 = self.Module).locateFile = s4.locateFile, s4.mainScriptUrlOrBlob && (e5.mainScriptUrlOrBlob = s4.mainScriptUrlOrBlob)), s4 = await self.ModuleFactory(self.Module || s4), self.ModuleFactory = self.Module = void 0, new t5(s4, r5);
    })(t4, n4.wasmLoaderPath, n4.assetLoaderPath, e4, { locateFile: (t5) => t5.endsWith(".wasm") ? n4.wasmBinaryPath.toString() : n4.assetBinaryPath && t5.endsWith(".data") ? n4.assetBinaryPath.toString() : t5 }), await t4.o(r4), t4;
  }
  function Ho2(t4, e4) {
    const n4 = Tn3(t4.baseOptions, Ti2, 1) || new Ti2();
    "string" == typeof e4 ? (rn3(n4, 2, ke3(e4)), rn3(n4, 1)) : e4 instanceof Uint8Array && (rn3(n4, 1, se2(e4, false, false)), rn3(n4, 2)), kn3(t4.baseOptions, 0, 1, n4);
  }
  function Wo(t4) {
    try {
      const e4 = t4.H.length;
      if (1 === e4)
        throw Error(t4.H[0].message);
      if (1 < e4)
        throw Error("Encountered multiple errors: " + t4.H.map((t5) => t5.message).join(", "));
    } finally {
      t4.H = [];
    }
  }
  function zo(t4, e4) {
    t4.C = Math.max(t4.C, e4);
  }
  function Ko2(t4, e4) {
    t4.B = new vs2(), ms2(t4.B, "PassThroughCalculator"), ys2(t4.B, "free_memory"), _s2(t4.B, "free_memory_unused_out"), xs2(e4, "free_memory"), ks2(e4, t4.B);
  }
  function Yo2(t4, e4) {
    ys2(t4.B, e4), _s2(t4.B, e4 + "_unused_out");
  }
  function $o2(t4) {
    t4.g.addBoolToStream(true, "free_memory", t4.C);
  }
  function Jo2(t4, e4) {
    if (!t4)
      throw Error(`Unable to obtain required WebGL resource: ${e4}`);
    return t4;
  }
  function Qo2(t4, e4, n4) {
    const r4 = t4.g;
    if (n4 = Jo2(r4.createShader(n4), "Failed to create WebGL shader"), r4.shaderSource(n4, e4), r4.compileShader(n4), !r4.getShaderParameter(n4, r4.COMPILE_STATUS))
      throw Error(`Could not compile WebGL shader: ${r4.getShaderInfoLog(n4)}`);
    return r4.attachShader(t4.h, n4), n4;
  }
  function ta2(t4, e4) {
    const n4 = t4.g, r4 = Jo2(n4.createVertexArray(), "Failed to create vertex array");
    n4.bindVertexArray(r4);
    const s4 = Jo2(n4.createBuffer(), "Failed to create buffer");
    n4.bindBuffer(n4.ARRAY_BUFFER, s4), n4.enableVertexAttribArray(t4.P), n4.vertexAttribPointer(t4.P, 2, n4.FLOAT, false, 0, 0), n4.bufferData(n4.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n4.STATIC_DRAW);
    const i5 = Jo2(n4.createBuffer(), "Failed to create buffer");
    return n4.bindBuffer(n4.ARRAY_BUFFER, i5), n4.enableVertexAttribArray(t4.O), n4.vertexAttribPointer(t4.O, 2, n4.FLOAT, false, 0, 0), n4.bufferData(n4.ARRAY_BUFFER, new Float32Array(e4 ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), n4.STATIC_DRAW), n4.bindBuffer(n4.ARRAY_BUFFER, null), n4.bindVertexArray(null), new Zo(n4, r4, s4, i5);
  }
  function ea2(t4, e4) {
    if (t4.g) {
      if (e4 !== t4.g)
        throw Error("Cannot change GL context once initialized");
    } else
      t4.g = e4;
  }
  function na2(t4, e4, n4, r4) {
    return ea2(t4, e4), t4.h || (t4.m(), t4.D()), n4 ? (t4.s || (t4.s = ta2(t4, true)), n4 = t4.s) : (t4.v || (t4.v = ta2(t4, false)), n4 = t4.v), e4.useProgram(t4.h), n4.bind(), t4.l(), t4 = r4(), n4.g.bindVertexArray(null), t4;
  }
  function ra2(t4, e4, n4) {
    return ea2(t4, e4), t4 = Jo2(e4.createTexture(), "Failed to create texture"), e4.bindTexture(e4.TEXTURE_2D, t4), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_S, e4.CLAMP_TO_EDGE), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_T, e4.CLAMP_TO_EDGE), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MIN_FILTER, n4 ?? e4.LINEAR), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MAG_FILTER, n4 ?? e4.LINEAR), e4.bindTexture(e4.TEXTURE_2D, null), t4;
  }
  function sa2(t4, e4, n4) {
    ea2(t4, e4), t4.B || (t4.B = Jo2(e4.createFramebuffer(), "Failed to create framebuffe.")), e4.bindFramebuffer(e4.FRAMEBUFFER, t4.B), e4.framebufferTexture2D(e4.FRAMEBUFFER, e4.COLOR_ATTACHMENT0, e4.TEXTURE_2D, n4, 0);
  }
  function ia(t4) {
    t4.g?.bindFramebuffer(t4.g.FRAMEBUFFER, null);
  }
  function ca2(t4, e4) {
    switch (e4) {
      case 0:
        return t4.g.find((t5) => t5 instanceof Uint8Array);
      case 1:
        return t4.g.find((t5) => t5 instanceof Float32Array);
      case 2:
        return t4.g.find((t5) => "undefined" != typeof WebGLTexture && t5 instanceof WebGLTexture);
      default:
        throw Error(`Type is not supported: ${e4}`);
    }
  }
  function ua2(t4) {
    var e4 = ca2(t4, 1);
    if (!e4) {
      if (e4 = ca2(t4, 0))
        e4 = new Float32Array(e4).map((t5) => t5 / 255);
      else {
        e4 = new Float32Array(t4.width * t4.height);
        const r4 = da2(t4);
        var n4 = pa2(t4);
        if (sa2(n4, r4, la2(t4)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in self.document) {
          n4 = new Float32Array(t4.width * t4.height * 4), r4.readPixels(0, 0, t4.width, t4.height, r4.RGBA, r4.FLOAT, n4);
          for (let t5 = 0, r5 = 0; t5 < e4.length; ++t5, r5 += 4)
            e4[t5] = n4[r5];
        } else
          r4.readPixels(0, 0, t4.width, t4.height, r4.RED, r4.FLOAT, e4);
      }
      t4.g.push(e4);
    }
    return e4;
  }
  function la2(t4) {
    let e4 = ca2(t4, 2);
    if (!e4) {
      const n4 = da2(t4);
      e4 = ga(t4);
      const r4 = ua2(t4), s4 = fa2(t4);
      n4.texImage2D(n4.TEXTURE_2D, 0, s4, t4.width, t4.height, 0, n4.RED, n4.FLOAT, r4), ma2(t4);
    }
    return e4;
  }
  function da2(t4) {
    if (!t4.canvas)
      throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
    return t4.h || (t4.h = Jo2(t4.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t4.h;
  }
  function fa2(t4) {
    if (t4 = da2(t4), !ya)
      if (t4.getExtension("EXT_color_buffer_float") && t4.getExtension("OES_texture_float_linear") && t4.getExtension("EXT_float_blend"))
        ya = t4.R32F;
      else {
        if (!t4.getExtension("EXT_color_buffer_half_float"))
          throw Error("GPU does not fully support 4-channel float32 or float16 formats");
        ya = t4.R16F;
      }
    return ya;
  }
  function pa2(t4) {
    return t4.l || (t4.l = new oa2()), t4.l;
  }
  function ga(t4) {
    const e4 = da2(t4);
    e4.viewport(0, 0, t4.width, t4.height), e4.activeTexture(e4.TEXTURE0);
    let n4 = ca2(t4, 2);
    return n4 || (n4 = ra2(pa2(t4), e4, t4.m ? e4.LINEAR : e4.NEAREST), t4.g.push(n4), t4.j = true), e4.bindTexture(e4.TEXTURE_2D, n4), n4;
  }
  function ma2(t4) {
    t4.h.bindTexture(t4.h.TEXTURE_2D, null);
  }
  function wa(t4) {
    return { ...Ea, fillColor: (t4 = t4 || {}).color, ...t4 };
  }
  function Ta(t4, e4) {
    return t4 instanceof Function ? t4(e4) : t4;
  }
  function Aa(t4, e4, n4) {
    return Math.max(Math.min(e4, n4), Math.min(Math.max(e4, n4), t4));
  }
  function ba2(t4) {
    if (!t4.l)
      throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");
    return t4.l;
  }
  function ka(t4) {
    if (!t4.j)
      throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");
    return t4.j;
  }
  function xa(t4, e4, n4) {
    if (e4.R())
      n4(e4.M());
    else {
      const r4 = e4.la() ? e4.ja() : e4.ka();
      t4.m = t4.m ?? new oa2();
      const s4 = ka(t4);
      n4((t4 = new _a2([r4], e4.m, false, s4.canvas, t4.m, e4.width, e4.height)).M()), t4.close();
    }
  }
  function Sa(t4, e4, n4, r4) {
    const s4 = function(t5) {
      return t5.g || (t5.g = new aa()), t5.g;
    }(t4), i5 = ka(t4), o4 = Array.isArray(n4) ? new ImageData(new Uint8ClampedArray(n4), 1, 1) : n4;
    na2(s4, i5, true, () => {
      !function(t6, e5, n5, r5) {
        const s5 = t6.g;
        if (s5.activeTexture(s5.TEXTURE0), s5.bindTexture(s5.TEXTURE_2D, e5), s5.activeTexture(s5.TEXTURE1), s5.bindTexture(s5.TEXTURE_2D, t6.C), s5.texImage2D(s5.TEXTURE_2D, 0, s5.RGBA, s5.RGBA, s5.UNSIGNED_BYTE, n5), t6.I && function(t7, e6) {
          if (t7 !== e6)
            return false;
          t7 = t7.entries(), e6 = e6.entries();
          for (const [r6, s6] of t7) {
            t7 = r6;
            const i6 = s6;
            var n6 = e6.next();
            if (n6.done)
              return false;
            const [o5, a4] = n6.value;
            if (n6 = a4, t7 !== o5 || i6[0] !== n6[0] || i6[1] !== n6[1] || i6[2] !== n6[2] || i6[3] !== n6[3])
              return false;
          }
          return !!e6.next().done;
        }(t6.I, r5))
          s5.activeTexture(s5.TEXTURE2), s5.bindTexture(s5.TEXTURE_2D, t6.j);
        else {
          t6.I = r5;
          const e6 = Array(1024).fill(0);
          r5.forEach((t7, n6) => {
            if (4 !== t7.length)
              throw Error(`Color at index ${n6} is not a four-channel value.`);
            e6[4 * n6] = t7[0], e6[4 * n6 + 1] = t7[1], e6[4 * n6 + 2] = t7[2], e6[4 * n6 + 3] = t7[3];
          }), s5.activeTexture(s5.TEXTURE2), s5.bindTexture(s5.TEXTURE_2D, t6.j), s5.texImage2D(s5.TEXTURE_2D, 0, s5.RGBA, 256, 1, 0, s5.RGBA, s5.UNSIGNED_BYTE, new Uint8Array(e6));
        }
      }(s4, e4, o4, r4), i5.clearColor(0, 0, 0, 0), i5.clear(i5.COLOR_BUFFER_BIT), i5.drawArrays(i5.TRIANGLE_FAN, 0, 4);
      const t5 = s4.g;
      t5.activeTexture(t5.TEXTURE0), t5.bindTexture(t5.TEXTURE_2D, null), t5.activeTexture(t5.TEXTURE1), t5.bindTexture(t5.TEXTURE_2D, null), t5.activeTexture(t5.TEXTURE2), t5.bindTexture(t5.TEXTURE_2D, null);
    });
  }
  function La(t4, e4, n4, r4) {
    const s4 = ka(t4), i5 = function(t5) {
      return t5.h || (t5.h = new ha2()), t5.h;
    }(t4), o4 = Array.isArray(n4) ? new ImageData(new Uint8ClampedArray(n4), 1, 1) : n4, a4 = Array.isArray(r4) ? new ImageData(new Uint8ClampedArray(r4), 1, 1) : r4;
    na2(i5, s4, true, () => {
      var t5 = i5.g;
      t5.activeTexture(t5.TEXTURE0), t5.bindTexture(t5.TEXTURE_2D, e4), t5.activeTexture(t5.TEXTURE1), t5.bindTexture(t5.TEXTURE_2D, i5.j), t5.texImage2D(t5.TEXTURE_2D, 0, t5.RGBA, t5.RGBA, t5.UNSIGNED_BYTE, o4), t5.activeTexture(t5.TEXTURE2), t5.bindTexture(t5.TEXTURE_2D, i5.C), t5.texImage2D(t5.TEXTURE_2D, 0, t5.RGBA, t5.RGBA, t5.UNSIGNED_BYTE, a4), s4.clearColor(0, 0, 0, 0), s4.clear(s4.COLOR_BUFFER_BIT), s4.drawArrays(s4.TRIANGLE_FAN, 0, 4), s4.bindTexture(s4.TEXTURE_2D, null), (t5 = i5.g).activeTexture(t5.TEXTURE0), t5.bindTexture(t5.TEXTURE_2D, null), t5.activeTexture(t5.TEXTURE1), t5.bindTexture(t5.TEXTURE_2D, null), t5.activeTexture(t5.TEXTURE2), t5.bindTexture(t5.TEXTURE_2D, null);
    });
  }
  function Ra(t4, e4) {
    switch (e4) {
      case 0:
        return t4.g.find((t5) => t5 instanceof ImageData);
      case 1:
        return t4.g.find((t5) => "undefined" != typeof ImageBitmap && t5 instanceof ImageBitmap);
      case 2:
        return t4.g.find((t5) => "undefined" != typeof WebGLTexture && t5 instanceof WebGLTexture);
      default:
        throw Error(`Type is not supported: ${e4}`);
    }
  }
  function Ma(t4) {
    var e4 = Ra(t4, 0);
    if (!e4) {
      e4 = Oa(t4);
      const n4 = Ca(t4), r4 = new Uint8Array(t4.width * t4.height * 4);
      sa2(n4, e4, Pa(t4)), e4.readPixels(0, 0, t4.width, t4.height, e4.RGBA, e4.UNSIGNED_BYTE, r4), ia(n4), e4 = new ImageData(new Uint8ClampedArray(r4.buffer), t4.width, t4.height), t4.g.push(e4);
    }
    return e4;
  }
  function Pa(t4) {
    let e4 = Ra(t4, 2);
    if (!e4) {
      const n4 = Oa(t4);
      e4 = Ia(t4);
      const r4 = Ra(t4, 1) || Ma(t4);
      n4.texImage2D(n4.TEXTURE_2D, 0, n4.RGBA, n4.RGBA, n4.UNSIGNED_BYTE, r4), Da(t4);
    }
    return e4;
  }
  function Oa(t4) {
    if (!t4.canvas)
      throw Error("Conversion to different image formats require that a canvas is passed when iniitializing the image.");
    return t4.h || (t4.h = Jo2(t4.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t4.h;
  }
  function Ca(t4) {
    return t4.l || (t4.l = new oa2()), t4.l;
  }
  function Ia(t4) {
    const e4 = Oa(t4);
    e4.viewport(0, 0, t4.width, t4.height), e4.activeTexture(e4.TEXTURE0);
    let n4 = Ra(t4, 2);
    return n4 || (n4 = ra2(Ca(t4), e4), t4.g.push(n4), t4.m = true), e4.bindTexture(e4.TEXTURE_2D, n4), n4;
  }
  function Da(t4) {
    t4.h.bindTexture(t4.h.TEXTURE_2D, null);
  }
  function Na(t4) {
    const e4 = Oa(t4);
    return na2(Ca(t4), e4, true, () => function(t5, e5) {
      const n4 = t5.canvas;
      if (n4.width === t5.width && n4.height === t5.height)
        return e5();
      const r4 = n4.width, s4 = n4.height;
      return n4.width = t5.width, n4.height = t5.height, t5 = e5(), n4.width = r4, n4.height = s4, t5;
    }(t4, () => {
      if (e4.bindFramebuffer(e4.FRAMEBUFFER, null), e4.clearColor(0, 0, 0, 0), e4.clear(e4.COLOR_BUFFER_BIT), e4.drawArrays(e4.TRIANGLE_FAN, 0, 4), !(t4.canvas instanceof OffscreenCanvas))
        throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
      return t4.canvas.transferToImageBitmap();
    }));
  }
  function Ga(...t4) {
    return t4.map(([t5, e4]) => ({ start: t5, end: e4 }));
  }
  async function Ha(t4, e4, n4) {
    return async function(t5, e5, n5, r4) {
      return Xo2(t5, e5, n5, r4);
    }(t4, n4.canvas ?? ("undefined" == typeof OffscreenCanvas || Io3() ? document.createElement("canvas") : void 0), e4, n4);
  }
  function Wa(t4, e4, n4, r4) {
    if (t4.V) {
      const i5 = new si();
      if (n4?.regionOfInterest) {
        if (!t4.ra)
          throw Error("This task doesn't support region-of-interest.");
        var s4 = n4.regionOfInterest;
        if (s4.left >= s4.right || s4.top >= s4.bottom)
          throw Error("Expected RectF with left < right and top < bottom.");
        if (0 > s4.left || 0 > s4.top || 1 < s4.right || 1 < s4.bottom)
          throw Error("Expected RectF values to be in [0,1].");
        In2(i5, 1, (s4.left + s4.right) / 2), In2(i5, 2, (s4.top + s4.bottom) / 2), In2(i5, 4, s4.right - s4.left), In2(i5, 3, s4.bottom - s4.top);
      } else
        In2(i5, 1, 0.5), In2(i5, 2, 0.5), In2(i5, 4, 1), In2(i5, 3, 1);
      if (n4?.rotationDegrees) {
        if (0 != n4?.rotationDegrees % 90)
          throw Error("Expected rotation to be a multiple of 90\xB0.");
        if (In2(i5, 5, -Math.PI * n4.rotationDegrees / 180), 0 != n4?.rotationDegrees % 180) {
          const [t5, r5] = No(e4);
          n4 = Pn2(i5, 3) * r5 / t5, s4 = Pn2(i5, 4) * t5 / r5, In2(i5, 4, n4), In2(i5, 3, s4);
        }
      }
      t4.g.addProtoToStream(i5.g(), "mediapipe.NormalizedRect", t4.V, r4);
    }
    t4.g.sa(e4, t4.ba, r4 ?? performance.now()), t4.finishProcessing();
  }
  function za(t4, e4, n4) {
    if (t4.baseOptions?.g())
      throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
    Wa(t4, e4, n4, t4.C + 1);
  }
  function Ka2(t4, e4, n4, r4) {
    if (!t4.baseOptions?.g())
      throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
    Wa(t4, e4, n4, r4);
  }
  function Ya2(t4, e4, n4, r4) {
    var s4 = e4.data;
    const i5 = e4.width, o4 = i5 * (e4 = e4.height);
    if ((s4 instanceof Uint8Array || s4 instanceof Float32Array) && s4.length !== o4)
      throw Error("Unsupported channel count: " + s4.length / o4);
    return t4 = new _a2([s4], n4, false, t4.g.i.canvas, t4.O, i5, e4), r4 ? t4.clone() : t4;
  }
  function ah2(t4) {
    t4.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
  }
  function lh2(t4) {
    t4.gestures = [], t4.landmarks = [], t4.worldLandmarks = [], t4.handedness = [];
  }
  function dh2(t4) {
    return 0 === t4.gestures.length ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] } : { gestures: t4.gestures, landmarks: t4.landmarks, worldLandmarks: t4.worldLandmarks, handedness: t4.handedness, handednesses: t4.handedness };
  }
  function fh2(t4, e4 = true) {
    const n4 = [];
    for (const s4 of t4) {
      var r4 = Ds2(s4);
      t4 = [];
      for (const n5 of r4.g())
        r4 = e4 && null != Fn3(n5, 1) ? Mn3(Fn3(n5, 1)) : -1, t4.push({ score: Pn2(n5, 2) ?? 0, index: r4, categoryName: Rn3(n5, 3) ?? "" ?? "", displayName: Rn3(n5, 4) ?? "" ?? "" });
      n4.push(t4);
    }
    return n4;
  }
  function gh2(t4) {
    return { landmarks: t4.landmarks, worldLandmarks: t4.worldLandmarks, handednesses: t4.handedness, handedness: t4.handedness };
  }
  function _h2(t4) {
    t4.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] };
  }
  function vh2(t4) {
    try {
      if (!t4.D)
        return t4.h;
      t4.D(t4.h);
    } finally {
      $o2(t4);
    }
  }
  function Eh2(t4, e4) {
    t4 = ei2(t4), e4.push(xo3(t4));
  }
  function kh2(t4) {
    t4.categoryMask = void 0, t4.confidenceMasks = void 0, t4.qualityScores = void 0;
  }
  function xh2(t4) {
    try {
      const e4 = new bh2(t4.confidenceMasks, t4.categoryMask, t4.qualityScores);
      if (!t4.j)
        return e4;
      t4.j(e4);
    } finally {
      $o2(t4);
    }
  }
  function Jh2(t4) {
    t4.landmarks = [], t4.worldLandmarks = [], t4.segmentationMasks = void 0;
  }
  function Zh2(t4) {
    try {
      const e4 = new qh2(t4.landmarks, t4.worldLandmarks, t4.segmentationMasks);
      if (!t4.s)
        return e4;
      t4.s(e4);
    } finally {
      $o2(t4);
    }
  }
  var t3, s3, i3, o3, a3, h3, u3, l3, d3, f2, _2, v2, E3, A2, b2, x2, S2, M2, O4, C2, U4, H3, W3, z3, K4, pt3, wt3, At2, bt2, xt3, St2, Ut2, jt3, Vt3, Xt3, Ht3, zt2, Kt3, Yt3, Qt2, te2, ee3, oe3, he2, ce4, ue3, ge3, Fe3, Re3, Me2, Ie2, De3, Ne2, Ue2, je3, We2, Nn3, jn2, Hn2, Wn3, zn3, Kn3, Qn3, er3, ir2, mr3, br3, kr3, xr3, Sr2, Lr3, Fr3, Rr3, Mr3, Pr2, Or2, Cr2, Ir2, Dr3, Nr3, Ur3, Br3, Gr3, jr2, Vr3, Xr2, Hr3, Wr3, zr3, Kr2, Jr2, Zr2, Qr2, ts2, es2, ns2, rs2, ss2, is2, os2, as2, hs2, cs2, us2, ls2, ds2, fs2, ps2, gs2, vs2, Es2, ws2, Ts2, As2, bs2, Ls2, Fs2, Rs2, Ms, Ps2, Os2, Cs2, Is2, Ds2, Ns2, Us, Bs2, Gs2, js, Vs, Xs, Hs, Ws2, zs, Ks, Ys, $s2, qs2, Js, Zs, Qs2, ti2, ei2, ni, ri, si, ii, oi, ai, hi, ci, ui, li, di2, fi2, pi, gi2, mi2, yi2, _i2, vi2, Ei2, wi2, Ti2, Ai2, bi2, ki2, xi2, Si2, Li2, Fi2, Ri2, Mi2, Pi2, Oi2, Ci2, Ii2, Di2, Ni2, Ui2, Bi2, Gi2, ji2, Vi2, Xi2, Hi2, Wi2, zi2, Ki2, Yi2, $i2, qi2, Ji2, Zi2, Qi2, to3, eo3, no3, ro3, so3, io3, oo3, ao3, ho3, co3, uo3, lo3, fo3, po3, go3, mo3, yo3, _o3, vo3, Eo3, wo3, To3, Ro, Mo, Co2, qo2, Zo, oa2, aa, ha2, ya, _a2, va, Ea, Fa, Ua, Ba, ja2, Va, Xa2, $a, qa2, Ja2, Za2, Qa2, th2, eh2, nh2, rh2, sh2, ih2, oh2, hh2, ch2, uh, ph, mh2, yh2, wh2, Th2, Ah, bh2, Sh2, Lh2, Fh2, Rh2, Mh2, Ph2, Oh2, Ch2, Ih2, Dh2, Nh2, Uh2, Bh2, Gh2, jh2, Vh2, Xh2, Hh2, Wh2, zh2, Kh2, Yh2, $h2, qh2, Qh2;
  var init_vision_bundle = __esm({
    "node_modules/@mediapipe/tasks-vision/vision_bundle.mjs"() {
      t3 = "undefined" != typeof self ? self : {};
      o3 = "undefined" != typeof TextDecoder;
      h3 = "undefined" != typeof TextEncoder;
      l3 = e3(610401301);
      d3 = e3(188588736);
      f2 = t3.navigator;
      u3 = f2 && f2.userAgentData || null;
      _2 = !m2() && (g3("Trident") || g3("MSIE"));
      !g3("Android") || y2(), y2(), g3("Safari") && (y2() || !m2() && g3("Coast") || !m2() && g3("Opera") || !m2() && g3("Edge") || (m2() ? p3("Microsoft Edge") : g3("Edg/")) || m2() && p3("Opera"));
      v2 = {};
      E3 = null;
      A2 = "undefined" != typeof Uint8Array;
      b2 = !_2 && "function" == typeof btoa;
      x2 = /[-_.]/g;
      S2 = { "-": "+", _: "/", ".": "=" };
      O4 = {};
      U4 = class {
        constructor(t4, e4) {
          if (I2(e4), this.g = t4, null != t4 && 0 === t4.length)
            throw Error("ByteString should be constructed with non-empty values");
        }
        h() {
          const t4 = N3(this);
          return t4 ? new Uint8Array(t4) : P2();
        }
      };
      H3 = "function" == typeof Uint8Array.prototype.slice;
      z3 = 0;
      K4 = 0;
      pt3 = [];
      wt3 = [];
      At2 = class {
        constructor(t4, e4) {
          this.h = t4 >>> 0, this.g = e4 >>> 0;
        }
      };
      xt3 = class {
        constructor(t4, e4) {
          this.h = t4 >>> 0, this.g = e4 >>> 0;
        }
      };
      Ut2 = class {
        constructor(t4, e4, n4, r4) {
          this.g = t4, this.h = e4, this.l = n4, this.pa = r4;
        }
      };
      jt3 = Gt2();
      Vt3 = Gt2("0di");
      Xt3 = jt3 ? (t4, e4) => {
        t4[jt3] |= e4;
      } : (t4, e4) => {
        void 0 !== t4.g ? t4.g |= e4 : Object.defineProperties(t4, { g: { value: e4, configurable: true, writable: true, enumerable: false } });
      };
      Ht3 = jt3 ? (t4, e4) => {
        t4[jt3] &= ~e4;
      } : (t4, e4) => {
        void 0 !== t4.g && (t4.g &= ~e4);
      };
      zt2 = jt3 ? (t4) => 0 | t4[jt3] : (t4) => 0 | t4.g;
      Kt3 = jt3 ? (t4) => t4[jt3] : (t4) => t4.g;
      Yt3 = jt3 ? (t4, e4) => (t4[jt3] = e4, t4) : (t4, e4) => (void 0 !== t4.g ? t4.g = e4 : Object.defineProperties(t4, { g: { value: e4, configurable: true, writable: true, enumerable: false } }), t4);
      te2 = {};
      ee3 = {};
      oe3 = [];
      Yt3(oe3, 55), Qt2 = Object.freeze(oe3);
      he2 = class _he {
        constructor(t4, e4, n4) {
          this.l = 0, this.g = t4, this.h = e4, this.m = n4;
        }
        next() {
          if (this.l < this.g.length) {
            const t4 = this.g[this.l++];
            return { done: false, value: this.h ? this.h.call(this.m, t4) : t4 };
          }
          return { done: true, value: void 0 };
        }
        [Symbol.iterator]() {
          return new _he(this.g, this.h, this.m);
        }
      };
      Object.freeze(new class {
      }()), Object.freeze(new class {
      }());
      ge3 = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
      Ie2 = {};
      De3 = function() {
        try {
          return new class extends Map {
            constructor() {
              super();
            }
          }(), false;
        } catch {
          return true;
        }
      }();
      Ne2 = class {
        constructor() {
          this.g = /* @__PURE__ */ new Map();
        }
        get(t4) {
          return this.g.get(t4);
        }
        set(t4, e4) {
          return this.g.set(t4, e4), this.size = this.g.size, this;
        }
        delete(t4) {
          return t4 = this.g.delete(t4), this.size = this.g.size, t4;
        }
        clear() {
          this.g.clear(), this.size = this.g.size;
        }
        has(t4) {
          return this.g.has(t4);
        }
        entries() {
          return this.g.entries();
        }
        keys() {
          return this.g.keys();
        }
        values() {
          return this.g.values();
        }
        forEach(t4, e4) {
          return this.g.forEach(t4, e4);
        }
        [Symbol.iterator]() {
          return this.entries();
        }
      };
      Ue2 = De3 ? (Object.setPrototypeOf(Ne2.prototype, Map.prototype), Object.defineProperties(Ne2.prototype, { size: { value: 0, configurable: true, enumerable: true, writable: true } }), Ne2) : class extends Map {
        constructor() {
          super();
        }
      };
      je3 = class extends Ue2 {
        constructor(t4, e4, n4 = Be3, r4 = Be3) {
          super();
          let s4 = zt2(t4);
          s4 |= 64, Yt3(t4, s4), this.L = s4, this.U = e4, this.S = n4, this.Z = this.U ? Ve3 : r4;
          for (let i5 = 0; i5 < t4.length; i5++) {
            const o4 = t4[i5], a4 = n4(o4[0], false, true);
            let h4 = o4[1];
            e4 ? void 0 === h4 && (h4 = null) : h4 = r4(o4[1], false, true, void 0, void 0, s4), super.set(a4, h4);
          }
        }
        oa(t4 = Xe4) {
          if (0 !== this.size)
            return this.Y(t4);
        }
        Y(t4 = Xe4) {
          const e4 = [], n4 = super.entries();
          for (var r4; !(r4 = n4.next()).done; )
            (r4 = r4.value)[0] = t4(r4[0]), r4[1] = t4(r4[1]), e4.push(r4);
          return e4;
        }
        clear() {
          Ge3(this), super.clear();
        }
        delete(t4) {
          return Ge3(this), super.delete(this.S(t4, true, false));
        }
        entries() {
          var t4 = this.na();
          return new he2(t4, He2, this);
        }
        keys() {
          return this.Ia();
        }
        values() {
          var t4 = this.na();
          return new he2(t4, je3.prototype.get, this);
        }
        forEach(t4, e4) {
          super.forEach((n4, r4) => {
            t4.call(e4, this.get(r4), r4, this);
          });
        }
        set(t4, e4) {
          return Ge3(this), null == (t4 = this.S(t4, true, false)) ? this : null == e4 ? (super.delete(t4), this) : super.set(t4, this.Z(e4, true, true, this.U, false, this.L));
        }
        Oa(t4) {
          const e4 = this.S(t4[0], false, true);
          t4 = t4[1], t4 = this.U ? void 0 === t4 ? null : t4 : this.Z(t4, false, true, void 0, false, this.L), super.set(e4, t4);
        }
        has(t4) {
          return super.has(this.S(t4, false, false));
        }
        get(t4) {
          t4 = this.S(t4, false, false);
          const e4 = super.get(t4);
          if (void 0 !== e4) {
            var n4 = this.U;
            return n4 ? ((n4 = this.Z(e4, false, true, n4, this.ta, this.L)) !== e4 && super.set(t4, n4), n4) : e4;
          }
        }
        na() {
          return Array.from(super.keys());
        }
        Ia() {
          return super.keys();
        }
        [Symbol.iterator]() {
          return this.entries();
        }
      };
      je3.prototype.toJSON = void 0, je3.prototype.Ja = ee3;
      Nn3 = class {
        constructor(t4, e4) {
          this.u = Ce4(t4, e4);
        }
        toJSON() {
          return Un3(this, Ye2(this.u, qe2, void 0, void 0, false), true);
        }
        l() {
          var t4 = mo3;
          return t4.g ? t4.l(this, t4.g, t4.h, true) : t4.l(this, t4.h, t4.defaultValue, true);
        }
        clone() {
          const t4 = this.u;
          return Ze2(this, t4, Kt3(t4), false);
        }
        N() {
          return !!(2 & zt2(this.u));
        }
      };
      Nn3.prototype.X = te2, Nn3.prototype.toString = function() {
        return Un3(this, this.u, false).toString();
      };
      jn2 = Symbol();
      Hn2 = class {
      };
      Kn3 = Symbol();
      Qn3 = Symbol();
      er3 = Symbol();
      ir2 = Symbol();
      mr3 = pr2(function(t4, e4, n4, r4, s4) {
        return 2 === t4.h && (t4 = yt2(t4, Oe3([void 0, void 0], r4), s4), ae3(r4 = Kt3(e4)), (s4 = nn3(e4, r4, n4)) instanceof je3 ? 0 != (2 & s4.L) ? ((s4 = s4.Y()).push(t4), sn2(e4, r4, n4, s4)) : s4.Oa(t4) : Array.isArray(s4) ? (2 & zt2(s4) && sn2(e4, r4, n4, s4 = fn3(s4)), s4.push(t4)) : sn2(e4, r4, n4, [t4]), true);
      }, function(t4, e4, n4, r4, s4) {
        if (e4 instanceof je3)
          e4.forEach((e5, i5) => {
            Nt3(t4, n4, Oe3([i5, e5], r4), s4);
          });
        else if (Array.isArray(e4))
          for (let i5 = 0; i5 < e4.length; i5++) {
            const o4 = e4[i5];
            Array.isArray(o4) && Nt3(t4, n4, Oe3(o4, r4), s4);
          }
      });
      kr3 = dr2(function(t4, e4, n4) {
        if (1 !== t4.h)
          return false;
        var r4 = t4.g;
        t4 = at3(r4);
        const s4 = at3(r4);
        r4 = 2 * (s4 >> 31) + 1;
        const i5 = s4 >>> 20 & 2047;
        return t4 = 4294967296 * (1048575 & s4) + t4, gr3(e4, n4, 2047 == i5 ? t4 ? NaN : 1 / 0 * r4 : 0 == i5 ? r4 * Math.pow(2, -1074) * t4 : r4 * Math.pow(2, i5 - 1075) * (t4 + 4503599627370496)), true;
      }, function(t4, e4, n4) {
        null != (e4 = fe3(e4)) && (Ot3(t4, n4, 1), t4 = t4.g, (n4 = W3 ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +e4, true), z3 = n4.getUint32(0, true), K4 = n4.getUint32(4, true), Mt2(t4, z3), Mt2(t4, K4));
      });
      xr3 = dr2(function(t4, e4, n4) {
        return 5 === t4.h && (gr3(e4, n4, ht3(t4.g)), true);
      }, function(t4, e4, n4) {
        null != (e4 = fe3(e4)) && (Ot3(t4, n4, 5), t4 = t4.g, $4(e4), Mt2(t4, z3));
      });
      Sr2 = fr3(Ar2, function(t4, e4, n4) {
        if (null != (e4 = Gn3(fe3, e4)))
          for (let o4 = 0; o4 < e4.length; o4++) {
            var r4 = t4, s4 = n4, i5 = e4[o4];
            null != i5 && (Ot3(r4, s4, 5), r4 = r4.g, $4(i5), Mt2(r4, z3));
          }
      });
      Lr3 = fr3(Ar2, function(t4, e4, n4) {
        if (null != (e4 = Gn3(fe3, e4)) && e4.length) {
          Ot3(t4, n4, 2), Ft2(t4.g, 4 * e4.length);
          for (let r4 = 0; r4 < e4.length; r4++)
            n4 = t4.g, $4(e4[r4]), Mt2(n4, z3);
        }
      });
      Fr3 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, rt2(t4.g, J2)), true);
      }, yr3);
      Rr3 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, 0 === (t4 = rt2(t4.g, J2)) ? void 0 : t4), true);
      }, yr3);
      Mr3 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, rt2(t4.g, q3)), true);
      }, function(t4, e4, n4) {
        t:
          if (null != e4) {
            if (me3(e4)) {
              if ("string" == typeof e4) {
                var r4 = Math.trunc(Number(e4));
                Number.isSafeInteger(r4) && 0 <= r4 ? e4 = String(r4) : (-1 !== (r4 = e4.indexOf(".")) && (e4 = e4.substring(0, r4)), ve2(e4) || (et3(e4), e4 = Z3(z3, K4)));
                break t;
              }
              if ("number" == typeof e4) {
                e4 = 0 <= (e4 = Math.trunc(e4)) && Number.isSafeInteger(e4) ? e4 : function(t5) {
                  if (0 > t5) {
                    Y2(t5);
                    const e5 = Z3(z3, K4);
                    return t5 = Number(e5), Number.isSafeInteger(t5) ? t5 : e5;
                  }
                  return ve2(String(t5)) ? t5 : (Y2(t5), q3(z3, K4));
                }(e4);
                break t;
              }
            }
            e4 = void 0;
          }
        null != e4 && ("string" == typeof e4 && Tt3(e4), null != e4 && (Ot3(t4, n4, 0), "number" == typeof e4 ? (t4 = t4.g, Y2(e4), Lt2(t4, z3, K4)) : (n4 = Tt3(e4), Lt2(t4.g, n4.h, n4.g))));
      });
      Pr2 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, it3(t4.g)), true);
      }, _r3);
      Or2 = fr3(function(t4, e4, n4) {
        return (0 === t4.h || 2 === t4.h) && (e4 = on2(e4, Kt3(e4), n4, 2, false), 2 == t4.h ? Et2(t4, it3, e4) : e4.push(it3(t4.g)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = Gn3(ye4, e4)) && e4.length) {
          n4 = Ct2(t4, n4);
          for (let n5 = 0; n5 < e4.length; n5++)
            Rt3(t4.g, e4[n5]);
          It2(t4, n4);
        }
      });
      Cr2 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, 0 === (t4 = it3(t4.g)) ? void 0 : t4), true);
      }, _r3);
      Ir2 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, st3(t4.g)), true);
      }, vr3);
      Dr3 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, false === (t4 = st3(t4.g)) ? void 0 : t4), true);
      }, vr3);
      Nr3 = fr3(function(t4, e4, n4) {
        return 2 === t4.h && (mn3(e4, n4, yn3, t4 = _t2(t4)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = Gn3(xe4, e4)))
          for (let o4 = 0; o4 < e4.length; o4++) {
            var r4 = t4, s4 = n4, i5 = e4[o4];
            null != i5 && Dt2(r4, s4, c3(i5));
          }
      });
      Ur3 = dr2(function(t4, e4, n4) {
        return 2 === t4.h && (gr3(e4, n4, "" === (t4 = _t2(t4)) ? void 0 : t4), true);
      }, Er2);
      Br3 = dr2(function(t4, e4, n4) {
        return 2 === t4.h && (gr3(e4, n4, _t2(t4)), true);
      }, Er2);
      Gr3 = pr2(function(t4, e4, n4, r4, s4) {
        return 2 === t4.h && (yt2(t4, En2(e4, r4, n4, true), s4), true);
      }, wr3);
      jr2 = pr2(function(t4, e4, n4, r4, s4) {
        return 2 === t4.h && (yt2(t4, En2(e4, r4, n4), s4), true);
      }, wr3);
      br3 = new Ut2(function(t4, e4, n4, r4, s4) {
        if (2 !== t4.h)
          return false;
        r4 = Oe3(void 0, r4);
        let i5 = Kt3(e4);
        ae3(i5);
        let o4 = on2(e4, i5, n4, 3);
        return i5 = Kt3(e4), 4 & zt2(o4) && (o4 = Bt3(o4), Yt3(o4, -2079 & (1 | zt2(o4))), sn2(e4, i5, n4, o4)), o4.push(r4), yt2(t4, r4, s4), true;
      }, function(t4, e4, n4, r4, s4) {
        if (Array.isArray(e4))
          for (let i5 = 0; i5 < e4.length; i5++)
            wr3(t4, e4[i5], n4, r4, s4);
      }, true, true);
      Vr3 = pr2(function(t4, e4, n4, r4, s4, i5) {
        if (2 !== t4.h)
          return false;
        let o4 = Kt3(e4);
        return ae3(o4), (i5 = vn2(e4, o4, i5)) && n4 !== i5 && sn2(e4, o4, i5), yt2(t4, e4 = En2(e4, r4, n4), s4), true;
      }, wr3);
      Xr2 = dr2(function(t4, e4, n4) {
        return 2 === t4.h && (gr3(e4, n4, vt2(t4)), true);
      }, Tr3);
      Hr3 = fr3(function(t4, e4, n4) {
        return (0 === t4.h || 2 === t4.h) && (e4 = on2(e4, Kt3(e4), n4, 2, false), 2 == t4.h ? Et2(t4, ot2, e4) : e4.push(ot2(t4.g)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = Gn3(_e4, e4)))
          for (let o4 = 0; o4 < e4.length; o4++) {
            var r4 = t4, s4 = n4, i5 = e4[o4];
            null != i5 && (Ot3(r4, s4, 0), Ft2(r4.g, i5));
          }
      });
      Wr3 = dr2(function(t4, e4, n4) {
        return 0 === t4.h && (gr3(e4, n4, it3(t4.g)), true);
      }, function(t4, e4, n4) {
        null != (e4 = ye4(e4)) && (e4 = parseInt(e4, 10), Ot3(t4, n4, 0), Rt3(t4.g, e4));
      });
      zr3 = fr3(function(t4, e4, n4) {
        return (0 === t4.h || 2 === t4.h) && (e4 = on2(e4, Kt3(e4), n4, 2, false), 2 == t4.h ? Et2(t4, ct3, e4) : e4.push(it3(t4.g)), true);
      }, function(t4, e4, n4) {
        if (null != (e4 = Gn3(ye4, e4)) && e4.length) {
          n4 = Ct2(t4, n4);
          for (let n5 = 0; n5 < e4.length; n5++)
            Rt3(t4.g, e4[n5]);
          It2(t4, n4);
        }
      });
      Kr2 = class {
        constructor(t4, e4) {
          this.h = t4, this.g = e4, this.l = Tn3, this.m = kn3, this.defaultValue = void 0;
        }
      };
      Jr2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Zr2 = [0, Ur3, dr2(function(t4, e4, n4) {
        return 2 === t4.h && (gr3(e4, n4, (t4 = vt2(t4)) === D2() ? void 0 : t4), true);
      }, function(t4, e4, n4) {
        if (null != e4) {
          if (e4 instanceof Nn3) {
            const r4 = e4.Qa;
            return void (r4 && (e4 = r4(e4), null != e4 && Dt2(t4, n4, V3(e4).buffer)));
          }
          if (Array.isArray(e4))
            return;
        }
        Tr3(t4, e4, n4);
      })];
      Qr2 = [0, Br3];
      ts2 = [0, Pr2, Wr3, Ir2, -1, Or2, Wr3, -1];
      es2 = [0, Ir2, -1];
      ns2 = class extends Nn3 {
        constructor() {
          super();
        }
      };
      ns2.A = [6];
      rs2 = [0, Ir2, Br3, Ir2, Wr3, -1, zr3, Br3, -1, es2, Wr3];
      ss2 = [0, Br3, -2];
      is2 = class extends Nn3 {
        constructor() {
          super();
        }
      };
      os2 = [0];
      as2 = [0, Pr2, Ir2, -3];
      hs2 = class extends Nn3 {
        constructor(t4) {
          super(t4, 2);
        }
      };
      cs2 = {};
      us2 = [-2, cs2, Ir2];
      cs2[336783863] = [0, Br3, Ir2, -1, Pr2, [0, [1, 2, 3, 4, 5], Vr3, os2, Vr3, rs2, Vr3, ss2, Vr3, as2, Vr3, ts2], Qr2];
      ls2 = [0, Ur3, Dr3];
      ds2 = [0, Rr3, -1, Dr3, -3, Rr3, Or2, Ur3, Cr2, Rr3, -1, Dr3, Cr2, Dr3, -2, Ur3];
      fs2 = [-1, {}];
      ps2 = [0, Br3, 1, fs2];
      gs2 = [0, Br3, Nr3, fs2];
      vs2 = class extends Nn3 {
        constructor(t4) {
          super(t4, 500);
        }
        o(t4) {
          return kn3(this, 0, 7, t4);
        }
      };
      vs2.A = [3, 4, 5, 6, 8, 13, 17, 1005];
      Es2 = [-500, Ur3, -1, Nr3, -3, us2, br3, Zr2, Cr2, -1, ps2, gs2, br3, ls2, Ur3, ds2, Cr2, Nr3, 987, Nr3];
      ws2 = [0, Ur3, -1, fs2];
      Ts2 = [-500, Br3, -1, [-1, {}], 998, Br3];
      As2 = [-500, Br3, Nr3, -1, [-2, {}, Ir2], 997, Nr3, -1];
      bs2 = [-500, Br3, Nr3, fs2, 998, Nr3];
      Ls2 = class extends Nn3 {
        constructor(t4) {
          super(t4, 500);
        }
        o(t4) {
          return kn3(this, 0, 1001, t4);
        }
      };
      Ls2.A = [1, 6, 7, 9, 10, 15, 16, 17, 14, 1002];
      Fs2 = [-500, br3, Es2, 4, br3, Ts2, br3, As2, Cr2, br3, bs2, Nr3, Cr2, ps2, gs2, br3, ws2, Nr3, -2, ds2, Ur3, -1, Dr3, 979, fs2, br3, Zr2];
      Rs2 = $r3(Ls2, Fs2);
      Ls2.prototype.g = qr3(Fs2);
      Ms = [0, br3, [0, Pr2, -2]];
      Ps2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Os2 = [0, Pr2, xr3, Br3, -1];
      Cs2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        g() {
          return bn3(this, Ps2, 1);
        }
      };
      Cs2.A = [1];
      Is2 = [0, br3, Os2];
      Ds2 = $r3(Cs2, Is2);
      Ns2 = [0, Pr2, xr3];
      Us = [0, Pr2, -1, Ms];
      Bs2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Gs2 = [0, Pr2, -3];
      js = [0, xr3, -3];
      Vs = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Xs = [0, xr3, -1, Br3, xr3];
      Hs = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        h() {
          return Tn3(this, Bs2, 2);
        }
        g() {
          return bn3(this, Vs, 5);
        }
      };
      Hs.A = [5];
      Ws2 = [0, Wr3, Gs2, js, Us, br3, Xs];
      zs = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      zs.A = [1, 2, 3, 8, 9];
      Ks = $r3(zs, [0, Nr3, Or2, Lr3, Ws2, Br3, -1, Fr3, br3, Ns2, Nr3, Fr3]);
      Ys = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      $s2 = [0, xr3, -4];
      qs2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      qs2.A = [1];
      Js = $r3(qs2, [0, br3, $s2]);
      Zs = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Qs2 = [0, xr3, -4];
      ti2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      ti2.A = [1];
      ei2 = $r3(ti2, [0, br3, Qs2]);
      ni = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      ni.A = [3];
      ri = [0, Pr2, -1, Lr3, Wr3];
      si = class extends Nn3 {
        constructor() {
          super();
        }
      };
      si.prototype.g = qr3([0, xr3, -4, Fr3]);
      ii = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      oi = [0, 1, Pr2, Br3, Is2];
      ai = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      ai.A = [1];
      hi = $r3(ai, [0, br3, oi, Fr3]);
      ci = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      ci.A = [1];
      ui = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        qa() {
          const t4 = hn3(this);
          return null == t4 ? D2() : t4;
        }
      };
      li = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      di2 = [1, 2];
      fi2 = [0, di2, Vr3, [0, Lr3], Vr3, [0, Xr2], Pr2, Br3];
      pi = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      pi.A = [1];
      gi2 = $r3(pi, [0, br3, fi2, Fr3]);
      mi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      mi2.A = [4, 5];
      yi2 = [0, Br3, Pr2, xr3, Nr3, -1];
      _i2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      vi2 = [0, Ir2, -1];
      Ei2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      wi2 = [1, 2, 3, 4, 5];
      Ti2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        g() {
          return null != hn3(this);
        }
        h() {
          return null != Rn3(this, 2);
        }
      };
      Ai2 = [0, Xr2, Br3, [0, Pr2, Fr3, -1], [0, Mr3, Fr3]];
      bi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        g() {
          return pe2(en2(this, 2)) ?? false;
        }
      };
      ki2 = [0, Ai2, Ir2, [0, wi2, Vr3, as2, Vr3, rs2, Vr3, ts2, Vr3, os2, Vr3, ss2], Wr3];
      xi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Si2 = [0, ki2, xr3, -1, Pr2];
      Li2 = Yr2(502141897, xi2);
      cs2[502141897] = Si2;
      Fi2 = [0, Ai2];
      cs2[512499200] = Fi2;
      Ri2 = [0, Fi2];
      cs2[515723506] = Ri2;
      Mi2 = $r3(class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      }, [0, [0, Wr3, -1, Sr2, Hr3], ri]);
      Pi2 = [0, ki2];
      cs2[508981768] = Pi2;
      Oi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Ci2 = [0, ki2, xr3, Pi2, Ir2];
      Ii2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Di2 = [0, ki2, Si2, Ci2, xr3, Ri2];
      cs2[508968149] = Ci2;
      Ni2 = Yr2(508968150, Ii2);
      cs2[508968150] = Di2;
      Ui2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Bi2 = Yr2(513916220, Ui2);
      cs2[513916220] = [0, ki2, Di2, Pr2];
      Gi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        h() {
          return Tn3(this, mi2, 2);
        }
        g() {
          rn3(this, 2);
        }
      };
      ji2 = [0, ki2, yi2];
      cs2[478825465] = ji2;
      Vi2 = [0, ki2];
      cs2[478825422] = Vi2;
      Xi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Hi2 = [0, ki2, Vi2, ji2, -1];
      Wi2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      zi2 = [0, ki2, xr3, Pr2];
      Ki2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Yi2 = [0, ki2, xr3];
      $i2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      qi2 = [0, ki2, zi2, Yi2, xr3];
      Ji2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Zi2 = [0, ki2, qi2, Hi2];
      cs2[463370452] = Hi2, cs2[464864288] = zi2, cs2[474472470] = Yi2;
      Qi2 = Yr2(462713202, $i2);
      cs2[462713202] = qi2;
      to3 = Yr2(479097054, Ji2);
      cs2[479097054] = Zi2;
      eo3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      no3 = [0, ki2];
      ro3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      so3 = [0, ki2, xr3, -1, Pr2];
      cs2[514774813] = so3;
      io3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      oo3 = [0, ki2, xr3, Ir2];
      cs2[518928384] = oo3;
      ao3 = class extends Nn3 {
        constructor() {
          super();
        }
      };
      ao3.prototype.g = qr3([0, ki2, Yi2, no3, Si2, Ci2, so3, oo3]);
      ho3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      co3 = Yr2(456383383, ho3);
      cs2[456383383] = [0, ki2, yi2];
      uo3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      lo3 = Yr2(476348187, uo3);
      cs2[476348187] = [0, ki2, vi2];
      fo3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      po3 = [0, Wr3, -1];
      go3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      go3.A = [3];
      mo3 = Yr2(458105876, class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
        g() {
          var t4 = this.u;
          const e4 = Kt3(t4);
          var n4 = 2 & e4;
          return t4 = function(t5, e5, n5) {
            var r4 = go3;
            const s4 = 2 & e5;
            let i5 = false;
            if (null == n5) {
              if (s4)
                return ze2();
              n5 = [];
            } else if (n5.constructor === je3) {
              if (0 == (2 & n5.L) || s4)
                return n5;
              n5 = n5.Y();
            } else
              Array.isArray(n5) ? i5 = !!(2 & zt2(n5)) : n5 = [];
            if (s4) {
              if (!n5.length)
                return ze2();
              i5 || (i5 = true, $t2(n5));
            } else
              i5 && (i5 = false, n5 = fn3(n5));
            return i5 || (64 & zt2(n5) ? Ht3(n5, 32) : 32 & e5 && Xt3(n5, 32)), sn2(t5, e5, 2, r4 = new je3(n5, r4, Le4, void 0), false), r4;
          }(t4, e4, nn3(t4, e4, 2)), null == t4 || !n4 && go3 && (t4.ta = true), n4 = t4;
        }
      });
      cs2[458105876] = [0, po3, mr3, [true, Fr3, [0, Br3, -1, Nr3]]];
      yo3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      _o3 = Yr2(458105758, yo3);
      cs2[458105758] = [0, ki2, Br3, po3];
      vo3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      vo3.A = [5, 6];
      Eo3 = Yr2(443442058, vo3);
      cs2[443442058] = [0, ki2, Br3, Pr2, xr3, Nr3, -1];
      wo3 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      To3 = Yr2(516587230, wo3);
      cs2[516587230] = [0, ki2, so3, oo3, xr3];
      Mo = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
      Co2 = class {
      };
      Co2.forVisionTasks = function(t4) {
        return Oo3("vision", t4);
      }, Co2.forTextTasks = function(t4) {
        return Oo3("text", t4);
      }, Co2.forGenAiTasks = function(t4) {
        return Oo3("genai", t4);
      }, Co2.forAudioTasks = function(t4) {
        return Oo3("audio", t4);
      }, Co2.isSimdSupported = function() {
        return Po3();
      };
      qo2 = class {
        constructor(t4) {
          this.g = t4, this.H = [], this.C = 0, this.g.setAutoRenderToScreen(false);
        }
        l(t4, e4 = true) {
          if (e4) {
            const e5 = t4.baseOptions || {};
            if (t4.baseOptions?.modelAssetBuffer && t4.baseOptions?.modelAssetPath)
              throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
            if (!(Tn3(this.baseOptions, Ti2, 1)?.g() || Tn3(this.baseOptions, Ti2, 1)?.h() || t4.baseOptions?.modelAssetBuffer || t4.baseOptions?.modelAssetPath))
              throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
            if (function(t5, e6) {
              let n4 = Tn3(t5.baseOptions, Ei2, 3);
              if (!n4) {
                var r4 = n4 = new Ei2(), s4 = new is2();
                xn3(r4, 4, wi2, s4);
              }
              "delegate" in e6 && ("GPU" === e6.delegate ? (e6 = n4, r4 = new ns2(), xn3(e6, 2, wi2, r4)) : (e6 = n4, r4 = new is2(), xn3(e6, 4, wi2, r4))), kn3(t5.baseOptions, 0, 3, n4);
            }(this, e5), e5.modelAssetPath)
              return fetch(e5.modelAssetPath.toString()).then((t5) => {
                if (t5.ok)
                  return t5.arrayBuffer();
                throw Error(`Failed to fetch model: ${e5.modelAssetPath} (${t5.status})`);
              }).then((t5) => {
                try {
                  this.g.i.FS_unlink("/model.dat");
                } catch {
                }
                this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(t5), true, false, false), Ho2(this, "/model.dat"), this.m(), this.K();
              });
            Ho2(this, e5.modelAssetBuffer);
          }
          return this.m(), this.K(), Promise.resolve();
        }
        K() {
        }
        fa() {
          let t4;
          if (this.g.fa((e4) => {
            t4 = Rs2(e4);
          }), !t4)
            throw Error("Failed to retrieve CalculatorGraphConfig");
          return t4;
        }
        setGraph(t4, e4) {
          this.g.attachErrorListener((t5, e5) => {
            this.H.push(Error(e5));
          }), this.g.Ma(), this.g.setGraph(t4, e4), this.B = void 0, Wo(this);
        }
        finishProcessing() {
          this.g.finishProcessing(), Wo(this);
        }
        close() {
          this.B = void 0, this.g.closeGraph();
        }
      };
      qo2.prototype.close = qo2.prototype.close;
      Zo = class {
        constructor(t4, e4, n4, r4) {
          this.g = t4, this.h = e4, this.m = n4, this.l = r4;
        }
        bind() {
          this.g.bindVertexArray(this.h);
        }
        close() {
          this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
        }
      };
      oa2 = class {
        H() {
          return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n ";
        }
        m() {
          const t4 = this.g;
          if (this.h = Jo2(t4.createProgram(), "Failed to create WebGL program"), this.ba = Qo2(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", t4.VERTEX_SHADER), this.aa = Qo2(this, this.H(), t4.FRAGMENT_SHADER), t4.linkProgram(this.h), !t4.getProgramParameter(this.h, t4.LINK_STATUS))
            throw Error(`Error during program linking: ${t4.getProgramInfoLog(this.h)}`);
          this.P = t4.getAttribLocation(this.h, "aVertex"), this.O = t4.getAttribLocation(this.h, "aTex");
        }
        D() {
        }
        l() {
        }
        close() {
          if (this.h) {
            const t4 = this.g;
            t4.deleteProgram(this.h), t4.deleteShader(this.ba), t4.deleteShader(this.aa);
          }
          this.B && this.g.deleteFramebuffer(this.B), this.v && this.v.close(), this.s && this.s.close();
        }
      };
      aa = class extends oa2 {
        H() {
          return "\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n ";
        }
        D() {
          const t4 = this.g;
          t4.activeTexture(t4.TEXTURE1), this.C = ra2(this, t4, t4.LINEAR), t4.activeTexture(t4.TEXTURE2), this.j = ra2(this, t4, t4.NEAREST);
        }
        m() {
          super.m();
          const t4 = this.g;
          this.K = Jo2(t4.getUniformLocation(this.h, "backgroundTexture"), "Uniform location"), this.V = Jo2(t4.getUniformLocation(this.h, "colorMappingTexture"), "Uniform location"), this.J = Jo2(t4.getUniformLocation(this.h, "maskTexture"), "Uniform location");
        }
        l() {
          super.l();
          const t4 = this.g;
          t4.uniform1i(this.J, 0), t4.uniform1i(this.K, 1), t4.uniform1i(this.V, 2);
        }
        close() {
          this.C && this.g.deleteTexture(this.C), this.j && this.g.deleteTexture(this.j), super.close();
        }
      };
      ha2 = class extends oa2 {
        H() {
          return "\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n ";
        }
        D() {
          const t4 = this.g;
          t4.activeTexture(t4.TEXTURE1), this.j = ra2(this, t4), t4.activeTexture(t4.TEXTURE2), this.C = ra2(this, t4);
        }
        m() {
          super.m();
          const t4 = this.g;
          this.J = Jo2(t4.getUniformLocation(this.h, "defaultTexture"), "Uniform location"), this.K = Jo2(t4.getUniformLocation(this.h, "overlayTexture"), "Uniform location"), this.I = Jo2(t4.getUniformLocation(this.h, "maskTexture"), "Uniform location");
        }
        l() {
          super.l();
          const t4 = this.g;
          t4.uniform1i(this.I, 0), t4.uniform1i(this.J, 1), t4.uniform1i(this.K, 2);
        }
        close() {
          this.j && this.g.deleteTexture(this.j), this.C && this.g.deleteTexture(this.C), super.close();
        }
      };
      _a2 = class {
        constructor(t4, e4, n4, r4, s4, i5, o4) {
          this.g = t4, this.m = e4, this.j = n4, this.canvas = r4, this.l = s4, this.width = i5, this.height = o4, this.j && (0 === --va && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources."));
        }
        Ha() {
          return !!ca2(this, 0);
        }
        la() {
          return !!ca2(this, 1);
        }
        R() {
          return !!ca2(this, 2);
        }
        ka() {
          return (e4 = ca2(t4 = this, 0)) || (e4 = ua2(t4), e4 = new Uint8Array(e4.map((t5) => 255 * t5)), t4.g.push(e4)), e4;
          var t4, e4;
        }
        ja() {
          return ua2(this);
        }
        M() {
          return la2(this);
        }
        clone() {
          const t4 = [];
          for (const e4 of this.g) {
            let n4;
            if (e4 instanceof Uint8Array)
              n4 = new Uint8Array(e4);
            else if (e4 instanceof Float32Array)
              n4 = new Float32Array(e4);
            else {
              if (!(e4 instanceof WebGLTexture))
                throw Error(`Type is not supported: ${e4}`);
              {
                const t5 = da2(this), e5 = pa2(this);
                t5.activeTexture(t5.TEXTURE1), n4 = ra2(e5, t5, this.m ? t5.LINEAR : t5.NEAREST), t5.bindTexture(t5.TEXTURE_2D, n4);
                const r4 = fa2(this);
                t5.texImage2D(t5.TEXTURE_2D, 0, r4, this.width, this.height, 0, t5.RED, t5.FLOAT, null), t5.bindTexture(t5.TEXTURE_2D, null), sa2(e5, t5, n4), na2(e5, t5, false, () => {
                  ga(this), t5.clearColor(0, 0, 0, 0), t5.clear(t5.COLOR_BUFFER_BIT), t5.drawArrays(t5.TRIANGLE_FAN, 0, 4), ma2(this);
                }), ia(e5), ma2(this);
              }
            }
            t4.push(n4);
          }
          return new _a2(t4, this.m, this.R(), this.canvas, this.l, this.width, this.height);
        }
        close() {
          this.j && da2(this).deleteTexture(ca2(this, 2)), va = -1;
        }
      };
      _a2.prototype.close = _a2.prototype.close, _a2.prototype.clone = _a2.prototype.clone, _a2.prototype.getAsWebGLTexture = _a2.prototype.M, _a2.prototype.getAsFloat32Array = _a2.prototype.ja, _a2.prototype.getAsUint8Array = _a2.prototype.ka, _a2.prototype.hasWebGLTexture = _a2.prototype.R, _a2.prototype.hasFloat32Array = _a2.prototype.la, _a2.prototype.hasUint8Array = _a2.prototype.Ha;
      va = 250;
      Ea = { color: "white", lineWidth: 4, radius: 6 };
      Fa = class {
        constructor(t4, e4) {
          t4 instanceof CanvasRenderingContext2D || t4 instanceof OffscreenCanvasRenderingContext2D ? (this.l = t4, this.j = e4) : this.j = t4;
        }
        Aa(t4, e4) {
          if (t4) {
            var n4 = ba2(this);
            e4 = wa(e4), n4.save();
            var r4 = n4.canvas, s4 = 0;
            for (const i5 of t4)
              n4.fillStyle = Ta(e4.fillColor, { index: s4, from: i5 }), n4.strokeStyle = Ta(e4.color, { index: s4, from: i5 }), n4.lineWidth = Ta(e4.lineWidth, { index: s4, from: i5 }), (t4 = new Path2D()).arc(i5.x * r4.width, i5.y * r4.height, Ta(e4.radius, { index: s4, from: i5 }), 0, 2 * Math.PI), n4.fill(t4), n4.stroke(t4), ++s4;
            n4.restore();
          }
        }
        za(t4, e4, n4) {
          if (t4 && e4) {
            var r4 = ba2(this);
            n4 = wa(n4), r4.save();
            var s4 = r4.canvas, i5 = 0;
            for (const o4 of e4) {
              r4.beginPath(), e4 = t4[o4.start];
              const a4 = t4[o4.end];
              e4 && a4 && (r4.strokeStyle = Ta(n4.color, { index: i5, from: e4, to: a4 }), r4.lineWidth = Ta(n4.lineWidth, { index: i5, from: e4, to: a4 }), r4.moveTo(e4.x * s4.width, e4.y * s4.height), r4.lineTo(a4.x * s4.width, a4.y * s4.height)), ++i5, r4.stroke();
            }
            r4.restore();
          }
        }
        wa(t4, e4) {
          const n4 = ba2(this);
          e4 = wa(e4), n4.save(), n4.beginPath(), n4.lineWidth = Ta(e4.lineWidth, {}), n4.strokeStyle = Ta(e4.color, {}), n4.fillStyle = Ta(e4.fillColor, {}), n4.moveTo(t4.originX, t4.originY), n4.lineTo(t4.originX + t4.width, t4.originY), n4.lineTo(t4.originX + t4.width, t4.originY + t4.height), n4.lineTo(t4.originX, t4.originY + t4.height), n4.lineTo(t4.originX, t4.originY), n4.stroke(), n4.fill(), n4.restore();
        }
        xa(t4, e4, n4 = [0, 0, 0, 255]) {
          this.l ? function(t5, e5, n5, r4) {
            const s4 = ka(t5);
            xa(t5, e5, (e6) => {
              Sa(t5, e6, n5, r4), (e6 = ba2(t5)).drawImage(s4.canvas, 0, 0, e6.canvas.width, e6.canvas.height);
            });
          }(this, t4, n4, e4) : Sa(this, t4.M(), n4, e4);
        }
        ya(t4, e4, n4) {
          this.l ? function(t5, e5, n5, r4) {
            const s4 = ka(t5);
            xa(t5, e5, (e6) => {
              La(t5, e6, n5, r4), (e6 = ba2(t5)).drawImage(s4.canvas, 0, 0, e6.canvas.width, e6.canvas.height);
            });
          }(this, t4, e4, n4) : La(this, t4.M(), e4, n4);
        }
        close() {
          this.g?.close(), this.g = void 0, this.h?.close(), this.h = void 0, this.m?.close(), this.m = void 0;
        }
      };
      Fa.prototype.close = Fa.prototype.close, Fa.prototype.drawConfidenceMask = Fa.prototype.ya, Fa.prototype.drawCategoryMask = Fa.prototype.xa, Fa.prototype.drawBoundingBox = Fa.prototype.wa, Fa.prototype.drawConnectors = Fa.prototype.za, Fa.prototype.drawLandmarks = Fa.prototype.Aa, Fa.lerp = function(t4, e4, n4, r4, s4) {
        return Aa(r4 * (1 - (t4 - e4) / (n4 - e4)) + s4 * (1 - (n4 - t4) / (n4 - e4)), r4, s4);
      }, Fa.clamp = Aa;
      Ua = class {
        constructor(t4, e4, n4, r4, s4, i5, o4) {
          this.g = t4, this.j = e4, this.m = n4, this.canvas = r4, this.l = s4, this.width = i5, this.height = o4, (this.j || this.m) && (0 === --Ba && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources."));
        }
        Ga() {
          return !!Ra(this, 0);
        }
        ma() {
          return !!Ra(this, 1);
        }
        R() {
          return !!Ra(this, 2);
        }
        Ea() {
          return Ma(this);
        }
        Da() {
          var t4 = Ra(this, 1);
          return t4 || (Pa(this), Ia(this), t4 = Na(this), Da(this), this.g.push(t4), this.j = true), t4;
        }
        M() {
          return Pa(this);
        }
        clone() {
          const t4 = [];
          for (const e4 of this.g) {
            let n4;
            if (e4 instanceof ImageData)
              n4 = new ImageData(e4.data, this.width, this.height);
            else if (e4 instanceof WebGLTexture) {
              const t5 = Oa(this), e5 = Ca(this);
              t5.activeTexture(t5.TEXTURE1), n4 = ra2(e5, t5), t5.bindTexture(t5.TEXTURE_2D, n4), t5.texImage2D(t5.TEXTURE_2D, 0, t5.RGBA, this.width, this.height, 0, t5.RGBA, t5.UNSIGNED_BYTE, null), t5.bindTexture(t5.TEXTURE_2D, null), sa2(e5, t5, n4), na2(e5, t5, false, () => {
                Ia(this), t5.clearColor(0, 0, 0, 0), t5.clear(t5.COLOR_BUFFER_BIT), t5.drawArrays(t5.TRIANGLE_FAN, 0, 4), Da(this);
              }), ia(e5), Da(this);
            } else {
              if (!(e4 instanceof ImageBitmap))
                throw Error(`Type is not supported: ${e4}`);
              Pa(this), Ia(this), n4 = Na(this), Da(this);
            }
            t4.push(n4);
          }
          return new Ua(t4, this.ma(), this.R(), this.canvas, this.l, this.width, this.height);
        }
        close() {
          this.j && Ra(this, 1).close(), this.m && Oa(this).deleteTexture(Ra(this, 2)), Ba = -1;
        }
      };
      Ua.prototype.close = Ua.prototype.close, Ua.prototype.clone = Ua.prototype.clone, Ua.prototype.getAsWebGLTexture = Ua.prototype.M, Ua.prototype.getAsImageBitmap = Ua.prototype.Da, Ua.prototype.getAsImageData = Ua.prototype.Ea, Ua.prototype.hasWebGLTexture = Ua.prototype.R, Ua.prototype.hasImageBitmap = Ua.prototype.ma, Ua.prototype.hasImageData = Ua.prototype.Ga;
      Ba = 250;
      ja2 = /* @__PURE__ */ function(t4) {
        return class extends t4 {
          Ma() {
            this.i._registerModelResourcesGraphService();
          }
        };
      }((Va = class {
        constructor(t4, e4) {
          this.l = true, this.i = t4, this.g = null, this.h = 0, this.m = "function" == typeof this.i._addIntToInputStream, void 0 !== e4 ? this.i.canvas = e4 : "undefined" == typeof OffscreenCanvas || Io3() ? (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.i.canvas = document.createElement("canvas")) : this.i.canvas = new OffscreenCanvas(1, 1);
        }
        async initializeGraph(t4) {
          const e4 = await (await fetch(t4)).arrayBuffer();
          t4 = !(t4.endsWith(".pbtxt") || t4.endsWith(".textproto")), this.setGraph(new Uint8Array(e4), t4);
        }
        setGraphFromString(t4) {
          this.setGraph(new TextEncoder().encode(t4), false);
        }
        setGraph(t4, e4) {
          const n4 = t4.length, r4 = this.i._malloc(n4);
          this.i.HEAPU8.set(t4, r4), e4 ? this.i._changeBinaryGraph(n4, r4) : this.i._changeTextGraph(n4, r4), this.i._free(r4);
        }
        configureAudio(t4, e4, n4, r4, s4) {
          this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), Uo2(this, r4 || "input_audio", (r5) => {
            Uo2(this, s4 = s4 || "audio_header", (s5) => {
              this.i._configureAudio(r5, s5, t4, e4, n4);
            });
          });
        }
        setAutoResizeCanvas(t4) {
          this.l = t4;
        }
        setAutoRenderToScreen(t4) {
          this.i._setAutoRenderToScreen(t4);
        }
        setGpuBufferVerticalFlip(t4) {
          this.i.gpuOriginForWebTexturesIsBottomLeft = t4;
        }
        fa(t4) {
          jo3(this, "__graph_config__", (e4) => {
            t4(e4);
          }), Uo2(this, "__graph_config__", (t5) => {
            this.i._getGraphConfig(t5, void 0);
          }), delete this.i.simpleListeners.__graph_config__;
        }
        attachErrorListener(t4) {
          this.i.errorListener = t4;
        }
        attachEmptyPacketListener(t4, e4) {
          this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}, this.i.emptyPacketListeners[t4] = e4;
        }
        addAudioToStream(t4, e4, n4) {
          this.addAudioToStreamWithShape(t4, 0, 0, e4, n4);
        }
        addAudioToStreamWithShape(t4, e4, n4, r4, s4) {
          const i5 = 4 * t4.length;
          this.h !== i5 && (this.g && this.i._free(this.g), this.g = this.i._malloc(i5), this.h = i5), this.i.HEAPF32.set(t4, this.g / 4), Uo2(this, r4, (t5) => {
            this.i._addAudioToInputStream(this.g, e4, n4, t5, s4);
          });
        }
        addGpuBufferToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const [r4, s4] = Bo2(this, t4, e5);
            this.i._addBoundTextureToStream(e5, r4, s4, n4);
          });
        }
        addBoolToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            this.i._addBoolToInputStream(t4, e5, n4);
          });
        }
        addDoubleToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            this.i._addDoubleToInputStream(t4, e5, n4);
          });
        }
        addFloatToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            this.i._addFloatToInputStream(t4, e5, n4);
          });
        }
        addIntToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            this.i._addIntToInputStream(t4, e5, n4);
          });
        }
        addStringToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            Uo2(this, t4, (t5) => {
              this.i._addStringToInputStream(t5, e5, n4);
            });
          });
        }
        addStringRecordToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            Go(this, Object.keys(t4), (r4) => {
              Go(this, Object.values(t4), (s4) => {
                this.i._addFlatHashMapToInputStream(r4, s4, Object.keys(t4).length, e5, n4);
              });
            });
          });
        }
        addProtoToStream(t4, e4, n4, r4) {
          Uo2(this, n4, (n5) => {
            Uo2(this, e4, (e5) => {
              const s4 = this.i._malloc(t4.length);
              this.i.HEAPU8.set(t4, s4), this.i._addProtoToInputStream(s4, t4.length, e5, n5, r4), this.i._free(s4);
            });
          });
        }
        addEmptyPacketToStream(t4, e4) {
          Uo2(this, t4, (t5) => {
            this.i._addEmptyPacketToInputStream(t5, e4);
          });
        }
        addBoolVectorToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const r4 = this.i._allocateBoolVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new bool vector on heap.");
            for (const e6 of t4)
              this.i._addBoolVectorEntry(r4, e6);
            this.i._addBoolVectorToInputStream(r4, e5, n4);
          });
        }
        addDoubleVectorToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const r4 = this.i._allocateDoubleVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new double vector on heap.");
            for (const e6 of t4)
              this.i._addDoubleVectorEntry(r4, e6);
            this.i._addDoubleVectorToInputStream(r4, e5, n4);
          });
        }
        addFloatVectorToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const r4 = this.i._allocateFloatVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new float vector on heap.");
            for (const e6 of t4)
              this.i._addFloatVectorEntry(r4, e6);
            this.i._addFloatVectorToInputStream(r4, e5, n4);
          });
        }
        addIntVectorToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const r4 = this.i._allocateIntVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new int vector on heap.");
            for (const e6 of t4)
              this.i._addIntVectorEntry(r4, e6);
            this.i._addIntVectorToInputStream(r4, e5, n4);
          });
        }
        addStringVectorToStream(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const r4 = this.i._allocateStringVector(t4.length);
            if (!r4)
              throw Error("Unable to allocate new string vector on heap.");
            for (const e6 of t4)
              Uo2(this, e6, (t5) => {
                this.i._addStringVectorEntry(r4, t5);
              });
            this.i._addStringVectorToInputStream(r4, e5, n4);
          });
        }
        addBoolToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            this.i._addBoolToInputSidePacket(t4, e5);
          });
        }
        addDoubleToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            this.i._addDoubleToInputSidePacket(t4, e5);
          });
        }
        addFloatToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            this.i._addFloatToInputSidePacket(t4, e5);
          });
        }
        addIntToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            this.i._addIntToInputSidePacket(t4, e5);
          });
        }
        addStringToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            Uo2(this, t4, (t5) => {
              this.i._addStringToInputSidePacket(t5, e5);
            });
          });
        }
        addProtoToInputSidePacket(t4, e4, n4) {
          Uo2(this, n4, (n5) => {
            Uo2(this, e4, (e5) => {
              const r4 = this.i._malloc(t4.length);
              this.i.HEAPU8.set(t4, r4), this.i._addProtoToInputSidePacket(r4, t4.length, e5, n5), this.i._free(r4);
            });
          });
        }
        addBoolVectorToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            const n4 = this.i._allocateBoolVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new bool vector on heap.");
            for (const e6 of t4)
              this.i._addBoolVectorEntry(n4, e6);
            this.i._addBoolVectorToInputSidePacket(n4, e5);
          });
        }
        addDoubleVectorToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            const n4 = this.i._allocateDoubleVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new double vector on heap.");
            for (const e6 of t4)
              this.i._addDoubleVectorEntry(n4, e6);
            this.i._addDoubleVectorToInputSidePacket(n4, e5);
          });
        }
        addFloatVectorToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            const n4 = this.i._allocateFloatVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new float vector on heap.");
            for (const e6 of t4)
              this.i._addFloatVectorEntry(n4, e6);
            this.i._addFloatVectorToInputSidePacket(n4, e5);
          });
        }
        addIntVectorToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            const n4 = this.i._allocateIntVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new int vector on heap.");
            for (const e6 of t4)
              this.i._addIntVectorEntry(n4, e6);
            this.i._addIntVectorToInputSidePacket(n4, e5);
          });
        }
        addStringVectorToInputSidePacket(t4, e4) {
          Uo2(this, e4, (e5) => {
            const n4 = this.i._allocateStringVector(t4.length);
            if (!n4)
              throw Error("Unable to allocate new string vector on heap.");
            for (const e6 of t4)
              Uo2(this, e6, (t5) => {
                this.i._addStringVectorEntry(n4, t5);
              });
            this.i._addStringVectorToInputSidePacket(n4, e5);
          });
        }
        attachBoolListener(t4, e4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachBoolListener(t5);
          });
        }
        attachBoolVectorListener(t4, e4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachBoolVectorListener(t5);
          });
        }
        attachIntListener(t4, e4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachIntListener(t5);
          });
        }
        attachIntVectorListener(t4, e4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachIntVectorListener(t5);
          });
        }
        attachDoubleListener(t4, e4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachDoubleListener(t5);
          });
        }
        attachDoubleVectorListener(t4, e4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachDoubleVectorListener(t5);
          });
        }
        attachFloatListener(t4, e4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachFloatListener(t5);
          });
        }
        attachFloatVectorListener(t4, e4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachFloatVectorListener(t5);
          });
        }
        attachStringListener(t4, e4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachStringListener(t5);
          });
        }
        attachStringVectorListener(t4, e4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachStringVectorListener(t5);
          });
        }
        attachProtoListener(t4, e4, n4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachProtoListener(t5, n4 || false);
          });
        }
        attachProtoVectorListener(t4, e4, n4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.i._attachProtoVectorListener(t5, n4 || false);
          });
        }
        attachAudioListener(t4, e4, n4) {
          this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), jo3(this, t4, (t5, n5) => {
            t5 = new Float32Array(t5.buffer, t5.byteOffset, t5.length / 4), e4(t5, n5);
          }), Uo2(this, t4, (t5) => {
            this.i._attachAudioListener(t5, n4 || false);
          });
        }
        finishProcessing() {
          this.i._waitUntilIdle();
        }
        closeGraph() {
          this.i._closeGraph(), this.i.simpleListeners = void 0, this.i.emptyPacketListeners = void 0;
        }
      }, class extends Va {
        get ha() {
          return this.i;
        }
        sa(t4, e4, n4) {
          Uo2(this, e4, (e5) => {
            const [r4, s4] = Bo2(this, t4, e5);
            this.ha._addBoundTextureAsImageToStream(e5, r4, s4, n4);
          });
        }
        W(t4, e4) {
          jo3(this, t4, e4), Uo2(this, t4, (t5) => {
            this.ha._attachImageListener(t5);
          });
        }
        da(t4, e4) {
          Vo2(this, t4, e4), Uo2(this, t4, (t5) => {
            this.ha._attachImageVectorListener(t5);
          });
        }
      }));
      Xa2 = class extends ja2 {
      };
      $a = class extends qo2 {
        constructor(t4, e4, n4, r4) {
          super(t4), this.g = t4, this.ba = e4, this.V = n4, this.ra = r4, this.O = new oa2();
        }
        l(t4, e4 = true) {
          if ("runningMode" in t4 && On2(this.baseOptions, 2, !!t4.runningMode && "IMAGE" !== t4.runningMode), void 0 !== t4.canvas && this.g.i.canvas !== t4.canvas)
            throw Error("You must create a new task to reset the canvas.");
          return super.l(t4, e4);
        }
        close() {
          this.O.close(), super.close();
        }
      };
      $a.prototype.close = $a.prototype.close;
      qa2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect_in", false), this.j = { detections: [] }, kn3(t4 = this.h = new xi2(), 0, 1, e4 = new bi2()), In2(this.h, 2, 0.5), In2(this.h, 3, 0.3);
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return "minDetectionConfidence" in t4 && In2(this.h, 2, t4.minDetectionConfidence ?? 0.5), "minSuppressionThreshold" in t4 && In2(this.h, 3, t4.minSuppressionThreshold ?? 0.3), this.l(t4);
        }
        F(t4, e4) {
          return this.j = { detections: [] }, za(this, t4, e4), this.j;
        }
        G(t4, e4, n4) {
          return this.j = { detections: [] }, Ka2(this, t4, n4, e4), this.j;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect_in"), Ss2(t4, "detections");
          const e4 = new hs2();
          Dn3(e4, Li2, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect_in"), _s2(n4, "DETECTIONS:detections"), n4.o(e4), ks2(t4, n4), this.g.attachProtoVectorListener("detections", (t5, e5) => {
            for (const e6 of t5)
              t5 = Ks(e6), this.j.detections.push(ko3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("detections", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      qa2.prototype.detectForVideo = qa2.prototype.G, qa2.prototype.detect = qa2.prototype.F, qa2.prototype.setOptions = qa2.prototype.o, qa2.createFromModelPath = async function(t4, e4) {
        return Ha(qa2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, qa2.createFromModelBuffer = function(t4, e4) {
        return Ha(qa2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, qa2.createFromOptions = function(t4, e4) {
        return Ha(qa2, t4, e4);
      };
      Ja2 = Ga([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]);
      Za2 = Ga([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]);
      Qa2 = Ga([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]);
      th2 = Ga([474, 475], [475, 476], [476, 477], [477, 474]);
      eh2 = Ga([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]);
      nh2 = Ga([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]);
      rh2 = Ga([469, 470], [470, 471], [471, 472], [472, 469]);
      sh2 = Ga([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]);
      ih2 = [...Ja2, ...Za2, ...Qa2, ...eh2, ...nh2, ...sh2];
      oh2 = Ga([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
      hh2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", false), this.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = false, kn3(t4 = this.h = new Ii2(), 0, 1, e4 = new bi2()), this.v = new Oi2(), kn3(this.h, 0, 3, this.v), this.s = new xi2(), kn3(this.h, 0, 2, this.s), Cn3(this.s, 4, 1), In2(this.s, 2, 0.5), In2(this.v, 2, 0.5), In2(this.h, 4, 0.5);
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return "numFaces" in t4 && Cn3(this.s, 4, t4.numFaces ?? 1), "minFaceDetectionConfidence" in t4 && In2(this.s, 2, t4.minFaceDetectionConfidence ?? 0.5), "minTrackingConfidence" in t4 && In2(this.h, 4, t4.minTrackingConfidence ?? 0.5), "minFacePresenceConfidence" in t4 && In2(this.v, 2, t4.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t4 && (this.outputFaceBlendshapes = !!t4.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in t4 && (this.outputFacialTransformationMatrixes = !!t4.outputFacialTransformationMatrixes), this.l(t4);
        }
        F(t4, e4) {
          return ah2(this), za(this, t4, e4), this.j;
        }
        G(t4, e4, n4) {
          return ah2(this), Ka2(this, t4, n4, e4), this.j;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect"), Ss2(t4, "face_landmarks");
          const e4 = new hs2();
          Dn3(e4, Ni2, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "NORM_LANDMARKS:face_landmarks"), n4.o(e4), ks2(t4, n4), this.g.attachProtoVectorListener("face_landmarks", (t5, e5) => {
            for (const e6 of t5)
              t5 = ei2(e6), this.j.faceLandmarks.push(xo3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("face_landmarks", (t5) => {
            zo(this, t5);
          }), this.outputFaceBlendshapes && (Ss2(t4, "blendshapes"), _s2(n4, "BLENDSHAPES:blendshapes"), this.g.attachProtoVectorListener("blendshapes", (t5, e5) => {
            if (this.outputFaceBlendshapes)
              for (const e6 of t5)
                t5 = Ds2(e6), this.j.faceBlendshapes.push(bo3(t5.g() ?? []));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("blendshapes", (t5) => {
            zo(this, t5);
          })), this.outputFacialTransformationMatrixes && (Ss2(t4, "face_geometry"), _s2(n4, "FACE_GEOMETRY:face_geometry"), this.g.attachProtoVectorListener("face_geometry", (t5, e5) => {
            if (this.outputFacialTransformationMatrixes)
              for (const e6 of t5)
                (t5 = Tn3(Mi2(e6), ni, 2)) && this.j.facialTransformationMatrixes.push({ rows: Mn3(Fn3(t5, 1)) ?? 0, columns: Mn3(Fn3(t5, 2)) ?? 0, data: cn3(t5, 3, fe3).slice() ?? [] });
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("face_geometry", (t5) => {
            zo(this, t5);
          })), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      hh2.prototype.detectForVideo = hh2.prototype.G, hh2.prototype.detect = hh2.prototype.F, hh2.prototype.setOptions = hh2.prototype.o, hh2.createFromModelPath = function(t4, e4) {
        return Ha(hh2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, hh2.createFromModelBuffer = function(t4, e4) {
        return Ha(hh2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, hh2.createFromOptions = function(t4, e4) {
        return Ha(hh2, t4, e4);
      }, hh2.FACE_LANDMARKS_LIPS = Ja2, hh2.FACE_LANDMARKS_LEFT_EYE = Za2, hh2.FACE_LANDMARKS_LEFT_EYEBROW = Qa2, hh2.FACE_LANDMARKS_LEFT_IRIS = th2, hh2.FACE_LANDMARKS_RIGHT_EYE = eh2, hh2.FACE_LANDMARKS_RIGHT_EYEBROW = nh2, hh2.FACE_LANDMARKS_RIGHT_IRIS = rh2, hh2.FACE_LANDMARKS_FACE_OVAL = sh2, hh2.FACE_LANDMARKS_CONTOURS = ih2, hh2.FACE_LANDMARKS_TESSELATION = oh2;
      ch2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", true), kn3(t4 = this.j = new Ui2(), 0, 1, e4 = new bi2());
        }
        get baseOptions() {
          return Tn3(this.j, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.j, 0, 1, t4);
        }
        o(t4) {
          return super.l(t4);
        }
        Pa(t4, e4, n4) {
          const r4 = "function" != typeof e4 ? e4 : {};
          if (this.h = "function" == typeof e4 ? e4 : n4, za(this, t4, r4 ?? {}), !this.h)
            return this.s;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect"), Ss2(t4, "stylized_image");
          const e4 = new hs2();
          Dn3(e4, Bi2, this.j);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "STYLIZED_IMAGE:stylized_image"), n4.o(e4), ks2(t4, n4), this.g.W("stylized_image", (t5, e5) => {
            var n5 = !this.h, r4 = t5.data, s4 = t5.width;
            const i5 = s4 * (t5 = t5.height);
            if (r4 instanceof Uint8Array)
              if (r4.length === 3 * i5) {
                const e6 = new Uint8ClampedArray(4 * i5);
                for (let t6 = 0; t6 < i5; ++t6)
                  e6[4 * t6] = r4[3 * t6], e6[4 * t6 + 1] = r4[3 * t6 + 1], e6[4 * t6 + 2] = r4[3 * t6 + 2], e6[4 * t6 + 3] = 255;
                r4 = new ImageData(e6, s4, t5);
              } else {
                if (r4.length !== 4 * i5)
                  throw Error("Unsupported channel count: " + r4.length / i5);
                r4 = new ImageData(new Uint8ClampedArray(r4.buffer, r4.byteOffset, r4.length), s4, t5);
              }
            else if (!(r4 instanceof WebGLTexture))
              throw Error(`Unsupported format: ${r4.constructor.name}`);
            s4 = new Ua([r4], false, false, this.g.i.canvas, this.O, s4, t5), this.s = n5 = n5 ? s4.clone() : s4, this.h && this.h(n5), zo(this, e5);
          }), this.g.attachEmptyPacketListener("stylized_image", (t5) => {
            this.s = null, this.h && this.h(null), zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      ch2.prototype.stylize = ch2.prototype.Pa, ch2.prototype.setOptions = ch2.prototype.o, ch2.createFromModelPath = function(t4, e4) {
        return Ha(ch2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, ch2.createFromModelBuffer = function(t4, e4) {
        return Ha(ch2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, ch2.createFromOptions = function(t4, e4) {
        return Ha(ch2, t4, e4);
      };
      uh = Ga([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
      ph = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", false), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handedness = [], kn3(t4 = this.j = new Ji2(), 0, 1, e4 = new bi2()), this.s = new $i2(), kn3(this.j, 0, 2, this.s), this.D = new Ki2(), kn3(this.s, 0, 3, this.D), this.v = new Wi2(), kn3(this.s, 0, 2, this.v), this.h = new Xi2(), kn3(this.j, 0, 3, this.h), In2(this.v, 2, 0.5), In2(this.s, 4, 0.5), In2(this.D, 2, 0.5);
        }
        get baseOptions() {
          return Tn3(this.j, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.j, 0, 1, t4);
        }
        o(t4) {
          if (Cn3(this.v, 3, t4.numHands ?? 1), "minHandDetectionConfidence" in t4 && In2(this.v, 2, t4.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t4 && In2(this.s, 4, t4.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t4 && In2(this.D, 2, t4.minHandPresenceConfidence ?? 0.5), t4.cannedGesturesClassifierOptions) {
            var e4 = new Gi2(), n4 = e4, r4 = Ao3(t4.cannedGesturesClassifierOptions, Tn3(this.h, Gi2, 3)?.h());
            kn3(n4, 0, 2, r4), kn3(this.h, 0, 3, e4);
          } else
            void 0 === t4.cannedGesturesClassifierOptions && Tn3(this.h, Gi2, 3)?.g();
          return t4.customGesturesClassifierOptions ? (kn3(n4 = e4 = new Gi2(), 0, 2, r4 = Ao3(t4.customGesturesClassifierOptions, Tn3(this.h, Gi2, 4)?.h())), kn3(this.h, 0, 4, e4)) : void 0 === t4.customGesturesClassifierOptions && Tn3(this.h, Gi2, 4)?.g(), this.l(t4);
        }
        Ka(t4, e4) {
          return lh2(this), za(this, t4, e4), dh2(this);
        }
        La(t4, e4, n4) {
          return lh2(this), Ka2(this, t4, n4, e4), dh2(this);
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect"), Ss2(t4, "hand_gestures"), Ss2(t4, "hand_landmarks"), Ss2(t4, "world_hand_landmarks"), Ss2(t4, "handedness");
          const e4 = new hs2();
          Dn3(e4, to3, this.j);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "HAND_GESTURES:hand_gestures"), _s2(n4, "LANDMARKS:hand_landmarks"), _s2(n4, "WORLD_LANDMARKS:world_hand_landmarks"), _s2(n4, "HANDEDNESS:handedness"), n4.o(e4), ks2(t4, n4), this.g.attachProtoVectorListener("hand_landmarks", (t5, e5) => {
            for (const e6 of t5) {
              t5 = ei2(e6);
              const n5 = [];
              for (const e7 of bn3(t5, Zs, 1))
                n5.push({ x: Pn2(e7, 1) ?? 0, y: Pn2(e7, 2) ?? 0, z: Pn2(e7, 3) ?? 0, visibility: Pn2(e7, 4) ?? 0 });
              this.landmarks.push(n5);
            }
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("hand_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoVectorListener("world_hand_landmarks", (t5, e5) => {
            for (const e6 of t5) {
              t5 = Js(e6);
              const n5 = [];
              for (const e7 of bn3(t5, Ys, 1))
                n5.push({ x: Pn2(e7, 1) ?? 0, y: Pn2(e7, 2) ?? 0, z: Pn2(e7, 3) ?? 0, visibility: Pn2(e7, 4) ?? 0 });
              this.worldLandmarks.push(n5);
            }
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("world_hand_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoVectorListener("hand_gestures", (t5, e5) => {
            this.gestures.push(...fh2(t5, false)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("hand_gestures", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoVectorListener("handedness", (t5, e5) => {
            this.handedness.push(...fh2(t5)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("handedness", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      ph.prototype.recognizeForVideo = ph.prototype.La, ph.prototype.recognize = ph.prototype.Ka, ph.prototype.setOptions = ph.prototype.o, ph.createFromModelPath = function(t4, e4) {
        return Ha(ph, t4, { baseOptions: { modelAssetPath: e4 } });
      }, ph.createFromModelBuffer = function(t4, e4) {
        return Ha(ph, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, ph.createFromOptions = function(t4, e4) {
        return Ha(ph, t4, e4);
      }, ph.HAND_CONNECTIONS = uh;
      mh2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.handedness = [], kn3(t4 = this.h = new $i2(), 0, 1, e4 = new bi2()), this.s = new Ki2(), kn3(this.h, 0, 3, this.s), this.j = new Wi2(), kn3(this.h, 0, 2, this.j), Cn3(this.j, 3, 1), In2(this.j, 2, 0.5), In2(this.s, 2, 0.5), In2(this.h, 4, 0.5);
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return "numHands" in t4 && Cn3(this.j, 3, t4.numHands ?? 1), "minHandDetectionConfidence" in t4 && In2(this.j, 2, t4.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t4 && In2(this.h, 4, t4.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t4 && In2(this.s, 2, t4.minHandPresenceConfidence ?? 0.5), this.l(t4);
        }
        F(t4, e4) {
          return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], za(this, t4, e4), gh2(this);
        }
        G(t4, e4, n4) {
          return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Ka2(this, t4, n4, e4), gh2(this);
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect"), Ss2(t4, "hand_landmarks"), Ss2(t4, "world_hand_landmarks"), Ss2(t4, "handedness");
          const e4 = new hs2();
          Dn3(e4, Qi2, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "LANDMARKS:hand_landmarks"), _s2(n4, "WORLD_LANDMARKS:world_hand_landmarks"), _s2(n4, "HANDEDNESS:handedness"), n4.o(e4), ks2(t4, n4), this.g.attachProtoVectorListener("hand_landmarks", (t5, e5) => {
            for (const e6 of t5)
              t5 = ei2(e6), this.landmarks.push(xo3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("hand_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoVectorListener("world_hand_landmarks", (t5, e5) => {
            for (const e6 of t5)
              t5 = Js(e6), this.worldLandmarks.push(So3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("world_hand_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoVectorListener("handedness", (t5, e5) => {
            var n5 = this.handedness, r4 = n5.push;
            const s4 = [];
            for (const e6 of t5) {
              t5 = Ds2(e6);
              const n6 = [];
              for (const e7 of t5.g())
                n6.push({ score: Pn2(e7, 2) ?? 0, index: Mn3(Fn3(e7, 1)) ?? -1, categoryName: Rn3(e7, 3) ?? "" ?? "", displayName: Rn3(e7, 4) ?? "" ?? "" });
              s4.push(n6);
            }
            r4.call(n5, ...s4), zo(this, e5);
          }), this.g.attachEmptyPacketListener("handedness", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      mh2.prototype.detectForVideo = mh2.prototype.G, mh2.prototype.detect = mh2.prototype.F, mh2.prototype.setOptions = mh2.prototype.o, mh2.createFromModelPath = function(t4, e4) {
        return Ha(mh2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, mh2.createFromModelBuffer = function(t4, e4) {
        return Ha(mh2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, mh2.createFromOptions = function(t4, e4) {
        return Ha(mh2, t4, e4);
      }, mh2.HAND_CONNECTIONS = uh;
      yh2 = Ga([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
      wh2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "input_frames_image", null, false), this.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] }, this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = false, kn3(t4 = this.j = new ao3(), 0, 1, e4 = new bi2()), this.I = new Ki2(), kn3(this.j, 0, 2, this.I), this.aa = new eo3(), kn3(this.j, 0, 3, this.aa), this.s = new xi2(), kn3(this.j, 0, 4, this.s), this.P = new Oi2(), kn3(this.j, 0, 5, this.P), this.v = new ro3(), kn3(this.j, 0, 6, this.v), this.J = new io3(), kn3(this.j, 0, 7, this.J), In2(this.s, 2, 0.5), In2(this.s, 3, 0.3), In2(this.P, 2, 0.5), In2(this.v, 2, 0.5), In2(this.v, 3, 0.3), In2(this.J, 2, 0.5), In2(this.I, 2, 0.5);
        }
        get baseOptions() {
          return Tn3(this.j, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.j, 0, 1, t4);
        }
        o(t4) {
          return "minFaceDetectionConfidence" in t4 && In2(this.s, 2, t4.minFaceDetectionConfidence ?? 0.5), "minFaceSuppressionThreshold" in t4 && In2(this.s, 3, t4.minFaceSuppressionThreshold ?? 0.3), "minFacePresenceConfidence" in t4 && In2(this.P, 2, t4.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t4 && (this.outputFaceBlendshapes = !!t4.outputFaceBlendshapes), "minPoseDetectionConfidence" in t4 && In2(this.v, 2, t4.minPoseDetectionConfidence ?? 0.5), "minPoseSuppressionThreshold" in t4 && In2(this.v, 3, t4.minPoseSuppressionThreshold ?? 0.3), "minPosePresenceConfidence" in t4 && In2(this.J, 2, t4.minPosePresenceConfidence ?? 0.5), "outputPoseSegmentationMasks" in t4 && (this.outputPoseSegmentationMasks = !!t4.outputPoseSegmentationMasks), "minHandLandmarksConfidence" in t4 && In2(this.I, 2, t4.minHandLandmarksConfidence ?? 0.5), this.l(t4);
        }
        F(t4, e4, n4) {
          const r4 = "function" != typeof e4 ? e4 : {};
          return this.D = "function" == typeof e4 ? e4 : n4, _h2(this), za(this, t4, r4), vh2(this);
        }
        G(t4, e4, n4, r4) {
          const s4 = "function" != typeof n4 ? n4 : {};
          return this.D = "function" == typeof n4 ? n4 : r4, _h2(this), Ka2(this, t4, s4, e4), vh2(this);
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "input_frames_image"), Ss2(t4, "pose_landmarks"), Ss2(t4, "pose_world_landmarks"), Ss2(t4, "face_landmarks"), Ss2(t4, "left_hand_landmarks"), Ss2(t4, "left_hand_world_landmarks"), Ss2(t4, "right_hand_landmarks"), Ss2(t4, "right_hand_world_landmarks");
          const e4 = new hs2(), n4 = new Jr2();
          gn3(n4, 1, ke3("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""), function(t5, e5) {
            if (null != e5)
              if (Array.isArray(e5))
                rn3(t5, 2, Ye2(e5, qe2, void 0, void 0, false));
              else {
                if (!("string" == typeof e5 || e5 instanceof U4 || R4(e5)))
                  throw Error("invalid value in Any.value field: " + e5 + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
                gn3(t5, 2, se2(e5, false, false), D2());
              }
          }(n4, this.j.g());
          const r4 = new vs2();
          ms2(r4, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), Ln3(r4, 8, Jr2, n4), ys2(r4, "IMAGE:input_frames_image"), _s2(r4, "POSE_LANDMARKS:pose_landmarks"), _s2(r4, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), _s2(r4, "FACE_LANDMARKS:face_landmarks"), _s2(r4, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), _s2(r4, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), _s2(r4, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), _s2(r4, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), r4.o(e4), ks2(t4, r4), Ko2(this, t4), this.g.attachProtoListener("pose_landmarks", (t5, e5) => {
            Eh2(t5, this.h.poseLandmarks), zo(this, e5);
          }), this.g.attachEmptyPacketListener("pose_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoListener("pose_world_landmarks", (t5, e5) => {
            var n5 = this.h.poseWorldLandmarks;
            t5 = Js(t5), n5.push(So3(t5)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("pose_world_landmarks", (t5) => {
            zo(this, t5);
          }), this.outputPoseSegmentationMasks && (_s2(r4, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), Yo2(this, "pose_segmentation_mask"), this.g.W("pose_segmentation_mask", (t5, e5) => {
            this.h.poseSegmentationMasks = [Ya2(this, t5, true, !this.D)], zo(this, e5);
          }), this.g.attachEmptyPacketListener("pose_segmentation_mask", (t5) => {
            this.h.poseSegmentationMasks = [], zo(this, t5);
          })), this.g.attachProtoListener("face_landmarks", (t5, e5) => {
            Eh2(t5, this.h.faceLandmarks), zo(this, e5);
          }), this.g.attachEmptyPacketListener("face_landmarks", (t5) => {
            zo(this, t5);
          }), this.outputFaceBlendshapes && (Ss2(t4, "extra_blendshapes"), _s2(r4, "FACE_BLENDSHAPES:extra_blendshapes"), this.g.attachProtoListener("extra_blendshapes", (t5, e5) => {
            var n5 = this.h.faceBlendshapes;
            this.outputFaceBlendshapes && (t5 = Ds2(t5), n5.push(bo3(t5.g() ?? []))), zo(this, e5);
          }), this.g.attachEmptyPacketListener("extra_blendshapes", (t5) => {
            zo(this, t5);
          })), this.g.attachProtoListener("left_hand_landmarks", (t5, e5) => {
            Eh2(t5, this.h.leftHandLandmarks), zo(this, e5);
          }), this.g.attachEmptyPacketListener("left_hand_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoListener("left_hand_world_landmarks", (t5, e5) => {
            var n5 = this.h.leftHandWorldLandmarks;
            t5 = Js(t5), n5.push(So3(t5)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("left_hand_world_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoListener("right_hand_landmarks", (t5, e5) => {
            Eh2(t5, this.h.rightHandLandmarks), zo(this, e5);
          }), this.g.attachEmptyPacketListener("right_hand_landmarks", (t5) => {
            zo(this, t5);
          }), this.g.attachProtoListener("right_hand_world_landmarks", (t5, e5) => {
            var n5 = this.h.rightHandWorldLandmarks;
            t5 = Js(t5), n5.push(So3(t5)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("right_hand_world_landmarks", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      wh2.prototype.detectForVideo = wh2.prototype.G, wh2.prototype.detect = wh2.prototype.F, wh2.prototype.setOptions = wh2.prototype.o, wh2.createFromModelPath = function(t4, e4) {
        return Ha(wh2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, wh2.createFromModelBuffer = function(t4, e4) {
        return Ha(wh2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, wh2.createFromOptions = function(t4, e4) {
        return Ha(wh2, t4, e4);
      }, wh2.HAND_CONNECTIONS = uh, wh2.POSE_CONNECTIONS = yh2, wh2.FACE_LANDMARKS_LIPS = Ja2, wh2.FACE_LANDMARKS_LEFT_EYE = Za2, wh2.FACE_LANDMARKS_LEFT_EYEBROW = Qa2, wh2.FACE_LANDMARKS_LEFT_IRIS = th2, wh2.FACE_LANDMARKS_RIGHT_EYE = eh2, wh2.FACE_LANDMARKS_RIGHT_EYEBROW = nh2, wh2.FACE_LANDMARKS_RIGHT_IRIS = rh2, wh2.FACE_LANDMARKS_FACE_OVAL = sh2, wh2.FACE_LANDMARKS_CONTOURS = ih2, wh2.FACE_LANDMARKS_TESSELATION = oh2;
      Th2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "input_image", "norm_rect", true), this.j = { classifications: [] }, kn3(t4 = this.h = new ho3(), 0, 1, e4 = new bi2());
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return kn3(this.h, 0, 2, Ao3(t4, Tn3(this.h, mi2, 2))), this.l(t4);
        }
        ua(t4, e4) {
          return this.j = { classifications: [] }, za(this, t4, e4), this.j;
        }
        va(t4, e4, n4) {
          return this.j = { classifications: [] }, Ka2(this, t4, n4, e4), this.j;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "input_image"), xs2(t4, "norm_rect"), Ss2(t4, "classifications");
          const e4 = new hs2();
          Dn3(e4, co3, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), ys2(n4, "IMAGE:input_image"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "CLASSIFICATIONS:classifications"), n4.o(e4), ks2(t4, n4), this.g.attachProtoListener("classifications", (t5, e5) => {
            this.j = function(t6) {
              const e6 = { classifications: bn3(t6, ii, 1).map((t7) => bo3(Tn3(t7, Cs2, 4)?.g() ?? [], Mn3(Fn3(t7, 2)), Rn3(t7, 3) ?? "")) };
              return null != Ae2(en2(t6, 2)) && (e6.timestampMs = Mn3(Ae2(en2(t6, 2)))), e6;
            }(hi(t5)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("classifications", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Th2.prototype.classifyForVideo = Th2.prototype.va, Th2.prototype.classify = Th2.prototype.ua, Th2.prototype.setOptions = Th2.prototype.o, Th2.createFromModelPath = function(t4, e4) {
        return Ha(Th2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Th2.createFromModelBuffer = function(t4, e4) {
        return Ha(Th2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Th2.createFromOptions = function(t4, e4) {
        return Ha(Th2, t4, e4);
      };
      Ah = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", true), this.h = new uo3(), this.embeddings = { embeddings: [] }, kn3(t4 = this.h, 0, 1, e4 = new bi2());
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          var e4 = this.h, n4 = Tn3(this.h, _i2, 2);
          return n4 = n4 ? n4.clone() : new _i2(), void 0 !== t4.l2Normalize ? On2(n4, 1, t4.l2Normalize) : "l2Normalize" in t4 && rn3(n4, 1), void 0 !== t4.quantize ? On2(n4, 2, t4.quantize) : "quantize" in t4 && rn3(n4, 2), kn3(e4, 0, 2, n4), this.l(t4);
        }
        Ba(t4, e4) {
          return za(this, t4, e4), this.embeddings;
        }
        Ca(t4, e4, n4) {
          return Ka2(this, t4, n4, e4), this.embeddings;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect"), Ss2(t4, "embeddings_out");
          const e4 = new hs2();
          Dn3(e4, lo3, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "EMBEDDINGS:embeddings_out"), n4.o(e4), ks2(t4, n4), this.g.attachProtoListener("embeddings_out", (t5, e5) => {
            t5 = gi2(t5), this.embeddings = function(t6) {
              return { embeddings: bn3(t6, li, 1).map((t7) => {
                const e6 = { headIndex: Mn3(Fn3(t7, 3)) ?? -1, headName: Rn3(t7, 4) ?? "" ?? "" };
                if (void 0 !== wn2(t7, ci, _n2(t7, 1)))
                  t7 = cn3(t7 = Tn3(t7, ci, _n2(t7, 1)), 1, fe3), e6.floatEmbedding = t7.slice();
                else {
                  const n5 = new Uint8Array(0);
                  e6.quantizedEmbedding = Tn3(t7, ui, _n2(t7, 2))?.qa()?.h() ?? n5;
                }
                return e6;
              }), timestampMs: Mn3(Ae2(en2(t6, 2))) };
            }(t5), zo(this, e5);
          }), this.g.attachEmptyPacketListener("embeddings_out", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Ah.cosineSimilarity = function(t4, e4) {
        if (t4.floatEmbedding && e4.floatEmbedding)
          t4 = Fo3(t4.floatEmbedding, e4.floatEmbedding);
        else {
          if (!t4.quantizedEmbedding || !e4.quantizedEmbedding)
            throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
          t4 = Fo3(Lo3(t4.quantizedEmbedding), Lo3(e4.quantizedEmbedding));
        }
        return t4;
      }, Ah.prototype.embedForVideo = Ah.prototype.Ca, Ah.prototype.embed = Ah.prototype.Ba, Ah.prototype.setOptions = Ah.prototype.o, Ah.createFromModelPath = function(t4, e4) {
        return Ha(Ah, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Ah.createFromModelBuffer = function(t4, e4) {
        return Ha(Ah, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Ah.createFromOptions = function(t4, e4) {
        return Ha(Ah, t4, e4);
      };
      bh2 = class {
        constructor(t4, e4, n4) {
          this.confidenceMasks = t4, this.categoryMask = e4, this.qualityScores = n4;
        }
        close() {
          this.confidenceMasks?.forEach((t4) => {
            t4.close();
          }), this.categoryMask?.close();
        }
      };
      bh2.prototype.close = bh2.prototype.close;
      Sh2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", false), this.s = [], this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new yo3(), this.v = new fo3(), kn3(this.h, 0, 3, this.v), kn3(t4 = this.h, 0, 1, e4 = new bi2());
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return void 0 !== t4.displayNamesLocale ? rn3(this.h, 2, ke3(t4.displayNamesLocale)) : "displayNamesLocale" in t4 && rn3(this.h, 2), "outputCategoryMask" in t4 && (this.outputCategoryMask = t4.outputCategoryMask ?? false), "outputConfidenceMasks" in t4 && (this.outputConfidenceMasks = t4.outputConfidenceMasks ?? true), super.l(t4);
        }
        K() {
          !function(t4) {
            const e4 = bn3(t4.fa(), vs2, 1).filter((t5) => (Rn3(t5, 1) ?? "").includes("mediapipe.tasks.TensorsToSegmentationCalculator"));
            if (t4.s = [], 1 < e4.length)
              throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
            1 === e4.length && (Tn3(e4[0], hs2, 7)?.l()?.g() ?? /* @__PURE__ */ new Map()).forEach((e5, n4) => {
              t4.s[Number(n4)] = Rn3(e5, 1) ?? "";
            });
          }(this);
        }
        ga(t4, e4, n4) {
          const r4 = "function" != typeof e4 ? e4 : {};
          return this.j = "function" == typeof e4 ? e4 : n4, kh2(this), za(this, t4, r4), xh2(this);
        }
        Na(t4, e4, n4, r4) {
          const s4 = "function" != typeof n4 ? n4 : {};
          return this.j = "function" == typeof n4 ? n4 : r4, kh2(this), Ka2(this, t4, s4, e4), xh2(this);
        }
        Fa() {
          return this.s;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect");
          const e4 = new hs2();
          Dn3(e4, _o3, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), n4.o(e4), ks2(t4, n4), Ko2(this, t4), this.outputConfidenceMasks && (Ss2(t4, "confidence_masks"), _s2(n4, "CONFIDENCE_MASKS:confidence_masks"), Yo2(this, "confidence_masks"), this.g.da("confidence_masks", (t5, e5) => {
            this.confidenceMasks = t5.map((t6) => Ya2(this, t6, true, !this.j)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("confidence_masks", (t5) => {
            this.confidenceMasks = [], zo(this, t5);
          })), this.outputCategoryMask && (Ss2(t4, "category_mask"), _s2(n4, "CATEGORY_MASK:category_mask"), Yo2(this, "category_mask"), this.g.W("category_mask", (t5, e5) => {
            this.categoryMask = Ya2(this, t5, false, !this.j), zo(this, e5);
          }), this.g.attachEmptyPacketListener("category_mask", (t5) => {
            this.categoryMask = void 0, zo(this, t5);
          })), Ss2(t4, "quality_scores"), _s2(n4, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (t5, e5) => {
            this.qualityScores = t5, zo(this, e5);
          }), this.g.attachEmptyPacketListener("quality_scores", (t5) => {
            this.categoryMask = void 0, zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Sh2.prototype.getLabels = Sh2.prototype.Fa, Sh2.prototype.segmentForVideo = Sh2.prototype.Na, Sh2.prototype.segment = Sh2.prototype.ga, Sh2.prototype.setOptions = Sh2.prototype.o, Sh2.createFromModelPath = function(t4, e4) {
        return Ha(Sh2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Sh2.createFromModelBuffer = function(t4, e4) {
        return Ha(Sh2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Sh2.createFromOptions = function(t4, e4) {
        return Ha(Sh2, t4, e4);
      };
      Lh2 = class {
        constructor(t4, e4, n4) {
          this.confidenceMasks = t4, this.categoryMask = e4, this.qualityScores = n4;
        }
        close() {
          this.confidenceMasks?.forEach((t4) => {
            t4.close();
          }), this.categoryMask?.close();
        }
      };
      Lh2.prototype.close = Lh2.prototype.close;
      Fh2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Rh2 = [0, Pr2, -2];
      Mh2 = [0, kr3, -3, Ir2];
      Ph2 = [0, kr3, -3, Ir2, kr3, -1];
      Oh2 = [0, Ph2];
      Ch2 = [0, Oh2, Rh2];
      Ih2 = [0, Ph2, Rh2];
      Dh2 = [0, Ph2, Pr2, -1];
      Nh2 = [0, Dh2, Rh2];
      Uh2 = [0, kr3, -3, Ir2, Rh2, -1];
      Bh2 = [0, kr3, -3, Ir2, Wr3];
      Gh2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      jh2 = [0, kr3, -1, Ir2];
      Vh2 = class extends Nn3 {
        constructor() {
          super();
        }
      };
      Vh2.A = [1];
      Xh2 = class extends Nn3 {
        constructor(t4) {
          super(t4);
        }
      };
      Hh2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15];
      Wh2 = [0, Hh2, Vr3, Ph2, Vr3, Ih2, Vr3, Oh2, Vr3, Ch2, Vr3, jh2, Vr3, Bh2, Vr3, Mh2, Vr3, [0, Br3, kr3, -2, Ir2, Pr2, Ir2, -1, 2, kr3, Rh2], Vr3, Dh2, Vr3, Nh2, kr3, Rh2, Br3, Vr3, Uh2, Vr3, [0, br3, jh2]];
      zh2 = [0, Br3, Pr2, -1, Ir2];
      Kh2 = class extends Nn3 {
        constructor() {
          super();
        }
      };
      Kh2.A = [1], Kh2.prototype.g = qr3([0, br3, Wh2, Br3, zh2]);
      Yh2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect_in", false), this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new yo3(), this.s = new fo3(), kn3(this.h, 0, 3, this.s), kn3(t4 = this.h, 0, 1, e4 = new bi2());
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return "outputCategoryMask" in t4 && (this.outputCategoryMask = t4.outputCategoryMask ?? false), "outputConfidenceMasks" in t4 && (this.outputConfidenceMasks = t4.outputConfidenceMasks ?? true), super.l(t4);
        }
        ga(t4, e4, n4, r4) {
          const s4 = "function" != typeof n4 ? n4 : {};
          this.j = "function" == typeof n4 ? n4 : r4, this.qualityScores = this.categoryMask = this.confidenceMasks = void 0, n4 = this.C + 1, r4 = new Kh2();
          const i5 = new Xh2();
          var o4 = new Fh2();
          if (Cn3(o4, 1, 255), kn3(i5, 0, 12, o4), e4.keypoint && e4.scribble)
            throw Error("Cannot provide both keypoint and scribble.");
          if (e4.keypoint) {
            var a4 = new Gh2();
            On2(a4, 3, true), In2(a4, 1, e4.keypoint.x), In2(a4, 2, e4.keypoint.y), xn3(i5, 5, Hh2, a4);
          } else {
            if (!e4.scribble)
              throw Error("Must provide either a keypoint or a scribble.");
            for (a4 of (o4 = new Vh2(), e4.scribble))
              On2(e4 = new Gh2(), 3, true), In2(e4, 1, a4.x), In2(e4, 2, a4.y), Ln3(o4, 1, Gh2, e4);
            xn3(i5, 15, Hh2, o4);
          }
          Ln3(r4, 1, Xh2, i5), this.g.addProtoToStream(r4.g(), "drishti.RenderData", "roi_in", n4), za(this, t4, s4);
          t: {
            try {
              const t5 = new Lh2(this.confidenceMasks, this.categoryMask, this.qualityScores);
              if (!this.j) {
                var h4 = t5;
                break t;
              }
              this.j(t5);
            } finally {
              $o2(this);
            }
            h4 = void 0;
          }
          return h4;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "roi_in"), xs2(t4, "norm_rect_in");
          const e4 = new hs2();
          Dn3(e4, _o3, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "ROI:roi_in"), ys2(n4, "NORM_RECT:norm_rect_in"), n4.o(e4), ks2(t4, n4), Ko2(this, t4), this.outputConfidenceMasks && (Ss2(t4, "confidence_masks"), _s2(n4, "CONFIDENCE_MASKS:confidence_masks"), Yo2(this, "confidence_masks"), this.g.da("confidence_masks", (t5, e5) => {
            this.confidenceMasks = t5.map((t6) => Ya2(this, t6, true, !this.j)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("confidence_masks", (t5) => {
            this.confidenceMasks = [], zo(this, t5);
          })), this.outputCategoryMask && (Ss2(t4, "category_mask"), _s2(n4, "CATEGORY_MASK:category_mask"), Yo2(this, "category_mask"), this.g.W("category_mask", (t5, e5) => {
            this.categoryMask = Ya2(this, t5, false, !this.j), zo(this, e5);
          }), this.g.attachEmptyPacketListener("category_mask", (t5) => {
            this.categoryMask = void 0, zo(this, t5);
          })), Ss2(t4, "quality_scores"), _s2(n4, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (t5, e5) => {
            this.qualityScores = t5, zo(this, e5);
          }), this.g.attachEmptyPacketListener("quality_scores", (t5) => {
            this.categoryMask = void 0, zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Yh2.prototype.segment = Yh2.prototype.ga, Yh2.prototype.setOptions = Yh2.prototype.o, Yh2.createFromModelPath = function(t4, e4) {
        return Ha(Yh2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Yh2.createFromModelBuffer = function(t4, e4) {
        return Ha(Yh2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Yh2.createFromOptions = function(t4, e4) {
        return Ha(Yh2, t4, e4);
      };
      $h2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "input_frame_gpu", "norm_rect", false), this.j = { detections: [] }, kn3(t4 = this.h = new vo3(), 0, 1, e4 = new bi2());
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return void 0 !== t4.displayNamesLocale ? rn3(this.h, 2, ke3(t4.displayNamesLocale)) : "displayNamesLocale" in t4 && rn3(this.h, 2), void 0 !== t4.maxResults ? Cn3(this.h, 3, t4.maxResults) : "maxResults" in t4 && rn3(this.h, 3), void 0 !== t4.scoreThreshold ? In2(this.h, 4, t4.scoreThreshold) : "scoreThreshold" in t4 && rn3(this.h, 4), void 0 !== t4.categoryAllowlist ? pn3(this.h, 5, t4.categoryAllowlist) : "categoryAllowlist" in t4 && rn3(this.h, 5), void 0 !== t4.categoryDenylist ? pn3(this.h, 6, t4.categoryDenylist) : "categoryDenylist" in t4 && rn3(this.h, 6), this.l(t4);
        }
        F(t4, e4) {
          return this.j = { detections: [] }, za(this, t4, e4), this.j;
        }
        G(t4, e4, n4) {
          return this.j = { detections: [] }, Ka2(this, t4, n4, e4), this.j;
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "input_frame_gpu"), xs2(t4, "norm_rect"), Ss2(t4, "detections");
          const e4 = new hs2();
          Dn3(e4, Eo3, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.ObjectDetectorGraph"), ys2(n4, "IMAGE:input_frame_gpu"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "DETECTIONS:detections"), n4.o(e4), ks2(t4, n4), this.g.attachProtoVectorListener("detections", (t5, e5) => {
            for (const e6 of t5)
              t5 = Ks(e6), this.j.detections.push(ko3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("detections", (t5) => {
            zo(this, t5);
          }), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      $h2.prototype.detectForVideo = $h2.prototype.G, $h2.prototype.detect = $h2.prototype.F, $h2.prototype.setOptions = $h2.prototype.o, $h2.createFromModelPath = async function(t4, e4) {
        return Ha($h2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, $h2.createFromModelBuffer = function(t4, e4) {
        return Ha($h2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, $h2.createFromOptions = function(t4, e4) {
        return Ha($h2, t4, e4);
      };
      qh2 = class {
        constructor(t4, e4, n4) {
          this.landmarks = t4, this.worldLandmarks = e4, this.segmentationMasks = n4;
        }
        close() {
          this.segmentationMasks?.forEach((t4) => {
            t4.close();
          });
        }
      };
      qh2.prototype.close = qh2.prototype.close;
      Qh2 = class extends $a {
        constructor(t4, e4) {
          super(new Xa2(t4, e4), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = false, kn3(t4 = this.h = new wo3(), 0, 1, e4 = new bi2()), this.v = new io3(), kn3(this.h, 0, 3, this.v), this.j = new ro3(), kn3(this.h, 0, 2, this.j), Cn3(this.j, 4, 1), In2(this.j, 2, 0.5), In2(this.v, 2, 0.5), In2(this.h, 4, 0.5);
        }
        get baseOptions() {
          return Tn3(this.h, bi2, 1);
        }
        set baseOptions(t4) {
          kn3(this.h, 0, 1, t4);
        }
        o(t4) {
          return "numPoses" in t4 && Cn3(this.j, 4, t4.numPoses ?? 1), "minPoseDetectionConfidence" in t4 && In2(this.j, 2, t4.minPoseDetectionConfidence ?? 0.5), "minTrackingConfidence" in t4 && In2(this.h, 4, t4.minTrackingConfidence ?? 0.5), "minPosePresenceConfidence" in t4 && In2(this.v, 2, t4.minPosePresenceConfidence ?? 0.5), "outputSegmentationMasks" in t4 && (this.outputSegmentationMasks = t4.outputSegmentationMasks ?? false), this.l(t4);
        }
        F(t4, e4, n4) {
          const r4 = "function" != typeof e4 ? e4 : {};
          return this.s = "function" == typeof e4 ? e4 : n4, Jh2(this), za(this, t4, r4), Zh2(this);
        }
        G(t4, e4, n4, r4) {
          const s4 = "function" != typeof n4 ? n4 : {};
          return this.s = "function" == typeof n4 ? n4 : r4, Jh2(this), Ka2(this, t4, s4, e4), Zh2(this);
        }
        m() {
          var t4 = new Ls2();
          xs2(t4, "image_in"), xs2(t4, "norm_rect"), Ss2(t4, "normalized_landmarks"), Ss2(t4, "world_landmarks"), Ss2(t4, "segmentation_masks");
          const e4 = new hs2();
          Dn3(e4, To3, this.h);
          const n4 = new vs2();
          ms2(n4, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), ys2(n4, "IMAGE:image_in"), ys2(n4, "NORM_RECT:norm_rect"), _s2(n4, "NORM_LANDMARKS:normalized_landmarks"), _s2(n4, "WORLD_LANDMARKS:world_landmarks"), n4.o(e4), ks2(t4, n4), Ko2(this, t4), this.g.attachProtoVectorListener("normalized_landmarks", (t5, e5) => {
            this.landmarks = [];
            for (const e6 of t5)
              t5 = ei2(e6), this.landmarks.push(xo3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("normalized_landmarks", (t5) => {
            this.landmarks = [], zo(this, t5);
          }), this.g.attachProtoVectorListener("world_landmarks", (t5, e5) => {
            this.worldLandmarks = [];
            for (const e6 of t5)
              t5 = Js(e6), this.worldLandmarks.push(So3(t5));
            zo(this, e5);
          }), this.g.attachEmptyPacketListener("world_landmarks", (t5) => {
            this.worldLandmarks = [], zo(this, t5);
          }), this.outputSegmentationMasks && (_s2(n4, "SEGMENTATION_MASK:segmentation_masks"), Yo2(this, "segmentation_masks"), this.g.da("segmentation_masks", (t5, e5) => {
            this.segmentationMasks = t5.map((t6) => Ya2(this, t6, true, !this.s)), zo(this, e5);
          }), this.g.attachEmptyPacketListener("segmentation_masks", (t5) => {
            this.segmentationMasks = [], zo(this, t5);
          })), t4 = t4.g(), this.setGraph(new Uint8Array(t4), true);
        }
      };
      Qh2.prototype.detectForVideo = Qh2.prototype.G, Qh2.prototype.detect = Qh2.prototype.F, Qh2.prototype.setOptions = Qh2.prototype.o, Qh2.createFromModelPath = function(t4, e4) {
        return Ha(Qh2, t4, { baseOptions: { modelAssetPath: e4 } });
      }, Qh2.createFromModelBuffer = function(t4, e4) {
        return Ha(Qh2, t4, { baseOptions: { modelAssetBuffer: e4 } });
      }, Qh2.createFromOptions = function(t4, e4) {
        return Ha(Qh2, t4, e4);
      }, Qh2.POSE_CONNECTIONS = yh2;
    }
  });

  // node_modules/@sermas/toolkit/detection/video/mediapipe/v2/face-landmarker/face-landmarker.detector.js
  var init_face_landmarker_detector = __esm({
    "node_modules/@sermas/toolkit/detection/video/mediapipe/v2/face-landmarker/face-landmarker.detector.js"() {
      init_audio_bundle();
      init_vision_bundle();
      init_base_detector();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/mediapipe/v2/face-landmarker/face-landmarker.dto.js
  var init_face_landmarker_dto = __esm({
    "node_modules/@sermas/toolkit/detection/video/mediapipe/v2/face-landmarker/face-landmarker.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/detection/video/mediapipe/v2/face-landmarker/index.js
  var init_face_landmarker = __esm({
    "node_modules/@sermas/toolkit/detection/video/mediapipe/v2/face-landmarker/index.js"() {
      init_face_landmarker_detector();
      init_face_landmarker_dto();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/qrcode/qrcode.dto.js
  var init_qrcode_dto = __esm({
    "node_modules/@sermas/toolkit/detection/video/qrcode/qrcode.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/detection/video/qrcode/qrcode.detector.js
  var init_qrcode_detector = __esm({
    "node_modules/@sermas/toolkit/detection/video/qrcode/qrcode.detector.js"() {
      init_toolkit();
      init_base_detector();
    }
  });

  // node_modules/@sermas/toolkit/detection/video/qrcode/index.js
  var init_qrcode = __esm({
    "node_modules/@sermas/toolkit/detection/video/qrcode/index.js"() {
      init_qrcode_dto();
      init_qrcode_detector();
    }
  });

  // node_modules/@sermas/toolkit/detection/audio/audio.detection.dto.js
  var init_audio_detection_dto = __esm({
    "node_modules/@sermas/toolkit/detection/audio/audio.detection.dto.js"() {
    }
  });

  // node_modules/@sermas/toolkit/detection/audio/mediapipe/audio.classifier.js
  var createAudioClassifier;
  var init_audio_classifier = __esm({
    "node_modules/@sermas/toolkit/detection/audio/mediapipe/audio.classifier.js"() {
      init_audio_bundle();
      createAudioClassifier = async () => {
        const audio = await Vo.forAudioTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-audio@0.10.0/wasm");
        const audioClassifier = await Lo2.createFromOptions(audio, {
          baseOptions: {
            delegate: "GPU",
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/audio_classifier/yamnet/float32/1/yamnet.tflite"
          },
          maxResults: 1
        });
        return audioClassifier;
      };
    }
  });

  // node_modules/@sermas/toolkit/detection/audio/mediapipe/classes.json
  var classes_default;
  var init_classes = __esm({
    "node_modules/@sermas/toolkit/detection/audio/mediapipe/classes.json"() {
      classes_default = {
        human: {
          "0": "Speech",
          "1": "Child speech, kid speaking",
          "2": "Conversation"
        },
        other: {
          "3": "Narration, monologue",
          "4": "Babbling",
          "5": "Speech synthesizer",
          "6": "Shout",
          "7": "Bellow",
          "8": "Whoop",
          "9": "Yell",
          "10": "Children shouting",
          "11": "Screaming",
          "12": "Whispering",
          "13": "Laughter",
          "14": "Baby laughter",
          "15": "Giggle",
          "16": "Snicker",
          "17": "Belly laugh",
          "18": "Chuckle, chortle",
          "19": "Crying, sobbing",
          "20": "Baby cry, infant cry",
          "21": "Whimper",
          "22": "Wail, moan",
          "23": "Sigh",
          "24": "Singing",
          "25": "Choir",
          "26": "Yodeling",
          "27": "Chant",
          "28": "Mantra",
          "29": "Child singing",
          "30": "Synthetic singing",
          "31": "Rapping",
          "32": "Humming",
          "33": "Groan",
          "34": "Grunt",
          "35": "Whistling",
          "36": "Breathing",
          "37": "Wheeze",
          "38": "Snoring",
          "39": "Gasp",
          "40": "Pant",
          "41": "Snort",
          "42": "Cough",
          "43": "Throat clearing",
          "44": "Sneeze",
          "45": "Sniff",
          "46": "Run",
          "47": "Shuffle",
          "48": "Walk, footsteps",
          "49": "Chewing, mastication",
          "50": "Biting",
          "51": "Gargling",
          "52": "Stomach rumble",
          "53": "Burping, eructation",
          "54": "Hiccup",
          "55": "Fart",
          "56": "Hands",
          "57": "Finger snapping",
          "58": "Clapping",
          "59": "Heart sounds, heartbeat",
          "60": "Heart murmur",
          "61": "Cheering",
          "62": "Applause",
          "63": "Chatter",
          "64": "Crowd",
          "65": "Hubbub, speech noise, speech babble",
          "66": "Children playing",
          "67": "Animal",
          "68": "Domestic animals, pets",
          "69": "Dog",
          "70": "Bark",
          "71": "Yip",
          "72": "Howl",
          "73": "Bow-wow",
          "74": "Growling",
          "75": "Whimper (dog)",
          "76": "Cat",
          "77": "Purr",
          "78": "Meow",
          "79": "Hiss",
          "80": "Caterwaul",
          "81": "Livestock, farm animals, working animals",
          "82": "Horse",
          "83": "Clip-clop",
          "84": "Neigh, whinny",
          "85": "Cattle, bovinae",
          "86": "Moo",
          "87": "Cowbell",
          "88": "Pig",
          "89": "Oink",
          "90": "Goat",
          "91": "Bleat",
          "92": "Sheep",
          "93": "Fowl",
          "94": "Chicken, rooster",
          "95": "Cluck",
          "96": "Crowing, cock-a-doodle-doo",
          "97": "Turkey",
          "98": "Gobble",
          "99": "Duck",
          "100": "Quack",
          "101": "Goose",
          "102": "Honk",
          "103": "Wild animals",
          "104": "Roaring cats (lions, tigers)",
          "105": "Roar",
          "106": "Bird",
          "107": "Bird vocalization, bird call, bird song",
          "108": "Chirp, tweet",
          "109": "Squawk",
          "110": "Pigeon, dove",
          "111": "Coo",
          "112": "Crow",
          "113": "Caw",
          "114": "Owl",
          "115": "Hoot",
          "116": "Bird flight, flapping wings",
          "117": "Canidae, dogs, wolves",
          "118": "Rodents, rats, mice",
          "119": "Mouse",
          "120": "Patter",
          "121": "Insect",
          "122": "Cricket",
          "123": "Mosquito",
          "124": "Fly, housefly",
          "125": "Buzz",
          "126": "Bee, wasp, etc.",
          "127": "Frog",
          "128": "Croak",
          "129": "Snake",
          "130": "Rattle",
          "131": "Whale vocalization",
          "132": "Music",
          "133": "Musical instrument",
          "134": "Plucked string instrument",
          "135": "Guitar",
          "136": "Electric guitar",
          "137": "Bass guitar",
          "138": "Acoustic guitar",
          "139": "Steel guitar, slide guitar",
          "140": "Tapping (guitar technique)",
          "141": "Strum",
          "142": "Banjo",
          "143": "Sitar",
          "144": "Mandolin",
          "145": "Zither",
          "146": "Ukulele",
          "147": "Keyboard (musical)",
          "148": "Piano",
          "149": "Electric piano",
          "150": "Organ",
          "151": "Electronic organ",
          "152": "Hammond organ",
          "153": "Synthesizer",
          "154": "Sampler",
          "155": "Harpsichord",
          "156": "Percussion",
          "157": "Drum kit",
          "158": "Drum machine",
          "159": "Drum",
          "160": "Snare drum",
          "161": "Rimshot",
          "162": "Drum roll",
          "163": "Bass drum",
          "164": "Timpani",
          "165": "Tabla",
          "166": "Cymbal",
          "167": "Hi-hat",
          "168": "Wood block",
          "169": "Tambourine",
          "170": "Rattle (instrument)",
          "171": "Maraca",
          "172": "Gong",
          "173": "Tubular bells",
          "174": "Mallet percussion",
          "175": "Marimba, xylophone",
          "176": "Glockenspiel",
          "177": "Vibraphone",
          "178": "Steelpan",
          "179": "Orchestra",
          "180": "Brass instrument",
          "181": "French horn",
          "182": "Trumpet",
          "183": "Trombone",
          "184": "Bowed string instrument",
          "185": "String section",
          "186": "Violin, fiddle",
          "187": "Pizzicato",
          "188": "Cello",
          "189": "Double bass",
          "190": "Wind instrument, woodwind instrument",
          "191": "Flute",
          "192": "Saxophone",
          "193": "Clarinet",
          "194": "Harp",
          "195": "Bell",
          "196": "Church bell",
          "197": "Jingle bell",
          "198": "Bicycle bell",
          "199": "Tuning fork",
          "200": "Chime",
          "201": "Wind chime",
          "202": "Change ringing (campanology)",
          "203": "Harmonica",
          "204": "Accordion",
          "205": "Bagpipes",
          "206": "Didgeridoo",
          "207": "Shofar",
          "208": "Theremin",
          "209": "Singing bowl",
          "210": "Scratching (performance technique)",
          "211": "Pop music",
          "212": "Hip hop music",
          "213": "Beatboxing",
          "214": "Rock music",
          "215": "Heavy metal",
          "216": "Punk rock",
          "217": "Grunge",
          "218": "Progressive rock",
          "219": "Rock and roll",
          "220": "Psychedelic rock",
          "221": "Rhythm and blues",
          "222": "Soul music",
          "223": "Reggae",
          "224": "Country",
          "225": "Swing music",
          "226": "Bluegrass",
          "227": "Funk",
          "228": "Folk music",
          "229": "Middle Eastern music",
          "230": "Jazz",
          "231": "Disco",
          "232": "Classical music",
          "233": "Opera",
          "234": "Electronic music",
          "235": "House music",
          "236": "Techno",
          "237": "Dubstep",
          "238": "Drum and bass",
          "239": "Electronica",
          "240": "Electronic dance music",
          "241": "Ambient music",
          "242": "Trance music",
          "243": "Music of Latin America",
          "244": "Salsa music",
          "245": "Flamenco",
          "246": "Blues",
          "247": "Music for children",
          "248": "New-age music",
          "249": "Vocal music",
          "250": "A capella",
          "251": "Music of Africa",
          "252": "Afrobeat",
          "253": "Christian music",
          "254": "Gospel music",
          "255": "Music of Asia",
          "256": "Carnatic music",
          "257": "Music of Bollywood",
          "258": "Ska",
          "259": "Traditional music",
          "260": "Independent music",
          "261": "Song",
          "262": "Background music",
          "263": "Theme music",
          "264": "Jingle (music)",
          "265": "Soundtrack music",
          "266": "Lullaby",
          "267": "Video game music",
          "268": "Christmas music",
          "269": "Dance music",
          "270": "Wedding music",
          "271": "Happy music",
          "272": "Sad music",
          "273": "Tender music",
          "274": "Exciting music",
          "275": "Angry music",
          "276": "Scary music",
          "277": "Wind",
          "278": "Rustling leaves",
          "279": "Wind noise (microphone)",
          "280": "Thunderstorm",
          "281": "Thunder",
          "282": "Water",
          "283": "Rain",
          "284": "Raindrop",
          "285": "Rain on surface",
          "286": "Stream",
          "287": "Waterfall",
          "288": "Ocean",
          "289": "Waves, surf",
          "290": "Steam",
          "291": "Gurgling",
          "292": "Fire",
          "293": "Crackle",
          "294": "Vehicle",
          "295": "Boat, Water vehicle",
          "296": "Sailboat, sailing ship",
          "297": "Rowboat, canoe, kayak",
          "298": "Motorboat, speedboat",
          "299": "Ship",
          "300": "Motor vehicle (road)",
          "301": "Car",
          "302": "Vehicle horn, car horn, honking",
          "303": "Toot",
          "304": "Car alarm",
          "305": "Power windows, electric windows",
          "306": "Skidding",
          "307": "Tire squeal",
          "308": "Car passing by",
          "309": "Race car, auto racing",
          "310": "Truck",
          "311": "Air brake",
          "312": "Air horn, truck horn",
          "313": "Reversing beeps",
          "314": "Ice cream truck, ice cream van",
          "315": "Bus",
          "316": "Emergency vehicle",
          "317": "Police car (siren)",
          "318": "Ambulance (siren)",
          "319": "Fire engine, fire truck (siren)",
          "320": "Motorcycle",
          "321": "Traffic noise, roadway noise",
          "322": "Rail transport",
          "323": "Train",
          "324": "Train whistle",
          "325": "Train horn",
          "326": "Railroad car, train wagon",
          "327": "Train wheels squealing",
          "328": "Subway, metro, underground",
          "329": "Aircraft",
          "330": "Aircraft engine",
          "331": "Jet engine",
          "332": "Propeller, airscrew",
          "333": "Helicopter",
          "334": "Fixed-wing aircraft, airplane",
          "335": "Bicycle",
          "336": "Skateboard",
          "337": "Engine",
          "338": "Light engine (high frequency)",
          "339": "Dental drill, dentist's drill",
          "340": "Lawn mower",
          "341": "Chainsaw",
          "342": "Medium engine (mid frequency)",
          "343": "Heavy engine (low frequency)",
          "344": "Engine knocking",
          "345": "Engine starting",
          "346": "Idling",
          "347": "Accelerating, revving, vroom",
          "348": "Door",
          "349": "Doorbell",
          "350": "Ding-dong",
          "351": "Sliding door",
          "352": "Slam",
          "353": "Knock",
          "354": "Tap",
          "355": "Squeak",
          "356": "Cupboard open or close",
          "357": "Drawer open or close",
          "358": "Dishes, pots, and pans",
          "359": "Cutlery, silverware",
          "360": "Chopping (food)",
          "361": "Frying (food)",
          "362": "Microwave oven",
          "363": "Blender",
          "364": "Water tap, faucet",
          "365": "Sink (filling or washing)",
          "366": "Bathtub (filling or washing)",
          "367": "Hair dryer",
          "368": "Toilet flush",
          "369": "Toothbrush",
          "370": "Electric toothbrush",
          "371": "Vacuum cleaner",
          "372": "Zipper (clothing)",
          "373": "Keys jangling",
          "374": "Coin (dropping)",
          "375": "Scissors",
          "376": "Electric shaver, electric razor",
          "377": "Shuffling cards",
          "378": "Typing",
          "379": "Typewriter",
          "380": "Computer keyboard",
          "381": "Writing",
          "382": "Alarm",
          "383": "Telephone",
          "384": "Telephone bell ringing",
          "385": "Ringtone",
          "386": "Telephone dialing, DTMF",
          "387": "Dial tone",
          "388": "Busy signal",
          "389": "Alarm clock",
          "390": "Siren",
          "391": "Civil defense siren",
          "392": "Buzzer",
          "393": "Smoke detector, smoke alarm",
          "394": "Fire alarm",
          "395": "Foghorn",
          "396": "Whistle",
          "397": "Steam whistle",
          "398": "Mechanisms",
          "399": "Ratchet, pawl",
          "400": "Clock",
          "401": "Tick",
          "402": "Tick-tock",
          "403": "Gears",
          "404": "Pulleys",
          "405": "Sewing machine",
          "406": "Mechanical fan",
          "407": "Air conditioning",
          "408": "Cash register",
          "409": "Printer",
          "410": "Camera",
          "411": "Single-lens reflex camera",
          "412": "Tools",
          "413": "Hammer",
          "414": "Jackhammer",
          "415": "Sawing",
          "416": "Filing (rasp)",
          "417": "Sanding",
          "418": "Power tool",
          "419": "Drill",
          "420": "Explosion",
          "421": "Gunshot, gunfire",
          "422": "Machine gun",
          "423": "Fusillade",
          "424": "Artillery fire",
          "425": "Cap gun",
          "426": "Fireworks",
          "427": "Firecracker",
          "428": "Burst, pop",
          "429": "Eruption",
          "430": "Boom",
          "431": "Wood",
          "432": "Chop",
          "433": "Splinter",
          "434": "Crack",
          "435": "Glass",
          "436": "Chink, clink",
          "437": "Shatter",
          "438": "Liquid",
          "439": "Splash, splatter",
          "440": "Slosh",
          "441": "Squish",
          "442": "Drip",
          "443": "Pour",
          "444": "Trickle, dribble",
          "445": "Gush",
          "446": "Fill (with liquid)",
          "447": "Spray",
          "448": "Pump (liquid)",
          "449": "Stir",
          "450": "Boiling",
          "451": "Sonar",
          "452": "Arrow",
          "453": "Whoosh, swoosh, swish",
          "454": "Thump, thud",
          "455": "Thunk",
          "456": "Electronic tuner",
          "457": "Effects unit",
          "458": "Chorus effect",
          "459": "Basketball bounce",
          "460": "Bang",
          "461": "Slap, smack",
          "462": "Whack, thwack",
          "463": "Smash, crash",
          "464": "Breaking",
          "465": "Bouncing",
          "466": "Whip",
          "467": "Flap",
          "468": "Scratch",
          "469": "Scrape",
          "470": "Rub",
          "471": "Roll",
          "472": "Crushing",
          "473": "Crumpling, crinkling",
          "474": "Tearing",
          "475": "Beep, bleep",
          "476": "Ping",
          "477": "Ding",
          "478": "Clang",
          "479": "Squeal",
          "480": "Creak",
          "481": "Rustle",
          "482": "Whir",
          "483": "Clatter",
          "484": "Sizzle",
          "485": "Clicking",
          "486": "Clickety-clack",
          "487": "Rumble",
          "488": "Plop",
          "489": "Jingle, tinkle",
          "490": "Hum",
          "491": "Zing",
          "492": "Boing",
          "493": "Crunch",
          "494": "Silence",
          "495": "Sine wave",
          "496": "Harmonic",
          "497": "Chirp tone",
          "498": "Sound effect",
          "499": "Pulse",
          "500": "Inside, small room",
          "501": "Inside, large room or hall",
          "502": "Inside, public space",
          "503": "Outside, urban or manmade",
          "504": "Outside, rural or natural",
          "505": "Reverberation",
          "506": "Echo",
          "507": "Noise",
          "508": "Environmental noise",
          "509": "Static",
          "510": "Mains hum",
          "511": "Distortion",
          "512": "Sidetone",
          "513": "Cacophony",
          "514": "White noise",
          "515": "Pink noise",
          "516": "Throbbing",
          "517": "Vibration",
          "518": "Television",
          "519": "Radio",
          "520": "Field recording"
        }
      };
    }
  });

  // node_modules/onnxruntime-web/dist/cjs/ort.min.js
  var require_ort_min = __commonJS({
    "node_modules/onnxruntime-web/dist/cjs/ort.min.js"(exports, module) {
      "use strict";
      var Sd = Object.create;
      var Dn = Object.defineProperty;
      var Ad = Object.getOwnPropertyDescriptor;
      var Pd = Object.getOwnPropertyNames;
      var Ed = Object.getPrototypeOf;
      var Dd = Object.prototype.hasOwnProperty;
      var E = (a4, t4) => () => (a4 && (t4 = a4(a4 = 0)), t4);
      var me = (a4, t4) => () => (t4 || a4((t4 = { exports: {} }).exports, t4), t4.exports);
      var sr = (a4, t4) => {
        for (var o4 in t4)
          Dn(a4, o4, { get: t4[o4], enumerable: true });
      };
      var qa = (a4, t4, o4, e4) => {
        if (t4 && typeof t4 == "object" || typeof t4 == "function")
          for (let r4 of Pd(t4))
            !Dd.call(a4, r4) && r4 !== o4 && Dn(a4, r4, { get: () => t4[r4], enumerable: !(e4 = Ad(t4, r4)) || e4.enumerable });
        return a4;
      };
      var Dr = (a4, t4, o4) => (o4 = a4 != null ? Sd(Ed(a4)) : {}, qa(t4 || !a4 || !a4.__esModule ? Dn(o4, "default", { value: a4, enumerable: true }) : o4, a4));
      var jt = (a4) => qa(Dn({}, "__esModule", { value: true }), a4);
      var Ln;
      var ur;
      var lr;
      var Ld;
      var Fn;
      var Cn = E(() => {
        "use strict";
        Ln = /* @__PURE__ */ new Map(), ur = [], lr = (a4, t4, o4) => {
          if (t4 && typeof t4.init == "function" && typeof t4.createInferenceSessionHandler == "function") {
            let e4 = Ln.get(a4);
            if (e4 === void 0)
              Ln.set(a4, { backend: t4, priority: o4 });
            else {
              if (e4.priority > o4)
                return;
              if (e4.priority === o4 && e4.backend !== t4)
                throw new Error(`cannot register backend "${a4}" using priority ${o4}`);
            }
            if (o4 >= 0) {
              let r4 = ur.indexOf(a4);
              r4 !== -1 && ur.splice(r4, 1);
              for (let n4 = 0; n4 < ur.length; n4++)
                if (Ln.get(ur[n4]).priority <= o4) {
                  ur.splice(n4, 0, a4);
                  return;
                }
              ur.push(a4);
            }
            return;
          }
          throw new TypeError("not a valid backend");
        }, Ld = async (a4) => {
          let t4 = Ln.get(a4);
          if (!t4)
            return "backend not found.";
          if (t4.initialized)
            return t4.backend;
          if (t4.aborted)
            return t4.error;
          {
            let o4 = !!t4.initPromise;
            try {
              return o4 || (t4.initPromise = t4.backend.init(a4)), await t4.initPromise, t4.initialized = true, t4.backend;
            } catch (e4) {
              return o4 || (t4.error = `${e4}`, t4.aborted = true), t4.error;
            } finally {
              delete t4.initPromise;
            }
          }
        }, Fn = async (a4) => {
          let t4 = a4.executionProviders || [], o4 = t4.map((u4) => typeof u4 == "string" ? u4 : u4.name), e4 = o4.length === 0 ? ur : o4, r4, n4 = [], s4 = /* @__PURE__ */ new Set();
          for (let u4 of e4) {
            let l4 = await Ld(u4);
            typeof l4 == "string" ? n4.push({ name: u4, err: l4 }) : (r4 || (r4 = l4), r4 === l4 && s4.add(u4));
          }
          if (!r4)
            throw new Error(`no available backend found. ERR: ${n4.map((u4) => `[${u4.name}] ${u4.err}`).join(", ")}`);
          for (let { name: u4, err: l4 } of n4)
            o4.includes(u4) && console.warn(`removing requested execution provider "${u4}" from session options because it is not available: ${l4}`);
          let i5 = t4.filter((u4) => s4.has(typeof u4 == "string" ? u4 : u4.name));
          return [r4, new Proxy(a4, { get: (u4, l4) => l4 === "executionProviders" ? i5 : Reflect.get(u4, l4) })];
        };
      });
      var ja = E(() => {
        "use strict";
        Cn();
      });
      var Ya;
      var Xa = E(() => {
        "use strict";
        Ya = "1.17.3";
      });
      var Ka;
      var it;
      var Ho = E(() => {
        "use strict";
        Xa();
        Ka = "warning", it = { wasm: {}, webgl: {}, webgpu: {}, versions: { common: Ya }, set logLevel(a4) {
          if (a4 !== void 0) {
            if (typeof a4 != "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(a4) === -1)
              throw new Error(`Unsupported logging level: ${a4}`);
            Ka = a4;
          }
        }, get logLevel() {
          return Ka;
        } };
        Object.defineProperty(it, "logLevel", { enumerable: true });
      });
      var Z;
      var Ja = E(() => {
        "use strict";
        Ho();
        Z = it;
      });
      var Za;
      var Qa;
      var es = E(() => {
        "use strict";
        Za = (a4, t4) => {
          let o4 = typeof document < "u" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
          o4.width = a4.dims[3], o4.height = a4.dims[2];
          let e4 = o4.getContext("2d");
          if (e4 != null) {
            let r4, n4;
            t4?.tensorLayout !== void 0 && t4.tensorLayout === "NHWC" ? (r4 = a4.dims[2], n4 = a4.dims[3]) : (r4 = a4.dims[3], n4 = a4.dims[2]);
            let s4 = t4?.format !== void 0 ? t4.format : "RGB", i5 = t4?.norm, u4, l4;
            i5 === void 0 || i5.mean === void 0 ? u4 = [255, 255, 255, 255] : typeof i5.mean == "number" ? u4 = [i5.mean, i5.mean, i5.mean, i5.mean] : (u4 = [i5.mean[0], i5.mean[1], i5.mean[2], 0], i5.mean[3] !== void 0 && (u4[3] = i5.mean[3])), i5 === void 0 || i5.bias === void 0 ? l4 = [0, 0, 0, 0] : typeof i5.bias == "number" ? l4 = [i5.bias, i5.bias, i5.bias, i5.bias] : (l4 = [i5.bias[0], i5.bias[1], i5.bias[2], 0], i5.bias[3] !== void 0 && (l4[3] = i5.bias[3]));
            let f3 = n4 * r4, p4 = 0, d4 = f3, T3 = f3 * 2, v5 = -1;
            s4 === "RGBA" ? (p4 = 0, d4 = f3, T3 = f3 * 2, v5 = f3 * 3) : s4 === "RGB" ? (p4 = 0, d4 = f3, T3 = f3 * 2) : s4 === "RBG" && (p4 = 0, T3 = f3, d4 = f3 * 2);
            for (let w3 = 0; w3 < n4; w3++)
              for (let I3 = 0; I3 < r4; I3++) {
                let L3 = (a4.data[p4++] - l4[0]) * u4[0], F4 = (a4.data[d4++] - l4[1]) * u4[1], C3 = (a4.data[T3++] - l4[2]) * u4[2], Y5 = v5 === -1 ? 255 : (a4.data[v5++] - l4[3]) * u4[3];
                e4.fillStyle = "rgba(" + L3 + "," + F4 + "," + C3 + "," + Y5 + ")", e4.fillRect(I3, w3, 1, 1);
              }
            if ("toDataURL" in o4)
              return o4.toDataURL();
            throw new Error("toDataURL is not supported");
          } else
            throw new Error("Can not access image data");
        }, Qa = (a4, t4) => {
          let o4 = typeof document < "u" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d"), e4;
          if (o4 != null) {
            let r4, n4, s4;
            t4?.tensorLayout !== void 0 && t4.tensorLayout === "NHWC" ? (r4 = a4.dims[2], n4 = a4.dims[1], s4 = a4.dims[3]) : (r4 = a4.dims[3], n4 = a4.dims[2], s4 = a4.dims[1]);
            let i5 = t4 !== void 0 && t4.format !== void 0 ? t4.format : "RGB", u4 = t4?.norm, l4, f3;
            u4 === void 0 || u4.mean === void 0 ? l4 = [255, 255, 255, 255] : typeof u4.mean == "number" ? l4 = [u4.mean, u4.mean, u4.mean, u4.mean] : (l4 = [u4.mean[0], u4.mean[1], u4.mean[2], 255], u4.mean[3] !== void 0 && (l4[3] = u4.mean[3])), u4 === void 0 || u4.bias === void 0 ? f3 = [0, 0, 0, 0] : typeof u4.bias == "number" ? f3 = [u4.bias, u4.bias, u4.bias, u4.bias] : (f3 = [u4.bias[0], u4.bias[1], u4.bias[2], 0], u4.bias[3] !== void 0 && (f3[3] = u4.bias[3]));
            let p4 = n4 * r4;
            if (t4 !== void 0 && (t4.format !== void 0 && s4 === 4 && t4.format !== "RGBA" || s4 === 3 && t4.format !== "RGB" && t4.format !== "BGR"))
              throw new Error("Tensor format doesn't match input tensor dims");
            let d4 = 4, T3 = 0, v5 = 1, w3 = 2, I3 = 3, L3 = 0, F4 = p4, C3 = p4 * 2, Y5 = -1;
            i5 === "RGBA" ? (L3 = 0, F4 = p4, C3 = p4 * 2, Y5 = p4 * 3) : i5 === "RGB" ? (L3 = 0, F4 = p4, C3 = p4 * 2) : i5 === "RBG" && (L3 = 0, C3 = p4, F4 = p4 * 2), e4 = o4.createImageData(r4, n4);
            for (let j4 = 0; j4 < n4 * r4; T3 += d4, v5 += d4, w3 += d4, I3 += d4, j4++)
              e4.data[T3] = (a4.data[L3++] - f3[0]) * l4[0], e4.data[v5] = (a4.data[F4++] - f3[1]) * l4[1], e4.data[w3] = (a4.data[C3++] - f3[2]) * l4[2], e4.data[I3] = Y5 === -1 ? 255 : (a4.data[Y5++] - f3[3]) * l4[3];
          } else
            throw new Error("Can not access image data");
          return e4;
        };
      });
      var qo;
      var ts;
      var rs;
      var ns;
      var os;
      var is = E(() => {
        "use strict";
        $n();
        qo = (a4, t4) => {
          if (a4 === void 0)
            throw new Error("Image buffer must be defined");
          if (t4.height === void 0 || t4.width === void 0)
            throw new Error("Image height and width must be defined");
          if (t4.tensorLayout === "NHWC")
            throw new Error("NHWC Tensor layout is not supported yet");
          let { height: o4, width: e4 } = t4, r4 = t4.norm ?? { mean: 255, bias: 0 }, n4, s4;
          typeof r4.mean == "number" ? n4 = [r4.mean, r4.mean, r4.mean, r4.mean] : n4 = [r4.mean[0], r4.mean[1], r4.mean[2], r4.mean[3] ?? 255], typeof r4.bias == "number" ? s4 = [r4.bias, r4.bias, r4.bias, r4.bias] : s4 = [r4.bias[0], r4.bias[1], r4.bias[2], r4.bias[3] ?? 0];
          let i5 = t4.format !== void 0 ? t4.format : "RGBA", u4 = t4.tensorFormat !== void 0 && t4.tensorFormat !== void 0 ? t4.tensorFormat : "RGB", l4 = o4 * e4, f3 = u4 === "RGBA" ? new Float32Array(l4 * 4) : new Float32Array(l4 * 3), p4 = 4, d4 = 0, T3 = 1, v5 = 2, w3 = 3, I3 = 0, L3 = l4, F4 = l4 * 2, C3 = -1;
          i5 === "RGB" && (p4 = 3, d4 = 0, T3 = 1, v5 = 2, w3 = -1), u4 === "RGBA" ? C3 = l4 * 3 : u4 === "RBG" ? (I3 = 0, F4 = l4, L3 = l4 * 2) : u4 === "BGR" && (F4 = 0, L3 = l4, I3 = l4 * 2);
          for (let j4 = 0; j4 < l4; j4++, d4 += p4, v5 += p4, T3 += p4, w3 += p4)
            f3[I3++] = (a4[d4] + s4[0]) / n4[0], f3[L3++] = (a4[T3] + s4[1]) / n4[1], f3[F4++] = (a4[v5] + s4[2]) / n4[2], C3 !== -1 && w3 !== -1 && (f3[C3++] = (a4[w3] + s4[3]) / n4[3]);
          return u4 === "RGBA" ? new Xe("float32", f3, [1, 4, o4, e4]) : new Xe("float32", f3, [1, 3, o4, e4]);
        }, ts = async (a4, t4) => {
          let o4 = typeof HTMLImageElement < "u" && a4 instanceof HTMLImageElement, e4 = typeof ImageData < "u" && a4 instanceof ImageData, r4 = typeof ImageBitmap < "u" && a4 instanceof ImageBitmap, n4 = typeof a4 == "string", s4, i5 = t4 ?? {}, u4 = () => {
            if (typeof document < "u")
              return document.createElement("canvas");
            if (typeof OffscreenCanvas < "u")
              return new OffscreenCanvas(1, 1);
            throw new Error("Canvas is not supported");
          }, l4 = (f3) => f3 instanceof HTMLCanvasElement || f3 instanceof OffscreenCanvas ? f3.getContext("2d") : null;
          if (o4) {
            let f3 = u4();
            f3.width = a4.width, f3.height = a4.height;
            let p4 = l4(f3);
            if (p4 != null) {
              let d4 = a4.height, T3 = a4.width;
              if (t4 !== void 0 && t4.resizedHeight !== void 0 && t4.resizedWidth !== void 0 && (d4 = t4.resizedHeight, T3 = t4.resizedWidth), t4 !== void 0) {
                if (i5 = t4, t4.tensorFormat !== void 0)
                  throw new Error("Image input config format must be RGBA for HTMLImageElement");
                i5.tensorFormat = "RGBA", i5.height = d4, i5.width = T3;
              } else
                i5.tensorFormat = "RGBA", i5.height = d4, i5.width = T3;
              p4.drawImage(a4, 0, 0), s4 = p4.getImageData(0, 0, T3, d4).data;
            } else
              throw new Error("Can not access image data");
          } else if (e4) {
            let f3, p4;
            if (t4 !== void 0 && t4.resizedWidth !== void 0 && t4.resizedHeight !== void 0 ? (f3 = t4.resizedHeight, p4 = t4.resizedWidth) : (f3 = a4.height, p4 = a4.width), t4 !== void 0 && (i5 = t4), i5.format = "RGBA", i5.height = f3, i5.width = p4, t4 !== void 0) {
              let d4 = u4();
              d4.width = p4, d4.height = f3;
              let T3 = l4(d4);
              if (T3 != null)
                T3.putImageData(a4, 0, 0), s4 = T3.getImageData(0, 0, p4, f3).data;
              else
                throw new Error("Can not access image data");
            } else
              s4 = a4.data;
          } else if (r4) {
            if (t4 === void 0)
              throw new Error("Please provide image config with format for Imagebitmap");
            let f3 = u4();
            f3.width = a4.width, f3.height = a4.height;
            let p4 = l4(f3);
            if (p4 != null) {
              let d4 = a4.height, T3 = a4.width;
              return p4.drawImage(a4, 0, 0, T3, d4), s4 = p4.getImageData(0, 0, T3, d4).data, i5.height = d4, i5.width = T3, qo(s4, i5);
            } else
              throw new Error("Can not access image data");
          } else {
            if (n4)
              return new Promise((f3, p4) => {
                let d4 = u4(), T3 = l4(d4);
                if (!a4 || !T3)
                  return p4();
                let v5 = new Image();
                v5.crossOrigin = "Anonymous", v5.src = a4, v5.onload = () => {
                  d4.width = v5.width, d4.height = v5.height, T3.drawImage(v5, 0, 0, d4.width, d4.height);
                  let w3 = T3.getImageData(0, 0, d4.width, d4.height);
                  i5.height = d4.height, i5.width = d4.width, f3(qo(w3.data, i5));
                };
              });
            throw new Error("Input data provided is not supported - aborted tensor creation");
          }
          if (s4 !== void 0)
            return qo(s4, i5);
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }, rs = (a4, t4) => {
          let { width: o4, height: e4, download: r4, dispose: n4 } = t4, s4 = [1, e4, o4, 4];
          return new Xe({ location: "texture", type: "float32", texture: a4, dims: s4, download: r4, dispose: n4 });
        }, ns = (a4, t4) => {
          let { dataType: o4, dims: e4, download: r4, dispose: n4 } = t4;
          return new Xe({ location: "gpu-buffer", type: o4 ?? "float32", gpuBuffer: a4, dims: e4, download: r4, dispose: n4 });
        }, os = (a4, t4, o4) => new Xe({ location: "cpu-pinned", type: a4, data: t4, dims: o4 ?? [t4.length] });
      });
      var fr;
      var tn;
      var as;
      var ss;
      var us = E(() => {
        "use strict";
        fr = /* @__PURE__ */ new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), tn = /* @__PURE__ */ new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]), as = false, ss = () => {
          if (!as) {
            as = true;
            let a4 = typeof BigInt64Array < "u" && BigInt64Array.from, t4 = typeof BigUint64Array < "u" && BigUint64Array.from, o4 = typeof Float16Array < "u" && Float16Array.from;
            a4 && (fr.set("int64", BigInt64Array), tn.set(BigInt64Array, "int64")), t4 && (fr.set("uint64", BigUint64Array), tn.set(BigUint64Array, "uint64")), o4 ? (fr.set("float16", Float16Array), tn.set(Float16Array, "float16")) : fr.set("float16", Uint16Array);
          }
        };
      });
      var ls;
      var fs;
      var cs = E(() => {
        "use strict";
        $n();
        ls = (a4) => {
          let t4 = 1;
          for (let o4 = 0; o4 < a4.length; o4++) {
            let e4 = a4[o4];
            if (typeof e4 != "number" || !Number.isSafeInteger(e4))
              throw new TypeError(`dims[${o4}] must be an integer, got: ${e4}`);
            if (e4 < 0)
              throw new RangeError(`dims[${o4}] must be a non-negative integer, got: ${e4}`);
            t4 *= e4;
          }
          return t4;
        }, fs = (a4, t4) => {
          switch (a4.location) {
            case "cpu":
              return new Xe(a4.type, a4.data, t4);
            case "cpu-pinned":
              return new Xe({ location: "cpu-pinned", data: a4.data, type: a4.type, dims: t4 });
            case "texture":
              return new Xe({ location: "texture", texture: a4.texture, type: a4.type, dims: t4 });
            case "gpu-buffer":
              return new Xe({ location: "gpu-buffer", gpuBuffer: a4.gpuBuffer, type: a4.type, dims: t4 });
            default:
              throw new Error(`tensorReshape: tensor location ${a4.location} is not supported`);
          }
        };
      });
      var Xe;
      var $n = E(() => {
        "use strict";
        es();
        is();
        us();
        cs();
        Xe = class {
          constructor(t4, o4, e4) {
            ss();
            let r4, n4;
            if (typeof t4 == "object" && "location" in t4)
              switch (this.dataLocation = t4.location, r4 = t4.type, n4 = t4.dims, t4.location) {
                case "cpu-pinned": {
                  let i5 = fr.get(r4);
                  if (!i5)
                    throw new TypeError(`unsupported type "${r4}" to create tensor from pinned buffer`);
                  if (!(t4.data instanceof i5))
                    throw new TypeError(`buffer should be of type ${i5.name}`);
                  this.cpuData = t4.data;
                  break;
                }
                case "texture": {
                  if (r4 !== "float32")
                    throw new TypeError(`unsupported type "${r4}" to create tensor from texture`);
                  this.gpuTextureData = t4.texture, this.downloader = t4.download, this.disposer = t4.dispose;
                  break;
                }
                case "gpu-buffer": {
                  if (r4 !== "float32" && r4 !== "float16" && r4 !== "int32" && r4 !== "int64" && r4 !== "uint32" && r4 !== "uint8" && r4 !== "bool")
                    throw new TypeError(`unsupported type "${r4}" to create tensor from gpu buffer`);
                  this.gpuBufferData = t4.gpuBuffer, this.downloader = t4.download, this.disposer = t4.dispose;
                  break;
                }
                default:
                  throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
              }
            else {
              let i5, u4;
              if (typeof t4 == "string")
                if (r4 = t4, u4 = e4, t4 === "string") {
                  if (!Array.isArray(o4))
                    throw new TypeError("A string tensor's data must be a string array.");
                  i5 = o4;
                } else {
                  let l4 = fr.get(t4);
                  if (l4 === void 0)
                    throw new TypeError(`Unsupported tensor type: ${t4}.`);
                  if (Array.isArray(o4)) {
                    if (t4 === "float16" && l4 === Uint16Array)
                      throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                    t4 === "uint64" || t4 === "int64" ? i5 = l4.from(o4, BigInt) : i5 = l4.from(o4);
                  } else if (o4 instanceof l4)
                    i5 = o4;
                  else
                    throw new TypeError(`A ${r4} tensor's data must be type of ${l4}`);
                }
              else if (u4 = o4, Array.isArray(t4)) {
                if (t4.length === 0)
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                let l4 = typeof t4[0];
                if (l4 === "string")
                  r4 = "string", i5 = t4;
                else if (l4 === "boolean")
                  r4 = "bool", i5 = Uint8Array.from(t4);
                else
                  throw new TypeError(`Invalid element type of data array: ${l4}.`);
              } else {
                let l4 = tn.get(t4.constructor);
                if (l4 === void 0)
                  throw new TypeError(`Unsupported type for tensor data: ${t4.constructor}.`);
                r4 = l4, i5 = t4;
              }
              if (u4 === void 0)
                u4 = [i5.length];
              else if (!Array.isArray(u4))
                throw new TypeError("A tensor's dims must be a number array");
              n4 = u4, this.cpuData = i5, this.dataLocation = "cpu";
            }
            let s4 = ls(n4);
            if (this.cpuData && s4 !== this.cpuData.length)
              throw new Error(`Tensor's size(${s4}) does not match data length(${this.cpuData.length}).`);
            this.type = r4, this.dims = n4, this.size = s4;
          }
          static async fromImage(t4, o4) {
            return ts(t4, o4);
          }
          static fromTexture(t4, o4) {
            return rs(t4, o4);
          }
          static fromGpuBuffer(t4, o4) {
            return ns(t4, o4);
          }
          static fromPinnedBuffer(t4, o4, e4) {
            return os(t4, o4, e4);
          }
          toDataURL(t4) {
            return Za(this, t4);
          }
          toImageData(t4) {
            return Qa(this, t4);
          }
          get data() {
            if (this.ensureValid(), !this.cpuData)
              throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
            return this.cpuData;
          }
          get location() {
            return this.dataLocation;
          }
          get texture() {
            if (this.ensureValid(), !this.gpuTextureData)
              throw new Error("The data is not stored as a WebGL texture.");
            return this.gpuTextureData;
          }
          get gpuBuffer() {
            if (this.ensureValid(), !this.gpuBufferData)
              throw new Error("The data is not stored as a WebGPU buffer.");
            return this.gpuBufferData;
          }
          async getData(t4) {
            switch (this.ensureValid(), this.dataLocation) {
              case "cpu":
              case "cpu-pinned":
                return this.data;
              case "texture":
              case "gpu-buffer": {
                if (!this.downloader)
                  throw new Error("The current tensor is not created with a specified data downloader.");
                if (this.isDownloading)
                  throw new Error("The current tensor is being downloaded.");
                try {
                  this.isDownloading = true;
                  let o4 = await this.downloader();
                  return this.downloader = void 0, this.dataLocation = "cpu", this.cpuData = o4, t4 && this.disposer && (this.disposer(), this.disposer = void 0), o4;
                } finally {
                  this.isDownloading = false;
                }
              }
              default:
                throw new Error(`cannot get data from location: ${this.dataLocation}`);
            }
          }
          dispose() {
            if (this.isDownloading)
              throw new Error("The current tensor is being downloaded.");
            this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = "none";
          }
          ensureValid() {
            if (this.dataLocation === "none")
              throw new Error("The tensor is disposed.");
          }
          reshape(t4) {
            if (this.ensureValid(), this.downloader || this.disposer)
              throw new Error("Cannot reshape a tensor that owns GPU resource.");
            return fs(this, t4);
          }
        };
      });
      var Be;
      var kn = E(() => {
        "use strict";
        $n();
        Be = Xe;
      });
      var jo;
      var ps;
      var Yt;
      var Xt;
      var Yo = E(() => {
        "use strict";
        Ho();
        jo = (a4, t4) => {
          (typeof it.trace > "u" ? !it.wasm.trace : !it.trace) || console.timeStamp(`${a4}::ORT::${t4}`);
        }, ps = (a4, t4) => {
          let o4 = new Error().stack?.split(/\r\n|\r|\n/g) || [], e4 = false;
          for (let r4 = 0; r4 < o4.length; r4++) {
            if (e4 && !o4[r4].includes("TRACE_FUNC")) {
              let n4 = `FUNC_${a4}::${o4[r4].trim().split(" ")[1]}`;
              t4 && (n4 += `::${t4}`), jo("CPU", n4);
              return;
            }
            o4[r4].includes("TRACE_FUNC") && (e4 = true);
          }
        }, Yt = (a4) => {
          (typeof it.trace > "u" ? !it.wasm.trace : !it.trace) || ps("BEGIN", a4);
        }, Xt = (a4) => {
          (typeof it.trace > "u" ? !it.wasm.trace : !it.trace) || ps("END", a4);
        };
      });
      var Bn;
      var ds = E(() => {
        "use strict";
        Cn();
        kn();
        Yo();
        Bn = class a4 {
          constructor(t4) {
            this.handler = t4;
          }
          async run(t4, o4, e4) {
            Yt();
            let r4 = {}, n4 = {};
            if (typeof t4 != "object" || t4 === null || t4 instanceof Be || Array.isArray(t4))
              throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
            let s4 = true;
            if (typeof o4 == "object") {
              if (o4 === null)
                throw new TypeError("Unexpected argument[1]: cannot be null.");
              if (o4 instanceof Be)
                throw new TypeError("'fetches' cannot be a Tensor");
              if (Array.isArray(o4)) {
                if (o4.length === 0)
                  throw new TypeError("'fetches' cannot be an empty array.");
                s4 = false;
                for (let l4 of o4) {
                  if (typeof l4 != "string")
                    throw new TypeError("'fetches' must be a string array or an object.");
                  if (this.outputNames.indexOf(l4) === -1)
                    throw new RangeError(`'fetches' contains invalid output name: ${l4}.`);
                  r4[l4] = null;
                }
                if (typeof e4 == "object" && e4 !== null)
                  n4 = e4;
                else if (typeof e4 < "u")
                  throw new TypeError("'options' must be an object.");
              } else {
                let l4 = false, f3 = Object.getOwnPropertyNames(o4);
                for (let p4 of this.outputNames)
                  if (f3.indexOf(p4) !== -1) {
                    let d4 = o4[p4];
                    (d4 === null || d4 instanceof Be) && (l4 = true, s4 = false, r4[p4] = d4);
                  }
                if (l4) {
                  if (typeof e4 == "object" && e4 !== null)
                    n4 = e4;
                  else if (typeof e4 < "u")
                    throw new TypeError("'options' must be an object.");
                } else
                  n4 = o4;
              }
            } else if (typeof o4 < "u")
              throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
            for (let l4 of this.inputNames)
              if (typeof t4[l4] > "u")
                throw new Error(`input '${l4}' is missing in 'feeds'.`);
            if (s4)
              for (let l4 of this.outputNames)
                r4[l4] = null;
            let i5 = await this.handler.run(t4, r4, n4), u4 = {};
            for (let l4 in i5)
              if (Object.hasOwnProperty.call(i5, l4)) {
                let f3 = i5[l4];
                f3 instanceof Be ? u4[l4] = f3 : u4[l4] = new Be(f3.type, f3.data, f3.dims);
              }
            return Xt(), u4;
          }
          async release() {
            return this.handler.dispose();
          }
          static async create(t4, o4, e4, r4) {
            Yt();
            let n4, s4 = {};
            if (typeof t4 == "string") {
              if (n4 = t4, typeof o4 == "object" && o4 !== null)
                s4 = o4;
              else if (typeof o4 < "u")
                throw new TypeError("'options' must be an object.");
            } else if (t4 instanceof Uint8Array) {
              if (n4 = t4, typeof o4 == "object" && o4 !== null)
                s4 = o4;
              else if (typeof o4 < "u")
                throw new TypeError("'options' must be an object.");
            } else if (t4 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && t4 instanceof SharedArrayBuffer) {
              let f3 = t4, p4 = 0, d4 = t4.byteLength;
              if (typeof o4 == "object" && o4 !== null)
                s4 = o4;
              else if (typeof o4 == "number") {
                if (p4 = o4, !Number.isSafeInteger(p4))
                  throw new RangeError("'byteOffset' must be an integer.");
                if (p4 < 0 || p4 >= f3.byteLength)
                  throw new RangeError(`'byteOffset' is out of range [0, ${f3.byteLength}).`);
                if (d4 = t4.byteLength - p4, typeof e4 == "number") {
                  if (d4 = e4, !Number.isSafeInteger(d4))
                    throw new RangeError("'byteLength' must be an integer.");
                  if (d4 <= 0 || p4 + d4 > f3.byteLength)
                    throw new RangeError(`'byteLength' is out of range (0, ${f3.byteLength - p4}].`);
                  if (typeof r4 == "object" && r4 !== null)
                    s4 = r4;
                  else if (typeof r4 < "u")
                    throw new TypeError("'options' must be an object.");
                } else if (typeof e4 < "u")
                  throw new TypeError("'byteLength' must be a number.");
              } else if (typeof o4 < "u")
                throw new TypeError("'options' must be an object.");
              n4 = new Uint8Array(f3, p4, d4);
            } else
              throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
            let [i5, u4] = await Fn(s4), l4 = await i5.createInferenceSessionHandler(n4, u4);
            return Xt(), new a4(l4);
          }
          startProfiling() {
            this.handler.startProfiling();
          }
          endProfiling() {
            this.handler.endProfiling();
          }
          get inputNames() {
            return this.handler.inputNames;
          }
          get outputNames() {
            return this.handler.outputNames;
          }
        };
      });
      var hs;
      var ms = E(() => {
        "use strict";
        ds();
        hs = Bn;
      });
      var bs = E(() => {
        "use strict";
      });
      var gs = E(() => {
        "use strict";
      });
      var ys = E(() => {
        "use strict";
      });
      var Ts = E(() => {
        "use strict";
      });
      var Fd;
      var Nn;
      var xs = E(() => {
        "use strict";
        Cn();
        kn();
        Fd = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.", Nn = class a4 {
          constructor(t4, o4, e4) {
            this.handler = t4, this.hasOptimizerModel = o4, this.hasEvalModel = e4;
          }
          get trainingInputNames() {
            return this.handler.inputNames;
          }
          get trainingOutputNames() {
            return this.handler.outputNames;
          }
          get evalInputNames() {
            if (this.hasEvalModel)
              return this.handler.evalInputNames;
            throw new Error("This training session has no evalModel loaded.");
          }
          get evalOutputNames() {
            if (this.hasEvalModel)
              return this.handler.evalOutputNames;
            throw new Error("This training session has no evalModel loaded.");
          }
          static async create(t4, o4) {
            let e4 = t4.evalModel || "", r4 = t4.optimizerModel || "", n4 = o4 || {}, [s4, i5] = await Fn(n4);
            if (s4.createTrainingSessionHandler) {
              let u4 = await s4.createTrainingSessionHandler(t4.checkpointState, t4.trainModel, e4, r4, i5);
              return new a4(u4, !!t4.optimizerModel, !!t4.evalModel);
            } else
              throw new Error(Fd);
          }
          typeNarrowingForRunStep(t4, o4, e4, r4, n4) {
            let s4 = {}, i5 = {};
            if (typeof e4 != "object" || e4 === null || e4 instanceof Be || Array.isArray(e4))
              throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
            let u4 = true;
            if (typeof r4 == "object") {
              if (r4 === null)
                throw new TypeError("Unexpected argument[1]: cannot be null.");
              if (r4 instanceof Be)
                throw new TypeError("'fetches' cannot be a Tensor");
              if (Array.isArray(r4)) {
                if (r4.length === 0)
                  throw new TypeError("'fetches' cannot be an empty array.");
                u4 = false;
                for (let l4 of r4) {
                  if (typeof l4 != "string")
                    throw new TypeError("'fetches' must be a string array or an object.");
                  if (o4.indexOf(l4) === -1)
                    throw new RangeError(`'fetches' contains invalid output name: ${l4}.`);
                  s4[l4] = null;
                }
                if (typeof n4 == "object" && n4 !== null)
                  i5 = n4;
                else if (typeof n4 < "u")
                  throw new TypeError("'options' must be an object.");
              } else {
                let l4 = false, f3 = Object.getOwnPropertyNames(r4);
                for (let p4 of o4)
                  if (f3.indexOf(p4) !== -1) {
                    let d4 = r4[p4];
                    (d4 === null || d4 instanceof Be) && (l4 = true, u4 = false, s4[p4] = d4);
                  }
                if (l4) {
                  if (typeof n4 == "object" && n4 !== null)
                    i5 = n4;
                  else if (typeof n4 < "u")
                    throw new TypeError("'options' must be an object.");
                } else
                  i5 = r4;
              }
            } else if (typeof r4 < "u")
              throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
            for (let l4 of t4)
              if (typeof e4[l4] > "u")
                throw new Error(`input '${l4}' is missing in 'feeds'.`);
            if (u4)
              for (let l4 of o4)
                s4[l4] = null;
            return [s4, i5];
          }
          convertHandlerReturnTypeToMapOfTensors(t4) {
            let o4 = {};
            for (let e4 in t4)
              if (Object.hasOwnProperty.call(t4, e4)) {
                let r4 = t4[e4];
                r4 instanceof Be ? o4[e4] = r4 : o4[e4] = new Be(r4.type, r4.data, r4.dims);
              }
            return o4;
          }
          async lazyResetGrad() {
            await this.handler.lazyResetGrad();
          }
          async runTrainStep(t4, o4, e4) {
            let [r4, n4] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, t4, o4, e4), s4 = await this.handler.runTrainStep(t4, r4, n4);
            return this.convertHandlerReturnTypeToMapOfTensors(s4);
          }
          async runOptimizerStep(t4) {
            if (this.hasOptimizerModel)
              await this.handler.runOptimizerStep(t4 || {});
            else
              throw new Error("This TrainingSession has no OptimizerModel loaded.");
          }
          async runEvalStep(t4, o4, e4) {
            if (this.hasEvalModel) {
              let [r4, n4] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, t4, o4, e4), s4 = await this.handler.runEvalStep(t4, r4, n4);
              return this.convertHandlerReturnTypeToMapOfTensors(s4);
            } else
              throw new Error("This TrainingSession has no EvalModel loaded.");
          }
          async getParametersSize(t4 = true) {
            return this.handler.getParametersSize(t4);
          }
          async loadParametersBuffer(t4, o4 = true) {
            let e4 = await this.getParametersSize(o4);
            if (t4.length !== 4 * e4)
              throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
            return this.handler.loadParametersBuffer(t4, o4);
          }
          async getContiguousParameters(t4 = true) {
            return this.handler.getContiguousParameters(t4);
          }
          async release() {
            return this.handler.dispose();
          }
        };
      });
      var ws;
      var vs = E(() => {
        "use strict";
        xs();
        ws = Nn;
      });
      var Xo = {};
      sr(Xo, { InferenceSession: () => hs, TRACE: () => jo, TRACE_FUNC_BEGIN: () => Yt, TRACE_FUNC_END: () => Xt, Tensor: () => Be, TrainingSession: () => ws, env: () => Z, registerBackend: () => lr });
      var Tt = E(() => {
        "use strict";
        ja();
        Ja();
        ms();
        kn();
        bs();
        gs();
        Yo();
        ys();
        Ts();
        vs();
      });
      function Kt(a4, t4, o4, e4) {
        if (t4 === void 0)
          return $d(a4);
        if (o4 === void 0)
          Rn(a4, t4, 1);
        else if (typeof o4 == "number" && e4 === void 0)
          Rn(a4, t4, o4);
        else if (typeof o4 == "string" && e4 === void 0)
          Rn(a4, o4, 1, t4);
        else if (typeof o4 == "string" && typeof e4 == "number")
          Rn(a4, o4, e4, t4);
        else
          throw new TypeError("input is valid");
      }
      function $d(a4) {
        return { verbose: Kt.verbose.bind(null, a4), info: Kt.info.bind(null, a4), warning: Kt.warning.bind(null, a4), error: Kt.error.bind(null, a4), fatal: Kt.fatal.bind(null, a4) };
      }
      function Rn(a4, t4, o4, e4) {
        let r4 = rn[e4 || ""] || rn[""];
        Os[a4] < Os[r4.minimalSeverity] || (r4.logDateTime && (t4 = `${(/* @__PURE__ */ new Date()).toISOString()}|${t4}`), r4.logSourceLocation, Cd[r4.provider].log(a4, t4, e4));
      }
      var Ko;
      var Jo;
      var Os;
      var Cd;
      var Is;
      var rn;
      var ce;
      var Gn;
      var Un;
      var zn;
      var Mn;
      var at = E(() => {
        "use strict";
        Ko = class {
          log(t4, o4, e4) {
          }
        }, Jo = class {
          log(t4, o4, e4) {
            console.log(`${this.color(t4)} ${e4 ? "\x1B[35m" + e4 + "\x1B[0m " : ""}${o4}`);
          }
          color(t4) {
            switch (t4) {
              case "verbose":
                return "\x1B[34;40mv\x1B[0m";
              case "info":
                return "\x1B[32mi\x1B[0m";
              case "warning":
                return "\x1B[30;43mw\x1B[0m";
              case "error":
                return "\x1B[31;40me\x1B[0m";
              case "fatal":
                return "\x1B[101mf\x1B[0m";
              default:
                throw new Error(`unsupported severity: ${t4}`);
            }
          }
        }, Os = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, Cd = { none: new Ko(), console: new Jo() }, Is = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false }, rn = { "": Is };
        ((u4) => {
          function a4(l4, f3) {
            u4("verbose", l4, f3);
          }
          u4.verbose = a4;
          function t4(l4, f3) {
            u4("info", l4, f3);
          }
          u4.info = t4;
          function o4(l4, f3) {
            u4("warning", l4, f3);
          }
          u4.warning = o4;
          function e4(l4, f3) {
            u4("error", l4, f3);
          }
          u4.error = e4;
          function r4(l4, f3) {
            u4("fatal", l4, f3);
          }
          u4.fatal = r4;
          function n4(l4) {
            rn = {}, s4("", l4 || {});
          }
          u4.reset = n4;
          function s4(l4, f3) {
            if (l4 === "*")
              n4(f3);
            else {
              let p4 = rn[l4] || Is;
              rn[l4] = { provider: f3.provider || p4.provider, minimalSeverity: f3.minimalSeverity || p4.minimalSeverity, logDateTime: f3.logDateTime === void 0 ? p4.logDateTime : f3.logDateTime, logSourceLocation: f3.logSourceLocation === void 0 ? p4.logSourceLocation : f3.logSourceLocation };
            }
          }
          u4.set = s4;
          function i5(l4) {
            let f3 = {};
            l4.logLevel && (f3.minimalSeverity = l4.logLevel), s4("", f3);
          }
          u4.setWithEnv = i5;
        })(Kt ||= {});
        ce = Kt, Gn = class {
          constructor(t4, o4, e4, r4, n4, s4) {
            this.category = t4;
            this.name = o4;
            this.startTime = e4;
            this.endCallback = r4;
            this.timer = n4;
            this.ctx = s4;
          }
          async end() {
            return this.endCallback(this);
          }
          async checkTimer() {
            if (this.ctx === void 0 || this.timer === void 0)
              throw new Error("No webgl timer found");
            return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
          }
        }, Un = class {
          constructor(t4, o4, e4, r4) {
            this.category = t4;
            this.name = o4;
            this.startTime = e4;
            this.endTime = r4;
          }
        }, zn = class {
          constructor(t4, o4, e4) {
            this._started = false;
            this._flushPointer = 0;
            this._started = false, this._maxNumberEvents = t4 === void 0 ? 1e4 : t4, this._flushBatchSize = o4 === void 0 ? 10 : o4, this._flushIntervalInMilliseconds = e4 === void 0 ? 5e3 : e4;
          }
          static create(t4) {
            return t4 === void 0 ? new this() : new this(t4.maxNumberEvents, t4.flushBatchSize, t4.flushIntervalInMilliseconds);
          }
          start() {
            this._started = true, this._timingEvents = [], this._flushTime = Mn(), this._flushPointer = 0;
          }
          stop() {
            for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++)
              this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
          event(t4, o4, e4, r4) {
            let n4 = this._started ? this.begin(t4, o4, r4) : void 0, s4 = false, i5 = e4();
            if (i5 && typeof i5.then == "function")
              return s4 = true, new Promise((u4, l4) => {
                i5.then(async (f3) => {
                  n4 && await n4.end(), u4(f3);
                }, async (f3) => {
                  n4 && await n4.end(), l4(f3);
                });
              });
            if (!s4 && n4) {
              let u4 = n4.end();
              if (u4 && typeof u4.then == "function")
                return new Promise((l4, f3) => {
                  u4.then(() => {
                    l4(i5);
                  }, (p4) => {
                    f3(p4);
                  });
                });
            }
            return i5;
          }
          begin(t4, o4, e4) {
            if (!this._started)
              throw new Error("profiler is not started yet");
            if (e4 === void 0) {
              let r4 = Mn();
              return this.flush(r4), new Gn(t4, o4, r4, (n4) => this.endSync(n4));
            } else {
              let r4 = e4.beginTimer();
              return new Gn(t4, o4, 0, async (n4) => this.end(n4), r4, e4);
            }
          }
          async end(t4) {
            let o4 = await t4.checkTimer();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new Un(t4.category, t4.name, t4.startTime, o4)), this.flush(o4));
          }
          endSync(t4) {
            let o4 = Mn();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new Un(t4.category, t4.name, t4.startTime, o4)), this.flush(o4));
          }
          logOneEvent(t4) {
            ce.verbose(`Profiler.${t4.category}`, `${(t4.endTime - t4.startTime).toFixed(2)}ms on event '${t4.name}' at ${t4.endTime.toFixed(2)}`);
          }
          flush(t4) {
            if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t4 - this._flushTime >= this._flushIntervalInMilliseconds) {
              for (let o4 = this._flushPointer; this._flushPointer < o4 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                this.logOneEvent(this._timingEvents[this._flushPointer]);
              this._flushTime = Mn();
            }
          }
          get started() {
            return this._started;
          }
        }, Mn = typeof performance < "u" && performance.now ? () => performance.now() : Date.now;
      });
      function Ss(a4, t4, o4) {
        for (let e4 of o4) {
          let r4 = e4[0], n4 = e4[1], s4 = e4[2], i5 = e4[3], u4 = e4[4];
          if (a4.opType === r4) {
            for (let l4 of t4)
              if ((l4.domain === n4 || l4.domain === "ai.onnx" && n4 === "") && kd(l4.version, s4))
                return { opImpl: i5, opInit: u4 };
          }
        }
        throw new TypeError(`cannot resolve operator '${a4.opType}' with opsets: ${t4.map((e4) => `${e4.domain || "ai.onnx"} v${e4.version}`).join(", ")}`);
      }
      function kd(a4, t4) {
        if (t4.endsWith("+")) {
          let o4 = Number.parseInt(t4.substring(0, t4.length - 1), 10);
          return !isNaN(o4) && o4 <= a4;
        } else if (t4.split("-").length === 2) {
          let o4 = t4.split("-"), e4 = Number.parseInt(o4[0], 10), r4 = Number.parseInt(o4[1], 10);
          return !isNaN(e4) && !isNaN(r4) && e4 <= a4 && a4 <= r4;
        } else
          return Number.parseInt(t4, 10) === a4;
      }
      var As = E(() => {
        "use strict";
      });
      var Ps = me((Zo2) => {
        "use strict";
        Zo2.__esModule = true;
        var Bd = function() {
          function a4(t4) {
            if (!t4)
              throw new TypeError("Invalid argument; `value` has no value.");
            this.value = a4.EMPTY, t4 && a4.isGuid(t4) && (this.value = t4);
          }
          return a4.isGuid = function(t4) {
            var o4 = t4.toString();
            return t4 && (t4 instanceof a4 || a4.validator.test(o4));
          }, a4.create = function() {
            return new a4([a4.gen(2), a4.gen(1), a4.gen(1), a4.gen(1), a4.gen(3)].join("-"));
          }, a4.createEmpty = function() {
            return new a4("emptyguid");
          }, a4.parse = function(t4) {
            return new a4(t4);
          }, a4.raw = function() {
            return [a4.gen(2), a4.gen(1), a4.gen(1), a4.gen(1), a4.gen(3)].join("-");
          }, a4.gen = function(t4) {
            for (var o4 = "", e4 = 0; e4 < t4; e4++)
              o4 += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
            return o4;
          }, a4.prototype.equals = function(t4) {
            return a4.isGuid(t4) && this.value === t4.toString();
          }, a4.prototype.isEmpty = function() {
            return this.value === a4.EMPTY;
          }, a4.prototype.toString = function() {
            return this.value;
          }, a4.prototype.toJSON = function() {
            return { value: this.value };
          }, a4.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), a4.EMPTY = "00000000-0000-0000-0000-000000000000", a4;
        }();
        Zo2.Guid = Bd;
      });
      function be(a4, t4, o4) {
        this.low = a4 | 0, this.high = t4 | 0, this.unsigned = !!o4;
      }
      function je(a4) {
        return (a4 && a4.__isLong__) === true;
      }
      function Es(a4) {
        var t4 = Math.clz32(a4 & -a4);
        return a4 ? 31 - t4 : t4;
      }
      function cr(a4, t4) {
        var o4, e4, r4;
        return t4 ? (a4 >>>= 0, (r4 = 0 <= a4 && a4 < 256) && (e4 = Ls[a4], e4) ? e4 : (o4 = le(a4, 0, true), r4 && (Ls[a4] = o4), o4)) : (a4 |= 0, (r4 = -128 <= a4 && a4 < 128) && (e4 = Ds[a4], e4) ? e4 : (o4 = le(a4, a4 < 0 ? -1 : 0, false), r4 && (Ds[a4] = o4), o4));
      }
      function ut(a4, t4) {
        if (isNaN(a4))
          return t4 ? Vt : xt;
        if (t4) {
          if (a4 < 0)
            return Vt;
          if (a4 >= ks)
            return Rs;
        } else {
          if (a4 <= -Cs)
            return tt;
          if (a4 + 1 >= Cs)
            return Ns;
        }
        return a4 < 0 ? ut(-a4, t4).neg() : le(a4 % Fr | 0, a4 / Fr | 0, t4);
      }
      function le(a4, t4, o4) {
        return new be(a4, t4, o4);
      }
      function ei(a4, t4, o4) {
        if (a4.length === 0)
          throw Error("empty string");
        if (typeof t4 == "number" ? (o4 = t4, t4 = false) : t4 = !!t4, a4 === "NaN" || a4 === "Infinity" || a4 === "+Infinity" || a4 === "-Infinity")
          return t4 ? Vt : xt;
        if (o4 = o4 || 10, o4 < 2 || 36 < o4)
          throw RangeError("radix");
        var e4;
        if ((e4 = a4.indexOf("-")) > 0)
          throw Error("interior hyphen");
        if (e4 === 0)
          return ei(a4.substring(1), t4, o4).neg();
        for (var r4 = ut(Vn(o4, 8)), n4 = xt, s4 = 0; s4 < a4.length; s4 += 8) {
          var i5 = Math.min(8, a4.length - s4), u4 = parseInt(a4.substring(s4, s4 + i5), o4);
          if (i5 < 8) {
            var l4 = ut(Vn(o4, i5));
            n4 = n4.mul(l4).add(ut(u4));
          } else
            n4 = n4.mul(r4), n4 = n4.add(ut(u4));
        }
        return n4.unsigned = t4, n4;
      }
      function wt(a4, t4) {
        return typeof a4 == "number" ? ut(a4, t4) : typeof a4 == "string" ? ei(a4, t4) : le(a4.low, a4.high, typeof t4 == "boolean" ? t4 : a4.unsigned);
      }
      var st;
      var Ds;
      var Ls;
      var Vn;
      var Fs;
      var Nd;
      var Fr;
      var ks;
      var Cs;
      var $s;
      var xt;
      var Vt;
      var Lr;
      var Bs;
      var Qo;
      var Ns;
      var Rs;
      var tt;
      var $;
      var Wt;
      var ti = E(() => {
        st = null;
        try {
          st = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
        } catch {
        }
        be.prototype.__isLong__;
        Object.defineProperty(be.prototype, "__isLong__", { value: true });
        be.isLong = je;
        Ds = {}, Ls = {};
        be.fromInt = cr;
        be.fromNumber = ut;
        be.fromBits = le;
        Vn = Math.pow;
        be.fromString = ei;
        be.fromValue = wt;
        Fs = 65536, Nd = 1 << 24, Fr = Fs * Fs, ks = Fr * Fr, Cs = ks / 2, $s = cr(Nd), xt = cr(0);
        be.ZERO = xt;
        Vt = cr(0, true);
        be.UZERO = Vt;
        Lr = cr(1);
        be.ONE = Lr;
        Bs = cr(1, true);
        be.UONE = Bs;
        Qo = cr(-1);
        be.NEG_ONE = Qo;
        Ns = le(-1, 2147483647, false);
        be.MAX_VALUE = Ns;
        Rs = le(-1, -1, true);
        be.MAX_UNSIGNED_VALUE = Rs;
        tt = le(0, -2147483648, false);
        be.MIN_VALUE = tt;
        $ = be.prototype;
        $.toInt = function() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        $.toNumber = function() {
          return this.unsigned ? (this.high >>> 0) * Fr + (this.low >>> 0) : this.high * Fr + (this.low >>> 0);
        };
        $.toString = function(t4) {
          if (t4 = t4 || 10, t4 < 2 || 36 < t4)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative())
            if (this.eq(tt)) {
              var o4 = ut(t4), e4 = this.div(o4), r4 = e4.mul(o4).sub(this);
              return e4.toString(t4) + r4.toInt().toString(t4);
            } else
              return "-" + this.neg().toString(t4);
          for (var n4 = ut(Vn(t4, 6), this.unsigned), s4 = this, i5 = ""; ; ) {
            var u4 = s4.div(n4), l4 = s4.sub(u4.mul(n4)).toInt() >>> 0, f3 = l4.toString(t4);
            if (s4 = u4, s4.isZero())
              return f3 + i5;
            for (; f3.length < 6; )
              f3 = "0" + f3;
            i5 = "" + f3 + i5;
          }
        };
        $.getHighBits = function() {
          return this.high;
        };
        $.getHighBitsUnsigned = function() {
          return this.high >>> 0;
        };
        $.getLowBits = function() {
          return this.low;
        };
        $.getLowBitsUnsigned = function() {
          return this.low >>> 0;
        };
        $.getNumBitsAbs = function() {
          if (this.isNegative())
            return this.eq(tt) ? 64 : this.neg().getNumBitsAbs();
          for (var t4 = this.high != 0 ? this.high : this.low, o4 = 31; o4 > 0 && !(t4 & 1 << o4); o4--)
            ;
          return this.high != 0 ? o4 + 33 : o4 + 1;
        };
        $.isZero = function() {
          return this.high === 0 && this.low === 0;
        };
        $.eqz = $.isZero;
        $.isNegative = function() {
          return !this.unsigned && this.high < 0;
        };
        $.isPositive = function() {
          return this.unsigned || this.high >= 0;
        };
        $.isOdd = function() {
          return (this.low & 1) === 1;
        };
        $.isEven = function() {
          return (this.low & 1) === 0;
        };
        $.equals = function(t4) {
          return je(t4) || (t4 = wt(t4)), this.unsigned !== t4.unsigned && this.high >>> 31 === 1 && t4.high >>> 31 === 1 ? false : this.high === t4.high && this.low === t4.low;
        };
        $.eq = $.equals;
        $.notEquals = function(t4) {
          return !this.eq(t4);
        };
        $.neq = $.notEquals;
        $.ne = $.notEquals;
        $.lessThan = function(t4) {
          return this.comp(t4) < 0;
        };
        $.lt = $.lessThan;
        $.lessThanOrEqual = function(t4) {
          return this.comp(t4) <= 0;
        };
        $.lte = $.lessThanOrEqual;
        $.le = $.lessThanOrEqual;
        $.greaterThan = function(t4) {
          return this.comp(t4) > 0;
        };
        $.gt = $.greaterThan;
        $.greaterThanOrEqual = function(t4) {
          return this.comp(t4) >= 0;
        };
        $.gte = $.greaterThanOrEqual;
        $.ge = $.greaterThanOrEqual;
        $.compare = function(t4) {
          if (je(t4) || (t4 = wt(t4)), this.eq(t4))
            return 0;
          var o4 = this.isNegative(), e4 = t4.isNegative();
          return o4 && !e4 ? -1 : !o4 && e4 ? 1 : this.unsigned ? t4.high >>> 0 > this.high >>> 0 || t4.high === this.high && t4.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t4).isNegative() ? -1 : 1;
        };
        $.comp = $.compare;
        $.negate = function() {
          return !this.unsigned && this.eq(tt) ? tt : this.not().add(Lr);
        };
        $.neg = $.negate;
        $.add = function(t4) {
          je(t4) || (t4 = wt(t4));
          var o4 = this.high >>> 16, e4 = this.high & 65535, r4 = this.low >>> 16, n4 = this.low & 65535, s4 = t4.high >>> 16, i5 = t4.high & 65535, u4 = t4.low >>> 16, l4 = t4.low & 65535, f3 = 0, p4 = 0, d4 = 0, T3 = 0;
          return T3 += n4 + l4, d4 += T3 >>> 16, T3 &= 65535, d4 += r4 + u4, p4 += d4 >>> 16, d4 &= 65535, p4 += e4 + i5, f3 += p4 >>> 16, p4 &= 65535, f3 += o4 + s4, f3 &= 65535, le(d4 << 16 | T3, f3 << 16 | p4, this.unsigned);
        };
        $.subtract = function(t4) {
          return je(t4) || (t4 = wt(t4)), this.add(t4.neg());
        };
        $.sub = $.subtract;
        $.multiply = function(t4) {
          if (this.isZero())
            return this;
          if (je(t4) || (t4 = wt(t4)), st) {
            var o4 = st.mul(this.low, this.high, t4.low, t4.high);
            return le(o4, st.get_high(), this.unsigned);
          }
          if (t4.isZero())
            return this.unsigned ? Vt : xt;
          if (this.eq(tt))
            return t4.isOdd() ? tt : xt;
          if (t4.eq(tt))
            return this.isOdd() ? tt : xt;
          if (this.isNegative())
            return t4.isNegative() ? this.neg().mul(t4.neg()) : this.neg().mul(t4).neg();
          if (t4.isNegative())
            return this.mul(t4.neg()).neg();
          if (this.lt($s) && t4.lt($s))
            return ut(this.toNumber() * t4.toNumber(), this.unsigned);
          var e4 = this.high >>> 16, r4 = this.high & 65535, n4 = this.low >>> 16, s4 = this.low & 65535, i5 = t4.high >>> 16, u4 = t4.high & 65535, l4 = t4.low >>> 16, f3 = t4.low & 65535, p4 = 0, d4 = 0, T3 = 0, v5 = 0;
          return v5 += s4 * f3, T3 += v5 >>> 16, v5 &= 65535, T3 += n4 * f3, d4 += T3 >>> 16, T3 &= 65535, T3 += s4 * l4, d4 += T3 >>> 16, T3 &= 65535, d4 += r4 * f3, p4 += d4 >>> 16, d4 &= 65535, d4 += n4 * l4, p4 += d4 >>> 16, d4 &= 65535, d4 += s4 * u4, p4 += d4 >>> 16, d4 &= 65535, p4 += e4 * f3 + r4 * l4 + n4 * u4 + s4 * i5, p4 &= 65535, le(T3 << 16 | v5, p4 << 16 | d4, this.unsigned);
        };
        $.mul = $.multiply;
        $.divide = function(t4) {
          if (je(t4) || (t4 = wt(t4)), t4.isZero())
            throw Error("division by zero");
          if (st) {
            if (!this.unsigned && this.high === -2147483648 && t4.low === -1 && t4.high === -1)
              return this;
            var o4 = (this.unsigned ? st.div_u : st.div_s)(this.low, this.high, t4.low, t4.high);
            return le(o4, st.get_high(), this.unsigned);
          }
          if (this.isZero())
            return this.unsigned ? Vt : xt;
          var e4, r4, n4;
          if (this.unsigned) {
            if (t4.unsigned || (t4 = t4.toUnsigned()), t4.gt(this))
              return Vt;
            if (t4.gt(this.shru(1)))
              return Bs;
            n4 = Vt;
          } else {
            if (this.eq(tt)) {
              if (t4.eq(Lr) || t4.eq(Qo))
                return tt;
              if (t4.eq(tt))
                return Lr;
              var s4 = this.shr(1);
              return e4 = s4.div(t4).shl(1), e4.eq(xt) ? t4.isNegative() ? Lr : Qo : (r4 = this.sub(t4.mul(e4)), n4 = e4.add(r4.div(t4)), n4);
            } else if (t4.eq(tt))
              return this.unsigned ? Vt : xt;
            if (this.isNegative())
              return t4.isNegative() ? this.neg().div(t4.neg()) : this.neg().div(t4).neg();
            if (t4.isNegative())
              return this.div(t4.neg()).neg();
            n4 = xt;
          }
          for (r4 = this; r4.gte(t4); ) {
            e4 = Math.max(1, Math.floor(r4.toNumber() / t4.toNumber()));
            for (var i5 = Math.ceil(Math.log(e4) / Math.LN2), u4 = i5 <= 48 ? 1 : Vn(2, i5 - 48), l4 = ut(e4), f3 = l4.mul(t4); f3.isNegative() || f3.gt(r4); )
              e4 -= u4, l4 = ut(e4, this.unsigned), f3 = l4.mul(t4);
            l4.isZero() && (l4 = Lr), n4 = n4.add(l4), r4 = r4.sub(f3);
          }
          return n4;
        };
        $.div = $.divide;
        $.modulo = function(t4) {
          if (je(t4) || (t4 = wt(t4)), st) {
            var o4 = (this.unsigned ? st.rem_u : st.rem_s)(this.low, this.high, t4.low, t4.high);
            return le(o4, st.get_high(), this.unsigned);
          }
          return this.sub(this.div(t4).mul(t4));
        };
        $.mod = $.modulo;
        $.rem = $.modulo;
        $.not = function() {
          return le(~this.low, ~this.high, this.unsigned);
        };
        $.countLeadingZeros = function() {
          return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
        };
        $.clz = $.countLeadingZeros;
        $.countTrailingZeros = function() {
          return this.low ? Es(this.low) : Es(this.high) + 32;
        };
        $.ctz = $.countTrailingZeros;
        $.and = function(t4) {
          return je(t4) || (t4 = wt(t4)), le(this.low & t4.low, this.high & t4.high, this.unsigned);
        };
        $.or = function(t4) {
          return je(t4) || (t4 = wt(t4)), le(this.low | t4.low, this.high | t4.high, this.unsigned);
        };
        $.xor = function(t4) {
          return je(t4) || (t4 = wt(t4)), le(this.low ^ t4.low, this.high ^ t4.high, this.unsigned);
        };
        $.shiftLeft = function(t4) {
          return je(t4) && (t4 = t4.toInt()), (t4 &= 63) === 0 ? this : t4 < 32 ? le(this.low << t4, this.high << t4 | this.low >>> 32 - t4, this.unsigned) : le(0, this.low << t4 - 32, this.unsigned);
        };
        $.shl = $.shiftLeft;
        $.shiftRight = function(t4) {
          return je(t4) && (t4 = t4.toInt()), (t4 &= 63) === 0 ? this : t4 < 32 ? le(this.low >>> t4 | this.high << 32 - t4, this.high >> t4, this.unsigned) : le(this.high >> t4 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        $.shr = $.shiftRight;
        $.shiftRightUnsigned = function(t4) {
          return je(t4) && (t4 = t4.toInt()), (t4 &= 63) === 0 ? this : t4 < 32 ? le(this.low >>> t4 | this.high << 32 - t4, this.high >>> t4, this.unsigned) : t4 === 32 ? le(this.high, 0, this.unsigned) : le(this.high >>> t4 - 32, 0, this.unsigned);
        };
        $.shru = $.shiftRightUnsigned;
        $.shr_u = $.shiftRightUnsigned;
        $.rotateLeft = function(t4) {
          var o4;
          return je(t4) && (t4 = t4.toInt()), (t4 &= 63) === 0 ? this : t4 === 32 ? le(this.high, this.low, this.unsigned) : t4 < 32 ? (o4 = 32 - t4, le(this.low << t4 | this.high >>> o4, this.high << t4 | this.low >>> o4, this.unsigned)) : (t4 -= 32, o4 = 32 - t4, le(this.high << t4 | this.low >>> o4, this.low << t4 | this.high >>> o4, this.unsigned));
        };
        $.rotl = $.rotateLeft;
        $.rotateRight = function(t4) {
          var o4;
          return je(t4) && (t4 = t4.toInt()), (t4 &= 63) === 0 ? this : t4 === 32 ? le(this.high, this.low, this.unsigned) : t4 < 32 ? (o4 = 32 - t4, le(this.high << o4 | this.low >>> t4, this.low << o4 | this.high >>> t4, this.unsigned)) : (t4 -= 32, o4 = 32 - t4, le(this.low << o4 | this.high >>> t4, this.high << o4 | this.low >>> t4, this.unsigned));
        };
        $.rotr = $.rotateRight;
        $.toSigned = function() {
          return this.unsigned ? le(this.low, this.high, false) : this;
        };
        $.toUnsigned = function() {
          return this.unsigned ? this : le(this.low, this.high, true);
        };
        $.toBytes = function(t4) {
          return t4 ? this.toBytesLE() : this.toBytesBE();
        };
        $.toBytesLE = function() {
          var t4 = this.high, o4 = this.low;
          return [o4 & 255, o4 >>> 8 & 255, o4 >>> 16 & 255, o4 >>> 24, t4 & 255, t4 >>> 8 & 255, t4 >>> 16 & 255, t4 >>> 24];
        };
        $.toBytesBE = function() {
          var t4 = this.high, o4 = this.low;
          return [t4 >>> 24, t4 >>> 16 & 255, t4 >>> 8 & 255, t4 & 255, o4 >>> 24, o4 >>> 16 & 255, o4 >>> 8 & 255, o4 & 255];
        };
        be.fromBytes = function(t4, o4, e4) {
          return e4 ? be.fromBytesLE(t4, o4) : be.fromBytesBE(t4, o4);
        };
        be.fromBytesLE = function(t4, o4) {
          return new be(t4[0] | t4[1] << 8 | t4[2] << 16 | t4[3] << 24, t4[4] | t4[5] << 8 | t4[6] << 16 | t4[7] << 24, o4);
        };
        be.fromBytesBE = function(t4, o4) {
          return new be(t4[4] << 24 | t4[5] << 16 | t4[6] << 8 | t4[7], t4[0] << 24 | t4[1] << 16 | t4[2] << 8 | t4[3], o4);
        };
        Wt = be;
      });
      var O;
      var Wn = E(() => {
        O = {};
        O.Offset;
        O.Table;
        O.SIZEOF_SHORT = 2;
        O.SIZEOF_INT = 4;
        O.FILE_IDENTIFIER_LENGTH = 4;
        O.SIZE_PREFIX_LENGTH = 4;
        O.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 };
        O.int32 = new Int32Array(2);
        O.float32 = new Float32Array(O.int32.buffer);
        O.float64 = new Float64Array(O.int32.buffer);
        O.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
        O.Long = function(a4, t4) {
          this.low = a4 | 0, this.high = t4 | 0;
        };
        O.Long.create = function(a4, t4) {
          return a4 == 0 && t4 == 0 ? O.Long.ZERO : new O.Long(a4, t4);
        };
        O.Long.prototype.toFloat64 = function() {
          return (this.low >>> 0) + this.high * 4294967296;
        };
        O.Long.prototype.equals = function(a4) {
          return this.low == a4.low && this.high == a4.high;
        };
        O.Long.ZERO = new O.Long(0, 0);
        O.Builder = function(a4) {
          if (a4)
            var t4 = a4;
          else
            var t4 = 1024;
          this.bb = O.ByteBuffer.allocate(t4), this.space = t4, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        };
        O.Builder.prototype.clear = function() {
          this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        };
        O.Builder.prototype.forceDefaults = function(a4) {
          this.force_defaults = a4;
        };
        O.Builder.prototype.dataBuffer = function() {
          return this.bb;
        };
        O.Builder.prototype.asUint8Array = function() {
          return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
        };
        O.Builder.prototype.prep = function(a4, t4) {
          a4 > this.minalign && (this.minalign = a4);
          for (var o4 = ~(this.bb.capacity() - this.space + t4) + 1 & a4 - 1; this.space < o4 + a4 + t4; ) {
            var e4 = this.bb.capacity();
            this.bb = O.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - e4;
          }
          this.pad(o4);
        };
        O.Builder.prototype.pad = function(a4) {
          for (var t4 = 0; t4 < a4; t4++)
            this.bb.writeInt8(--this.space, 0);
        };
        O.Builder.prototype.writeInt8 = function(a4) {
          this.bb.writeInt8(this.space -= 1, a4);
        };
        O.Builder.prototype.writeInt16 = function(a4) {
          this.bb.writeInt16(this.space -= 2, a4);
        };
        O.Builder.prototype.writeInt32 = function(a4) {
          this.bb.writeInt32(this.space -= 4, a4);
        };
        O.Builder.prototype.writeInt64 = function(a4) {
          this.bb.writeInt64(this.space -= 8, a4);
        };
        O.Builder.prototype.writeFloat32 = function(a4) {
          this.bb.writeFloat32(this.space -= 4, a4);
        };
        O.Builder.prototype.writeFloat64 = function(a4) {
          this.bb.writeFloat64(this.space -= 8, a4);
        };
        O.Builder.prototype.addInt8 = function(a4) {
          this.prep(1, 0), this.writeInt8(a4);
        };
        O.Builder.prototype.addInt16 = function(a4) {
          this.prep(2, 0), this.writeInt16(a4);
        };
        O.Builder.prototype.addInt32 = function(a4) {
          this.prep(4, 0), this.writeInt32(a4);
        };
        O.Builder.prototype.addInt64 = function(a4) {
          this.prep(8, 0), this.writeInt64(a4);
        };
        O.Builder.prototype.addFloat32 = function(a4) {
          this.prep(4, 0), this.writeFloat32(a4);
        };
        O.Builder.prototype.addFloat64 = function(a4) {
          this.prep(8, 0), this.writeFloat64(a4);
        };
        O.Builder.prototype.addFieldInt8 = function(a4, t4, o4) {
          (this.force_defaults || t4 != o4) && (this.addInt8(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldInt16 = function(a4, t4, o4) {
          (this.force_defaults || t4 != o4) && (this.addInt16(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldInt32 = function(a4, t4, o4) {
          (this.force_defaults || t4 != o4) && (this.addInt32(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldInt64 = function(a4, t4, o4) {
          (this.force_defaults || !t4.equals(o4)) && (this.addInt64(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldFloat32 = function(a4, t4, o4) {
          (this.force_defaults || t4 != o4) && (this.addFloat32(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldFloat64 = function(a4, t4, o4) {
          (this.force_defaults || t4 != o4) && (this.addFloat64(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldOffset = function(a4, t4, o4) {
          (this.force_defaults || t4 != o4) && (this.addOffset(t4), this.slot(a4));
        };
        O.Builder.prototype.addFieldStruct = function(a4, t4, o4) {
          t4 != o4 && (this.nested(t4), this.slot(a4));
        };
        O.Builder.prototype.nested = function(a4) {
          if (a4 != this.offset())
            throw new Error("FlatBuffers: struct must be serialized inline.");
        };
        O.Builder.prototype.notNested = function() {
          if (this.isNested)
            throw new Error("FlatBuffers: object serialization must not be nested.");
        };
        O.Builder.prototype.slot = function(a4) {
          this.vtable[a4] = this.offset();
        };
        O.Builder.prototype.offset = function() {
          return this.bb.capacity() - this.space;
        };
        O.Builder.growByteBuffer = function(a4) {
          var t4 = a4.capacity();
          if (t4 & 3221225472)
            throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
          var o4 = t4 << 1, e4 = O.ByteBuffer.allocate(o4);
          return e4.setPosition(o4 - t4), e4.bytes().set(a4.bytes(), o4 - t4), e4;
        };
        O.Builder.prototype.addOffset = function(a4) {
          this.prep(O.SIZEOF_INT, 0), this.writeInt32(this.offset() - a4 + O.SIZEOF_INT);
        };
        O.Builder.prototype.startObject = function(a4) {
          this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = a4;
          for (var t4 = 0; t4 < a4; t4++)
            this.vtable[t4] = 0;
          this.isNested = true, this.object_start = this.offset();
        };
        O.Builder.prototype.endObject = function() {
          if (this.vtable == null || !this.isNested)
            throw new Error("FlatBuffers: endObject called without startObject");
          this.addInt32(0);
          for (var a4 = this.offset(), t4 = this.vtable_in_use - 1; t4 >= 0 && this.vtable[t4] == 0; t4--)
            ;
          for (var o4 = t4 + 1; t4 >= 0; t4--)
            this.addInt16(this.vtable[t4] != 0 ? a4 - this.vtable[t4] : 0);
          var e4 = 2;
          this.addInt16(a4 - this.object_start);
          var r4 = (o4 + e4) * O.SIZEOF_SHORT;
          this.addInt16(r4);
          var n4 = 0, s4 = this.space;
          e:
            for (t4 = 0; t4 < this.vtables.length; t4++) {
              var i5 = this.bb.capacity() - this.vtables[t4];
              if (r4 == this.bb.readInt16(i5)) {
                for (var u4 = O.SIZEOF_SHORT; u4 < r4; u4 += O.SIZEOF_SHORT)
                  if (this.bb.readInt16(s4 + u4) != this.bb.readInt16(i5 + u4))
                    continue e;
                n4 = this.vtables[t4];
                break;
              }
            }
          return n4 ? (this.space = this.bb.capacity() - a4, this.bb.writeInt32(this.space, n4 - a4)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - a4, this.offset() - a4)), this.isNested = false, a4;
        };
        O.Builder.prototype.finish = function(a4, t4, o4) {
          var e4 = o4 ? O.SIZE_PREFIX_LENGTH : 0;
          if (t4) {
            var r4 = t4;
            if (this.prep(this.minalign, O.SIZEOF_INT + O.FILE_IDENTIFIER_LENGTH + e4), r4.length != O.FILE_IDENTIFIER_LENGTH)
              throw new Error("FlatBuffers: file identifier must be length " + O.FILE_IDENTIFIER_LENGTH);
            for (var n4 = O.FILE_IDENTIFIER_LENGTH - 1; n4 >= 0; n4--)
              this.writeInt8(r4.charCodeAt(n4));
          }
          this.prep(this.minalign, O.SIZEOF_INT + e4), this.addOffset(a4), e4 && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
        };
        O.Builder.prototype.finishSizePrefixed = function(a4, t4) {
          this.finish(a4, t4, true);
        };
        O.Builder.prototype.requiredField = function(a4, t4) {
          var o4 = this.bb.capacity() - a4, e4 = o4 - this.bb.readInt32(o4), r4 = this.bb.readInt16(e4 + t4) != 0;
          if (!r4)
            throw new Error("FlatBuffers: field " + t4 + " must be set");
        };
        O.Builder.prototype.startVector = function(a4, t4, o4) {
          this.notNested(), this.vector_num_elems = t4, this.prep(O.SIZEOF_INT, a4 * t4), this.prep(o4, a4 * t4);
        };
        O.Builder.prototype.endVector = function() {
          return this.writeInt32(this.vector_num_elems), this.offset();
        };
        O.Builder.prototype.createString = function(a4) {
          if (a4 instanceof Uint8Array)
            var t4 = a4;
          else
            for (var t4 = [], o4 = 0; o4 < a4.length; ) {
              var e4, r4 = a4.charCodeAt(o4++);
              if (r4 < 55296 || r4 >= 56320)
                e4 = r4;
              else {
                var n4 = a4.charCodeAt(o4++);
                e4 = (r4 << 10) + n4 + (65536 - 56623104 - 56320);
              }
              e4 < 128 ? t4.push(e4) : (e4 < 2048 ? t4.push(e4 >> 6 & 31 | 192) : (e4 < 65536 ? t4.push(e4 >> 12 & 15 | 224) : t4.push(e4 >> 18 & 7 | 240, e4 >> 12 & 63 | 128), t4.push(e4 >> 6 & 63 | 128)), t4.push(e4 & 63 | 128));
            }
          this.addInt8(0), this.startVector(1, t4.length, 1), this.bb.setPosition(this.space -= t4.length);
          for (var o4 = 0, s4 = this.space, i5 = this.bb.bytes(); o4 < t4.length; o4++)
            i5[s4++] = t4[o4];
          return this.endVector();
        };
        O.Builder.prototype.createLong = function(a4, t4) {
          return O.Long.create(a4, t4);
        };
        O.ByteBuffer = function(a4) {
          this.bytes_ = a4, this.position_ = 0;
        };
        O.ByteBuffer.allocate = function(a4) {
          return new O.ByteBuffer(new Uint8Array(a4));
        };
        O.ByteBuffer.prototype.clear = function() {
          this.position_ = 0;
        };
        O.ByteBuffer.prototype.bytes = function() {
          return this.bytes_;
        };
        O.ByteBuffer.prototype.position = function() {
          return this.position_;
        };
        O.ByteBuffer.prototype.setPosition = function(a4) {
          this.position_ = a4;
        };
        O.ByteBuffer.prototype.capacity = function() {
          return this.bytes_.length;
        };
        O.ByteBuffer.prototype.readInt8 = function(a4) {
          return this.readUint8(a4) << 24 >> 24;
        };
        O.ByteBuffer.prototype.readUint8 = function(a4) {
          return this.bytes_[a4];
        };
        O.ByteBuffer.prototype.readInt16 = function(a4) {
          return this.readUint16(a4) << 16 >> 16;
        };
        O.ByteBuffer.prototype.readUint16 = function(a4) {
          return this.bytes_[a4] | this.bytes_[a4 + 1] << 8;
        };
        O.ByteBuffer.prototype.readInt32 = function(a4) {
          return this.bytes_[a4] | this.bytes_[a4 + 1] << 8 | this.bytes_[a4 + 2] << 16 | this.bytes_[a4 + 3] << 24;
        };
        O.ByteBuffer.prototype.readUint32 = function(a4) {
          return this.readInt32(a4) >>> 0;
        };
        O.ByteBuffer.prototype.readInt64 = function(a4) {
          return new O.Long(this.readInt32(a4), this.readInt32(a4 + 4));
        };
        O.ByteBuffer.prototype.readUint64 = function(a4) {
          return new O.Long(this.readUint32(a4), this.readUint32(a4 + 4));
        };
        O.ByteBuffer.prototype.readFloat32 = function(a4) {
          return O.int32[0] = this.readInt32(a4), O.float32[0];
        };
        O.ByteBuffer.prototype.readFloat64 = function(a4) {
          return O.int32[O.isLittleEndian ? 0 : 1] = this.readInt32(a4), O.int32[O.isLittleEndian ? 1 : 0] = this.readInt32(a4 + 4), O.float64[0];
        };
        O.ByteBuffer.prototype.writeInt8 = function(a4, t4) {
          this.bytes_[a4] = t4;
        };
        O.ByteBuffer.prototype.writeUint8 = function(a4, t4) {
          this.bytes_[a4] = t4;
        };
        O.ByteBuffer.prototype.writeInt16 = function(a4, t4) {
          this.bytes_[a4] = t4, this.bytes_[a4 + 1] = t4 >> 8;
        };
        O.ByteBuffer.prototype.writeUint16 = function(a4, t4) {
          this.bytes_[a4] = t4, this.bytes_[a4 + 1] = t4 >> 8;
        };
        O.ByteBuffer.prototype.writeInt32 = function(a4, t4) {
          this.bytes_[a4] = t4, this.bytes_[a4 + 1] = t4 >> 8, this.bytes_[a4 + 2] = t4 >> 16, this.bytes_[a4 + 3] = t4 >> 24;
        };
        O.ByteBuffer.prototype.writeUint32 = function(a4, t4) {
          this.bytes_[a4] = t4, this.bytes_[a4 + 1] = t4 >> 8, this.bytes_[a4 + 2] = t4 >> 16, this.bytes_[a4 + 3] = t4 >> 24;
        };
        O.ByteBuffer.prototype.writeInt64 = function(a4, t4) {
          this.writeInt32(a4, t4.low), this.writeInt32(a4 + 4, t4.high);
        };
        O.ByteBuffer.prototype.writeUint64 = function(a4, t4) {
          this.writeUint32(a4, t4.low), this.writeUint32(a4 + 4, t4.high);
        };
        O.ByteBuffer.prototype.writeFloat32 = function(a4, t4) {
          O.float32[0] = t4, this.writeInt32(a4, O.int32[0]);
        };
        O.ByteBuffer.prototype.writeFloat64 = function(a4, t4) {
          O.float64[0] = t4, this.writeInt32(a4, O.int32[O.isLittleEndian ? 0 : 1]), this.writeInt32(a4 + 4, O.int32[O.isLittleEndian ? 1 : 0]);
        };
        O.ByteBuffer.prototype.getBufferIdentifier = function() {
          if (this.bytes_.length < this.position_ + O.SIZEOF_INT + O.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
          for (var a4 = "", t4 = 0; t4 < O.FILE_IDENTIFIER_LENGTH; t4++)
            a4 += String.fromCharCode(this.readInt8(this.position_ + O.SIZEOF_INT + t4));
          return a4;
        };
        O.ByteBuffer.prototype.__offset = function(a4, t4) {
          var o4 = a4 - this.readInt32(a4);
          return t4 < this.readInt16(o4) ? this.readInt16(o4 + t4) : 0;
        };
        O.ByteBuffer.prototype.__union = function(a4, t4) {
          return a4.bb_pos = t4 + this.readInt32(t4), a4.bb = this, a4;
        };
        O.ByteBuffer.prototype.__string = function(a4, t4) {
          a4 += this.readInt32(a4);
          var o4 = this.readInt32(a4), e4 = "", r4 = 0;
          if (a4 += O.SIZEOF_INT, t4 === O.Encoding.UTF8_BYTES)
            return this.bytes_.subarray(a4, a4 + o4);
          for (; r4 < o4; ) {
            var n4, s4 = this.readUint8(a4 + r4++);
            if (s4 < 192)
              n4 = s4;
            else {
              var i5 = this.readUint8(a4 + r4++);
              if (s4 < 224)
                n4 = (s4 & 31) << 6 | i5 & 63;
              else {
                var u4 = this.readUint8(a4 + r4++);
                if (s4 < 240)
                  n4 = (s4 & 15) << 12 | (i5 & 63) << 6 | u4 & 63;
                else {
                  var l4 = this.readUint8(a4 + r4++);
                  n4 = (s4 & 7) << 18 | (i5 & 63) << 12 | (u4 & 63) << 6 | l4 & 63;
                }
              }
            }
            n4 < 65536 ? e4 += String.fromCharCode(n4) : (n4 -= 65536, e4 += String.fromCharCode((n4 >> 10) + 55296, (n4 & 1024 - 1) + 56320));
          }
          return e4;
        };
        O.ByteBuffer.prototype.__indirect = function(a4) {
          return a4 + this.readInt32(a4);
        };
        O.ByteBuffer.prototype.__vector = function(a4) {
          return a4 + this.readInt32(a4) + O.SIZEOF_INT;
        };
        O.ByteBuffer.prototype.__vector_len = function(a4) {
          return this.readInt32(a4 + this.readInt32(a4));
        };
        O.ByteBuffer.prototype.__has_identifier = function(a4) {
          if (a4.length != O.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: file identifier must be length " + O.FILE_IDENTIFIER_LENGTH);
          for (var t4 = 0; t4 < O.FILE_IDENTIFIER_LENGTH; t4++)
            if (a4.charCodeAt(t4) != this.readInt8(this.position_ + O.SIZEOF_INT + t4))
              return false;
          return true;
        };
        O.ByteBuffer.prototype.createLong = function(a4, t4) {
          return O.Long.create(a4, t4);
        };
      });
      var W;
      var nn = E(() => {
        "use strict";
        Wn();
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              let r4;
              ((C3) => (C3[C3.UNDEFINED = 0] = "UNDEFINED", C3[C3.FLOAT = 1] = "FLOAT", C3[C3.INT = 2] = "INT", C3[C3.STRING = 3] = "STRING", C3[C3.TENSOR = 4] = "TENSOR", C3[C3.GRAPH = 5] = "GRAPH", C3[C3.FLOATS = 6] = "FLOATS", C3[C3.INTS = 7] = "INTS", C3[C3.STRINGS = 8] = "STRINGS", C3[C3.TENSORS = 9] = "TENSORS", C3[C3.GRAPHS = 10] = "GRAPHS", C3[C3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", C3[C3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS"))(r4 = n4.AttributeType ||= {});
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              let r4;
              ((l4) => (l4[l4.UNKNOWN = 0] = "UNKNOWN", l4[l4.VALUE = 1] = "VALUE", l4[l4.PARAM = 2] = "PARAM"))(r4 = n4.DimensionValueType ||= {});
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              let r4;
              ((V4) => (V4[V4.UNDEFINED = 0] = "UNDEFINED", V4[V4.FLOAT = 1] = "FLOAT", V4[V4.UINT8 = 2] = "UINT8", V4[V4.INT8 = 3] = "INT8", V4[V4.UINT16 = 4] = "UINT16", V4[V4.INT16 = 5] = "INT16", V4[V4.INT32 = 6] = "INT32", V4[V4.INT64 = 7] = "INT64", V4[V4.STRING = 8] = "STRING", V4[V4.BOOL = 9] = "BOOL", V4[V4.FLOAT16 = 10] = "FLOAT16", V4[V4.DOUBLE = 11] = "DOUBLE", V4[V4.UINT32 = 12] = "UINT32", V4[V4.UINT64 = 13] = "UINT64", V4[V4.COMPLEX64 = 14] = "COMPLEX64", V4[V4.COMPLEX128 = 15] = "COMPLEX128", V4[V4.BFLOAT16 = 16] = "BFLOAT16", V4[V4.FLOAT8E4M3FN = 17] = "FLOAT8E4M3FN", V4[V4.FLOAT8E4M3FNUZ = 18] = "FLOAT8E4M3FNUZ", V4[V4.FLOAT8E5M2 = 19] = "FLOAT8E5M2", V4[V4.FLOAT8E5M2FNUZ = 20] = "FLOAT8E5M2FNUZ"))(r4 = n4.TensorDataType ||= {});
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              let r4;
              ((u4) => (u4[u4.Primitive = 0] = "Primitive", u4[u4.Fused = 1] = "Fused"))(r4 = n4.NodeType ||= {});
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              let r4;
              ((f3) => (f3[f3.NONE = 0] = "NONE", f3[f3.tensor_type = 1] = "tensor_type", f3[f3.sequence_type = 2] = "sequence_type", f3[f3.map_type = 3] = "map_type"))(r4 = n4.TypeInfoValue ||= {});
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsShape(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsShape(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                dim(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 4);
                  return l4 ? (u4 || new t4.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                dimLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startShape(i5) {
                  i5.startObject(1);
                }
                static addDim(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static createDimVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startDimVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static endShape(i5) {
                  return i5.endObject();
                }
                static createShape(i5, u4) {
                  return r4.startShape(i5), r4.addDim(i5, u4), r4.endShape(i5);
                }
              }
              n4.Shape = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsDimension(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsDimension(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                value(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? (i5 || new t4.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                denotation(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                static startDimension(i5) {
                  i5.startObject(2);
                }
                static addValue(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addDenotation(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static endDimension(i5) {
                  return i5.endObject();
                }
                static createDimension(i5, u4, l4) {
                  return r4.startDimension(i5), r4.addValue(i5, u4), r4.addDenotation(i5, l4), r4.endDimension(i5);
                }
              }
              n4.Dimension = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsDimensionValue(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsDimensionValue(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                dimType() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.readInt8(this.bb_pos + i5) : 0;
                }
                dimValue() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.readInt64(this.bb_pos + i5) : this.bb.createLong(0, 0);
                }
                dimParam(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                static startDimensionValue(i5) {
                  i5.startObject(3);
                }
                static addDimType(i5, u4) {
                  i5.addFieldInt8(0, u4, 0);
                }
                static addDimValue(i5, u4) {
                  i5.addFieldInt64(1, u4, i5.createLong(0, 0));
                }
                static addDimParam(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static endDimensionValue(i5) {
                  return i5.endObject();
                }
                static createDimensionValue(i5, u4, l4, f3) {
                  return r4.startDimensionValue(i5), r4.addDimType(i5, u4), r4.addDimValue(i5, l4), r4.addDimParam(i5, f3), r4.endDimensionValue(i5);
                }
              }
              n4.DimensionValue = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsTensorTypeAndShape(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsTensorTypeAndShape(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                elemType() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.readInt32(this.bb_pos + i5) : 0;
                }
                shape(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? (i5 || new t4.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                static startTensorTypeAndShape(i5) {
                  i5.startObject(2);
                }
                static addElemType(i5, u4) {
                  i5.addFieldInt32(0, u4, 0);
                }
                static addShape(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static endTensorTypeAndShape(i5) {
                  return i5.endObject();
                }
                static createTensorTypeAndShape(i5, u4, l4) {
                  return r4.startTensorTypeAndShape(i5), r4.addElemType(i5, u4), r4.addShape(i5, l4), r4.endTensorTypeAndShape(i5);
                }
              }
              n4.TensorTypeAndShape = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsMapType(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsMapType(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                keyType() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.readInt32(this.bb_pos + i5) : 0;
                }
                valueType(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? (i5 || new t4.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                static startMapType(i5) {
                  i5.startObject(2);
                }
                static addKeyType(i5, u4) {
                  i5.addFieldInt32(0, u4, 0);
                }
                static addValueType(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static endMapType(i5) {
                  return i5.endObject();
                }
                static createMapType(i5, u4, l4) {
                  return r4.startMapType(i5), r4.addKeyType(i5, u4), r4.addValueType(i5, l4), r4.endMapType(i5);
                }
              }
              n4.MapType = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsSequenceType(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsSequenceType(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                elemType(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? (i5 || new t4.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                static startSequenceType(i5) {
                  i5.startObject(1);
                }
                static addElemType(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static endSequenceType(i5) {
                  return i5.endObject();
                }
                static createSequenceType(i5, u4) {
                  return r4.startSequenceType(i5), r4.addElemType(i5, u4), r4.endSequenceType(i5);
                }
              }
              n4.SequenceType = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                nodeIndex() {
                  return this.bb.readUint32(this.bb_pos);
                }
                srcArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 4);
                }
                dstArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 8);
                }
                static createEdgeEnd(i5, u4, l4, f3) {
                  return i5.prep(4, 12), i5.writeInt32(f3), i5.writeInt32(l4), i5.writeInt32(u4), i5.offset();
                }
              }
              n4.EdgeEnd = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsNodeEdge(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsNodeEdge(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                nodeIndex() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.readUint32(this.bb_pos + i5) : 0;
                }
                inputEdges(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 6);
                  return l4 ? (u4 || new t4.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + l4) + i5 * 12, this.bb) : null;
                }
                inputEdgesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                outputEdges(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 8);
                  return l4 ? (u4 || new t4.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + l4) + i5 * 12, this.bb) : null;
                }
                outputEdgesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 8);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startNodeEdge(i5) {
                  i5.startObject(3);
                }
                static addNodeIndex(i5, u4) {
                  i5.addFieldInt32(0, u4, 0);
                }
                static addInputEdges(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static startInputEdgesVector(i5, u4) {
                  i5.startVector(12, u4, 4);
                }
                static addOutputEdges(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static startOutputEdgesVector(i5, u4) {
                  i5.startVector(12, u4, 4);
                }
                static endNodeEdge(i5) {
                  return i5.endObject();
                }
                static createNodeEdge(i5, u4, l4, f3) {
                  return r4.startNodeEdge(i5), r4.addNodeIndex(i5, u4), r4.addInputEdges(i5, l4), r4.addOutputEdges(i5, f3), r4.endNodeEdge(i5);
                }
              }
              n4.NodeEdge = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsNode(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsNode(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                name(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                docString(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                domain(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                sinceVersion() {
                  let i5 = this.bb.__offset(this.bb_pos, 10);
                  return i5 ? this.bb.readInt32(this.bb_pos + i5) : 0;
                }
                index() {
                  let i5 = this.bb.__offset(this.bb_pos, 12);
                  return i5 ? this.bb.readUint32(this.bb_pos + i5) : 0;
                }
                opType(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 14);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                type() {
                  let i5 = this.bb.__offset(this.bb_pos, 16);
                  return i5 ? this.bb.readInt32(this.bb_pos + i5) : 0;
                }
                executionProviderType(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 18);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                inputs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 20);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                inputsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 20);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                outputs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 22);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                outputsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 22);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                attributes(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 24);
                  return l4 ? (u4 || new t4.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                attributesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 24);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                inputArgCounts(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 26);
                  return u4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + u4) + i5 * 4) : 0;
                }
                inputArgCountsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 26);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                inputArgCountsArray() {
                  let i5 = this.bb.__offset(this.bb_pos, 26);
                  return i5 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + i5), this.bb.__vector_len(this.bb_pos + i5)) : null;
                }
                implicitInputs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 28);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                implicitInputsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 28);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startNode(i5) {
                  i5.startObject(13);
                }
                static addName(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addDocString(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static addDomain(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static addSinceVersion(i5, u4) {
                  i5.addFieldInt32(3, u4, 0);
                }
                static addIndex(i5, u4) {
                  i5.addFieldInt32(4, u4, 0);
                }
                static addOpType(i5, u4) {
                  i5.addFieldOffset(5, u4, 0);
                }
                static addType(i5, u4) {
                  i5.addFieldInt32(6, u4, 0);
                }
                static addExecutionProviderType(i5, u4) {
                  i5.addFieldOffset(7, u4, 0);
                }
                static addInputs(i5, u4) {
                  i5.addFieldOffset(8, u4, 0);
                }
                static createInputsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startInputsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addOutputs(i5, u4) {
                  i5.addFieldOffset(9, u4, 0);
                }
                static createOutputsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startOutputsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addAttributes(i5, u4) {
                  i5.addFieldOffset(10, u4, 0);
                }
                static createAttributesVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startAttributesVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addInputArgCounts(i5, u4) {
                  i5.addFieldOffset(11, u4, 0);
                }
                static createInputArgCountsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt32(u4[l4]);
                  return i5.endVector();
                }
                static startInputArgCountsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addImplicitInputs(i5, u4) {
                  i5.addFieldOffset(12, u4, 0);
                }
                static createImplicitInputsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startImplicitInputsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static endNode(i5) {
                  return i5.endObject();
                }
                static createNode(i5, u4, l4, f3, p4, d4, T3, v5, w3, I3, L3, F4, C3, Y5) {
                  return r4.startNode(i5), r4.addName(i5, u4), r4.addDocString(i5, l4), r4.addDomain(i5, f3), r4.addSinceVersion(i5, p4), r4.addIndex(i5, d4), r4.addOpType(i5, T3), r4.addType(i5, v5), r4.addExecutionProviderType(i5, w3), r4.addInputs(i5, I3), r4.addOutputs(i5, L3), r4.addAttributes(i5, F4), r4.addInputArgCounts(i5, C3), r4.addImplicitInputs(i5, Y5), r4.endNode(i5);
                }
              }
              n4.Node = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsValueInfo(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsValueInfo(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                name(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                docString(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                type(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? (i5 || new t4.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                static startValueInfo(i5) {
                  i5.startObject(3);
                }
                static addName(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addDocString(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static addType(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static endValueInfo(i5) {
                  return i5.endObject();
                }
                static createValueInfo(i5, u4, l4, f3) {
                  return r4.startValueInfo(i5), r4.addName(i5, u4), r4.addDocString(i5, l4), r4.addType(i5, f3), r4.endValueInfo(i5);
                }
              }
              n4.ValueInfo = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsTypeInfo(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsTypeInfo(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                denotation(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                valueType() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.readUint8(this.bb_pos + i5) : 0;
                }
                value(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? this.bb.__union(i5, this.bb_pos + u4) : null;
                }
                static startTypeInfo(i5) {
                  i5.startObject(3);
                }
                static addDenotation(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addValueType(i5, u4) {
                  i5.addFieldInt8(1, u4, 0);
                }
                static addValue(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static endTypeInfo(i5) {
                  return i5.endObject();
                }
                static createTypeInfo(i5, u4, l4, f3) {
                  return r4.startTypeInfo(i5), r4.addDenotation(i5, u4), r4.addValueType(i5, l4), r4.addValue(i5, f3), r4.endTypeInfo(i5);
                }
              }
              n4.TypeInfo = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsOperatorSetId(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsOperatorSetId(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                domain(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                version() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.readInt64(this.bb_pos + i5) : this.bb.createLong(0, 0);
                }
                static startOperatorSetId(i5) {
                  i5.startObject(2);
                }
                static addDomain(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addVersion(i5, u4) {
                  i5.addFieldInt64(1, u4, i5.createLong(0, 0));
                }
                static endOperatorSetId(i5) {
                  return i5.endObject();
                }
                static createOperatorSetId(i5, u4, l4) {
                  return r4.startOperatorSetId(i5), r4.addDomain(i5, u4), r4.addVersion(i5, l4), r4.endOperatorSetId(i5);
                }
              }
              n4.OperatorSetId = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsTensor(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsTensor(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                name(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                docString(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                dims(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u4) + i5 * 8) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 8);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                dataType() {
                  let i5 = this.bb.__offset(this.bb_pos, 10);
                  return i5 ? this.bb.readInt32(this.bb_pos + i5) : 0;
                }
                rawData(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 12);
                  return u4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + u4) + i5) : 0;
                }
                rawDataLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 12);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                rawDataArray() {
                  let i5 = this.bb.__offset(this.bb_pos, 12);
                  return i5 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + i5), this.bb.__vector_len(this.bb_pos + i5)) : null;
                }
                stringData(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 14);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                stringDataLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 14);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startTensor(i5) {
                  i5.startObject(6);
                }
                static addName(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addDocString(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static addDims(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static createDimsVector(i5, u4) {
                  i5.startVector(8, u4.length, 8);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt64(u4[l4]);
                  return i5.endVector();
                }
                static startDimsVector(i5, u4) {
                  i5.startVector(8, u4, 8);
                }
                static addDataType(i5, u4) {
                  i5.addFieldInt32(3, u4, 0);
                }
                static addRawData(i5, u4) {
                  i5.addFieldOffset(4, u4, 0);
                }
                static createRawDataVector(i5, u4) {
                  i5.startVector(1, u4.length, 1);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt8(u4[l4]);
                  return i5.endVector();
                }
                static startRawDataVector(i5, u4) {
                  i5.startVector(1, u4, 1);
                }
                static addStringData(i5, u4) {
                  i5.addFieldOffset(5, u4, 0);
                }
                static createStringDataVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startStringDataVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static endTensor(i5) {
                  return i5.endObject();
                }
                static createTensor(i5, u4, l4, f3, p4, d4, T3) {
                  return r4.startTensor(i5), r4.addName(i5, u4), r4.addDocString(i5, l4), r4.addDims(i5, f3), r4.addDataType(i5, p4), r4.addRawData(i5, d4), r4.addStringData(i5, T3), r4.endTensor(i5);
                }
              }
              n4.Tensor = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsSparseTensor(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsSparseTensor(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                values(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? (i5 || new t4.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                indices(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? (i5 || new t4.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                dims(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u4) + i5 * 8) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 8);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startSparseTensor(i5) {
                  i5.startObject(3);
                }
                static addValues(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addIndices(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static addDims(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static createDimsVector(i5, u4) {
                  i5.startVector(8, u4.length, 8);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt64(u4[l4]);
                  return i5.endVector();
                }
                static startDimsVector(i5, u4) {
                  i5.startVector(8, u4, 8);
                }
                static endSparseTensor(i5) {
                  return i5.endObject();
                }
                static createSparseTensor(i5, u4, l4, f3) {
                  return r4.startSparseTensor(i5), r4.addValues(i5, u4), r4.addIndices(i5, l4), r4.addDims(i5, f3), r4.endSparseTensor(i5);
                }
              }
              n4.SparseTensor = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsAttribute(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsAttribute(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                name(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                docString(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                type() {
                  let i5 = this.bb.__offset(this.bb_pos, 8);
                  return i5 ? this.bb.readInt32(this.bb_pos + i5) : 0;
                }
                f() {
                  let i5 = this.bb.__offset(this.bb_pos, 10);
                  return i5 ? this.bb.readFloat32(this.bb_pos + i5) : 0;
                }
                i() {
                  let i5 = this.bb.__offset(this.bb_pos, 12);
                  return i5 ? this.bb.readInt64(this.bb_pos + i5) : this.bb.createLong(0, 0);
                }
                s(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 14);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                t(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 16);
                  return u4 ? (i5 || new t4.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                g(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 18);
                  return u4 ? (i5 || new t4.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                floats(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 20);
                  return u4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + u4) + i5 * 4) : 0;
                }
                floatsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 20);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                floatsArray() {
                  let i5 = this.bb.__offset(this.bb_pos, 20);
                  return i5 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + i5), this.bb.__vector_len(this.bb_pos + i5)) : null;
                }
                ints(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 22);
                  return u4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + u4) + i5 * 8) : this.bb.createLong(0, 0);
                }
                intsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 22);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                strings(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 24);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                stringsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 24);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                tensors(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 26);
                  return l4 ? (u4 || new t4.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                tensorsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 26);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                graphs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 28);
                  return l4 ? (u4 || new t4.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                graphsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 28);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startAttribute(i5) {
                  i5.startObject(13);
                }
                static addName(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addDocString(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static addType(i5, u4) {
                  i5.addFieldInt32(2, u4, 0);
                }
                static addF(i5, u4) {
                  i5.addFieldFloat32(3, u4, 0);
                }
                static addI(i5, u4) {
                  i5.addFieldInt64(4, u4, i5.createLong(0, 0));
                }
                static addS(i5, u4) {
                  i5.addFieldOffset(5, u4, 0);
                }
                static addT(i5, u4) {
                  i5.addFieldOffset(6, u4, 0);
                }
                static addG(i5, u4) {
                  i5.addFieldOffset(7, u4, 0);
                }
                static addFloats(i5, u4) {
                  i5.addFieldOffset(8, u4, 0);
                }
                static createFloatsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addFloat32(u4[l4]);
                  return i5.endVector();
                }
                static startFloatsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addInts(i5, u4) {
                  i5.addFieldOffset(9, u4, 0);
                }
                static createIntsVector(i5, u4) {
                  i5.startVector(8, u4.length, 8);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt64(u4[l4]);
                  return i5.endVector();
                }
                static startIntsVector(i5, u4) {
                  i5.startVector(8, u4, 8);
                }
                static addStrings(i5, u4) {
                  i5.addFieldOffset(10, u4, 0);
                }
                static createStringsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startStringsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addTensors(i5, u4) {
                  i5.addFieldOffset(11, u4, 0);
                }
                static createTensorsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startTensorsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addGraphs(i5, u4) {
                  i5.addFieldOffset(12, u4, 0);
                }
                static createGraphsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startGraphsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static endAttribute(i5) {
                  return i5.endObject();
                }
                static createAttribute(i5, u4, l4, f3, p4, d4, T3, v5, w3, I3, L3, F4, C3, Y5) {
                  return r4.startAttribute(i5), r4.addName(i5, u4), r4.addDocString(i5, l4), r4.addType(i5, f3), r4.addF(i5, p4), r4.addI(i5, d4), r4.addS(i5, T3), r4.addT(i5, v5), r4.addG(i5, w3), r4.addFloats(i5, I3), r4.addInts(i5, L3), r4.addStrings(i5, F4), r4.addTensors(i5, C3), r4.addGraphs(i5, Y5), r4.endAttribute(i5);
                }
              }
              n4.Attribute = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsGraph(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsGraph(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                initializers(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 4);
                  return l4 ? (u4 || new t4.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                initializersLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                nodeArgs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 6);
                  return l4 ? (u4 || new t4.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                nodeArgsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                nodes(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 8);
                  return l4 ? (u4 || new t4.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                nodesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 8);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                maxNodeIndex() {
                  let i5 = this.bb.__offset(this.bb_pos, 10);
                  return i5 ? this.bb.readUint32(this.bb_pos + i5) : 0;
                }
                nodeEdges(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 12);
                  return l4 ? (u4 || new t4.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                nodeEdgesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 12);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                inputs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 14);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                inputsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 14);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                outputs(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 16);
                  return l4 ? this.bb.__string(this.bb.__vector(this.bb_pos + l4) + i5 * 4, u4) : null;
                }
                outputsLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 16);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                sparseInitializers(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 18);
                  return l4 ? (u4 || new t4.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                sparseInitializersLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 18);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startGraph(i5) {
                  i5.startObject(8);
                }
                static addInitializers(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static createInitializersVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startInitializersVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addNodeArgs(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static createNodeArgsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startNodeArgsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addNodes(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static createNodesVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startNodesVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addMaxNodeIndex(i5, u4) {
                  i5.addFieldInt32(3, u4, 0);
                }
                static addNodeEdges(i5, u4) {
                  i5.addFieldOffset(4, u4, 0);
                }
                static createNodeEdgesVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startNodeEdgesVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addInputs(i5, u4) {
                  i5.addFieldOffset(5, u4, 0);
                }
                static createInputsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startInputsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addOutputs(i5, u4) {
                  i5.addFieldOffset(6, u4, 0);
                }
                static createOutputsVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startOutputsVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addSparseInitializers(i5, u4) {
                  i5.addFieldOffset(7, u4, 0);
                }
                static createSparseInitializersVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startSparseInitializersVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static endGraph(i5) {
                  return i5.endObject();
                }
                static createGraph(i5, u4, l4, f3, p4, d4, T3, v5, w3) {
                  return r4.startGraph(i5), r4.addInitializers(i5, u4), r4.addNodeArgs(i5, l4), r4.addNodes(i5, f3), r4.addMaxNodeIndex(i5, p4), r4.addNodeEdges(i5, d4), r4.addInputs(i5, T3), r4.addOutputs(i5, v5), r4.addSparseInitializers(i5, w3), r4.endGraph(i5);
                }
              }
              n4.Graph = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsModel(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsModel(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                irVersion() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.readInt64(this.bb_pos + i5) : this.bb.createLong(0, 0);
                }
                opsetImport(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 6);
                  return l4 ? (u4 || new t4.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                opsetImportLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                producerName(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                producerVersion(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 10);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                domain(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 12);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                modelVersion() {
                  let i5 = this.bb.__offset(this.bb_pos, 14);
                  return i5 ? this.bb.readInt64(this.bb_pos + i5) : this.bb.createLong(0, 0);
                }
                docString(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 16);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                graph(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 18);
                  return u4 ? (i5 || new t4.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                graphDocString(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 20);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                static startModel(i5) {
                  i5.startObject(9);
                }
                static addIrVersion(i5, u4) {
                  i5.addFieldInt64(0, u4, i5.createLong(0, 0));
                }
                static addOpsetImport(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static createOpsetImportVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startOpsetImportVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addProducerName(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static addProducerVersion(i5, u4) {
                  i5.addFieldOffset(3, u4, 0);
                }
                static addDomain(i5, u4) {
                  i5.addFieldOffset(4, u4, 0);
                }
                static addModelVersion(i5, u4) {
                  i5.addFieldInt64(5, u4, i5.createLong(0, 0));
                }
                static addDocString(i5, u4) {
                  i5.addFieldOffset(6, u4, 0);
                }
                static addGraph(i5, u4) {
                  i5.addFieldOffset(7, u4, 0);
                }
                static addGraphDocString(i5, u4) {
                  i5.addFieldOffset(8, u4, 0);
                }
                static endModel(i5) {
                  return i5.endObject();
                }
                static createModel(i5, u4, l4, f3, p4, d4, T3, v5, w3, I3) {
                  return r4.startModel(i5), r4.addIrVersion(i5, u4), r4.addOpsetImport(i5, l4), r4.addProducerName(i5, f3), r4.addProducerVersion(i5, p4), r4.addDomain(i5, d4), r4.addModelVersion(i5, T3), r4.addDocString(i5, v5), r4.addGraph(i5, w3), r4.addGraphDocString(i5, I3), r4.endModel(i5);
                }
              }
              n4.Model = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsKernelCreateInfos(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsKernelCreateInfos(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                nodeIndices(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + u4) + i5 * 4) : 0;
                }
                nodeIndicesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                nodeIndicesArray() {
                  let i5 = this.bb.__offset(this.bb_pos, 4);
                  return i5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + i5), this.bb.__vector_len(this.bb_pos + i5)) : null;
                }
                kernelDefHashes(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + u4) + i5 * 8) : this.bb.createLong(0, 0);
                }
                kernelDefHashesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startKernelCreateInfos(i5) {
                  i5.startObject(2);
                }
                static addNodeIndices(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static createNodeIndicesVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt32(u4[l4]);
                  return i5.endVector();
                }
                static startNodeIndicesVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static addKernelDefHashes(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static createKernelDefHashesVector(i5, u4) {
                  i5.startVector(8, u4.length, 8);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addInt64(u4[l4]);
                  return i5.endVector();
                }
                static startKernelDefHashesVector(i5, u4) {
                  i5.startVector(8, u4, 8);
                }
                static endKernelCreateInfos(i5) {
                  return i5.endObject();
                }
                static createKernelCreateInfos(i5, u4, l4) {
                  return r4.startKernelCreateInfos(i5), r4.addNodeIndices(i5, u4), r4.addKernelDefHashes(i5, l4), r4.endKernelCreateInfos(i5);
                }
              }
              n4.KernelCreateInfos = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsSubGraphSessionState(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsSubGraphSessionState(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                graphId(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                sessionState(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? (i5 || new t4.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                static startSubGraphSessionState(i5) {
                  i5.startObject(2);
                }
                static addGraphId(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addSessionState(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static endSubGraphSessionState(i5) {
                  let u4 = i5.endObject();
                  return i5.requiredField(u4, 4), u4;
                }
                static createSubGraphSessionState(i5, u4, l4) {
                  return r4.startSubGraphSessionState(i5), r4.addGraphId(i5, u4), r4.addSessionState(i5, l4), r4.endSubGraphSessionState(i5);
                }
              }
              n4.SubGraphSessionState = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsSessionState(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsSessionState(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                kernels(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? (i5 || new t4.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                subGraphSessionStates(i5, u4) {
                  let l4 = this.bb.__offset(this.bb_pos, 6);
                  return l4 ? (u4 || new t4.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + l4) + i5 * 4), this.bb) : null;
                }
                subGraphSessionStatesLength() {
                  let i5 = this.bb.__offset(this.bb_pos, 6);
                  return i5 ? this.bb.__vector_len(this.bb_pos + i5) : 0;
                }
                static startSessionState(i5) {
                  i5.startObject(2);
                }
                static addKernels(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addSubGraphSessionStates(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static createSubGraphSessionStatesVector(i5, u4) {
                  i5.startVector(4, u4.length, 4);
                  for (let l4 = u4.length - 1; l4 >= 0; l4--)
                    i5.addOffset(u4[l4]);
                  return i5.endVector();
                }
                static startSubGraphSessionStatesVector(i5, u4) {
                  i5.startVector(4, u4, 4);
                }
                static endSessionState(i5) {
                  return i5.endObject();
                }
                static createSessionState(i5, u4, l4) {
                  return r4.startSessionState(i5), r4.addKernels(i5, u4), r4.addSubGraphSessionStates(i5, l4), r4.endSessionState(i5);
                }
              }
              n4.SessionState = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
        ((t4) => {
          let a4;
          ((e4) => {
            let o4;
            ((n4) => {
              class r4 {
                constructor() {
                  this.bb = null;
                  this.bb_pos = 0;
                }
                __init(i5, u4) {
                  return this.bb_pos = i5, this.bb = u4, this;
                }
                static getRootAsInferenceSession(i5, u4) {
                  return (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static getSizePrefixedRootAsInferenceSession(i5, u4) {
                  return i5.setPosition(i5.position() + O.SIZE_PREFIX_LENGTH), (u4 || new r4()).__init(i5.readInt32(i5.position()) + i5.position(), i5);
                }
                static bufferHasIdentifier(i5) {
                  return i5.__has_identifier("ORTM");
                }
                ortVersion(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 4);
                  return u4 ? this.bb.__string(this.bb_pos + u4, i5) : null;
                }
                model(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 6);
                  return u4 ? (i5 || new t4.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                sessionState(i5) {
                  let u4 = this.bb.__offset(this.bb_pos, 8);
                  return u4 ? (i5 || new t4.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + u4), this.bb) : null;
                }
                static startInferenceSession(i5) {
                  i5.startObject(3);
                }
                static addOrtVersion(i5, u4) {
                  i5.addFieldOffset(0, u4, 0);
                }
                static addModel(i5, u4) {
                  i5.addFieldOffset(1, u4, 0);
                }
                static addSessionState(i5, u4) {
                  i5.addFieldOffset(2, u4, 0);
                }
                static endInferenceSession(i5) {
                  return i5.endObject();
                }
                static finishInferenceSessionBuffer(i5, u4) {
                  i5.finish(u4, "ORTM");
                }
                static finishSizePrefixedInferenceSessionBuffer(i5, u4) {
                  i5.finish(u4, "ORTM", true);
                }
                static createInferenceSession(i5, u4, l4, f3) {
                  return r4.startInferenceSession(i5), r4.addOrtVersion(i5, u4), r4.addModel(i5, l4), r4.addSessionState(i5, f3), r4.endInferenceSession(i5);
                }
              }
              n4.InferenceSession = r4;
            })(o4 = e4.fbs ||= {});
          })(a4 = t4.experimental ||= {});
        })(W ||= {});
      });
      var Gs = me((Sy, Ms2) => {
        "use strict";
        Ms2.exports = Rd;
        function Rd(a4, t4) {
          for (var o4 = new Array(arguments.length - 1), e4 = 0, r4 = 2, n4 = true; r4 < arguments.length; )
            o4[e4++] = arguments[r4++];
          return new Promise(function(i5, u4) {
            o4[e4] = function(f3) {
              if (n4)
                if (n4 = false, f3)
                  u4(f3);
                else {
                  for (var p4 = new Array(arguments.length - 1), d4 = 0; d4 < p4.length; )
                    p4[d4++] = arguments[d4];
                  i5.apply(null, p4);
                }
            };
            try {
              a4.apply(t4 || null, o4);
            } catch (l4) {
              n4 && (n4 = false, u4(l4));
            }
          });
        }
      });
      var Ws = me((Vs3) => {
        "use strict";
        var Hn3 = Vs3;
        Hn3.length = function(t4) {
          var o4 = t4.length;
          if (!o4)
            return 0;
          for (var e4 = 0; --o4 % 4 > 1 && t4.charAt(o4) === "="; )
            ++e4;
          return Math.ceil(t4.length * 3) / 4 - e4;
        };
        var Cr3 = new Array(64), zs3 = new Array(123);
        for (vt4 = 0; vt4 < 64; )
          zs3[Cr3[vt4] = vt4 < 26 ? vt4 + 65 : vt4 < 52 ? vt4 + 71 : vt4 < 62 ? vt4 - 4 : vt4 - 59 | 43] = vt4++;
        var vt4;
        Hn3.encode = function(t4, o4, e4) {
          for (var r4 = null, n4 = [], s4 = 0, i5 = 0, u4; o4 < e4; ) {
            var l4 = t4[o4++];
            switch (i5) {
              case 0:
                n4[s4++] = Cr3[l4 >> 2], u4 = (l4 & 3) << 4, i5 = 1;
                break;
              case 1:
                n4[s4++] = Cr3[u4 | l4 >> 4], u4 = (l4 & 15) << 2, i5 = 2;
                break;
              case 2:
                n4[s4++] = Cr3[u4 | l4 >> 6], n4[s4++] = Cr3[l4 & 63], i5 = 0;
                break;
            }
            s4 > 8191 && ((r4 || (r4 = [])).push(String.fromCharCode.apply(String, n4)), s4 = 0);
          }
          return i5 && (n4[s4++] = Cr3[u4], n4[s4++] = 61, i5 === 1 && (n4[s4++] = 61)), r4 ? (s4 && r4.push(String.fromCharCode.apply(String, n4.slice(0, s4))), r4.join("")) : String.fromCharCode.apply(String, n4.slice(0, s4));
        };
        var Us2 = "invalid encoding";
        Hn3.decode = function(t4, o4, e4) {
          for (var r4 = e4, n4 = 0, s4, i5 = 0; i5 < t4.length; ) {
            var u4 = t4.charCodeAt(i5++);
            if (u4 === 61 && n4 > 1)
              break;
            if ((u4 = zs3[u4]) === void 0)
              throw Error(Us2);
            switch (n4) {
              case 0:
                s4 = u4, n4 = 1;
                break;
              case 1:
                o4[e4++] = s4 << 2 | (u4 & 48) >> 4, s4 = u4, n4 = 2;
                break;
              case 2:
                o4[e4++] = (s4 & 15) << 4 | (u4 & 60) >> 2, s4 = u4, n4 = 3;
                break;
              case 3:
                o4[e4++] = (s4 & 3) << 6 | u4, n4 = 0;
                break;
            }
          }
          if (n4 === 1)
            throw Error(Us2);
          return e4 - r4;
        };
        Hn3.test = function(t4) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t4);
        };
      });
      var qs = me((Py, Hs3) => {
        "use strict";
        Hs3.exports = qn4;
        function qn4() {
          this._listeners = {};
        }
        qn4.prototype.on = function(t4, o4, e4) {
          return (this._listeners[t4] || (this._listeners[t4] = [])).push({ fn: o4, ctx: e4 || this }), this;
        };
        qn4.prototype.off = function(t4, o4) {
          if (t4 === void 0)
            this._listeners = {};
          else if (o4 === void 0)
            this._listeners[t4] = [];
          else
            for (var e4 = this._listeners[t4], r4 = 0; r4 < e4.length; )
              e4[r4].fn === o4 ? e4.splice(r4, 1) : ++r4;
          return this;
        };
        qn4.prototype.emit = function(t4) {
          var o4 = this._listeners[t4];
          if (o4) {
            for (var e4 = [], r4 = 1; r4 < arguments.length; )
              e4.push(arguments[r4++]);
            for (r4 = 0; r4 < o4.length; )
              o4[r4].fn.apply(o4[r4++].ctx, e4);
          }
          return this;
        };
      });
      var Qs = me((Ey, Zs2) => {
        "use strict";
        Zs2.exports = js2(js2);
        function js2(a4) {
          return typeof Float32Array < "u" ? function() {
            var t4 = new Float32Array([-0]), o4 = new Uint8Array(t4.buffer), e4 = o4[3] === 128;
            function r4(u4, l4, f3) {
              t4[0] = u4, l4[f3] = o4[0], l4[f3 + 1] = o4[1], l4[f3 + 2] = o4[2], l4[f3 + 3] = o4[3];
            }
            function n4(u4, l4, f3) {
              t4[0] = u4, l4[f3] = o4[3], l4[f3 + 1] = o4[2], l4[f3 + 2] = o4[1], l4[f3 + 3] = o4[0];
            }
            a4.writeFloatLE = e4 ? r4 : n4, a4.writeFloatBE = e4 ? n4 : r4;
            function s4(u4, l4) {
              return o4[0] = u4[l4], o4[1] = u4[l4 + 1], o4[2] = u4[l4 + 2], o4[3] = u4[l4 + 3], t4[0];
            }
            function i5(u4, l4) {
              return o4[3] = u4[l4], o4[2] = u4[l4 + 1], o4[1] = u4[l4 + 2], o4[0] = u4[l4 + 3], t4[0];
            }
            a4.readFloatLE = e4 ? s4 : i5, a4.readFloatBE = e4 ? i5 : s4;
          }() : function() {
            function t4(e4, r4, n4, s4) {
              var i5 = r4 < 0 ? 1 : 0;
              if (i5 && (r4 = -r4), r4 === 0)
                e4(1 / r4 > 0 ? 0 : 2147483648, n4, s4);
              else if (isNaN(r4))
                e4(2143289344, n4, s4);
              else if (r4 > 34028234663852886e22)
                e4((i5 << 31 | 2139095040) >>> 0, n4, s4);
              else if (r4 < 11754943508222875e-54)
                e4((i5 << 31 | Math.round(r4 / 1401298464324817e-60)) >>> 0, n4, s4);
              else {
                var u4 = Math.floor(Math.log(r4) / Math.LN2), l4 = Math.round(r4 * Math.pow(2, -u4) * 8388608) & 8388607;
                e4((i5 << 31 | u4 + 127 << 23 | l4) >>> 0, n4, s4);
              }
            }
            a4.writeFloatLE = t4.bind(null, Ys3), a4.writeFloatBE = t4.bind(null, Xs2);
            function o4(e4, r4, n4) {
              var s4 = e4(r4, n4), i5 = (s4 >> 31) * 2 + 1, u4 = s4 >>> 23 & 255, l4 = s4 & 8388607;
              return u4 === 255 ? l4 ? NaN : i5 * (1 / 0) : u4 === 0 ? i5 * 1401298464324817e-60 * l4 : i5 * Math.pow(2, u4 - 150) * (l4 + 8388608);
            }
            a4.readFloatLE = o4.bind(null, Ks3), a4.readFloatBE = o4.bind(null, Js3);
          }(), typeof Float64Array < "u" ? function() {
            var t4 = new Float64Array([-0]), o4 = new Uint8Array(t4.buffer), e4 = o4[7] === 128;
            function r4(u4, l4, f3) {
              t4[0] = u4, l4[f3] = o4[0], l4[f3 + 1] = o4[1], l4[f3 + 2] = o4[2], l4[f3 + 3] = o4[3], l4[f3 + 4] = o4[4], l4[f3 + 5] = o4[5], l4[f3 + 6] = o4[6], l4[f3 + 7] = o4[7];
            }
            function n4(u4, l4, f3) {
              t4[0] = u4, l4[f3] = o4[7], l4[f3 + 1] = o4[6], l4[f3 + 2] = o4[5], l4[f3 + 3] = o4[4], l4[f3 + 4] = o4[3], l4[f3 + 5] = o4[2], l4[f3 + 6] = o4[1], l4[f3 + 7] = o4[0];
            }
            a4.writeDoubleLE = e4 ? r4 : n4, a4.writeDoubleBE = e4 ? n4 : r4;
            function s4(u4, l4) {
              return o4[0] = u4[l4], o4[1] = u4[l4 + 1], o4[2] = u4[l4 + 2], o4[3] = u4[l4 + 3], o4[4] = u4[l4 + 4], o4[5] = u4[l4 + 5], o4[6] = u4[l4 + 6], o4[7] = u4[l4 + 7], t4[0];
            }
            function i5(u4, l4) {
              return o4[7] = u4[l4], o4[6] = u4[l4 + 1], o4[5] = u4[l4 + 2], o4[4] = u4[l4 + 3], o4[3] = u4[l4 + 4], o4[2] = u4[l4 + 5], o4[1] = u4[l4 + 6], o4[0] = u4[l4 + 7], t4[0];
            }
            a4.readDoubleLE = e4 ? s4 : i5, a4.readDoubleBE = e4 ? i5 : s4;
          }() : function() {
            function t4(e4, r4, n4, s4, i5, u4) {
              var l4 = s4 < 0 ? 1 : 0;
              if (l4 && (s4 = -s4), s4 === 0)
                e4(0, i5, u4 + r4), e4(1 / s4 > 0 ? 0 : 2147483648, i5, u4 + n4);
              else if (isNaN(s4))
                e4(0, i5, u4 + r4), e4(2146959360, i5, u4 + n4);
              else if (s4 > 17976931348623157e292)
                e4(0, i5, u4 + r4), e4((l4 << 31 | 2146435072) >>> 0, i5, u4 + n4);
              else {
                var f3;
                if (s4 < 22250738585072014e-324)
                  f3 = s4 / 5e-324, e4(f3 >>> 0, i5, u4 + r4), e4((l4 << 31 | f3 / 4294967296) >>> 0, i5, u4 + n4);
                else {
                  var p4 = Math.floor(Math.log(s4) / Math.LN2);
                  p4 === 1024 && (p4 = 1023), f3 = s4 * Math.pow(2, -p4), e4(f3 * 4503599627370496 >>> 0, i5, u4 + r4), e4((l4 << 31 | p4 + 1023 << 20 | f3 * 1048576 & 1048575) >>> 0, i5, u4 + n4);
                }
              }
            }
            a4.writeDoubleLE = t4.bind(null, Ys3, 0, 4), a4.writeDoubleBE = t4.bind(null, Xs2, 4, 0);
            function o4(e4, r4, n4, s4, i5) {
              var u4 = e4(s4, i5 + r4), l4 = e4(s4, i5 + n4), f3 = (l4 >> 31) * 2 + 1, p4 = l4 >>> 20 & 2047, d4 = 4294967296 * (l4 & 1048575) + u4;
              return p4 === 2047 ? d4 ? NaN : f3 * (1 / 0) : p4 === 0 ? f3 * 5e-324 * d4 : f3 * Math.pow(2, p4 - 1075) * (d4 + 4503599627370496);
            }
            a4.readDoubleLE = o4.bind(null, Ks3, 0, 4), a4.readDoubleBE = o4.bind(null, Js3, 4, 0);
          }(), a4;
        }
        function Ys3(a4, t4, o4) {
          t4[o4] = a4 & 255, t4[o4 + 1] = a4 >>> 8 & 255, t4[o4 + 2] = a4 >>> 16 & 255, t4[o4 + 3] = a4 >>> 24;
        }
        function Xs2(a4, t4, o4) {
          t4[o4] = a4 >>> 24, t4[o4 + 1] = a4 >>> 16 & 255, t4[o4 + 2] = a4 >>> 8 & 255, t4[o4 + 3] = a4 & 255;
        }
        function Ks3(a4, t4) {
          return (a4[t4] | a4[t4 + 1] << 8 | a4[t4 + 2] << 16 | a4[t4 + 3] << 24) >>> 0;
        }
        function Js3(a4, t4) {
          return (a4[t4] << 24 | a4[t4 + 1] << 16 | a4[t4 + 2] << 8 | a4[t4 + 3]) >>> 0;
        }
      });
      var eu = me((exports, module) => {
        "use strict";
        module.exports = inquire;
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
              return mod;
          } catch (a4) {
          }
          return null;
        }
      });
      var ru = me((tu2) => {
        "use strict";
        var ri3 = tu2;
        ri3.length = function(t4) {
          for (var o4 = 0, e4 = 0, r4 = 0; r4 < t4.length; ++r4)
            e4 = t4.charCodeAt(r4), e4 < 128 ? o4 += 1 : e4 < 2048 ? o4 += 2 : (e4 & 64512) === 55296 && (t4.charCodeAt(r4 + 1) & 64512) === 56320 ? (++r4, o4 += 4) : o4 += 3;
          return o4;
        };
        ri3.read = function(t4, o4, e4) {
          var r4 = e4 - o4;
          if (r4 < 1)
            return "";
          for (var n4 = null, s4 = [], i5 = 0, u4; o4 < e4; )
            u4 = t4[o4++], u4 < 128 ? s4[i5++] = u4 : u4 > 191 && u4 < 224 ? s4[i5++] = (u4 & 31) << 6 | t4[o4++] & 63 : u4 > 239 && u4 < 365 ? (u4 = ((u4 & 7) << 18 | (t4[o4++] & 63) << 12 | (t4[o4++] & 63) << 6 | t4[o4++] & 63) - 65536, s4[i5++] = 55296 + (u4 >> 10), s4[i5++] = 56320 + (u4 & 1023)) : s4[i5++] = (u4 & 15) << 12 | (t4[o4++] & 63) << 6 | t4[o4++] & 63, i5 > 8191 && ((n4 || (n4 = [])).push(String.fromCharCode.apply(String, s4)), i5 = 0);
          return n4 ? (i5 && n4.push(String.fromCharCode.apply(String, s4.slice(0, i5))), n4.join("")) : String.fromCharCode.apply(String, s4.slice(0, i5));
        };
        ri3.write = function(t4, o4, e4) {
          for (var r4 = e4, n4, s4, i5 = 0; i5 < t4.length; ++i5)
            n4 = t4.charCodeAt(i5), n4 < 128 ? o4[e4++] = n4 : n4 < 2048 ? (o4[e4++] = n4 >> 6 | 192, o4[e4++] = n4 & 63 | 128) : (n4 & 64512) === 55296 && ((s4 = t4.charCodeAt(i5 + 1)) & 64512) === 56320 ? (n4 = 65536 + ((n4 & 1023) << 10) + (s4 & 1023), ++i5, o4[e4++] = n4 >> 18 | 240, o4[e4++] = n4 >> 12 & 63 | 128, o4[e4++] = n4 >> 6 & 63 | 128, o4[e4++] = n4 & 63 | 128) : (o4[e4++] = n4 >> 12 | 224, o4[e4++] = n4 >> 6 & 63 | 128, o4[e4++] = n4 & 63 | 128);
          return e4 - r4;
        };
      });
      var ou = me((Ly, nu2) => {
        "use strict";
        nu2.exports = Md;
        function Md(a4, t4, o4) {
          var e4 = o4 || 8192, r4 = e4 >>> 1, n4 = null, s4 = e4;
          return function(u4) {
            if (u4 < 1 || u4 > r4)
              return a4(u4);
            s4 + u4 > e4 && (n4 = a4(e4), s4 = 0);
            var l4 = t4.call(n4, s4, s4 += u4);
            return s4 & 7 && (s4 = (s4 | 7) + 1), l4;
          };
        }
      });
      var au = me((Fy, iu2) => {
        "use strict";
        iu2.exports = Me4;
        var on4 = Zt();
        function Me4(a4, t4) {
          this.lo = a4 >>> 0, this.hi = t4 >>> 0;
        }
        var pr3 = Me4.zero = new Me4(0, 0);
        pr3.toNumber = function() {
          return 0;
        };
        pr3.zzEncode = pr3.zzDecode = function() {
          return this;
        };
        pr3.length = function() {
          return 1;
        };
        var Gd2 = Me4.zeroHash = "\0\0\0\0\0\0\0\0";
        Me4.fromNumber = function(t4) {
          if (t4 === 0)
            return pr3;
          var o4 = t4 < 0;
          o4 && (t4 = -t4);
          var e4 = t4 >>> 0, r4 = (t4 - e4) / 4294967296 >>> 0;
          return o4 && (r4 = ~r4 >>> 0, e4 = ~e4 >>> 0, ++e4 > 4294967295 && (e4 = 0, ++r4 > 4294967295 && (r4 = 0))), new Me4(e4, r4);
        };
        Me4.from = function(t4) {
          if (typeof t4 == "number")
            return Me4.fromNumber(t4);
          if (on4.isString(t4))
            if (on4.Long)
              t4 = on4.Long.fromString(t4);
            else
              return Me4.fromNumber(parseInt(t4, 10));
          return t4.low || t4.high ? new Me4(t4.low >>> 0, t4.high >>> 0) : pr3;
        };
        Me4.prototype.toNumber = function(t4) {
          if (!t4 && this.hi >>> 31) {
            var o4 = ~this.lo + 1 >>> 0, e4 = ~this.hi >>> 0;
            return o4 || (e4 = e4 + 1 >>> 0), -(o4 + e4 * 4294967296);
          }
          return this.lo + this.hi * 4294967296;
        };
        Me4.prototype.toLong = function(t4) {
          return on4.Long ? new on4.Long(this.lo | 0, this.hi | 0, !!t4) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!t4 };
        };
        var Jt4 = String.prototype.charCodeAt;
        Me4.fromHash = function(t4) {
          return t4 === Gd2 ? pr3 : new Me4((Jt4.call(t4, 0) | Jt4.call(t4, 1) << 8 | Jt4.call(t4, 2) << 16 | Jt4.call(t4, 3) << 24) >>> 0, (Jt4.call(t4, 4) | Jt4.call(t4, 5) << 8 | Jt4.call(t4, 6) << 16 | Jt4.call(t4, 7) << 24) >>> 0);
        };
        Me4.prototype.toHash = function() {
          return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        };
        Me4.prototype.zzEncode = function() {
          var t4 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t4) >>> 0, this.lo = (this.lo << 1 ^ t4) >>> 0, this;
        };
        Me4.prototype.zzDecode = function() {
          var t4 = -(this.lo & 1);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t4) >>> 0, this.hi = (this.hi >>> 1 ^ t4) >>> 0, this;
        };
        Me4.prototype.length = function() {
          var t4 = this.lo, o4 = (this.lo >>> 28 | this.hi << 4) >>> 0, e4 = this.hi >>> 24;
          return e4 === 0 ? o4 === 0 ? t4 < 16384 ? t4 < 128 ? 1 : 2 : t4 < 2097152 ? 3 : 4 : o4 < 16384 ? o4 < 128 ? 5 : 6 : o4 < 2097152 ? 7 : 8 : e4 < 128 ? 9 : 10;
        };
      });
      var Zt = me((ni3) => {
        "use strict";
        var H4 = ni3;
        H4.asPromise = Gs();
        H4.base64 = Ws();
        H4.EventEmitter = qs();
        H4.float = Qs();
        H4.inquire = eu();
        H4.utf8 = ru();
        H4.pool = ou();
        H4.LongBits = au();
        H4.isNode = !!(typeof global < "u" && global && global.process && global.process.versions && global.process.versions.node);
        H4.global = H4.isNode && global || typeof window < "u" && window || typeof self < "u" && self || ni3;
        H4.emptyArray = Object.freeze ? Object.freeze([]) : [];
        H4.emptyObject = Object.freeze ? Object.freeze({}) : {};
        H4.isInteger = Number.isInteger || function(t4) {
          return typeof t4 == "number" && isFinite(t4) && Math.floor(t4) === t4;
        };
        H4.isString = function(t4) {
          return typeof t4 == "string" || t4 instanceof String;
        };
        H4.isObject = function(t4) {
          return t4 && typeof t4 == "object";
        };
        H4.isset = H4.isSet = function(t4, o4) {
          var e4 = t4[o4];
          return e4 != null && t4.hasOwnProperty(o4) ? typeof e4 != "object" || (Array.isArray(e4) ? e4.length : Object.keys(e4).length) > 0 : false;
        };
        H4.Buffer = function() {
          try {
            var a4 = H4.inquire("buffer").Buffer;
            return a4.prototype.utf8Write ? a4 : null;
          } catch {
            return null;
          }
        }();
        H4._Buffer_from = null;
        H4._Buffer_allocUnsafe = null;
        H4.newBuffer = function(t4) {
          return typeof t4 == "number" ? H4.Buffer ? H4._Buffer_allocUnsafe(t4) : new H4.Array(t4) : H4.Buffer ? H4._Buffer_from(t4) : typeof Uint8Array > "u" ? t4 : new Uint8Array(t4);
        };
        H4.Array = typeof Uint8Array < "u" ? Uint8Array : Array;
        H4.Long = H4.global.dcodeIO && H4.global.dcodeIO.Long || H4.global.Long || H4.inquire("long");
        H4.key2Re = /^true|false|0|1$/;
        H4.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
        H4.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
        H4.longToHash = function(t4) {
          return t4 ? H4.LongBits.from(t4).toHash() : H4.LongBits.zeroHash;
        };
        H4.longFromHash = function(t4, o4) {
          var e4 = H4.LongBits.fromHash(t4);
          return H4.Long ? H4.Long.fromBits(e4.lo, e4.hi, o4) : e4.toNumber(!!o4);
        };
        function su2(a4, t4, o4) {
          for (var e4 = Object.keys(t4), r4 = 0; r4 < e4.length; ++r4)
            (a4[e4[r4]] === void 0 || !o4) && (a4[e4[r4]] = t4[e4[r4]]);
          return a4;
        }
        H4.merge = su2;
        H4.lcFirst = function(t4) {
          return t4.charAt(0).toLowerCase() + t4.substring(1);
        };
        function uu2(a4) {
          function t4(o4, e4) {
            if (!(this instanceof t4))
              return new t4(o4, e4);
            Object.defineProperty(this, "message", { get: function() {
              return o4;
            } }), Error.captureStackTrace ? Error.captureStackTrace(this, t4) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), e4 && su2(this, e4);
          }
          return t4.prototype = Object.create(Error.prototype, { constructor: { value: t4, writable: true, enumerable: false, configurable: true }, name: { get: function() {
            return a4;
          }, set: void 0, enumerable: false, configurable: true }, toString: { value: function() {
            return this.name + ": " + this.message;
          }, writable: true, enumerable: false, configurable: true } }), t4;
        }
        H4.newError = uu2;
        H4.ProtocolError = uu2("ProtocolError");
        H4.oneOfGetter = function(t4) {
          for (var o4 = {}, e4 = 0; e4 < t4.length; ++e4)
            o4[t4[e4]] = 1;
          return function() {
            for (var r4 = Object.keys(this), n4 = r4.length - 1; n4 > -1; --n4)
              if (o4[r4[n4]] === 1 && this[r4[n4]] !== void 0 && this[r4[n4]] !== null)
                return r4[n4];
          };
        };
        H4.oneOfSetter = function(t4) {
          return function(o4) {
            for (var e4 = 0; e4 < t4.length; ++e4)
              t4[e4] !== o4 && delete this[t4[e4]];
          };
        };
        H4.toJSONOptions = { longs: String, enums: String, bytes: String, json: true };
        H4._configure = function() {
          var a4 = H4.Buffer;
          if (!a4) {
            H4._Buffer_from = H4._Buffer_allocUnsafe = null;
            return;
          }
          H4._Buffer_from = a4.from !== Uint8Array.from && a4.from || function(o4, e4) {
            return new a4(o4, e4);
          }, H4._Buffer_allocUnsafe = a4.allocUnsafe || function(o4) {
            return new a4(o4);
          };
        };
      });
      var fi = me(($y, pu2) => {
        "use strict";
        pu2.exports = se3;
        var lt4 = Zt(), oi2, jn3 = lt4.LongBits, lu2 = lt4.base64, fu2 = lt4.utf8;
        function an4(a4, t4, o4) {
          this.fn = a4, this.len = t4, this.next = void 0, this.val = o4;
        }
        function ai2() {
        }
        function Ud2(a4) {
          this.head = a4.head, this.tail = a4.tail, this.len = a4.len, this.next = a4.states;
        }
        function se3() {
          this.len = 0, this.head = new an4(ai2, 0, 0), this.tail = this.head, this.states = null;
        }
        var cu2 = function() {
          return lt4.Buffer ? function() {
            return (se3.create = function() {
              return new oi2();
            })();
          } : function() {
            return new se3();
          };
        };
        se3.create = cu2();
        se3.alloc = function(t4) {
          return new lt4.Array(t4);
        };
        lt4.Array !== Array && (se3.alloc = lt4.pool(se3.alloc, lt4.Array.prototype.subarray));
        se3.prototype._push = function(t4, o4, e4) {
          return this.tail = this.tail.next = new an4(t4, o4, e4), this.len += o4, this;
        };
        function si3(a4, t4, o4) {
          t4[o4] = a4 & 255;
        }
        function zd2(a4, t4, o4) {
          for (; a4 > 127; )
            t4[o4++] = a4 & 127 | 128, a4 >>>= 7;
          t4[o4] = a4;
        }
        function ui3(a4, t4) {
          this.len = a4, this.next = void 0, this.val = t4;
        }
        ui3.prototype = Object.create(an4.prototype);
        ui3.prototype.fn = zd2;
        se3.prototype.uint32 = function(t4) {
          return this.len += (this.tail = this.tail.next = new ui3((t4 = t4 >>> 0) < 128 ? 1 : t4 < 16384 ? 2 : t4 < 2097152 ? 3 : t4 < 268435456 ? 4 : 5, t4)).len, this;
        };
        se3.prototype.int32 = function(t4) {
          return t4 < 0 ? this._push(li2, 10, jn3.fromNumber(t4)) : this.uint32(t4);
        };
        se3.prototype.sint32 = function(t4) {
          return this.uint32((t4 << 1 ^ t4 >> 31) >>> 0);
        };
        function li2(a4, t4, o4) {
          for (; a4.hi; )
            t4[o4++] = a4.lo & 127 | 128, a4.lo = (a4.lo >>> 7 | a4.hi << 25) >>> 0, a4.hi >>>= 7;
          for (; a4.lo > 127; )
            t4[o4++] = a4.lo & 127 | 128, a4.lo = a4.lo >>> 7;
          t4[o4++] = a4.lo;
        }
        se3.prototype.uint64 = function(t4) {
          var o4 = jn3.from(t4);
          return this._push(li2, o4.length(), o4);
        };
        se3.prototype.int64 = se3.prototype.uint64;
        se3.prototype.sint64 = function(t4) {
          var o4 = jn3.from(t4).zzEncode();
          return this._push(li2, o4.length(), o4);
        };
        se3.prototype.bool = function(t4) {
          return this._push(si3, 1, t4 ? 1 : 0);
        };
        function ii3(a4, t4, o4) {
          t4[o4] = a4 & 255, t4[o4 + 1] = a4 >>> 8 & 255, t4[o4 + 2] = a4 >>> 16 & 255, t4[o4 + 3] = a4 >>> 24;
        }
        se3.prototype.fixed32 = function(t4) {
          return this._push(ii3, 4, t4 >>> 0);
        };
        se3.prototype.sfixed32 = se3.prototype.fixed32;
        se3.prototype.fixed64 = function(t4) {
          var o4 = jn3.from(t4);
          return this._push(ii3, 4, o4.lo)._push(ii3, 4, o4.hi);
        };
        se3.prototype.sfixed64 = se3.prototype.fixed64;
        se3.prototype.float = function(t4) {
          return this._push(lt4.float.writeFloatLE, 4, t4);
        };
        se3.prototype.double = function(t4) {
          return this._push(lt4.float.writeDoubleLE, 8, t4);
        };
        var Vd2 = lt4.Array.prototype.set ? function(t4, o4, e4) {
          o4.set(t4, e4);
        } : function(t4, o4, e4) {
          for (var r4 = 0; r4 < t4.length; ++r4)
            o4[e4 + r4] = t4[r4];
        };
        se3.prototype.bytes = function(t4) {
          var o4 = t4.length >>> 0;
          if (!o4)
            return this._push(si3, 1, 0);
          if (lt4.isString(t4)) {
            var e4 = se3.alloc(o4 = lu2.length(t4));
            lu2.decode(t4, e4, 0), t4 = e4;
          }
          return this.uint32(o4)._push(Vd2, o4, t4);
        };
        se3.prototype.string = function(t4) {
          var o4 = fu2.length(t4);
          return o4 ? this.uint32(o4)._push(fu2.write, o4, t4) : this._push(si3, 1, 0);
        };
        se3.prototype.fork = function() {
          return this.states = new Ud2(this), this.head = this.tail = new an4(ai2, 0, 0), this.len = 0, this;
        };
        se3.prototype.reset = function() {
          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new an4(ai2, 0, 0), this.len = 0), this;
        };
        se3.prototype.ldelim = function() {
          var t4 = this.head, o4 = this.tail, e4 = this.len;
          return this.reset().uint32(e4), e4 && (this.tail.next = t4.next, this.tail = o4, this.len += e4), this;
        };
        se3.prototype.finish = function() {
          for (var t4 = this.head.next, o4 = this.constructor.alloc(this.len), e4 = 0; t4; )
            t4.fn(t4.val, o4, e4), e4 += t4.len, t4 = t4.next;
          return o4;
        };
        se3._configure = function(a4) {
          oi2 = a4, se3.create = cu2(), oi2._configure();
        };
      });
      var mu = me((ky, hu2) => {
        "use strict";
        hu2.exports = Ct3;
        var du2 = fi();
        (Ct3.prototype = Object.create(du2.prototype)).constructor = Ct3;
        var Qt4 = Zt();
        function Ct3() {
          du2.call(this);
        }
        Ct3._configure = function() {
          Ct3.alloc = Qt4._Buffer_allocUnsafe, Ct3.writeBytesBuffer = Qt4.Buffer && Qt4.Buffer.prototype instanceof Uint8Array && Qt4.Buffer.prototype.set.name === "set" ? function(t4, o4, e4) {
            o4.set(t4, e4);
          } : function(t4, o4, e4) {
            if (t4.copy)
              t4.copy(o4, e4, 0, t4.length);
            else
              for (var r4 = 0; r4 < t4.length; )
                o4[e4++] = t4[r4++];
          };
        };
        Ct3.prototype.bytes = function(t4) {
          Qt4.isString(t4) && (t4 = Qt4._Buffer_from(t4, "base64"));
          var o4 = t4.length >>> 0;
          return this.uint32(o4), o4 && this._push(Ct3.writeBytesBuffer, o4, t4), this;
        };
        function Wd(a4, t4, o4) {
          a4.length < 40 ? Qt4.utf8.write(a4, t4, o4) : t4.utf8Write ? t4.utf8Write(a4, o4) : t4.write(a4, o4);
        }
        Ct3.prototype.string = function(t4) {
          var o4 = Qt4.Buffer.byteLength(t4);
          return this.uint32(o4), o4 && this._push(Wd, o4, t4), this;
        };
        Ct3._configure();
      });
      var di = me((By, xu2) => {
        "use strict";
        xu2.exports = Pe4;
        var $t3 = Zt(), pi2, yu2 = $t3.LongBits, Hd = $t3.utf8;
        function _t3(a4, t4) {
          return RangeError("index out of range: " + a4.pos + " + " + (t4 || 1) + " > " + a4.len);
        }
        function Pe4(a4) {
          this.buf = a4, this.pos = 0, this.len = a4.length;
        }
        var bu2 = typeof Uint8Array < "u" ? function(t4) {
          if (t4 instanceof Uint8Array || Array.isArray(t4))
            return new Pe4(t4);
          throw Error("illegal buffer");
        } : function(t4) {
          if (Array.isArray(t4))
            return new Pe4(t4);
          throw Error("illegal buffer");
        }, Tu2 = function() {
          return $t3.Buffer ? function(o4) {
            return (Pe4.create = function(r4) {
              return $t3.Buffer.isBuffer(r4) ? new pi2(r4) : bu2(r4);
            })(o4);
          } : bu2;
        };
        Pe4.create = Tu2();
        Pe4.prototype._slice = $t3.Array.prototype.subarray || $t3.Array.prototype.slice;
        Pe4.prototype.uint32 = /* @__PURE__ */ function() {
          var t4 = 4294967295;
          return function() {
            if (t4 = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (t4 = (t4 | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (t4 = (t4 | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (t4 = (t4 | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (t4 = (t4 | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
              return t4;
            if ((this.pos += 5) > this.len)
              throw this.pos = this.len, _t3(this, 10);
            return t4;
          };
        }();
        Pe4.prototype.int32 = function() {
          return this.uint32() | 0;
        };
        Pe4.prototype.sint32 = function() {
          var t4 = this.uint32();
          return t4 >>> 1 ^ -(t4 & 1) | 0;
        };
        function ci3() {
          var a4 = new yu2(0, 0), t4 = 0;
          if (this.len - this.pos > 4) {
            for (; t4 < 4; ++t4)
              if (a4.lo = (a4.lo | (this.buf[this.pos] & 127) << t4 * 7) >>> 0, this.buf[this.pos++] < 128)
                return a4;
            if (a4.lo = (a4.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a4.hi = (a4.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
              return a4;
            t4 = 0;
          } else {
            for (; t4 < 3; ++t4) {
              if (this.pos >= this.len)
                throw _t3(this);
              if (a4.lo = (a4.lo | (this.buf[this.pos] & 127) << t4 * 7) >>> 0, this.buf[this.pos++] < 128)
                return a4;
            }
            return a4.lo = (a4.lo | (this.buf[this.pos++] & 127) << t4 * 7) >>> 0, a4;
          }
          if (this.len - this.pos > 4) {
            for (; t4 < 5; ++t4)
              if (a4.hi = (a4.hi | (this.buf[this.pos] & 127) << t4 * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
                return a4;
          } else
            for (; t4 < 5; ++t4) {
              if (this.pos >= this.len)
                throw _t3(this);
              if (a4.hi = (a4.hi | (this.buf[this.pos] & 127) << t4 * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
                return a4;
            }
          throw Error("invalid varint encoding");
        }
        Pe4.prototype.bool = function() {
          return this.uint32() !== 0;
        };
        function Yn3(a4, t4) {
          return (a4[t4 - 4] | a4[t4 - 3] << 8 | a4[t4 - 2] << 16 | a4[t4 - 1] << 24) >>> 0;
        }
        Pe4.prototype.fixed32 = function() {
          if (this.pos + 4 > this.len)
            throw _t3(this, 4);
          return Yn3(this.buf, this.pos += 4);
        };
        Pe4.prototype.sfixed32 = function() {
          if (this.pos + 4 > this.len)
            throw _t3(this, 4);
          return Yn3(this.buf, this.pos += 4) | 0;
        };
        function gu2() {
          if (this.pos + 8 > this.len)
            throw _t3(this, 8);
          return new yu2(Yn3(this.buf, this.pos += 4), Yn3(this.buf, this.pos += 4));
        }
        Pe4.prototype.float = function() {
          if (this.pos + 4 > this.len)
            throw _t3(this, 4);
          var t4 = $t3.float.readFloatLE(this.buf, this.pos);
          return this.pos += 4, t4;
        };
        Pe4.prototype.double = function() {
          if (this.pos + 8 > this.len)
            throw _t3(this, 4);
          var t4 = $t3.float.readDoubleLE(this.buf, this.pos);
          return this.pos += 8, t4;
        };
        Pe4.prototype.bytes = function() {
          var t4 = this.uint32(), o4 = this.pos, e4 = this.pos + t4;
          if (e4 > this.len)
            throw _t3(this, t4);
          return this.pos += t4, Array.isArray(this.buf) ? this.buf.slice(o4, e4) : o4 === e4 ? new this.buf.constructor(0) : this._slice.call(this.buf, o4, e4);
        };
        Pe4.prototype.string = function() {
          var t4 = this.bytes();
          return Hd.read(t4, 0, t4.length);
        };
        Pe4.prototype.skip = function(t4) {
          if (typeof t4 == "number") {
            if (this.pos + t4 > this.len)
              throw _t3(this, t4);
            this.pos += t4;
          } else
            do
              if (this.pos >= this.len)
                throw _t3(this);
            while (this.buf[this.pos++] & 128);
          return this;
        };
        Pe4.prototype.skipType = function(a4) {
          switch (a4) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              for (; (a4 = this.uint32() & 7) !== 4; )
                this.skipType(a4);
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + a4 + " at offset " + this.pos);
          }
          return this;
        };
        Pe4._configure = function(a4) {
          pi2 = a4, Pe4.create = Tu2(), pi2._configure();
          var t4 = $t3.Long ? "toLong" : "toNumber";
          $t3.merge(Pe4.prototype, { int64: function() {
            return ci3.call(this)[t4](false);
          }, uint64: function() {
            return ci3.call(this)[t4](true);
          }, sint64: function() {
            return ci3.call(this).zzDecode()[t4](false);
          }, fixed64: function() {
            return gu2.call(this)[t4](true);
          }, sfixed64: function() {
            return gu2.call(this)[t4](false);
          } });
        };
      });
      var Ou = me((Ny, _u2) => {
        "use strict";
        _u2.exports = dr3;
        var vu2 = di();
        (dr3.prototype = Object.create(vu2.prototype)).constructor = dr3;
        var wu2 = Zt();
        function dr3(a4) {
          vu2.call(this, a4);
        }
        dr3._configure = function() {
          wu2.Buffer && (dr3.prototype._slice = wu2.Buffer.prototype.slice);
        };
        dr3.prototype.string = function() {
          var t4 = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t4, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t4, this.len));
        };
        dr3._configure();
      });
      var Su = me((Ry, Iu2) => {
        "use strict";
        Iu2.exports = sn4;
        var hi3 = Zt();
        (sn4.prototype = Object.create(hi3.EventEmitter.prototype)).constructor = sn4;
        function sn4(a4, t4, o4) {
          if (typeof a4 != "function")
            throw TypeError("rpcImpl must be a function");
          hi3.EventEmitter.call(this), this.rpcImpl = a4, this.requestDelimited = !!t4, this.responseDelimited = !!o4;
        }
        sn4.prototype.rpcCall = function a4(t4, o4, e4, r4, n4) {
          if (!r4)
            throw TypeError("request must be specified");
          var s4 = this;
          if (!n4)
            return hi3.asPromise(a4, s4, t4, o4, e4, r4);
          if (!s4.rpcImpl) {
            setTimeout(function() {
              n4(Error("already ended"));
            }, 0);
            return;
          }
          try {
            return s4.rpcImpl(t4, o4[s4.requestDelimited ? "encodeDelimited" : "encode"](r4).finish(), function(u4, l4) {
              if (u4)
                return s4.emit("error", u4, t4), n4(u4);
              if (l4 === null) {
                s4.end(true);
                return;
              }
              if (!(l4 instanceof e4))
                try {
                  l4 = e4[s4.responseDelimited ? "decodeDelimited" : "decode"](l4);
                } catch (f3) {
                  return s4.emit("error", f3, t4), n4(f3);
                }
              return s4.emit("data", l4, t4), n4(null, l4);
            });
          } catch (i5) {
            s4.emit("error", i5, t4), setTimeout(function() {
              n4(i5);
            }, 0);
            return;
          }
        };
        sn4.prototype.end = function(t4) {
          return this.rpcImpl && (t4 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
        };
      });
      var Pu = me((Au2) => {
        "use strict";
        var qd = Au2;
        qd.Service = Su();
      });
      var Du = me((Gy, Eu2) => {
        "use strict";
        Eu2.exports = {};
      });
      var Cu = me((Fu2) => {
        "use strict";
        var rt3 = Fu2;
        rt3.build = "minimal";
        rt3.Writer = fi();
        rt3.BufferWriter = mu();
        rt3.Reader = di();
        rt3.BufferReader = Ou();
        rt3.util = Zt();
        rt3.rpc = Pu();
        rt3.roots = Du();
        rt3.configure = Lu2;
        function Lu2() {
          rt3.util._configure(), rt3.Writer._configure(rt3.BufferWriter), rt3.Reader._configure(rt3.BufferReader);
        }
        Lu2();
      });
      var ku = me((zy, $u2) => {
        "use strict";
        $u2.exports = Cu();
      });
      var $r = me((Vy, Bu2) => {
        "use strict";
        var ge4 = ku(), N4 = ge4.Reader, Ee4 = ge4.Writer, y3 = ge4.util, m4 = ge4.roots.default || (ge4.roots.default = {});
        m4.onnx = function() {
          var a4 = {};
          return a4.Version = function() {
            var t4 = {}, o4 = Object.create(t4);
            return o4[t4[0] = "_START_VERSION"] = 0, o4[t4[1] = "IR_VERSION_2017_10_10"] = 1, o4[t4[2] = "IR_VERSION_2017_10_30"] = 2, o4[t4[3] = "IR_VERSION_2017_11_3"] = 3, o4[t4[4] = "IR_VERSION_2019_1_22"] = 4, o4[t4[5] = "IR_VERSION_2019_3_18"] = 5, o4[t4[6] = "IR_VERSION_2019_9_19"] = 6, o4[t4[7] = "IR_VERSION_2020_5_8"] = 7, o4[t4[8] = "IR_VERSION_2021_7_30"] = 8, o4[t4[9] = "IR_VERSION"] = 9, o4;
          }(), a4.AttributeProto = function() {
            function t4(o4) {
              if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.name = "", t4.prototype.refAttrName = "", t4.prototype.docString = "", t4.prototype.type = 0, t4.prototype.f = 0, t4.prototype.i = y3.Long ? y3.Long.fromBits(0, 0, false) : 0, t4.prototype.s = y3.newBuffer([]), t4.prototype.t = null, t4.prototype.g = null, t4.prototype.sparseTensor = null, t4.prototype.tp = null, t4.prototype.floats = y3.emptyArray, t4.prototype.ints = y3.emptyArray, t4.prototype.strings = y3.emptyArray, t4.prototype.tensors = y3.emptyArray, t4.prototype.graphs = y3.emptyArray, t4.prototype.sparseTensors = y3.emptyArray, t4.prototype.typeProtos = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.name != null && Object.hasOwnProperty.call(e4, "name") && r4.uint32(10).string(e4.name), e4.f != null && Object.hasOwnProperty.call(e4, "f") && r4.uint32(21).float(e4.f), e4.i != null && Object.hasOwnProperty.call(e4, "i") && r4.uint32(24).int64(e4.i), e4.s != null && Object.hasOwnProperty.call(e4, "s") && r4.uint32(34).bytes(e4.s), e4.t != null && Object.hasOwnProperty.call(e4, "t") && m4.onnx.TensorProto.encode(e4.t, r4.uint32(42).fork()).ldelim(), e4.g != null && Object.hasOwnProperty.call(e4, "g") && m4.onnx.GraphProto.encode(e4.g, r4.uint32(50).fork()).ldelim(), e4.floats != null && e4.floats.length) {
                r4.uint32(58).fork();
                for (var n4 = 0; n4 < e4.floats.length; ++n4)
                  r4.float(e4.floats[n4]);
                r4.ldelim();
              }
              if (e4.ints != null && e4.ints.length) {
                r4.uint32(66).fork();
                for (var n4 = 0; n4 < e4.ints.length; ++n4)
                  r4.int64(e4.ints[n4]);
                r4.ldelim();
              }
              if (e4.strings != null && e4.strings.length)
                for (var n4 = 0; n4 < e4.strings.length; ++n4)
                  r4.uint32(74).bytes(e4.strings[n4]);
              if (e4.tensors != null && e4.tensors.length)
                for (var n4 = 0; n4 < e4.tensors.length; ++n4)
                  m4.onnx.TensorProto.encode(e4.tensors[n4], r4.uint32(82).fork()).ldelim();
              if (e4.graphs != null && e4.graphs.length)
                for (var n4 = 0; n4 < e4.graphs.length; ++n4)
                  m4.onnx.GraphProto.encode(e4.graphs[n4], r4.uint32(90).fork()).ldelim();
              if (e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(106).string(e4.docString), e4.tp != null && Object.hasOwnProperty.call(e4, "tp") && m4.onnx.TypeProto.encode(e4.tp, r4.uint32(114).fork()).ldelim(), e4.typeProtos != null && e4.typeProtos.length)
                for (var n4 = 0; n4 < e4.typeProtos.length; ++n4)
                  m4.onnx.TypeProto.encode(e4.typeProtos[n4], r4.uint32(122).fork()).ldelim();
              if (e4.type != null && Object.hasOwnProperty.call(e4, "type") && r4.uint32(160).int32(e4.type), e4.refAttrName != null && Object.hasOwnProperty.call(e4, "refAttrName") && r4.uint32(170).string(e4.refAttrName), e4.sparseTensor != null && Object.hasOwnProperty.call(e4, "sparseTensor") && m4.onnx.SparseTensorProto.encode(e4.sparseTensor, r4.uint32(178).fork()).ldelim(), e4.sparseTensors != null && e4.sparseTensors.length)
                for (var n4 = 0; n4 < e4.sparseTensors.length; ++n4)
                  m4.onnx.SparseTensorProto.encode(e4.sparseTensors[n4], r4.uint32(186).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.AttributeProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.name = e4.string();
                    break;
                  }
                  case 21: {
                    s4.refAttrName = e4.string();
                    break;
                  }
                  case 13: {
                    s4.docString = e4.string();
                    break;
                  }
                  case 20: {
                    s4.type = e4.int32();
                    break;
                  }
                  case 2: {
                    s4.f = e4.float();
                    break;
                  }
                  case 3: {
                    s4.i = e4.int64();
                    break;
                  }
                  case 4: {
                    s4.s = e4.bytes();
                    break;
                  }
                  case 5: {
                    s4.t = m4.onnx.TensorProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 6: {
                    s4.g = m4.onnx.GraphProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 22: {
                    s4.sparseTensor = m4.onnx.SparseTensorProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 14: {
                    s4.tp = m4.onnx.TypeProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 7: {
                    if (s4.floats && s4.floats.length || (s4.floats = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.floats.push(e4.float());
                    else
                      s4.floats.push(e4.float());
                    break;
                  }
                  case 8: {
                    if (s4.ints && s4.ints.length || (s4.ints = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.ints.push(e4.int64());
                    else
                      s4.ints.push(e4.int64());
                    break;
                  }
                  case 9: {
                    s4.strings && s4.strings.length || (s4.strings = []), s4.strings.push(e4.bytes());
                    break;
                  }
                  case 10: {
                    s4.tensors && s4.tensors.length || (s4.tensors = []), s4.tensors.push(m4.onnx.TensorProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 11: {
                    s4.graphs && s4.graphs.length || (s4.graphs = []), s4.graphs.push(m4.onnx.GraphProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 23: {
                    s4.sparseTensors && s4.sparseTensors.length || (s4.sparseTensors = []), s4.sparseTensors.push(m4.onnx.SparseTensorProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 15: {
                    s4.typeProtos && s4.typeProtos.length || (s4.typeProtos = []), s4.typeProtos.push(m4.onnx.TypeProto.decode(e4, e4.uint32()));
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.name != null && e4.hasOwnProperty("name") && !y3.isString(e4.name))
                return "name: string expected";
              if (e4.refAttrName != null && e4.hasOwnProperty("refAttrName") && !y3.isString(e4.refAttrName))
                return "refAttrName: string expected";
              if (e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString))
                return "docString: string expected";
              if (e4.type != null && e4.hasOwnProperty("type"))
                switch (e4.type) {
                  default:
                    return "type: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 11:
                  case 13:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                  case 12:
                  case 14:
                    break;
                }
              if (e4.f != null && e4.hasOwnProperty("f") && typeof e4.f != "number")
                return "f: number expected";
              if (e4.i != null && e4.hasOwnProperty("i") && !y3.isInteger(e4.i) && !(e4.i && y3.isInteger(e4.i.low) && y3.isInteger(e4.i.high)))
                return "i: integer|Long expected";
              if (e4.s != null && e4.hasOwnProperty("s") && !(e4.s && typeof e4.s.length == "number" || y3.isString(e4.s)))
                return "s: buffer expected";
              if (e4.t != null && e4.hasOwnProperty("t")) {
                var r4 = m4.onnx.TensorProto.verify(e4.t);
                if (r4)
                  return "t." + r4;
              }
              if (e4.g != null && e4.hasOwnProperty("g")) {
                var r4 = m4.onnx.GraphProto.verify(e4.g);
                if (r4)
                  return "g." + r4;
              }
              if (e4.sparseTensor != null && e4.hasOwnProperty("sparseTensor")) {
                var r4 = m4.onnx.SparseTensorProto.verify(e4.sparseTensor);
                if (r4)
                  return "sparseTensor." + r4;
              }
              if (e4.tp != null && e4.hasOwnProperty("tp")) {
                var r4 = m4.onnx.TypeProto.verify(e4.tp);
                if (r4)
                  return "tp." + r4;
              }
              if (e4.floats != null && e4.hasOwnProperty("floats")) {
                if (!Array.isArray(e4.floats))
                  return "floats: array expected";
                for (var n4 = 0; n4 < e4.floats.length; ++n4)
                  if (typeof e4.floats[n4] != "number")
                    return "floats: number[] expected";
              }
              if (e4.ints != null && e4.hasOwnProperty("ints")) {
                if (!Array.isArray(e4.ints))
                  return "ints: array expected";
                for (var n4 = 0; n4 < e4.ints.length; ++n4)
                  if (!y3.isInteger(e4.ints[n4]) && !(e4.ints[n4] && y3.isInteger(e4.ints[n4].low) && y3.isInteger(e4.ints[n4].high)))
                    return "ints: integer|Long[] expected";
              }
              if (e4.strings != null && e4.hasOwnProperty("strings")) {
                if (!Array.isArray(e4.strings))
                  return "strings: array expected";
                for (var n4 = 0; n4 < e4.strings.length; ++n4)
                  if (!(e4.strings[n4] && typeof e4.strings[n4].length == "number" || y3.isString(e4.strings[n4])))
                    return "strings: buffer[] expected";
              }
              if (e4.tensors != null && e4.hasOwnProperty("tensors")) {
                if (!Array.isArray(e4.tensors))
                  return "tensors: array expected";
                for (var n4 = 0; n4 < e4.tensors.length; ++n4) {
                  var r4 = m4.onnx.TensorProto.verify(e4.tensors[n4]);
                  if (r4)
                    return "tensors." + r4;
                }
              }
              if (e4.graphs != null && e4.hasOwnProperty("graphs")) {
                if (!Array.isArray(e4.graphs))
                  return "graphs: array expected";
                for (var n4 = 0; n4 < e4.graphs.length; ++n4) {
                  var r4 = m4.onnx.GraphProto.verify(e4.graphs[n4]);
                  if (r4)
                    return "graphs." + r4;
                }
              }
              if (e4.sparseTensors != null && e4.hasOwnProperty("sparseTensors")) {
                if (!Array.isArray(e4.sparseTensors))
                  return "sparseTensors: array expected";
                for (var n4 = 0; n4 < e4.sparseTensors.length; ++n4) {
                  var r4 = m4.onnx.SparseTensorProto.verify(e4.sparseTensors[n4]);
                  if (r4)
                    return "sparseTensors." + r4;
                }
              }
              if (e4.typeProtos != null && e4.hasOwnProperty("typeProtos")) {
                if (!Array.isArray(e4.typeProtos))
                  return "typeProtos: array expected";
                for (var n4 = 0; n4 < e4.typeProtos.length; ++n4) {
                  var r4 = m4.onnx.TypeProto.verify(e4.typeProtos[n4]);
                  if (r4)
                    return "typeProtos." + r4;
                }
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.AttributeProto)
                return e4;
              var r4 = new m4.onnx.AttributeProto();
              switch (e4.name != null && (r4.name = String(e4.name)), e4.refAttrName != null && (r4.refAttrName = String(e4.refAttrName)), e4.docString != null && (r4.docString = String(e4.docString)), e4.type) {
                default:
                  if (typeof e4.type == "number") {
                    r4.type = e4.type;
                    break;
                  }
                  break;
                case "UNDEFINED":
                case 0:
                  r4.type = 0;
                  break;
                case "FLOAT":
                case 1:
                  r4.type = 1;
                  break;
                case "INT":
                case 2:
                  r4.type = 2;
                  break;
                case "STRING":
                case 3:
                  r4.type = 3;
                  break;
                case "TENSOR":
                case 4:
                  r4.type = 4;
                  break;
                case "GRAPH":
                case 5:
                  r4.type = 5;
                  break;
                case "SPARSE_TENSOR":
                case 11:
                  r4.type = 11;
                  break;
                case "TYPE_PROTO":
                case 13:
                  r4.type = 13;
                  break;
                case "FLOATS":
                case 6:
                  r4.type = 6;
                  break;
                case "INTS":
                case 7:
                  r4.type = 7;
                  break;
                case "STRINGS":
                case 8:
                  r4.type = 8;
                  break;
                case "TENSORS":
                case 9:
                  r4.type = 9;
                  break;
                case "GRAPHS":
                case 10:
                  r4.type = 10;
                  break;
                case "SPARSE_TENSORS":
                case 12:
                  r4.type = 12;
                  break;
                case "TYPE_PROTOS":
                case 14:
                  r4.type = 14;
                  break;
              }
              if (e4.f != null && (r4.f = Number(e4.f)), e4.i != null && (y3.Long ? (r4.i = y3.Long.fromValue(e4.i)).unsigned = false : typeof e4.i == "string" ? r4.i = parseInt(e4.i, 10) : typeof e4.i == "number" ? r4.i = e4.i : typeof e4.i == "object" && (r4.i = new y3.LongBits(e4.i.low >>> 0, e4.i.high >>> 0).toNumber())), e4.s != null && (typeof e4.s == "string" ? y3.base64.decode(e4.s, r4.s = y3.newBuffer(y3.base64.length(e4.s)), 0) : e4.s.length >= 0 && (r4.s = e4.s)), e4.t != null) {
                if (typeof e4.t != "object")
                  throw TypeError(".onnx.AttributeProto.t: object expected");
                r4.t = m4.onnx.TensorProto.fromObject(e4.t);
              }
              if (e4.g != null) {
                if (typeof e4.g != "object")
                  throw TypeError(".onnx.AttributeProto.g: object expected");
                r4.g = m4.onnx.GraphProto.fromObject(e4.g);
              }
              if (e4.sparseTensor != null) {
                if (typeof e4.sparseTensor != "object")
                  throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
                r4.sparseTensor = m4.onnx.SparseTensorProto.fromObject(e4.sparseTensor);
              }
              if (e4.tp != null) {
                if (typeof e4.tp != "object")
                  throw TypeError(".onnx.AttributeProto.tp: object expected");
                r4.tp = m4.onnx.TypeProto.fromObject(e4.tp);
              }
              if (e4.floats) {
                if (!Array.isArray(e4.floats))
                  throw TypeError(".onnx.AttributeProto.floats: array expected");
                r4.floats = [];
                for (var n4 = 0; n4 < e4.floats.length; ++n4)
                  r4.floats[n4] = Number(e4.floats[n4]);
              }
              if (e4.ints) {
                if (!Array.isArray(e4.ints))
                  throw TypeError(".onnx.AttributeProto.ints: array expected");
                r4.ints = [];
                for (var n4 = 0; n4 < e4.ints.length; ++n4)
                  y3.Long ? (r4.ints[n4] = y3.Long.fromValue(e4.ints[n4])).unsigned = false : typeof e4.ints[n4] == "string" ? r4.ints[n4] = parseInt(e4.ints[n4], 10) : typeof e4.ints[n4] == "number" ? r4.ints[n4] = e4.ints[n4] : typeof e4.ints[n4] == "object" && (r4.ints[n4] = new y3.LongBits(e4.ints[n4].low >>> 0, e4.ints[n4].high >>> 0).toNumber());
              }
              if (e4.strings) {
                if (!Array.isArray(e4.strings))
                  throw TypeError(".onnx.AttributeProto.strings: array expected");
                r4.strings = [];
                for (var n4 = 0; n4 < e4.strings.length; ++n4)
                  typeof e4.strings[n4] == "string" ? y3.base64.decode(e4.strings[n4], r4.strings[n4] = y3.newBuffer(y3.base64.length(e4.strings[n4])), 0) : e4.strings[n4].length >= 0 && (r4.strings[n4] = e4.strings[n4]);
              }
              if (e4.tensors) {
                if (!Array.isArray(e4.tensors))
                  throw TypeError(".onnx.AttributeProto.tensors: array expected");
                r4.tensors = [];
                for (var n4 = 0; n4 < e4.tensors.length; ++n4) {
                  if (typeof e4.tensors[n4] != "object")
                    throw TypeError(".onnx.AttributeProto.tensors: object expected");
                  r4.tensors[n4] = m4.onnx.TensorProto.fromObject(e4.tensors[n4]);
                }
              }
              if (e4.graphs) {
                if (!Array.isArray(e4.graphs))
                  throw TypeError(".onnx.AttributeProto.graphs: array expected");
                r4.graphs = [];
                for (var n4 = 0; n4 < e4.graphs.length; ++n4) {
                  if (typeof e4.graphs[n4] != "object")
                    throw TypeError(".onnx.AttributeProto.graphs: object expected");
                  r4.graphs[n4] = m4.onnx.GraphProto.fromObject(e4.graphs[n4]);
                }
              }
              if (e4.sparseTensors) {
                if (!Array.isArray(e4.sparseTensors))
                  throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
                r4.sparseTensors = [];
                for (var n4 = 0; n4 < e4.sparseTensors.length; ++n4) {
                  if (typeof e4.sparseTensors[n4] != "object")
                    throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
                  r4.sparseTensors[n4] = m4.onnx.SparseTensorProto.fromObject(e4.sparseTensors[n4]);
                }
              }
              if (e4.typeProtos) {
                if (!Array.isArray(e4.typeProtos))
                  throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
                r4.typeProtos = [];
                for (var n4 = 0; n4 < e4.typeProtos.length; ++n4) {
                  if (typeof e4.typeProtos[n4] != "object")
                    throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
                  r4.typeProtos[n4] = m4.onnx.TypeProto.fromObject(e4.typeProtos[n4]);
                }
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.floats = [], n4.ints = [], n4.strings = [], n4.tensors = [], n4.graphs = [], n4.typeProtos = [], n4.sparseTensors = []), r4.defaults) {
                if (n4.name = "", n4.f = 0, y3.Long) {
                  var s4 = new y3.Long(0, 0, false);
                  n4.i = r4.longs === String ? s4.toString() : r4.longs === Number ? s4.toNumber() : s4;
                } else
                  n4.i = r4.longs === String ? "0" : 0;
                r4.bytes === String ? n4.s = "" : (n4.s = [], r4.bytes !== Array && (n4.s = y3.newBuffer(n4.s))), n4.t = null, n4.g = null, n4.docString = "", n4.tp = null, n4.type = r4.enums === String ? "UNDEFINED" : 0, n4.refAttrName = "", n4.sparseTensor = null;
              }
              if (e4.name != null && e4.hasOwnProperty("name") && (n4.name = e4.name), e4.f != null && e4.hasOwnProperty("f") && (n4.f = r4.json && !isFinite(e4.f) ? String(e4.f) : e4.f), e4.i != null && e4.hasOwnProperty("i") && (typeof e4.i == "number" ? n4.i = r4.longs === String ? String(e4.i) : e4.i : n4.i = r4.longs === String ? y3.Long.prototype.toString.call(e4.i) : r4.longs === Number ? new y3.LongBits(e4.i.low >>> 0, e4.i.high >>> 0).toNumber() : e4.i), e4.s != null && e4.hasOwnProperty("s") && (n4.s = r4.bytes === String ? y3.base64.encode(e4.s, 0, e4.s.length) : r4.bytes === Array ? Array.prototype.slice.call(e4.s) : e4.s), e4.t != null && e4.hasOwnProperty("t") && (n4.t = m4.onnx.TensorProto.toObject(e4.t, r4)), e4.g != null && e4.hasOwnProperty("g") && (n4.g = m4.onnx.GraphProto.toObject(e4.g, r4)), e4.floats && e4.floats.length) {
                n4.floats = [];
                for (var i5 = 0; i5 < e4.floats.length; ++i5)
                  n4.floats[i5] = r4.json && !isFinite(e4.floats[i5]) ? String(e4.floats[i5]) : e4.floats[i5];
              }
              if (e4.ints && e4.ints.length) {
                n4.ints = [];
                for (var i5 = 0; i5 < e4.ints.length; ++i5)
                  typeof e4.ints[i5] == "number" ? n4.ints[i5] = r4.longs === String ? String(e4.ints[i5]) : e4.ints[i5] : n4.ints[i5] = r4.longs === String ? y3.Long.prototype.toString.call(e4.ints[i5]) : r4.longs === Number ? new y3.LongBits(e4.ints[i5].low >>> 0, e4.ints[i5].high >>> 0).toNumber() : e4.ints[i5];
              }
              if (e4.strings && e4.strings.length) {
                n4.strings = [];
                for (var i5 = 0; i5 < e4.strings.length; ++i5)
                  n4.strings[i5] = r4.bytes === String ? y3.base64.encode(e4.strings[i5], 0, e4.strings[i5].length) : r4.bytes === Array ? Array.prototype.slice.call(e4.strings[i5]) : e4.strings[i5];
              }
              if (e4.tensors && e4.tensors.length) {
                n4.tensors = [];
                for (var i5 = 0; i5 < e4.tensors.length; ++i5)
                  n4.tensors[i5] = m4.onnx.TensorProto.toObject(e4.tensors[i5], r4);
              }
              if (e4.graphs && e4.graphs.length) {
                n4.graphs = [];
                for (var i5 = 0; i5 < e4.graphs.length; ++i5)
                  n4.graphs[i5] = m4.onnx.GraphProto.toObject(e4.graphs[i5], r4);
              }
              if (e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), e4.tp != null && e4.hasOwnProperty("tp") && (n4.tp = m4.onnx.TypeProto.toObject(e4.tp, r4)), e4.typeProtos && e4.typeProtos.length) {
                n4.typeProtos = [];
                for (var i5 = 0; i5 < e4.typeProtos.length; ++i5)
                  n4.typeProtos[i5] = m4.onnx.TypeProto.toObject(e4.typeProtos[i5], r4);
              }
              if (e4.type != null && e4.hasOwnProperty("type") && (n4.type = r4.enums === String ? m4.onnx.AttributeProto.AttributeType[e4.type] === void 0 ? e4.type : m4.onnx.AttributeProto.AttributeType[e4.type] : e4.type), e4.refAttrName != null && e4.hasOwnProperty("refAttrName") && (n4.refAttrName = e4.refAttrName), e4.sparseTensor != null && e4.hasOwnProperty("sparseTensor") && (n4.sparseTensor = m4.onnx.SparseTensorProto.toObject(e4.sparseTensor, r4)), e4.sparseTensors && e4.sparseTensors.length) {
                n4.sparseTensors = [];
                for (var i5 = 0; i5 < e4.sparseTensors.length; ++i5)
                  n4.sparseTensors[i5] = m4.onnx.SparseTensorProto.toObject(e4.sparseTensors[i5], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.AttributeProto";
            }, t4.AttributeType = function() {
              var o4 = {}, e4 = Object.create(o4);
              return e4[o4[0] = "UNDEFINED"] = 0, e4[o4[1] = "FLOAT"] = 1, e4[o4[2] = "INT"] = 2, e4[o4[3] = "STRING"] = 3, e4[o4[4] = "TENSOR"] = 4, e4[o4[5] = "GRAPH"] = 5, e4[o4[11] = "SPARSE_TENSOR"] = 11, e4[o4[13] = "TYPE_PROTO"] = 13, e4[o4[6] = "FLOATS"] = 6, e4[o4[7] = "INTS"] = 7, e4[o4[8] = "STRINGS"] = 8, e4[o4[9] = "TENSORS"] = 9, e4[o4[10] = "GRAPHS"] = 10, e4[o4[12] = "SPARSE_TENSORS"] = 12, e4[o4[14] = "TYPE_PROTOS"] = 14, e4;
            }(), t4;
          }(), a4.ValueInfoProto = function() {
            function t4(o4) {
              if (o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.name = "", t4.prototype.type = null, t4.prototype.docString = "", t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              return r4 || (r4 = Ee4.create()), e4.name != null && Object.hasOwnProperty.call(e4, "name") && r4.uint32(10).string(e4.name), e4.type != null && Object.hasOwnProperty.call(e4, "type") && m4.onnx.TypeProto.encode(e4.type, r4.uint32(18).fork()).ldelim(), e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(26).string(e4.docString), r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.ValueInfoProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.name = e4.string();
                    break;
                  }
                  case 2: {
                    s4.type = m4.onnx.TypeProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 3: {
                    s4.docString = e4.string();
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.name != null && e4.hasOwnProperty("name") && !y3.isString(e4.name))
                return "name: string expected";
              if (e4.type != null && e4.hasOwnProperty("type")) {
                var r4 = m4.onnx.TypeProto.verify(e4.type);
                if (r4)
                  return "type." + r4;
              }
              return e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString) ? "docString: string expected" : null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.ValueInfoProto)
                return e4;
              var r4 = new m4.onnx.ValueInfoProto();
              if (e4.name != null && (r4.name = String(e4.name)), e4.type != null) {
                if (typeof e4.type != "object")
                  throw TypeError(".onnx.ValueInfoProto.type: object expected");
                r4.type = m4.onnx.TypeProto.fromObject(e4.type);
              }
              return e4.docString != null && (r4.docString = String(e4.docString)), r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              return r4.defaults && (n4.name = "", n4.type = null, n4.docString = ""), e4.name != null && e4.hasOwnProperty("name") && (n4.name = e4.name), e4.type != null && e4.hasOwnProperty("type") && (n4.type = m4.onnx.TypeProto.toObject(e4.type, r4)), e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.ValueInfoProto";
            }, t4;
          }(), a4.NodeProto = function() {
            function t4(o4) {
              if (this.input = [], this.output = [], this.attribute = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.input = y3.emptyArray, t4.prototype.output = y3.emptyArray, t4.prototype.name = "", t4.prototype.opType = "", t4.prototype.domain = "", t4.prototype.attribute = y3.emptyArray, t4.prototype.docString = "", t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.input != null && e4.input.length)
                for (var n4 = 0; n4 < e4.input.length; ++n4)
                  r4.uint32(10).string(e4.input[n4]);
              if (e4.output != null && e4.output.length)
                for (var n4 = 0; n4 < e4.output.length; ++n4)
                  r4.uint32(18).string(e4.output[n4]);
              if (e4.name != null && Object.hasOwnProperty.call(e4, "name") && r4.uint32(26).string(e4.name), e4.opType != null && Object.hasOwnProperty.call(e4, "opType") && r4.uint32(34).string(e4.opType), e4.attribute != null && e4.attribute.length)
                for (var n4 = 0; n4 < e4.attribute.length; ++n4)
                  m4.onnx.AttributeProto.encode(e4.attribute[n4], r4.uint32(42).fork()).ldelim();
              return e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(50).string(e4.docString), e4.domain != null && Object.hasOwnProperty.call(e4, "domain") && r4.uint32(58).string(e4.domain), r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.NodeProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.input && s4.input.length || (s4.input = []), s4.input.push(e4.string());
                    break;
                  }
                  case 2: {
                    s4.output && s4.output.length || (s4.output = []), s4.output.push(e4.string());
                    break;
                  }
                  case 3: {
                    s4.name = e4.string();
                    break;
                  }
                  case 4: {
                    s4.opType = e4.string();
                    break;
                  }
                  case 7: {
                    s4.domain = e4.string();
                    break;
                  }
                  case 5: {
                    s4.attribute && s4.attribute.length || (s4.attribute = []), s4.attribute.push(m4.onnx.AttributeProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 6: {
                    s4.docString = e4.string();
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.input != null && e4.hasOwnProperty("input")) {
                if (!Array.isArray(e4.input))
                  return "input: array expected";
                for (var r4 = 0; r4 < e4.input.length; ++r4)
                  if (!y3.isString(e4.input[r4]))
                    return "input: string[] expected";
              }
              if (e4.output != null && e4.hasOwnProperty("output")) {
                if (!Array.isArray(e4.output))
                  return "output: array expected";
                for (var r4 = 0; r4 < e4.output.length; ++r4)
                  if (!y3.isString(e4.output[r4]))
                    return "output: string[] expected";
              }
              if (e4.name != null && e4.hasOwnProperty("name") && !y3.isString(e4.name))
                return "name: string expected";
              if (e4.opType != null && e4.hasOwnProperty("opType") && !y3.isString(e4.opType))
                return "opType: string expected";
              if (e4.domain != null && e4.hasOwnProperty("domain") && !y3.isString(e4.domain))
                return "domain: string expected";
              if (e4.attribute != null && e4.hasOwnProperty("attribute")) {
                if (!Array.isArray(e4.attribute))
                  return "attribute: array expected";
                for (var r4 = 0; r4 < e4.attribute.length; ++r4) {
                  var n4 = m4.onnx.AttributeProto.verify(e4.attribute[r4]);
                  if (n4)
                    return "attribute." + n4;
                }
              }
              return e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString) ? "docString: string expected" : null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.NodeProto)
                return e4;
              var r4 = new m4.onnx.NodeProto();
              if (e4.input) {
                if (!Array.isArray(e4.input))
                  throw TypeError(".onnx.NodeProto.input: array expected");
                r4.input = [];
                for (var n4 = 0; n4 < e4.input.length; ++n4)
                  r4.input[n4] = String(e4.input[n4]);
              }
              if (e4.output) {
                if (!Array.isArray(e4.output))
                  throw TypeError(".onnx.NodeProto.output: array expected");
                r4.output = [];
                for (var n4 = 0; n4 < e4.output.length; ++n4)
                  r4.output[n4] = String(e4.output[n4]);
              }
              if (e4.name != null && (r4.name = String(e4.name)), e4.opType != null && (r4.opType = String(e4.opType)), e4.domain != null && (r4.domain = String(e4.domain)), e4.attribute) {
                if (!Array.isArray(e4.attribute))
                  throw TypeError(".onnx.NodeProto.attribute: array expected");
                r4.attribute = [];
                for (var n4 = 0; n4 < e4.attribute.length; ++n4) {
                  if (typeof e4.attribute[n4] != "object")
                    throw TypeError(".onnx.NodeProto.attribute: object expected");
                  r4.attribute[n4] = m4.onnx.AttributeProto.fromObject(e4.attribute[n4]);
                }
              }
              return e4.docString != null && (r4.docString = String(e4.docString)), r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.input = [], n4.output = [], n4.attribute = []), r4.defaults && (n4.name = "", n4.opType = "", n4.docString = "", n4.domain = ""), e4.input && e4.input.length) {
                n4.input = [];
                for (var s4 = 0; s4 < e4.input.length; ++s4)
                  n4.input[s4] = e4.input[s4];
              }
              if (e4.output && e4.output.length) {
                n4.output = [];
                for (var s4 = 0; s4 < e4.output.length; ++s4)
                  n4.output[s4] = e4.output[s4];
              }
              if (e4.name != null && e4.hasOwnProperty("name") && (n4.name = e4.name), e4.opType != null && e4.hasOwnProperty("opType") && (n4.opType = e4.opType), e4.attribute && e4.attribute.length) {
                n4.attribute = [];
                for (var s4 = 0; s4 < e4.attribute.length; ++s4)
                  n4.attribute[s4] = m4.onnx.AttributeProto.toObject(e4.attribute[s4], r4);
              }
              return e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), e4.domain != null && e4.hasOwnProperty("domain") && (n4.domain = e4.domain), n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.NodeProto";
            }, t4;
          }(), a4.TrainingInfoProto = function() {
            function t4(o4) {
              if (this.initializationBinding = [], this.updateBinding = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.initialization = null, t4.prototype.algorithm = null, t4.prototype.initializationBinding = y3.emptyArray, t4.prototype.updateBinding = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.initialization != null && Object.hasOwnProperty.call(e4, "initialization") && m4.onnx.GraphProto.encode(e4.initialization, r4.uint32(10).fork()).ldelim(), e4.algorithm != null && Object.hasOwnProperty.call(e4, "algorithm") && m4.onnx.GraphProto.encode(e4.algorithm, r4.uint32(18).fork()).ldelim(), e4.initializationBinding != null && e4.initializationBinding.length)
                for (var n4 = 0; n4 < e4.initializationBinding.length; ++n4)
                  m4.onnx.StringStringEntryProto.encode(e4.initializationBinding[n4], r4.uint32(26).fork()).ldelim();
              if (e4.updateBinding != null && e4.updateBinding.length)
                for (var n4 = 0; n4 < e4.updateBinding.length; ++n4)
                  m4.onnx.StringStringEntryProto.encode(e4.updateBinding[n4], r4.uint32(34).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.TrainingInfoProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.initialization = m4.onnx.GraphProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 2: {
                    s4.algorithm = m4.onnx.GraphProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 3: {
                    s4.initializationBinding && s4.initializationBinding.length || (s4.initializationBinding = []), s4.initializationBinding.push(m4.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 4: {
                    s4.updateBinding && s4.updateBinding.length || (s4.updateBinding = []), s4.updateBinding.push(m4.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.initialization != null && e4.hasOwnProperty("initialization")) {
                var r4 = m4.onnx.GraphProto.verify(e4.initialization);
                if (r4)
                  return "initialization." + r4;
              }
              if (e4.algorithm != null && e4.hasOwnProperty("algorithm")) {
                var r4 = m4.onnx.GraphProto.verify(e4.algorithm);
                if (r4)
                  return "algorithm." + r4;
              }
              if (e4.initializationBinding != null && e4.hasOwnProperty("initializationBinding")) {
                if (!Array.isArray(e4.initializationBinding))
                  return "initializationBinding: array expected";
                for (var n4 = 0; n4 < e4.initializationBinding.length; ++n4) {
                  var r4 = m4.onnx.StringStringEntryProto.verify(e4.initializationBinding[n4]);
                  if (r4)
                    return "initializationBinding." + r4;
                }
              }
              if (e4.updateBinding != null && e4.hasOwnProperty("updateBinding")) {
                if (!Array.isArray(e4.updateBinding))
                  return "updateBinding: array expected";
                for (var n4 = 0; n4 < e4.updateBinding.length; ++n4) {
                  var r4 = m4.onnx.StringStringEntryProto.verify(e4.updateBinding[n4]);
                  if (r4)
                    return "updateBinding." + r4;
                }
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.TrainingInfoProto)
                return e4;
              var r4 = new m4.onnx.TrainingInfoProto();
              if (e4.initialization != null) {
                if (typeof e4.initialization != "object")
                  throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
                r4.initialization = m4.onnx.GraphProto.fromObject(e4.initialization);
              }
              if (e4.algorithm != null) {
                if (typeof e4.algorithm != "object")
                  throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
                r4.algorithm = m4.onnx.GraphProto.fromObject(e4.algorithm);
              }
              if (e4.initializationBinding) {
                if (!Array.isArray(e4.initializationBinding))
                  throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
                r4.initializationBinding = [];
                for (var n4 = 0; n4 < e4.initializationBinding.length; ++n4) {
                  if (typeof e4.initializationBinding[n4] != "object")
                    throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
                  r4.initializationBinding[n4] = m4.onnx.StringStringEntryProto.fromObject(e4.initializationBinding[n4]);
                }
              }
              if (e4.updateBinding) {
                if (!Array.isArray(e4.updateBinding))
                  throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
                r4.updateBinding = [];
                for (var n4 = 0; n4 < e4.updateBinding.length; ++n4) {
                  if (typeof e4.updateBinding[n4] != "object")
                    throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
                  r4.updateBinding[n4] = m4.onnx.StringStringEntryProto.fromObject(e4.updateBinding[n4]);
                }
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.initializationBinding = [], n4.updateBinding = []), r4.defaults && (n4.initialization = null, n4.algorithm = null), e4.initialization != null && e4.hasOwnProperty("initialization") && (n4.initialization = m4.onnx.GraphProto.toObject(e4.initialization, r4)), e4.algorithm != null && e4.hasOwnProperty("algorithm") && (n4.algorithm = m4.onnx.GraphProto.toObject(e4.algorithm, r4)), e4.initializationBinding && e4.initializationBinding.length) {
                n4.initializationBinding = [];
                for (var s4 = 0; s4 < e4.initializationBinding.length; ++s4)
                  n4.initializationBinding[s4] = m4.onnx.StringStringEntryProto.toObject(e4.initializationBinding[s4], r4);
              }
              if (e4.updateBinding && e4.updateBinding.length) {
                n4.updateBinding = [];
                for (var s4 = 0; s4 < e4.updateBinding.length; ++s4)
                  n4.updateBinding[s4] = m4.onnx.StringStringEntryProto.toObject(e4.updateBinding[s4], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.TrainingInfoProto";
            }, t4;
          }(), a4.ModelProto = function() {
            function t4(o4) {
              if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.irVersion = y3.Long ? y3.Long.fromBits(0, 0, false) : 0, t4.prototype.opsetImport = y3.emptyArray, t4.prototype.producerName = "", t4.prototype.producerVersion = "", t4.prototype.domain = "", t4.prototype.modelVersion = y3.Long ? y3.Long.fromBits(0, 0, false) : 0, t4.prototype.docString = "", t4.prototype.graph = null, t4.prototype.metadataProps = y3.emptyArray, t4.prototype.trainingInfo = y3.emptyArray, t4.prototype.functions = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.irVersion != null && Object.hasOwnProperty.call(e4, "irVersion") && r4.uint32(8).int64(e4.irVersion), e4.producerName != null && Object.hasOwnProperty.call(e4, "producerName") && r4.uint32(18).string(e4.producerName), e4.producerVersion != null && Object.hasOwnProperty.call(e4, "producerVersion") && r4.uint32(26).string(e4.producerVersion), e4.domain != null && Object.hasOwnProperty.call(e4, "domain") && r4.uint32(34).string(e4.domain), e4.modelVersion != null && Object.hasOwnProperty.call(e4, "modelVersion") && r4.uint32(40).int64(e4.modelVersion), e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(50).string(e4.docString), e4.graph != null && Object.hasOwnProperty.call(e4, "graph") && m4.onnx.GraphProto.encode(e4.graph, r4.uint32(58).fork()).ldelim(), e4.opsetImport != null && e4.opsetImport.length)
                for (var n4 = 0; n4 < e4.opsetImport.length; ++n4)
                  m4.onnx.OperatorSetIdProto.encode(e4.opsetImport[n4], r4.uint32(66).fork()).ldelim();
              if (e4.metadataProps != null && e4.metadataProps.length)
                for (var n4 = 0; n4 < e4.metadataProps.length; ++n4)
                  m4.onnx.StringStringEntryProto.encode(e4.metadataProps[n4], r4.uint32(114).fork()).ldelim();
              if (e4.trainingInfo != null && e4.trainingInfo.length)
                for (var n4 = 0; n4 < e4.trainingInfo.length; ++n4)
                  m4.onnx.TrainingInfoProto.encode(e4.trainingInfo[n4], r4.uint32(162).fork()).ldelim();
              if (e4.functions != null && e4.functions.length)
                for (var n4 = 0; n4 < e4.functions.length; ++n4)
                  m4.onnx.FunctionProto.encode(e4.functions[n4], r4.uint32(202).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.ModelProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.irVersion = e4.int64();
                    break;
                  }
                  case 8: {
                    s4.opsetImport && s4.opsetImport.length || (s4.opsetImport = []), s4.opsetImport.push(m4.onnx.OperatorSetIdProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 2: {
                    s4.producerName = e4.string();
                    break;
                  }
                  case 3: {
                    s4.producerVersion = e4.string();
                    break;
                  }
                  case 4: {
                    s4.domain = e4.string();
                    break;
                  }
                  case 5: {
                    s4.modelVersion = e4.int64();
                    break;
                  }
                  case 6: {
                    s4.docString = e4.string();
                    break;
                  }
                  case 7: {
                    s4.graph = m4.onnx.GraphProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 14: {
                    s4.metadataProps && s4.metadataProps.length || (s4.metadataProps = []), s4.metadataProps.push(m4.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 20: {
                    s4.trainingInfo && s4.trainingInfo.length || (s4.trainingInfo = []), s4.trainingInfo.push(m4.onnx.TrainingInfoProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 25: {
                    s4.functions && s4.functions.length || (s4.functions = []), s4.functions.push(m4.onnx.FunctionProto.decode(e4, e4.uint32()));
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.irVersion != null && e4.hasOwnProperty("irVersion") && !y3.isInteger(e4.irVersion) && !(e4.irVersion && y3.isInteger(e4.irVersion.low) && y3.isInteger(e4.irVersion.high)))
                return "irVersion: integer|Long expected";
              if (e4.opsetImport != null && e4.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(e4.opsetImport))
                  return "opsetImport: array expected";
                for (var r4 = 0; r4 < e4.opsetImport.length; ++r4) {
                  var n4 = m4.onnx.OperatorSetIdProto.verify(e4.opsetImport[r4]);
                  if (n4)
                    return "opsetImport." + n4;
                }
              }
              if (e4.producerName != null && e4.hasOwnProperty("producerName") && !y3.isString(e4.producerName))
                return "producerName: string expected";
              if (e4.producerVersion != null && e4.hasOwnProperty("producerVersion") && !y3.isString(e4.producerVersion))
                return "producerVersion: string expected";
              if (e4.domain != null && e4.hasOwnProperty("domain") && !y3.isString(e4.domain))
                return "domain: string expected";
              if (e4.modelVersion != null && e4.hasOwnProperty("modelVersion") && !y3.isInteger(e4.modelVersion) && !(e4.modelVersion && y3.isInteger(e4.modelVersion.low) && y3.isInteger(e4.modelVersion.high)))
                return "modelVersion: integer|Long expected";
              if (e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString))
                return "docString: string expected";
              if (e4.graph != null && e4.hasOwnProperty("graph")) {
                var n4 = m4.onnx.GraphProto.verify(e4.graph);
                if (n4)
                  return "graph." + n4;
              }
              if (e4.metadataProps != null && e4.hasOwnProperty("metadataProps")) {
                if (!Array.isArray(e4.metadataProps))
                  return "metadataProps: array expected";
                for (var r4 = 0; r4 < e4.metadataProps.length; ++r4) {
                  var n4 = m4.onnx.StringStringEntryProto.verify(e4.metadataProps[r4]);
                  if (n4)
                    return "metadataProps." + n4;
                }
              }
              if (e4.trainingInfo != null && e4.hasOwnProperty("trainingInfo")) {
                if (!Array.isArray(e4.trainingInfo))
                  return "trainingInfo: array expected";
                for (var r4 = 0; r4 < e4.trainingInfo.length; ++r4) {
                  var n4 = m4.onnx.TrainingInfoProto.verify(e4.trainingInfo[r4]);
                  if (n4)
                    return "trainingInfo." + n4;
                }
              }
              if (e4.functions != null && e4.hasOwnProperty("functions")) {
                if (!Array.isArray(e4.functions))
                  return "functions: array expected";
                for (var r4 = 0; r4 < e4.functions.length; ++r4) {
                  var n4 = m4.onnx.FunctionProto.verify(e4.functions[r4]);
                  if (n4)
                    return "functions." + n4;
                }
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.ModelProto)
                return e4;
              var r4 = new m4.onnx.ModelProto();
              if (e4.irVersion != null && (y3.Long ? (r4.irVersion = y3.Long.fromValue(e4.irVersion)).unsigned = false : typeof e4.irVersion == "string" ? r4.irVersion = parseInt(e4.irVersion, 10) : typeof e4.irVersion == "number" ? r4.irVersion = e4.irVersion : typeof e4.irVersion == "object" && (r4.irVersion = new y3.LongBits(e4.irVersion.low >>> 0, e4.irVersion.high >>> 0).toNumber())), e4.opsetImport) {
                if (!Array.isArray(e4.opsetImport))
                  throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                r4.opsetImport = [];
                for (var n4 = 0; n4 < e4.opsetImport.length; ++n4) {
                  if (typeof e4.opsetImport[n4] != "object")
                    throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                  r4.opsetImport[n4] = m4.onnx.OperatorSetIdProto.fromObject(e4.opsetImport[n4]);
                }
              }
              if (e4.producerName != null && (r4.producerName = String(e4.producerName)), e4.producerVersion != null && (r4.producerVersion = String(e4.producerVersion)), e4.domain != null && (r4.domain = String(e4.domain)), e4.modelVersion != null && (y3.Long ? (r4.modelVersion = y3.Long.fromValue(e4.modelVersion)).unsigned = false : typeof e4.modelVersion == "string" ? r4.modelVersion = parseInt(e4.modelVersion, 10) : typeof e4.modelVersion == "number" ? r4.modelVersion = e4.modelVersion : typeof e4.modelVersion == "object" && (r4.modelVersion = new y3.LongBits(e4.modelVersion.low >>> 0, e4.modelVersion.high >>> 0).toNumber())), e4.docString != null && (r4.docString = String(e4.docString)), e4.graph != null) {
                if (typeof e4.graph != "object")
                  throw TypeError(".onnx.ModelProto.graph: object expected");
                r4.graph = m4.onnx.GraphProto.fromObject(e4.graph);
              }
              if (e4.metadataProps) {
                if (!Array.isArray(e4.metadataProps))
                  throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                r4.metadataProps = [];
                for (var n4 = 0; n4 < e4.metadataProps.length; ++n4) {
                  if (typeof e4.metadataProps[n4] != "object")
                    throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                  r4.metadataProps[n4] = m4.onnx.StringStringEntryProto.fromObject(e4.metadataProps[n4]);
                }
              }
              if (e4.trainingInfo) {
                if (!Array.isArray(e4.trainingInfo))
                  throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
                r4.trainingInfo = [];
                for (var n4 = 0; n4 < e4.trainingInfo.length; ++n4) {
                  if (typeof e4.trainingInfo[n4] != "object")
                    throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
                  r4.trainingInfo[n4] = m4.onnx.TrainingInfoProto.fromObject(e4.trainingInfo[n4]);
                }
              }
              if (e4.functions) {
                if (!Array.isArray(e4.functions))
                  throw TypeError(".onnx.ModelProto.functions: array expected");
                r4.functions = [];
                for (var n4 = 0; n4 < e4.functions.length; ++n4) {
                  if (typeof e4.functions[n4] != "object")
                    throw TypeError(".onnx.ModelProto.functions: object expected");
                  r4.functions[n4] = m4.onnx.FunctionProto.fromObject(e4.functions[n4]);
                }
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.opsetImport = [], n4.metadataProps = [], n4.trainingInfo = [], n4.functions = []), r4.defaults) {
                if (y3.Long) {
                  var s4 = new y3.Long(0, 0, false);
                  n4.irVersion = r4.longs === String ? s4.toString() : r4.longs === Number ? s4.toNumber() : s4;
                } else
                  n4.irVersion = r4.longs === String ? "0" : 0;
                if (n4.producerName = "", n4.producerVersion = "", n4.domain = "", y3.Long) {
                  var s4 = new y3.Long(0, 0, false);
                  n4.modelVersion = r4.longs === String ? s4.toString() : r4.longs === Number ? s4.toNumber() : s4;
                } else
                  n4.modelVersion = r4.longs === String ? "0" : 0;
                n4.docString = "", n4.graph = null;
              }
              if (e4.irVersion != null && e4.hasOwnProperty("irVersion") && (typeof e4.irVersion == "number" ? n4.irVersion = r4.longs === String ? String(e4.irVersion) : e4.irVersion : n4.irVersion = r4.longs === String ? y3.Long.prototype.toString.call(e4.irVersion) : r4.longs === Number ? new y3.LongBits(e4.irVersion.low >>> 0, e4.irVersion.high >>> 0).toNumber() : e4.irVersion), e4.producerName != null && e4.hasOwnProperty("producerName") && (n4.producerName = e4.producerName), e4.producerVersion != null && e4.hasOwnProperty("producerVersion") && (n4.producerVersion = e4.producerVersion), e4.domain != null && e4.hasOwnProperty("domain") && (n4.domain = e4.domain), e4.modelVersion != null && e4.hasOwnProperty("modelVersion") && (typeof e4.modelVersion == "number" ? n4.modelVersion = r4.longs === String ? String(e4.modelVersion) : e4.modelVersion : n4.modelVersion = r4.longs === String ? y3.Long.prototype.toString.call(e4.modelVersion) : r4.longs === Number ? new y3.LongBits(e4.modelVersion.low >>> 0, e4.modelVersion.high >>> 0).toNumber() : e4.modelVersion), e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), e4.graph != null && e4.hasOwnProperty("graph") && (n4.graph = m4.onnx.GraphProto.toObject(e4.graph, r4)), e4.opsetImport && e4.opsetImport.length) {
                n4.opsetImport = [];
                for (var i5 = 0; i5 < e4.opsetImport.length; ++i5)
                  n4.opsetImport[i5] = m4.onnx.OperatorSetIdProto.toObject(e4.opsetImport[i5], r4);
              }
              if (e4.metadataProps && e4.metadataProps.length) {
                n4.metadataProps = [];
                for (var i5 = 0; i5 < e4.metadataProps.length; ++i5)
                  n4.metadataProps[i5] = m4.onnx.StringStringEntryProto.toObject(e4.metadataProps[i5], r4);
              }
              if (e4.trainingInfo && e4.trainingInfo.length) {
                n4.trainingInfo = [];
                for (var i5 = 0; i5 < e4.trainingInfo.length; ++i5)
                  n4.trainingInfo[i5] = m4.onnx.TrainingInfoProto.toObject(e4.trainingInfo[i5], r4);
              }
              if (e4.functions && e4.functions.length) {
                n4.functions = [];
                for (var i5 = 0; i5 < e4.functions.length; ++i5)
                  n4.functions[i5] = m4.onnx.FunctionProto.toObject(e4.functions[i5], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.ModelProto";
            }, t4;
          }(), a4.StringStringEntryProto = function() {
            function t4(o4) {
              if (o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.key = "", t4.prototype.value = "", t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              return r4 || (r4 = Ee4.create()), e4.key != null && Object.hasOwnProperty.call(e4, "key") && r4.uint32(10).string(e4.key), e4.value != null && Object.hasOwnProperty.call(e4, "value") && r4.uint32(18).string(e4.value), r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.StringStringEntryProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.key = e4.string();
                    break;
                  }
                  case 2: {
                    s4.value = e4.string();
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              return typeof e4 != "object" || e4 === null ? "object expected" : e4.key != null && e4.hasOwnProperty("key") && !y3.isString(e4.key) ? "key: string expected" : e4.value != null && e4.hasOwnProperty("value") && !y3.isString(e4.value) ? "value: string expected" : null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.StringStringEntryProto)
                return e4;
              var r4 = new m4.onnx.StringStringEntryProto();
              return e4.key != null && (r4.key = String(e4.key)), e4.value != null && (r4.value = String(e4.value)), r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              return r4.defaults && (n4.key = "", n4.value = ""), e4.key != null && e4.hasOwnProperty("key") && (n4.key = e4.key), e4.value != null && e4.hasOwnProperty("value") && (n4.value = e4.value), n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.StringStringEntryProto";
            }, t4;
          }(), a4.TensorAnnotation = function() {
            function t4(o4) {
              if (this.quantParameterTensorNames = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.tensorName = "", t4.prototype.quantParameterTensorNames = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.tensorName != null && Object.hasOwnProperty.call(e4, "tensorName") && r4.uint32(10).string(e4.tensorName), e4.quantParameterTensorNames != null && e4.quantParameterTensorNames.length)
                for (var n4 = 0; n4 < e4.quantParameterTensorNames.length; ++n4)
                  m4.onnx.StringStringEntryProto.encode(e4.quantParameterTensorNames[n4], r4.uint32(18).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.TensorAnnotation(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.tensorName = e4.string();
                    break;
                  }
                  case 2: {
                    s4.quantParameterTensorNames && s4.quantParameterTensorNames.length || (s4.quantParameterTensorNames = []), s4.quantParameterTensorNames.push(m4.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.tensorName != null && e4.hasOwnProperty("tensorName") && !y3.isString(e4.tensorName))
                return "tensorName: string expected";
              if (e4.quantParameterTensorNames != null && e4.hasOwnProperty("quantParameterTensorNames")) {
                if (!Array.isArray(e4.quantParameterTensorNames))
                  return "quantParameterTensorNames: array expected";
                for (var r4 = 0; r4 < e4.quantParameterTensorNames.length; ++r4) {
                  var n4 = m4.onnx.StringStringEntryProto.verify(e4.quantParameterTensorNames[r4]);
                  if (n4)
                    return "quantParameterTensorNames." + n4;
                }
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.TensorAnnotation)
                return e4;
              var r4 = new m4.onnx.TensorAnnotation();
              if (e4.tensorName != null && (r4.tensorName = String(e4.tensorName)), e4.quantParameterTensorNames) {
                if (!Array.isArray(e4.quantParameterTensorNames))
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                r4.quantParameterTensorNames = [];
                for (var n4 = 0; n4 < e4.quantParameterTensorNames.length; ++n4) {
                  if (typeof e4.quantParameterTensorNames[n4] != "object")
                    throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                  r4.quantParameterTensorNames[n4] = m4.onnx.StringStringEntryProto.fromObject(e4.quantParameterTensorNames[n4]);
                }
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.quantParameterTensorNames = []), r4.defaults && (n4.tensorName = ""), e4.tensorName != null && e4.hasOwnProperty("tensorName") && (n4.tensorName = e4.tensorName), e4.quantParameterTensorNames && e4.quantParameterTensorNames.length) {
                n4.quantParameterTensorNames = [];
                for (var s4 = 0; s4 < e4.quantParameterTensorNames.length; ++s4)
                  n4.quantParameterTensorNames[s4] = m4.onnx.StringStringEntryProto.toObject(e4.quantParameterTensorNames[s4], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorAnnotation";
            }, t4;
          }(), a4.GraphProto = function() {
            function t4(o4) {
              if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.node = y3.emptyArray, t4.prototype.name = "", t4.prototype.initializer = y3.emptyArray, t4.prototype.sparseInitializer = y3.emptyArray, t4.prototype.docString = "", t4.prototype.input = y3.emptyArray, t4.prototype.output = y3.emptyArray, t4.prototype.valueInfo = y3.emptyArray, t4.prototype.quantizationAnnotation = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.node != null && e4.node.length)
                for (var n4 = 0; n4 < e4.node.length; ++n4)
                  m4.onnx.NodeProto.encode(e4.node[n4], r4.uint32(10).fork()).ldelim();
              if (e4.name != null && Object.hasOwnProperty.call(e4, "name") && r4.uint32(18).string(e4.name), e4.initializer != null && e4.initializer.length)
                for (var n4 = 0; n4 < e4.initializer.length; ++n4)
                  m4.onnx.TensorProto.encode(e4.initializer[n4], r4.uint32(42).fork()).ldelim();
              if (e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(82).string(e4.docString), e4.input != null && e4.input.length)
                for (var n4 = 0; n4 < e4.input.length; ++n4)
                  m4.onnx.ValueInfoProto.encode(e4.input[n4], r4.uint32(90).fork()).ldelim();
              if (e4.output != null && e4.output.length)
                for (var n4 = 0; n4 < e4.output.length; ++n4)
                  m4.onnx.ValueInfoProto.encode(e4.output[n4], r4.uint32(98).fork()).ldelim();
              if (e4.valueInfo != null && e4.valueInfo.length)
                for (var n4 = 0; n4 < e4.valueInfo.length; ++n4)
                  m4.onnx.ValueInfoProto.encode(e4.valueInfo[n4], r4.uint32(106).fork()).ldelim();
              if (e4.quantizationAnnotation != null && e4.quantizationAnnotation.length)
                for (var n4 = 0; n4 < e4.quantizationAnnotation.length; ++n4)
                  m4.onnx.TensorAnnotation.encode(e4.quantizationAnnotation[n4], r4.uint32(114).fork()).ldelim();
              if (e4.sparseInitializer != null && e4.sparseInitializer.length)
                for (var n4 = 0; n4 < e4.sparseInitializer.length; ++n4)
                  m4.onnx.SparseTensorProto.encode(e4.sparseInitializer[n4], r4.uint32(122).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.GraphProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.node && s4.node.length || (s4.node = []), s4.node.push(m4.onnx.NodeProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 2: {
                    s4.name = e4.string();
                    break;
                  }
                  case 5: {
                    s4.initializer && s4.initializer.length || (s4.initializer = []), s4.initializer.push(m4.onnx.TensorProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 15: {
                    s4.sparseInitializer && s4.sparseInitializer.length || (s4.sparseInitializer = []), s4.sparseInitializer.push(m4.onnx.SparseTensorProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 10: {
                    s4.docString = e4.string();
                    break;
                  }
                  case 11: {
                    s4.input && s4.input.length || (s4.input = []), s4.input.push(m4.onnx.ValueInfoProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 12: {
                    s4.output && s4.output.length || (s4.output = []), s4.output.push(m4.onnx.ValueInfoProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 13: {
                    s4.valueInfo && s4.valueInfo.length || (s4.valueInfo = []), s4.valueInfo.push(m4.onnx.ValueInfoProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 14: {
                    s4.quantizationAnnotation && s4.quantizationAnnotation.length || (s4.quantizationAnnotation = []), s4.quantizationAnnotation.push(m4.onnx.TensorAnnotation.decode(e4, e4.uint32()));
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.node != null && e4.hasOwnProperty("node")) {
                if (!Array.isArray(e4.node))
                  return "node: array expected";
                for (var r4 = 0; r4 < e4.node.length; ++r4) {
                  var n4 = m4.onnx.NodeProto.verify(e4.node[r4]);
                  if (n4)
                    return "node." + n4;
                }
              }
              if (e4.name != null && e4.hasOwnProperty("name") && !y3.isString(e4.name))
                return "name: string expected";
              if (e4.initializer != null && e4.hasOwnProperty("initializer")) {
                if (!Array.isArray(e4.initializer))
                  return "initializer: array expected";
                for (var r4 = 0; r4 < e4.initializer.length; ++r4) {
                  var n4 = m4.onnx.TensorProto.verify(e4.initializer[r4]);
                  if (n4)
                    return "initializer." + n4;
                }
              }
              if (e4.sparseInitializer != null && e4.hasOwnProperty("sparseInitializer")) {
                if (!Array.isArray(e4.sparseInitializer))
                  return "sparseInitializer: array expected";
                for (var r4 = 0; r4 < e4.sparseInitializer.length; ++r4) {
                  var n4 = m4.onnx.SparseTensorProto.verify(e4.sparseInitializer[r4]);
                  if (n4)
                    return "sparseInitializer." + n4;
                }
              }
              if (e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString))
                return "docString: string expected";
              if (e4.input != null && e4.hasOwnProperty("input")) {
                if (!Array.isArray(e4.input))
                  return "input: array expected";
                for (var r4 = 0; r4 < e4.input.length; ++r4) {
                  var n4 = m4.onnx.ValueInfoProto.verify(e4.input[r4]);
                  if (n4)
                    return "input." + n4;
                }
              }
              if (e4.output != null && e4.hasOwnProperty("output")) {
                if (!Array.isArray(e4.output))
                  return "output: array expected";
                for (var r4 = 0; r4 < e4.output.length; ++r4) {
                  var n4 = m4.onnx.ValueInfoProto.verify(e4.output[r4]);
                  if (n4)
                    return "output." + n4;
                }
              }
              if (e4.valueInfo != null && e4.hasOwnProperty("valueInfo")) {
                if (!Array.isArray(e4.valueInfo))
                  return "valueInfo: array expected";
                for (var r4 = 0; r4 < e4.valueInfo.length; ++r4) {
                  var n4 = m4.onnx.ValueInfoProto.verify(e4.valueInfo[r4]);
                  if (n4)
                    return "valueInfo." + n4;
                }
              }
              if (e4.quantizationAnnotation != null && e4.hasOwnProperty("quantizationAnnotation")) {
                if (!Array.isArray(e4.quantizationAnnotation))
                  return "quantizationAnnotation: array expected";
                for (var r4 = 0; r4 < e4.quantizationAnnotation.length; ++r4) {
                  var n4 = m4.onnx.TensorAnnotation.verify(e4.quantizationAnnotation[r4]);
                  if (n4)
                    return "quantizationAnnotation." + n4;
                }
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.GraphProto)
                return e4;
              var r4 = new m4.onnx.GraphProto();
              if (e4.node) {
                if (!Array.isArray(e4.node))
                  throw TypeError(".onnx.GraphProto.node: array expected");
                r4.node = [];
                for (var n4 = 0; n4 < e4.node.length; ++n4) {
                  if (typeof e4.node[n4] != "object")
                    throw TypeError(".onnx.GraphProto.node: object expected");
                  r4.node[n4] = m4.onnx.NodeProto.fromObject(e4.node[n4]);
                }
              }
              if (e4.name != null && (r4.name = String(e4.name)), e4.initializer) {
                if (!Array.isArray(e4.initializer))
                  throw TypeError(".onnx.GraphProto.initializer: array expected");
                r4.initializer = [];
                for (var n4 = 0; n4 < e4.initializer.length; ++n4) {
                  if (typeof e4.initializer[n4] != "object")
                    throw TypeError(".onnx.GraphProto.initializer: object expected");
                  r4.initializer[n4] = m4.onnx.TensorProto.fromObject(e4.initializer[n4]);
                }
              }
              if (e4.sparseInitializer) {
                if (!Array.isArray(e4.sparseInitializer))
                  throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
                r4.sparseInitializer = [];
                for (var n4 = 0; n4 < e4.sparseInitializer.length; ++n4) {
                  if (typeof e4.sparseInitializer[n4] != "object")
                    throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
                  r4.sparseInitializer[n4] = m4.onnx.SparseTensorProto.fromObject(e4.sparseInitializer[n4]);
                }
              }
              if (e4.docString != null && (r4.docString = String(e4.docString)), e4.input) {
                if (!Array.isArray(e4.input))
                  throw TypeError(".onnx.GraphProto.input: array expected");
                r4.input = [];
                for (var n4 = 0; n4 < e4.input.length; ++n4) {
                  if (typeof e4.input[n4] != "object")
                    throw TypeError(".onnx.GraphProto.input: object expected");
                  r4.input[n4] = m4.onnx.ValueInfoProto.fromObject(e4.input[n4]);
                }
              }
              if (e4.output) {
                if (!Array.isArray(e4.output))
                  throw TypeError(".onnx.GraphProto.output: array expected");
                r4.output = [];
                for (var n4 = 0; n4 < e4.output.length; ++n4) {
                  if (typeof e4.output[n4] != "object")
                    throw TypeError(".onnx.GraphProto.output: object expected");
                  r4.output[n4] = m4.onnx.ValueInfoProto.fromObject(e4.output[n4]);
                }
              }
              if (e4.valueInfo) {
                if (!Array.isArray(e4.valueInfo))
                  throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                r4.valueInfo = [];
                for (var n4 = 0; n4 < e4.valueInfo.length; ++n4) {
                  if (typeof e4.valueInfo[n4] != "object")
                    throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                  r4.valueInfo[n4] = m4.onnx.ValueInfoProto.fromObject(e4.valueInfo[n4]);
                }
              }
              if (e4.quantizationAnnotation) {
                if (!Array.isArray(e4.quantizationAnnotation))
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                r4.quantizationAnnotation = [];
                for (var n4 = 0; n4 < e4.quantizationAnnotation.length; ++n4) {
                  if (typeof e4.quantizationAnnotation[n4] != "object")
                    throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                  r4.quantizationAnnotation[n4] = m4.onnx.TensorAnnotation.fromObject(e4.quantizationAnnotation[n4]);
                }
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.node = [], n4.initializer = [], n4.input = [], n4.output = [], n4.valueInfo = [], n4.quantizationAnnotation = [], n4.sparseInitializer = []), r4.defaults && (n4.name = "", n4.docString = ""), e4.node && e4.node.length) {
                n4.node = [];
                for (var s4 = 0; s4 < e4.node.length; ++s4)
                  n4.node[s4] = m4.onnx.NodeProto.toObject(e4.node[s4], r4);
              }
              if (e4.name != null && e4.hasOwnProperty("name") && (n4.name = e4.name), e4.initializer && e4.initializer.length) {
                n4.initializer = [];
                for (var s4 = 0; s4 < e4.initializer.length; ++s4)
                  n4.initializer[s4] = m4.onnx.TensorProto.toObject(e4.initializer[s4], r4);
              }
              if (e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), e4.input && e4.input.length) {
                n4.input = [];
                for (var s4 = 0; s4 < e4.input.length; ++s4)
                  n4.input[s4] = m4.onnx.ValueInfoProto.toObject(e4.input[s4], r4);
              }
              if (e4.output && e4.output.length) {
                n4.output = [];
                for (var s4 = 0; s4 < e4.output.length; ++s4)
                  n4.output[s4] = m4.onnx.ValueInfoProto.toObject(e4.output[s4], r4);
              }
              if (e4.valueInfo && e4.valueInfo.length) {
                n4.valueInfo = [];
                for (var s4 = 0; s4 < e4.valueInfo.length; ++s4)
                  n4.valueInfo[s4] = m4.onnx.ValueInfoProto.toObject(e4.valueInfo[s4], r4);
              }
              if (e4.quantizationAnnotation && e4.quantizationAnnotation.length) {
                n4.quantizationAnnotation = [];
                for (var s4 = 0; s4 < e4.quantizationAnnotation.length; ++s4)
                  n4.quantizationAnnotation[s4] = m4.onnx.TensorAnnotation.toObject(e4.quantizationAnnotation[s4], r4);
              }
              if (e4.sparseInitializer && e4.sparseInitializer.length) {
                n4.sparseInitializer = [];
                for (var s4 = 0; s4 < e4.sparseInitializer.length; ++s4)
                  n4.sparseInitializer[s4] = m4.onnx.SparseTensorProto.toObject(e4.sparseInitializer[s4], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.GraphProto";
            }, t4;
          }(), a4.TensorProto = function() {
            function t4(o4) {
              if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.dims = y3.emptyArray, t4.prototype.dataType = 0, t4.prototype.segment = null, t4.prototype.floatData = y3.emptyArray, t4.prototype.int32Data = y3.emptyArray, t4.prototype.stringData = y3.emptyArray, t4.prototype.int64Data = y3.emptyArray, t4.prototype.name = "", t4.prototype.docString = "", t4.prototype.rawData = y3.newBuffer([]), t4.prototype.externalData = y3.emptyArray, t4.prototype.dataLocation = 0, t4.prototype.doubleData = y3.emptyArray, t4.prototype.uint64Data = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.dims != null && e4.dims.length) {
                r4.uint32(10).fork();
                for (var n4 = 0; n4 < e4.dims.length; ++n4)
                  r4.int64(e4.dims[n4]);
                r4.ldelim();
              }
              if (e4.dataType != null && Object.hasOwnProperty.call(e4, "dataType") && r4.uint32(16).int32(e4.dataType), e4.segment != null && Object.hasOwnProperty.call(e4, "segment") && m4.onnx.TensorProto.Segment.encode(e4.segment, r4.uint32(26).fork()).ldelim(), e4.floatData != null && e4.floatData.length) {
                r4.uint32(34).fork();
                for (var n4 = 0; n4 < e4.floatData.length; ++n4)
                  r4.float(e4.floatData[n4]);
                r4.ldelim();
              }
              if (e4.int32Data != null && e4.int32Data.length) {
                r4.uint32(42).fork();
                for (var n4 = 0; n4 < e4.int32Data.length; ++n4)
                  r4.int32(e4.int32Data[n4]);
                r4.ldelim();
              }
              if (e4.stringData != null && e4.stringData.length)
                for (var n4 = 0; n4 < e4.stringData.length; ++n4)
                  r4.uint32(50).bytes(e4.stringData[n4]);
              if (e4.int64Data != null && e4.int64Data.length) {
                r4.uint32(58).fork();
                for (var n4 = 0; n4 < e4.int64Data.length; ++n4)
                  r4.int64(e4.int64Data[n4]);
                r4.ldelim();
              }
              if (e4.name != null && Object.hasOwnProperty.call(e4, "name") && r4.uint32(66).string(e4.name), e4.rawData != null && Object.hasOwnProperty.call(e4, "rawData") && r4.uint32(74).bytes(e4.rawData), e4.doubleData != null && e4.doubleData.length) {
                r4.uint32(82).fork();
                for (var n4 = 0; n4 < e4.doubleData.length; ++n4)
                  r4.double(e4.doubleData[n4]);
                r4.ldelim();
              }
              if (e4.uint64Data != null && e4.uint64Data.length) {
                r4.uint32(90).fork();
                for (var n4 = 0; n4 < e4.uint64Data.length; ++n4)
                  r4.uint64(e4.uint64Data[n4]);
                r4.ldelim();
              }
              if (e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(98).string(e4.docString), e4.externalData != null && e4.externalData.length)
                for (var n4 = 0; n4 < e4.externalData.length; ++n4)
                  m4.onnx.StringStringEntryProto.encode(e4.externalData[n4], r4.uint32(106).fork()).ldelim();
              return e4.dataLocation != null && Object.hasOwnProperty.call(e4, "dataLocation") && r4.uint32(112).int32(e4.dataLocation), r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.TensorProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    if (s4.dims && s4.dims.length || (s4.dims = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.dims.push(e4.int64());
                    else
                      s4.dims.push(e4.int64());
                    break;
                  }
                  case 2: {
                    s4.dataType = e4.int32();
                    break;
                  }
                  case 3: {
                    s4.segment = m4.onnx.TensorProto.Segment.decode(e4, e4.uint32());
                    break;
                  }
                  case 4: {
                    if (s4.floatData && s4.floatData.length || (s4.floatData = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.floatData.push(e4.float());
                    else
                      s4.floatData.push(e4.float());
                    break;
                  }
                  case 5: {
                    if (s4.int32Data && s4.int32Data.length || (s4.int32Data = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.int32Data.push(e4.int32());
                    else
                      s4.int32Data.push(e4.int32());
                    break;
                  }
                  case 6: {
                    s4.stringData && s4.stringData.length || (s4.stringData = []), s4.stringData.push(e4.bytes());
                    break;
                  }
                  case 7: {
                    if (s4.int64Data && s4.int64Data.length || (s4.int64Data = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.int64Data.push(e4.int64());
                    else
                      s4.int64Data.push(e4.int64());
                    break;
                  }
                  case 8: {
                    s4.name = e4.string();
                    break;
                  }
                  case 12: {
                    s4.docString = e4.string();
                    break;
                  }
                  case 9: {
                    s4.rawData = e4.bytes();
                    break;
                  }
                  case 13: {
                    s4.externalData && s4.externalData.length || (s4.externalData = []), s4.externalData.push(m4.onnx.StringStringEntryProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 14: {
                    s4.dataLocation = e4.int32();
                    break;
                  }
                  case 10: {
                    if (s4.doubleData && s4.doubleData.length || (s4.doubleData = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.doubleData.push(e4.double());
                    else
                      s4.doubleData.push(e4.double());
                    break;
                  }
                  case 11: {
                    if (s4.uint64Data && s4.uint64Data.length || (s4.uint64Data = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.uint64Data.push(e4.uint64());
                    else
                      s4.uint64Data.push(e4.uint64());
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.dims != null && e4.hasOwnProperty("dims")) {
                if (!Array.isArray(e4.dims))
                  return "dims: array expected";
                for (var r4 = 0; r4 < e4.dims.length; ++r4)
                  if (!y3.isInteger(e4.dims[r4]) && !(e4.dims[r4] && y3.isInteger(e4.dims[r4].low) && y3.isInteger(e4.dims[r4].high)))
                    return "dims: integer|Long[] expected";
              }
              if (e4.dataType != null && e4.hasOwnProperty("dataType") && !y3.isInteger(e4.dataType))
                return "dataType: integer expected";
              if (e4.segment != null && e4.hasOwnProperty("segment")) {
                var n4 = m4.onnx.TensorProto.Segment.verify(e4.segment);
                if (n4)
                  return "segment." + n4;
              }
              if (e4.floatData != null && e4.hasOwnProperty("floatData")) {
                if (!Array.isArray(e4.floatData))
                  return "floatData: array expected";
                for (var r4 = 0; r4 < e4.floatData.length; ++r4)
                  if (typeof e4.floatData[r4] != "number")
                    return "floatData: number[] expected";
              }
              if (e4.int32Data != null && e4.hasOwnProperty("int32Data")) {
                if (!Array.isArray(e4.int32Data))
                  return "int32Data: array expected";
                for (var r4 = 0; r4 < e4.int32Data.length; ++r4)
                  if (!y3.isInteger(e4.int32Data[r4]))
                    return "int32Data: integer[] expected";
              }
              if (e4.stringData != null && e4.hasOwnProperty("stringData")) {
                if (!Array.isArray(e4.stringData))
                  return "stringData: array expected";
                for (var r4 = 0; r4 < e4.stringData.length; ++r4)
                  if (!(e4.stringData[r4] && typeof e4.stringData[r4].length == "number" || y3.isString(e4.stringData[r4])))
                    return "stringData: buffer[] expected";
              }
              if (e4.int64Data != null && e4.hasOwnProperty("int64Data")) {
                if (!Array.isArray(e4.int64Data))
                  return "int64Data: array expected";
                for (var r4 = 0; r4 < e4.int64Data.length; ++r4)
                  if (!y3.isInteger(e4.int64Data[r4]) && !(e4.int64Data[r4] && y3.isInteger(e4.int64Data[r4].low) && y3.isInteger(e4.int64Data[r4].high)))
                    return "int64Data: integer|Long[] expected";
              }
              if (e4.name != null && e4.hasOwnProperty("name") && !y3.isString(e4.name))
                return "name: string expected";
              if (e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString))
                return "docString: string expected";
              if (e4.rawData != null && e4.hasOwnProperty("rawData") && !(e4.rawData && typeof e4.rawData.length == "number" || y3.isString(e4.rawData)))
                return "rawData: buffer expected";
              if (e4.externalData != null && e4.hasOwnProperty("externalData")) {
                if (!Array.isArray(e4.externalData))
                  return "externalData: array expected";
                for (var r4 = 0; r4 < e4.externalData.length; ++r4) {
                  var n4 = m4.onnx.StringStringEntryProto.verify(e4.externalData[r4]);
                  if (n4)
                    return "externalData." + n4;
                }
              }
              if (e4.dataLocation != null && e4.hasOwnProperty("dataLocation"))
                switch (e4.dataLocation) {
                  default:
                    return "dataLocation: enum value expected";
                  case 0:
                  case 1:
                    break;
                }
              if (e4.doubleData != null && e4.hasOwnProperty("doubleData")) {
                if (!Array.isArray(e4.doubleData))
                  return "doubleData: array expected";
                for (var r4 = 0; r4 < e4.doubleData.length; ++r4)
                  if (typeof e4.doubleData[r4] != "number")
                    return "doubleData: number[] expected";
              }
              if (e4.uint64Data != null && e4.hasOwnProperty("uint64Data")) {
                if (!Array.isArray(e4.uint64Data))
                  return "uint64Data: array expected";
                for (var r4 = 0; r4 < e4.uint64Data.length; ++r4)
                  if (!y3.isInteger(e4.uint64Data[r4]) && !(e4.uint64Data[r4] && y3.isInteger(e4.uint64Data[r4].low) && y3.isInteger(e4.uint64Data[r4].high)))
                    return "uint64Data: integer|Long[] expected";
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.TensorProto)
                return e4;
              var r4 = new m4.onnx.TensorProto();
              if (e4.dims) {
                if (!Array.isArray(e4.dims))
                  throw TypeError(".onnx.TensorProto.dims: array expected");
                r4.dims = [];
                for (var n4 = 0; n4 < e4.dims.length; ++n4)
                  y3.Long ? (r4.dims[n4] = y3.Long.fromValue(e4.dims[n4])).unsigned = false : typeof e4.dims[n4] == "string" ? r4.dims[n4] = parseInt(e4.dims[n4], 10) : typeof e4.dims[n4] == "number" ? r4.dims[n4] = e4.dims[n4] : typeof e4.dims[n4] == "object" && (r4.dims[n4] = new y3.LongBits(e4.dims[n4].low >>> 0, e4.dims[n4].high >>> 0).toNumber());
              }
              if (e4.dataType != null && (r4.dataType = e4.dataType | 0), e4.segment != null) {
                if (typeof e4.segment != "object")
                  throw TypeError(".onnx.TensorProto.segment: object expected");
                r4.segment = m4.onnx.TensorProto.Segment.fromObject(e4.segment);
              }
              if (e4.floatData) {
                if (!Array.isArray(e4.floatData))
                  throw TypeError(".onnx.TensorProto.floatData: array expected");
                r4.floatData = [];
                for (var n4 = 0; n4 < e4.floatData.length; ++n4)
                  r4.floatData[n4] = Number(e4.floatData[n4]);
              }
              if (e4.int32Data) {
                if (!Array.isArray(e4.int32Data))
                  throw TypeError(".onnx.TensorProto.int32Data: array expected");
                r4.int32Data = [];
                for (var n4 = 0; n4 < e4.int32Data.length; ++n4)
                  r4.int32Data[n4] = e4.int32Data[n4] | 0;
              }
              if (e4.stringData) {
                if (!Array.isArray(e4.stringData))
                  throw TypeError(".onnx.TensorProto.stringData: array expected");
                r4.stringData = [];
                for (var n4 = 0; n4 < e4.stringData.length; ++n4)
                  typeof e4.stringData[n4] == "string" ? y3.base64.decode(e4.stringData[n4], r4.stringData[n4] = y3.newBuffer(y3.base64.length(e4.stringData[n4])), 0) : e4.stringData[n4].length >= 0 && (r4.stringData[n4] = e4.stringData[n4]);
              }
              if (e4.int64Data) {
                if (!Array.isArray(e4.int64Data))
                  throw TypeError(".onnx.TensorProto.int64Data: array expected");
                r4.int64Data = [];
                for (var n4 = 0; n4 < e4.int64Data.length; ++n4)
                  y3.Long ? (r4.int64Data[n4] = y3.Long.fromValue(e4.int64Data[n4])).unsigned = false : typeof e4.int64Data[n4] == "string" ? r4.int64Data[n4] = parseInt(e4.int64Data[n4], 10) : typeof e4.int64Data[n4] == "number" ? r4.int64Data[n4] = e4.int64Data[n4] : typeof e4.int64Data[n4] == "object" && (r4.int64Data[n4] = new y3.LongBits(e4.int64Data[n4].low >>> 0, e4.int64Data[n4].high >>> 0).toNumber());
              }
              if (e4.name != null && (r4.name = String(e4.name)), e4.docString != null && (r4.docString = String(e4.docString)), e4.rawData != null && (typeof e4.rawData == "string" ? y3.base64.decode(e4.rawData, r4.rawData = y3.newBuffer(y3.base64.length(e4.rawData)), 0) : e4.rawData.length >= 0 && (r4.rawData = e4.rawData)), e4.externalData) {
                if (!Array.isArray(e4.externalData))
                  throw TypeError(".onnx.TensorProto.externalData: array expected");
                r4.externalData = [];
                for (var n4 = 0; n4 < e4.externalData.length; ++n4) {
                  if (typeof e4.externalData[n4] != "object")
                    throw TypeError(".onnx.TensorProto.externalData: object expected");
                  r4.externalData[n4] = m4.onnx.StringStringEntryProto.fromObject(e4.externalData[n4]);
                }
              }
              switch (e4.dataLocation) {
                default:
                  if (typeof e4.dataLocation == "number") {
                    r4.dataLocation = e4.dataLocation;
                    break;
                  }
                  break;
                case "DEFAULT":
                case 0:
                  r4.dataLocation = 0;
                  break;
                case "EXTERNAL":
                case 1:
                  r4.dataLocation = 1;
                  break;
              }
              if (e4.doubleData) {
                if (!Array.isArray(e4.doubleData))
                  throw TypeError(".onnx.TensorProto.doubleData: array expected");
                r4.doubleData = [];
                for (var n4 = 0; n4 < e4.doubleData.length; ++n4)
                  r4.doubleData[n4] = Number(e4.doubleData[n4]);
              }
              if (e4.uint64Data) {
                if (!Array.isArray(e4.uint64Data))
                  throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                r4.uint64Data = [];
                for (var n4 = 0; n4 < e4.uint64Data.length; ++n4)
                  y3.Long ? (r4.uint64Data[n4] = y3.Long.fromValue(e4.uint64Data[n4])).unsigned = true : typeof e4.uint64Data[n4] == "string" ? r4.uint64Data[n4] = parseInt(e4.uint64Data[n4], 10) : typeof e4.uint64Data[n4] == "number" ? r4.uint64Data[n4] = e4.uint64Data[n4] : typeof e4.uint64Data[n4] == "object" && (r4.uint64Data[n4] = new y3.LongBits(e4.uint64Data[n4].low >>> 0, e4.uint64Data[n4].high >>> 0).toNumber(true));
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.dims = [], n4.floatData = [], n4.int32Data = [], n4.stringData = [], n4.int64Data = [], n4.doubleData = [], n4.uint64Data = [], n4.externalData = []), r4.defaults && (n4.dataType = 0, n4.segment = null, n4.name = "", r4.bytes === String ? n4.rawData = "" : (n4.rawData = [], r4.bytes !== Array && (n4.rawData = y3.newBuffer(n4.rawData))), n4.docString = "", n4.dataLocation = r4.enums === String ? "DEFAULT" : 0), e4.dims && e4.dims.length) {
                n4.dims = [];
                for (var s4 = 0; s4 < e4.dims.length; ++s4)
                  typeof e4.dims[s4] == "number" ? n4.dims[s4] = r4.longs === String ? String(e4.dims[s4]) : e4.dims[s4] : n4.dims[s4] = r4.longs === String ? y3.Long.prototype.toString.call(e4.dims[s4]) : r4.longs === Number ? new y3.LongBits(e4.dims[s4].low >>> 0, e4.dims[s4].high >>> 0).toNumber() : e4.dims[s4];
              }
              if (e4.dataType != null && e4.hasOwnProperty("dataType") && (n4.dataType = e4.dataType), e4.segment != null && e4.hasOwnProperty("segment") && (n4.segment = m4.onnx.TensorProto.Segment.toObject(e4.segment, r4)), e4.floatData && e4.floatData.length) {
                n4.floatData = [];
                for (var s4 = 0; s4 < e4.floatData.length; ++s4)
                  n4.floatData[s4] = r4.json && !isFinite(e4.floatData[s4]) ? String(e4.floatData[s4]) : e4.floatData[s4];
              }
              if (e4.int32Data && e4.int32Data.length) {
                n4.int32Data = [];
                for (var s4 = 0; s4 < e4.int32Data.length; ++s4)
                  n4.int32Data[s4] = e4.int32Data[s4];
              }
              if (e4.stringData && e4.stringData.length) {
                n4.stringData = [];
                for (var s4 = 0; s4 < e4.stringData.length; ++s4)
                  n4.stringData[s4] = r4.bytes === String ? y3.base64.encode(e4.stringData[s4], 0, e4.stringData[s4].length) : r4.bytes === Array ? Array.prototype.slice.call(e4.stringData[s4]) : e4.stringData[s4];
              }
              if (e4.int64Data && e4.int64Data.length) {
                n4.int64Data = [];
                for (var s4 = 0; s4 < e4.int64Data.length; ++s4)
                  typeof e4.int64Data[s4] == "number" ? n4.int64Data[s4] = r4.longs === String ? String(e4.int64Data[s4]) : e4.int64Data[s4] : n4.int64Data[s4] = r4.longs === String ? y3.Long.prototype.toString.call(e4.int64Data[s4]) : r4.longs === Number ? new y3.LongBits(e4.int64Data[s4].low >>> 0, e4.int64Data[s4].high >>> 0).toNumber() : e4.int64Data[s4];
              }
              if (e4.name != null && e4.hasOwnProperty("name") && (n4.name = e4.name), e4.rawData != null && e4.hasOwnProperty("rawData") && (n4.rawData = r4.bytes === String ? y3.base64.encode(e4.rawData, 0, e4.rawData.length) : r4.bytes === Array ? Array.prototype.slice.call(e4.rawData) : e4.rawData), e4.doubleData && e4.doubleData.length) {
                n4.doubleData = [];
                for (var s4 = 0; s4 < e4.doubleData.length; ++s4)
                  n4.doubleData[s4] = r4.json && !isFinite(e4.doubleData[s4]) ? String(e4.doubleData[s4]) : e4.doubleData[s4];
              }
              if (e4.uint64Data && e4.uint64Data.length) {
                n4.uint64Data = [];
                for (var s4 = 0; s4 < e4.uint64Data.length; ++s4)
                  typeof e4.uint64Data[s4] == "number" ? n4.uint64Data[s4] = r4.longs === String ? String(e4.uint64Data[s4]) : e4.uint64Data[s4] : n4.uint64Data[s4] = r4.longs === String ? y3.Long.prototype.toString.call(e4.uint64Data[s4]) : r4.longs === Number ? new y3.LongBits(e4.uint64Data[s4].low >>> 0, e4.uint64Data[s4].high >>> 0).toNumber(true) : e4.uint64Data[s4];
              }
              if (e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), e4.externalData && e4.externalData.length) {
                n4.externalData = [];
                for (var s4 = 0; s4 < e4.externalData.length; ++s4)
                  n4.externalData[s4] = m4.onnx.StringStringEntryProto.toObject(e4.externalData[s4], r4);
              }
              return e4.dataLocation != null && e4.hasOwnProperty("dataLocation") && (n4.dataLocation = r4.enums === String ? m4.onnx.TensorProto.DataLocation[e4.dataLocation] === void 0 ? e4.dataLocation : m4.onnx.TensorProto.DataLocation[e4.dataLocation] : e4.dataLocation), n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorProto";
            }, t4.DataType = function() {
              var o4 = {}, e4 = Object.create(o4);
              return e4[o4[0] = "UNDEFINED"] = 0, e4[o4[1] = "FLOAT"] = 1, e4[o4[2] = "UINT8"] = 2, e4[o4[3] = "INT8"] = 3, e4[o4[4] = "UINT16"] = 4, e4[o4[5] = "INT16"] = 5, e4[o4[6] = "INT32"] = 6, e4[o4[7] = "INT64"] = 7, e4[o4[8] = "STRING"] = 8, e4[o4[9] = "BOOL"] = 9, e4[o4[10] = "FLOAT16"] = 10, e4[o4[11] = "DOUBLE"] = 11, e4[o4[12] = "UINT32"] = 12, e4[o4[13] = "UINT64"] = 13, e4[o4[14] = "COMPLEX64"] = 14, e4[o4[15] = "COMPLEX128"] = 15, e4[o4[16] = "BFLOAT16"] = 16, e4[o4[17] = "FLOAT8E4M3FN"] = 17, e4[o4[18] = "FLOAT8E4M3FNUZ"] = 18, e4[o4[19] = "FLOAT8E5M2"] = 19, e4[o4[20] = "FLOAT8E5M2FNUZ"] = 20, e4;
            }(), t4.Segment = function() {
              function o4(e4) {
                if (e4)
                  for (var r4 = Object.keys(e4), n4 = 0; n4 < r4.length; ++n4)
                    e4[r4[n4]] != null && (this[r4[n4]] = e4[r4[n4]]);
              }
              return o4.prototype.begin = y3.Long ? y3.Long.fromBits(0, 0, false) : 0, o4.prototype.end = y3.Long ? y3.Long.fromBits(0, 0, false) : 0, o4.create = function(r4) {
                return new o4(r4);
              }, o4.encode = function(r4, n4) {
                return n4 || (n4 = Ee4.create()), r4.begin != null && Object.hasOwnProperty.call(r4, "begin") && n4.uint32(8).int64(r4.begin), r4.end != null && Object.hasOwnProperty.call(r4, "end") && n4.uint32(16).int64(r4.end), n4;
              }, o4.encodeDelimited = function(r4, n4) {
                return this.encode(r4, n4).ldelim();
              }, o4.decode = function(r4, n4) {
                r4 instanceof N4 || (r4 = N4.create(r4));
                for (var s4 = n4 === void 0 ? r4.len : r4.pos + n4, i5 = new m4.onnx.TensorProto.Segment(); r4.pos < s4; ) {
                  var u4 = r4.uint32();
                  switch (u4 >>> 3) {
                    case 1: {
                      i5.begin = r4.int64();
                      break;
                    }
                    case 2: {
                      i5.end = r4.int64();
                      break;
                    }
                    default:
                      r4.skipType(u4 & 7);
                      break;
                  }
                }
                return i5;
              }, o4.decodeDelimited = function(r4) {
                return r4 instanceof N4 || (r4 = new N4(r4)), this.decode(r4, r4.uint32());
              }, o4.verify = function(r4) {
                return typeof r4 != "object" || r4 === null ? "object expected" : r4.begin != null && r4.hasOwnProperty("begin") && !y3.isInteger(r4.begin) && !(r4.begin && y3.isInteger(r4.begin.low) && y3.isInteger(r4.begin.high)) ? "begin: integer|Long expected" : r4.end != null && r4.hasOwnProperty("end") && !y3.isInteger(r4.end) && !(r4.end && y3.isInteger(r4.end.low) && y3.isInteger(r4.end.high)) ? "end: integer|Long expected" : null;
              }, o4.fromObject = function(r4) {
                if (r4 instanceof m4.onnx.TensorProto.Segment)
                  return r4;
                var n4 = new m4.onnx.TensorProto.Segment();
                return r4.begin != null && (y3.Long ? (n4.begin = y3.Long.fromValue(r4.begin)).unsigned = false : typeof r4.begin == "string" ? n4.begin = parseInt(r4.begin, 10) : typeof r4.begin == "number" ? n4.begin = r4.begin : typeof r4.begin == "object" && (n4.begin = new y3.LongBits(r4.begin.low >>> 0, r4.begin.high >>> 0).toNumber())), r4.end != null && (y3.Long ? (n4.end = y3.Long.fromValue(r4.end)).unsigned = false : typeof r4.end == "string" ? n4.end = parseInt(r4.end, 10) : typeof r4.end == "number" ? n4.end = r4.end : typeof r4.end == "object" && (n4.end = new y3.LongBits(r4.end.low >>> 0, r4.end.high >>> 0).toNumber())), n4;
              }, o4.toObject = function(r4, n4) {
                n4 || (n4 = {});
                var s4 = {};
                if (n4.defaults) {
                  if (y3.Long) {
                    var i5 = new y3.Long(0, 0, false);
                    s4.begin = n4.longs === String ? i5.toString() : n4.longs === Number ? i5.toNumber() : i5;
                  } else
                    s4.begin = n4.longs === String ? "0" : 0;
                  if (y3.Long) {
                    var i5 = new y3.Long(0, 0, false);
                    s4.end = n4.longs === String ? i5.toString() : n4.longs === Number ? i5.toNumber() : i5;
                  } else
                    s4.end = n4.longs === String ? "0" : 0;
                }
                return r4.begin != null && r4.hasOwnProperty("begin") && (typeof r4.begin == "number" ? s4.begin = n4.longs === String ? String(r4.begin) : r4.begin : s4.begin = n4.longs === String ? y3.Long.prototype.toString.call(r4.begin) : n4.longs === Number ? new y3.LongBits(r4.begin.low >>> 0, r4.begin.high >>> 0).toNumber() : r4.begin), r4.end != null && r4.hasOwnProperty("end") && (typeof r4.end == "number" ? s4.end = n4.longs === String ? String(r4.end) : r4.end : s4.end = n4.longs === String ? y3.Long.prototype.toString.call(r4.end) : n4.longs === Number ? new y3.LongBits(r4.end.low >>> 0, r4.end.high >>> 0).toNumber() : r4.end), s4;
              }, o4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, o4.getTypeUrl = function(r4) {
                return r4 === void 0 && (r4 = "type.googleapis.com"), r4 + "/onnx.TensorProto.Segment";
              }, o4;
            }(), t4.DataLocation = function() {
              var o4 = {}, e4 = Object.create(o4);
              return e4[o4[0] = "DEFAULT"] = 0, e4[o4[1] = "EXTERNAL"] = 1, e4;
            }(), t4;
          }(), a4.SparseTensorProto = function() {
            function t4(o4) {
              if (this.dims = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.values = null, t4.prototype.indices = null, t4.prototype.dims = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.values != null && Object.hasOwnProperty.call(e4, "values") && m4.onnx.TensorProto.encode(e4.values, r4.uint32(10).fork()).ldelim(), e4.indices != null && Object.hasOwnProperty.call(e4, "indices") && m4.onnx.TensorProto.encode(e4.indices, r4.uint32(18).fork()).ldelim(), e4.dims != null && e4.dims.length) {
                r4.uint32(26).fork();
                for (var n4 = 0; n4 < e4.dims.length; ++n4)
                  r4.int64(e4.dims[n4]);
                r4.ldelim();
              }
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.SparseTensorProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.values = m4.onnx.TensorProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 2: {
                    s4.indices = m4.onnx.TensorProto.decode(e4, e4.uint32());
                    break;
                  }
                  case 3: {
                    if (s4.dims && s4.dims.length || (s4.dims = []), (i5 & 7) === 2)
                      for (var u4 = e4.uint32() + e4.pos; e4.pos < u4; )
                        s4.dims.push(e4.int64());
                    else
                      s4.dims.push(e4.int64());
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.values != null && e4.hasOwnProperty("values")) {
                var r4 = m4.onnx.TensorProto.verify(e4.values);
                if (r4)
                  return "values." + r4;
              }
              if (e4.indices != null && e4.hasOwnProperty("indices")) {
                var r4 = m4.onnx.TensorProto.verify(e4.indices);
                if (r4)
                  return "indices." + r4;
              }
              if (e4.dims != null && e4.hasOwnProperty("dims")) {
                if (!Array.isArray(e4.dims))
                  return "dims: array expected";
                for (var n4 = 0; n4 < e4.dims.length; ++n4)
                  if (!y3.isInteger(e4.dims[n4]) && !(e4.dims[n4] && y3.isInteger(e4.dims[n4].low) && y3.isInteger(e4.dims[n4].high)))
                    return "dims: integer|Long[] expected";
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.SparseTensorProto)
                return e4;
              var r4 = new m4.onnx.SparseTensorProto();
              if (e4.values != null) {
                if (typeof e4.values != "object")
                  throw TypeError(".onnx.SparseTensorProto.values: object expected");
                r4.values = m4.onnx.TensorProto.fromObject(e4.values);
              }
              if (e4.indices != null) {
                if (typeof e4.indices != "object")
                  throw TypeError(".onnx.SparseTensorProto.indices: object expected");
                r4.indices = m4.onnx.TensorProto.fromObject(e4.indices);
              }
              if (e4.dims) {
                if (!Array.isArray(e4.dims))
                  throw TypeError(".onnx.SparseTensorProto.dims: array expected");
                r4.dims = [];
                for (var n4 = 0; n4 < e4.dims.length; ++n4)
                  y3.Long ? (r4.dims[n4] = y3.Long.fromValue(e4.dims[n4])).unsigned = false : typeof e4.dims[n4] == "string" ? r4.dims[n4] = parseInt(e4.dims[n4], 10) : typeof e4.dims[n4] == "number" ? r4.dims[n4] = e4.dims[n4] : typeof e4.dims[n4] == "object" && (r4.dims[n4] = new y3.LongBits(e4.dims[n4].low >>> 0, e4.dims[n4].high >>> 0).toNumber());
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.dims = []), r4.defaults && (n4.values = null, n4.indices = null), e4.values != null && e4.hasOwnProperty("values") && (n4.values = m4.onnx.TensorProto.toObject(e4.values, r4)), e4.indices != null && e4.hasOwnProperty("indices") && (n4.indices = m4.onnx.TensorProto.toObject(e4.indices, r4)), e4.dims && e4.dims.length) {
                n4.dims = [];
                for (var s4 = 0; s4 < e4.dims.length; ++s4)
                  typeof e4.dims[s4] == "number" ? n4.dims[s4] = r4.longs === String ? String(e4.dims[s4]) : e4.dims[s4] : n4.dims[s4] = r4.longs === String ? y3.Long.prototype.toString.call(e4.dims[s4]) : r4.longs === Number ? new y3.LongBits(e4.dims[s4].low >>> 0, e4.dims[s4].high >>> 0).toNumber() : e4.dims[s4];
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.SparseTensorProto";
            }, t4;
          }(), a4.TensorShapeProto = function() {
            function t4(o4) {
              if (this.dim = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.dim = y3.emptyArray, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.dim != null && e4.dim.length)
                for (var n4 = 0; n4 < e4.dim.length; ++n4)
                  m4.onnx.TensorShapeProto.Dimension.encode(e4.dim[n4], r4.uint32(10).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.TensorShapeProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.dim && s4.dim.length || (s4.dim = []), s4.dim.push(m4.onnx.TensorShapeProto.Dimension.decode(e4, e4.uint32()));
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.dim != null && e4.hasOwnProperty("dim")) {
                if (!Array.isArray(e4.dim))
                  return "dim: array expected";
                for (var r4 = 0; r4 < e4.dim.length; ++r4) {
                  var n4 = m4.onnx.TensorShapeProto.Dimension.verify(e4.dim[r4]);
                  if (n4)
                    return "dim." + n4;
                }
              }
              return null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.TensorShapeProto)
                return e4;
              var r4 = new m4.onnx.TensorShapeProto();
              if (e4.dim) {
                if (!Array.isArray(e4.dim))
                  throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                r4.dim = [];
                for (var n4 = 0; n4 < e4.dim.length; ++n4) {
                  if (typeof e4.dim[n4] != "object")
                    throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                  r4.dim[n4] = m4.onnx.TensorShapeProto.Dimension.fromObject(e4.dim[n4]);
                }
              }
              return r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.dim = []), e4.dim && e4.dim.length) {
                n4.dim = [];
                for (var s4 = 0; s4 < e4.dim.length; ++s4)
                  n4.dim[s4] = m4.onnx.TensorShapeProto.Dimension.toObject(e4.dim[s4], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorShapeProto";
            }, t4.Dimension = function() {
              function o4(r4) {
                if (r4)
                  for (var n4 = Object.keys(r4), s4 = 0; s4 < n4.length; ++s4)
                    r4[n4[s4]] != null && (this[n4[s4]] = r4[n4[s4]]);
              }
              o4.prototype.dimValue = null, o4.prototype.dimParam = null, o4.prototype.denotation = "";
              var e4;
              return Object.defineProperty(o4.prototype, "value", { get: y3.oneOfGetter(e4 = ["dimValue", "dimParam"]), set: y3.oneOfSetter(e4) }), o4.create = function(n4) {
                return new o4(n4);
              }, o4.encode = function(n4, s4) {
                return s4 || (s4 = Ee4.create()), n4.dimValue != null && Object.hasOwnProperty.call(n4, "dimValue") && s4.uint32(8).int64(n4.dimValue), n4.dimParam != null && Object.hasOwnProperty.call(n4, "dimParam") && s4.uint32(18).string(n4.dimParam), n4.denotation != null && Object.hasOwnProperty.call(n4, "denotation") && s4.uint32(26).string(n4.denotation), s4;
              }, o4.encodeDelimited = function(n4, s4) {
                return this.encode(n4, s4).ldelim();
              }, o4.decode = function(n4, s4) {
                n4 instanceof N4 || (n4 = N4.create(n4));
                for (var i5 = s4 === void 0 ? n4.len : n4.pos + s4, u4 = new m4.onnx.TensorShapeProto.Dimension(); n4.pos < i5; ) {
                  var l4 = n4.uint32();
                  switch (l4 >>> 3) {
                    case 1: {
                      u4.dimValue = n4.int64();
                      break;
                    }
                    case 2: {
                      u4.dimParam = n4.string();
                      break;
                    }
                    case 3: {
                      u4.denotation = n4.string();
                      break;
                    }
                    default:
                      n4.skipType(l4 & 7);
                      break;
                  }
                }
                return u4;
              }, o4.decodeDelimited = function(n4) {
                return n4 instanceof N4 || (n4 = new N4(n4)), this.decode(n4, n4.uint32());
              }, o4.verify = function(n4) {
                if (typeof n4 != "object" || n4 === null)
                  return "object expected";
                var s4 = {};
                if (n4.dimValue != null && n4.hasOwnProperty("dimValue") && (s4.value = 1, !y3.isInteger(n4.dimValue) && !(n4.dimValue && y3.isInteger(n4.dimValue.low) && y3.isInteger(n4.dimValue.high))))
                  return "dimValue: integer|Long expected";
                if (n4.dimParam != null && n4.hasOwnProperty("dimParam")) {
                  if (s4.value === 1)
                    return "value: multiple values";
                  if (s4.value = 1, !y3.isString(n4.dimParam))
                    return "dimParam: string expected";
                }
                return n4.denotation != null && n4.hasOwnProperty("denotation") && !y3.isString(n4.denotation) ? "denotation: string expected" : null;
              }, o4.fromObject = function(n4) {
                if (n4 instanceof m4.onnx.TensorShapeProto.Dimension)
                  return n4;
                var s4 = new m4.onnx.TensorShapeProto.Dimension();
                return n4.dimValue != null && (y3.Long ? (s4.dimValue = y3.Long.fromValue(n4.dimValue)).unsigned = false : typeof n4.dimValue == "string" ? s4.dimValue = parseInt(n4.dimValue, 10) : typeof n4.dimValue == "number" ? s4.dimValue = n4.dimValue : typeof n4.dimValue == "object" && (s4.dimValue = new y3.LongBits(n4.dimValue.low >>> 0, n4.dimValue.high >>> 0).toNumber())), n4.dimParam != null && (s4.dimParam = String(n4.dimParam)), n4.denotation != null && (s4.denotation = String(n4.denotation)), s4;
              }, o4.toObject = function(n4, s4) {
                s4 || (s4 = {});
                var i5 = {};
                return s4.defaults && (i5.denotation = ""), n4.dimValue != null && n4.hasOwnProperty("dimValue") && (typeof n4.dimValue == "number" ? i5.dimValue = s4.longs === String ? String(n4.dimValue) : n4.dimValue : i5.dimValue = s4.longs === String ? y3.Long.prototype.toString.call(n4.dimValue) : s4.longs === Number ? new y3.LongBits(n4.dimValue.low >>> 0, n4.dimValue.high >>> 0).toNumber() : n4.dimValue, s4.oneofs && (i5.value = "dimValue")), n4.dimParam != null && n4.hasOwnProperty("dimParam") && (i5.dimParam = n4.dimParam, s4.oneofs && (i5.value = "dimParam")), n4.denotation != null && n4.hasOwnProperty("denotation") && (i5.denotation = n4.denotation), i5;
              }, o4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, o4.getTypeUrl = function(n4) {
                return n4 === void 0 && (n4 = "type.googleapis.com"), n4 + "/onnx.TensorShapeProto.Dimension";
              }, o4;
            }(), t4;
          }(), a4.TypeProto = function() {
            function t4(e4) {
              if (e4)
                for (var r4 = Object.keys(e4), n4 = 0; n4 < r4.length; ++n4)
                  e4[r4[n4]] != null && (this[r4[n4]] = e4[r4[n4]]);
            }
            t4.prototype.tensorType = null, t4.prototype.sequenceType = null, t4.prototype.mapType = null, t4.prototype.optionalType = null, t4.prototype.sparseTensorType = null, t4.prototype.denotation = "";
            var o4;
            return Object.defineProperty(t4.prototype, "value", { get: y3.oneOfGetter(o4 = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]), set: y3.oneOfSetter(o4) }), t4.create = function(r4) {
              return new t4(r4);
            }, t4.encode = function(r4, n4) {
              return n4 || (n4 = Ee4.create()), r4.tensorType != null && Object.hasOwnProperty.call(r4, "tensorType") && m4.onnx.TypeProto.Tensor.encode(r4.tensorType, n4.uint32(10).fork()).ldelim(), r4.sequenceType != null && Object.hasOwnProperty.call(r4, "sequenceType") && m4.onnx.TypeProto.Sequence.encode(r4.sequenceType, n4.uint32(34).fork()).ldelim(), r4.mapType != null && Object.hasOwnProperty.call(r4, "mapType") && m4.onnx.TypeProto.Map.encode(r4.mapType, n4.uint32(42).fork()).ldelim(), r4.denotation != null && Object.hasOwnProperty.call(r4, "denotation") && n4.uint32(50).string(r4.denotation), r4.sparseTensorType != null && Object.hasOwnProperty.call(r4, "sparseTensorType") && m4.onnx.TypeProto.SparseTensor.encode(r4.sparseTensorType, n4.uint32(66).fork()).ldelim(), r4.optionalType != null && Object.hasOwnProperty.call(r4, "optionalType") && m4.onnx.TypeProto.Optional.encode(r4.optionalType, n4.uint32(74).fork()).ldelim(), n4;
            }, t4.encodeDelimited = function(r4, n4) {
              return this.encode(r4, n4).ldelim();
            }, t4.decode = function(r4, n4) {
              r4 instanceof N4 || (r4 = N4.create(r4));
              for (var s4 = n4 === void 0 ? r4.len : r4.pos + n4, i5 = new m4.onnx.TypeProto(); r4.pos < s4; ) {
                var u4 = r4.uint32();
                switch (u4 >>> 3) {
                  case 1: {
                    i5.tensorType = m4.onnx.TypeProto.Tensor.decode(r4, r4.uint32());
                    break;
                  }
                  case 4: {
                    i5.sequenceType = m4.onnx.TypeProto.Sequence.decode(r4, r4.uint32());
                    break;
                  }
                  case 5: {
                    i5.mapType = m4.onnx.TypeProto.Map.decode(r4, r4.uint32());
                    break;
                  }
                  case 9: {
                    i5.optionalType = m4.onnx.TypeProto.Optional.decode(r4, r4.uint32());
                    break;
                  }
                  case 8: {
                    i5.sparseTensorType = m4.onnx.TypeProto.SparseTensor.decode(r4, r4.uint32());
                    break;
                  }
                  case 6: {
                    i5.denotation = r4.string();
                    break;
                  }
                  default:
                    r4.skipType(u4 & 7);
                    break;
                }
              }
              return i5;
            }, t4.decodeDelimited = function(r4) {
              return r4 instanceof N4 || (r4 = new N4(r4)), this.decode(r4, r4.uint32());
            }, t4.verify = function(r4) {
              if (typeof r4 != "object" || r4 === null)
                return "object expected";
              var n4 = {};
              if (r4.tensorType != null && r4.hasOwnProperty("tensorType")) {
                n4.value = 1;
                {
                  var s4 = m4.onnx.TypeProto.Tensor.verify(r4.tensorType);
                  if (s4)
                    return "tensorType." + s4;
                }
              }
              if (r4.sequenceType != null && r4.hasOwnProperty("sequenceType")) {
                if (n4.value === 1)
                  return "value: multiple values";
                n4.value = 1;
                {
                  var s4 = m4.onnx.TypeProto.Sequence.verify(r4.sequenceType);
                  if (s4)
                    return "sequenceType." + s4;
                }
              }
              if (r4.mapType != null && r4.hasOwnProperty("mapType")) {
                if (n4.value === 1)
                  return "value: multiple values";
                n4.value = 1;
                {
                  var s4 = m4.onnx.TypeProto.Map.verify(r4.mapType);
                  if (s4)
                    return "mapType." + s4;
                }
              }
              if (r4.optionalType != null && r4.hasOwnProperty("optionalType")) {
                if (n4.value === 1)
                  return "value: multiple values";
                n4.value = 1;
                {
                  var s4 = m4.onnx.TypeProto.Optional.verify(r4.optionalType);
                  if (s4)
                    return "optionalType." + s4;
                }
              }
              if (r4.sparseTensorType != null && r4.hasOwnProperty("sparseTensorType")) {
                if (n4.value === 1)
                  return "value: multiple values";
                n4.value = 1;
                {
                  var s4 = m4.onnx.TypeProto.SparseTensor.verify(r4.sparseTensorType);
                  if (s4)
                    return "sparseTensorType." + s4;
                }
              }
              return r4.denotation != null && r4.hasOwnProperty("denotation") && !y3.isString(r4.denotation) ? "denotation: string expected" : null;
            }, t4.fromObject = function(r4) {
              if (r4 instanceof m4.onnx.TypeProto)
                return r4;
              var n4 = new m4.onnx.TypeProto();
              if (r4.tensorType != null) {
                if (typeof r4.tensorType != "object")
                  throw TypeError(".onnx.TypeProto.tensorType: object expected");
                n4.tensorType = m4.onnx.TypeProto.Tensor.fromObject(r4.tensorType);
              }
              if (r4.sequenceType != null) {
                if (typeof r4.sequenceType != "object")
                  throw TypeError(".onnx.TypeProto.sequenceType: object expected");
                n4.sequenceType = m4.onnx.TypeProto.Sequence.fromObject(r4.sequenceType);
              }
              if (r4.mapType != null) {
                if (typeof r4.mapType != "object")
                  throw TypeError(".onnx.TypeProto.mapType: object expected");
                n4.mapType = m4.onnx.TypeProto.Map.fromObject(r4.mapType);
              }
              if (r4.optionalType != null) {
                if (typeof r4.optionalType != "object")
                  throw TypeError(".onnx.TypeProto.optionalType: object expected");
                n4.optionalType = m4.onnx.TypeProto.Optional.fromObject(r4.optionalType);
              }
              if (r4.sparseTensorType != null) {
                if (typeof r4.sparseTensorType != "object")
                  throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
                n4.sparseTensorType = m4.onnx.TypeProto.SparseTensor.fromObject(r4.sparseTensorType);
              }
              return r4.denotation != null && (n4.denotation = String(r4.denotation)), n4;
            }, t4.toObject = function(r4, n4) {
              n4 || (n4 = {});
              var s4 = {};
              return n4.defaults && (s4.denotation = ""), r4.tensorType != null && r4.hasOwnProperty("tensorType") && (s4.tensorType = m4.onnx.TypeProto.Tensor.toObject(r4.tensorType, n4), n4.oneofs && (s4.value = "tensorType")), r4.sequenceType != null && r4.hasOwnProperty("sequenceType") && (s4.sequenceType = m4.onnx.TypeProto.Sequence.toObject(r4.sequenceType, n4), n4.oneofs && (s4.value = "sequenceType")), r4.mapType != null && r4.hasOwnProperty("mapType") && (s4.mapType = m4.onnx.TypeProto.Map.toObject(r4.mapType, n4), n4.oneofs && (s4.value = "mapType")), r4.denotation != null && r4.hasOwnProperty("denotation") && (s4.denotation = r4.denotation), r4.sparseTensorType != null && r4.hasOwnProperty("sparseTensorType") && (s4.sparseTensorType = m4.onnx.TypeProto.SparseTensor.toObject(r4.sparseTensorType, n4), n4.oneofs && (s4.value = "sparseTensorType")), r4.optionalType != null && r4.hasOwnProperty("optionalType") && (s4.optionalType = m4.onnx.TypeProto.Optional.toObject(r4.optionalType, n4), n4.oneofs && (s4.value = "optionalType")), s4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(r4) {
              return r4 === void 0 && (r4 = "type.googleapis.com"), r4 + "/onnx.TypeProto";
            }, t4.Tensor = function() {
              function e4(r4) {
                if (r4)
                  for (var n4 = Object.keys(r4), s4 = 0; s4 < n4.length; ++s4)
                    r4[n4[s4]] != null && (this[n4[s4]] = r4[n4[s4]]);
              }
              return e4.prototype.elemType = 0, e4.prototype.shape = null, e4.create = function(n4) {
                return new e4(n4);
              }, e4.encode = function(n4, s4) {
                return s4 || (s4 = Ee4.create()), n4.elemType != null && Object.hasOwnProperty.call(n4, "elemType") && s4.uint32(8).int32(n4.elemType), n4.shape != null && Object.hasOwnProperty.call(n4, "shape") && m4.onnx.TensorShapeProto.encode(n4.shape, s4.uint32(18).fork()).ldelim(), s4;
              }, e4.encodeDelimited = function(n4, s4) {
                return this.encode(n4, s4).ldelim();
              }, e4.decode = function(n4, s4) {
                n4 instanceof N4 || (n4 = N4.create(n4));
                for (var i5 = s4 === void 0 ? n4.len : n4.pos + s4, u4 = new m4.onnx.TypeProto.Tensor(); n4.pos < i5; ) {
                  var l4 = n4.uint32();
                  switch (l4 >>> 3) {
                    case 1: {
                      u4.elemType = n4.int32();
                      break;
                    }
                    case 2: {
                      u4.shape = m4.onnx.TensorShapeProto.decode(n4, n4.uint32());
                      break;
                    }
                    default:
                      n4.skipType(l4 & 7);
                      break;
                  }
                }
                return u4;
              }, e4.decodeDelimited = function(n4) {
                return n4 instanceof N4 || (n4 = new N4(n4)), this.decode(n4, n4.uint32());
              }, e4.verify = function(n4) {
                if (typeof n4 != "object" || n4 === null)
                  return "object expected";
                if (n4.elemType != null && n4.hasOwnProperty("elemType") && !y3.isInteger(n4.elemType))
                  return "elemType: integer expected";
                if (n4.shape != null && n4.hasOwnProperty("shape")) {
                  var s4 = m4.onnx.TensorShapeProto.verify(n4.shape);
                  if (s4)
                    return "shape." + s4;
                }
                return null;
              }, e4.fromObject = function(n4) {
                if (n4 instanceof m4.onnx.TypeProto.Tensor)
                  return n4;
                var s4 = new m4.onnx.TypeProto.Tensor();
                if (n4.elemType != null && (s4.elemType = n4.elemType | 0), n4.shape != null) {
                  if (typeof n4.shape != "object")
                    throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                  s4.shape = m4.onnx.TensorShapeProto.fromObject(n4.shape);
                }
                return s4;
              }, e4.toObject = function(n4, s4) {
                s4 || (s4 = {});
                var i5 = {};
                return s4.defaults && (i5.elemType = 0, i5.shape = null), n4.elemType != null && n4.hasOwnProperty("elemType") && (i5.elemType = n4.elemType), n4.shape != null && n4.hasOwnProperty("shape") && (i5.shape = m4.onnx.TensorShapeProto.toObject(n4.shape, s4)), i5;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, e4.getTypeUrl = function(n4) {
                return n4 === void 0 && (n4 = "type.googleapis.com"), n4 + "/onnx.TypeProto.Tensor";
              }, e4;
            }(), t4.Sequence = function() {
              function e4(r4) {
                if (r4)
                  for (var n4 = Object.keys(r4), s4 = 0; s4 < n4.length; ++s4)
                    r4[n4[s4]] != null && (this[n4[s4]] = r4[n4[s4]]);
              }
              return e4.prototype.elemType = null, e4.create = function(n4) {
                return new e4(n4);
              }, e4.encode = function(n4, s4) {
                return s4 || (s4 = Ee4.create()), n4.elemType != null && Object.hasOwnProperty.call(n4, "elemType") && m4.onnx.TypeProto.encode(n4.elemType, s4.uint32(10).fork()).ldelim(), s4;
              }, e4.encodeDelimited = function(n4, s4) {
                return this.encode(n4, s4).ldelim();
              }, e4.decode = function(n4, s4) {
                n4 instanceof N4 || (n4 = N4.create(n4));
                for (var i5 = s4 === void 0 ? n4.len : n4.pos + s4, u4 = new m4.onnx.TypeProto.Sequence(); n4.pos < i5; ) {
                  var l4 = n4.uint32();
                  switch (l4 >>> 3) {
                    case 1: {
                      u4.elemType = m4.onnx.TypeProto.decode(n4, n4.uint32());
                      break;
                    }
                    default:
                      n4.skipType(l4 & 7);
                      break;
                  }
                }
                return u4;
              }, e4.decodeDelimited = function(n4) {
                return n4 instanceof N4 || (n4 = new N4(n4)), this.decode(n4, n4.uint32());
              }, e4.verify = function(n4) {
                if (typeof n4 != "object" || n4 === null)
                  return "object expected";
                if (n4.elemType != null && n4.hasOwnProperty("elemType")) {
                  var s4 = m4.onnx.TypeProto.verify(n4.elemType);
                  if (s4)
                    return "elemType." + s4;
                }
                return null;
              }, e4.fromObject = function(n4) {
                if (n4 instanceof m4.onnx.TypeProto.Sequence)
                  return n4;
                var s4 = new m4.onnx.TypeProto.Sequence();
                if (n4.elemType != null) {
                  if (typeof n4.elemType != "object")
                    throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
                  s4.elemType = m4.onnx.TypeProto.fromObject(n4.elemType);
                }
                return s4;
              }, e4.toObject = function(n4, s4) {
                s4 || (s4 = {});
                var i5 = {};
                return s4.defaults && (i5.elemType = null), n4.elemType != null && n4.hasOwnProperty("elemType") && (i5.elemType = m4.onnx.TypeProto.toObject(n4.elemType, s4)), i5;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, e4.getTypeUrl = function(n4) {
                return n4 === void 0 && (n4 = "type.googleapis.com"), n4 + "/onnx.TypeProto.Sequence";
              }, e4;
            }(), t4.Map = function() {
              function e4(r4) {
                if (r4)
                  for (var n4 = Object.keys(r4), s4 = 0; s4 < n4.length; ++s4)
                    r4[n4[s4]] != null && (this[n4[s4]] = r4[n4[s4]]);
              }
              return e4.prototype.keyType = 0, e4.prototype.valueType = null, e4.create = function(n4) {
                return new e4(n4);
              }, e4.encode = function(n4, s4) {
                return s4 || (s4 = Ee4.create()), n4.keyType != null && Object.hasOwnProperty.call(n4, "keyType") && s4.uint32(8).int32(n4.keyType), n4.valueType != null && Object.hasOwnProperty.call(n4, "valueType") && m4.onnx.TypeProto.encode(n4.valueType, s4.uint32(18).fork()).ldelim(), s4;
              }, e4.encodeDelimited = function(n4, s4) {
                return this.encode(n4, s4).ldelim();
              }, e4.decode = function(n4, s4) {
                n4 instanceof N4 || (n4 = N4.create(n4));
                for (var i5 = s4 === void 0 ? n4.len : n4.pos + s4, u4 = new m4.onnx.TypeProto.Map(); n4.pos < i5; ) {
                  var l4 = n4.uint32();
                  switch (l4 >>> 3) {
                    case 1: {
                      u4.keyType = n4.int32();
                      break;
                    }
                    case 2: {
                      u4.valueType = m4.onnx.TypeProto.decode(n4, n4.uint32());
                      break;
                    }
                    default:
                      n4.skipType(l4 & 7);
                      break;
                  }
                }
                return u4;
              }, e4.decodeDelimited = function(n4) {
                return n4 instanceof N4 || (n4 = new N4(n4)), this.decode(n4, n4.uint32());
              }, e4.verify = function(n4) {
                if (typeof n4 != "object" || n4 === null)
                  return "object expected";
                if (n4.keyType != null && n4.hasOwnProperty("keyType") && !y3.isInteger(n4.keyType))
                  return "keyType: integer expected";
                if (n4.valueType != null && n4.hasOwnProperty("valueType")) {
                  var s4 = m4.onnx.TypeProto.verify(n4.valueType);
                  if (s4)
                    return "valueType." + s4;
                }
                return null;
              }, e4.fromObject = function(n4) {
                if (n4 instanceof m4.onnx.TypeProto.Map)
                  return n4;
                var s4 = new m4.onnx.TypeProto.Map();
                if (n4.keyType != null && (s4.keyType = n4.keyType | 0), n4.valueType != null) {
                  if (typeof n4.valueType != "object")
                    throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
                  s4.valueType = m4.onnx.TypeProto.fromObject(n4.valueType);
                }
                return s4;
              }, e4.toObject = function(n4, s4) {
                s4 || (s4 = {});
                var i5 = {};
                return s4.defaults && (i5.keyType = 0, i5.valueType = null), n4.keyType != null && n4.hasOwnProperty("keyType") && (i5.keyType = n4.keyType), n4.valueType != null && n4.hasOwnProperty("valueType") && (i5.valueType = m4.onnx.TypeProto.toObject(n4.valueType, s4)), i5;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, e4.getTypeUrl = function(n4) {
                return n4 === void 0 && (n4 = "type.googleapis.com"), n4 + "/onnx.TypeProto.Map";
              }, e4;
            }(), t4.Optional = function() {
              function e4(r4) {
                if (r4)
                  for (var n4 = Object.keys(r4), s4 = 0; s4 < n4.length; ++s4)
                    r4[n4[s4]] != null && (this[n4[s4]] = r4[n4[s4]]);
              }
              return e4.prototype.elemType = null, e4.create = function(n4) {
                return new e4(n4);
              }, e4.encode = function(n4, s4) {
                return s4 || (s4 = Ee4.create()), n4.elemType != null && Object.hasOwnProperty.call(n4, "elemType") && m4.onnx.TypeProto.encode(n4.elemType, s4.uint32(10).fork()).ldelim(), s4;
              }, e4.encodeDelimited = function(n4, s4) {
                return this.encode(n4, s4).ldelim();
              }, e4.decode = function(n4, s4) {
                n4 instanceof N4 || (n4 = N4.create(n4));
                for (var i5 = s4 === void 0 ? n4.len : n4.pos + s4, u4 = new m4.onnx.TypeProto.Optional(); n4.pos < i5; ) {
                  var l4 = n4.uint32();
                  switch (l4 >>> 3) {
                    case 1: {
                      u4.elemType = m4.onnx.TypeProto.decode(n4, n4.uint32());
                      break;
                    }
                    default:
                      n4.skipType(l4 & 7);
                      break;
                  }
                }
                return u4;
              }, e4.decodeDelimited = function(n4) {
                return n4 instanceof N4 || (n4 = new N4(n4)), this.decode(n4, n4.uint32());
              }, e4.verify = function(n4) {
                if (typeof n4 != "object" || n4 === null)
                  return "object expected";
                if (n4.elemType != null && n4.hasOwnProperty("elemType")) {
                  var s4 = m4.onnx.TypeProto.verify(n4.elemType);
                  if (s4)
                    return "elemType." + s4;
                }
                return null;
              }, e4.fromObject = function(n4) {
                if (n4 instanceof m4.onnx.TypeProto.Optional)
                  return n4;
                var s4 = new m4.onnx.TypeProto.Optional();
                if (n4.elemType != null) {
                  if (typeof n4.elemType != "object")
                    throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
                  s4.elemType = m4.onnx.TypeProto.fromObject(n4.elemType);
                }
                return s4;
              }, e4.toObject = function(n4, s4) {
                s4 || (s4 = {});
                var i5 = {};
                return s4.defaults && (i5.elemType = null), n4.elemType != null && n4.hasOwnProperty("elemType") && (i5.elemType = m4.onnx.TypeProto.toObject(n4.elemType, s4)), i5;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, e4.getTypeUrl = function(n4) {
                return n4 === void 0 && (n4 = "type.googleapis.com"), n4 + "/onnx.TypeProto.Optional";
              }, e4;
            }(), t4.SparseTensor = function() {
              function e4(r4) {
                if (r4)
                  for (var n4 = Object.keys(r4), s4 = 0; s4 < n4.length; ++s4)
                    r4[n4[s4]] != null && (this[n4[s4]] = r4[n4[s4]]);
              }
              return e4.prototype.elemType = 0, e4.prototype.shape = null, e4.create = function(n4) {
                return new e4(n4);
              }, e4.encode = function(n4, s4) {
                return s4 || (s4 = Ee4.create()), n4.elemType != null && Object.hasOwnProperty.call(n4, "elemType") && s4.uint32(8).int32(n4.elemType), n4.shape != null && Object.hasOwnProperty.call(n4, "shape") && m4.onnx.TensorShapeProto.encode(n4.shape, s4.uint32(18).fork()).ldelim(), s4;
              }, e4.encodeDelimited = function(n4, s4) {
                return this.encode(n4, s4).ldelim();
              }, e4.decode = function(n4, s4) {
                n4 instanceof N4 || (n4 = N4.create(n4));
                for (var i5 = s4 === void 0 ? n4.len : n4.pos + s4, u4 = new m4.onnx.TypeProto.SparseTensor(); n4.pos < i5; ) {
                  var l4 = n4.uint32();
                  switch (l4 >>> 3) {
                    case 1: {
                      u4.elemType = n4.int32();
                      break;
                    }
                    case 2: {
                      u4.shape = m4.onnx.TensorShapeProto.decode(n4, n4.uint32());
                      break;
                    }
                    default:
                      n4.skipType(l4 & 7);
                      break;
                  }
                }
                return u4;
              }, e4.decodeDelimited = function(n4) {
                return n4 instanceof N4 || (n4 = new N4(n4)), this.decode(n4, n4.uint32());
              }, e4.verify = function(n4) {
                if (typeof n4 != "object" || n4 === null)
                  return "object expected";
                if (n4.elemType != null && n4.hasOwnProperty("elemType") && !y3.isInteger(n4.elemType))
                  return "elemType: integer expected";
                if (n4.shape != null && n4.hasOwnProperty("shape")) {
                  var s4 = m4.onnx.TensorShapeProto.verify(n4.shape);
                  if (s4)
                    return "shape." + s4;
                }
                return null;
              }, e4.fromObject = function(n4) {
                if (n4 instanceof m4.onnx.TypeProto.SparseTensor)
                  return n4;
                var s4 = new m4.onnx.TypeProto.SparseTensor();
                if (n4.elemType != null && (s4.elemType = n4.elemType | 0), n4.shape != null) {
                  if (typeof n4.shape != "object")
                    throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
                  s4.shape = m4.onnx.TensorShapeProto.fromObject(n4.shape);
                }
                return s4;
              }, e4.toObject = function(n4, s4) {
                s4 || (s4 = {});
                var i5 = {};
                return s4.defaults && (i5.elemType = 0, i5.shape = null), n4.elemType != null && n4.hasOwnProperty("elemType") && (i5.elemType = n4.elemType), n4.shape != null && n4.hasOwnProperty("shape") && (i5.shape = m4.onnx.TensorShapeProto.toObject(n4.shape, s4)), i5;
              }, e4.prototype.toJSON = function() {
                return this.constructor.toObject(this, ge4.util.toJSONOptions);
              }, e4.getTypeUrl = function(n4) {
                return n4 === void 0 && (n4 = "type.googleapis.com"), n4 + "/onnx.TypeProto.SparseTensor";
              }, e4;
            }(), t4;
          }(), a4.OperatorSetIdProto = function() {
            function t4(o4) {
              if (o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.domain = "", t4.prototype.version = y3.Long ? y3.Long.fromBits(0, 0, false) : 0, t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              return r4 || (r4 = Ee4.create()), e4.domain != null && Object.hasOwnProperty.call(e4, "domain") && r4.uint32(10).string(e4.domain), e4.version != null && Object.hasOwnProperty.call(e4, "version") && r4.uint32(16).int64(e4.version), r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.OperatorSetIdProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.domain = e4.string();
                    break;
                  }
                  case 2: {
                    s4.version = e4.int64();
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              return typeof e4 != "object" || e4 === null ? "object expected" : e4.domain != null && e4.hasOwnProperty("domain") && !y3.isString(e4.domain) ? "domain: string expected" : e4.version != null && e4.hasOwnProperty("version") && !y3.isInteger(e4.version) && !(e4.version && y3.isInteger(e4.version.low) && y3.isInteger(e4.version.high)) ? "version: integer|Long expected" : null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.OperatorSetIdProto)
                return e4;
              var r4 = new m4.onnx.OperatorSetIdProto();
              return e4.domain != null && (r4.domain = String(e4.domain)), e4.version != null && (y3.Long ? (r4.version = y3.Long.fromValue(e4.version)).unsigned = false : typeof e4.version == "string" ? r4.version = parseInt(e4.version, 10) : typeof e4.version == "number" ? r4.version = e4.version : typeof e4.version == "object" && (r4.version = new y3.LongBits(e4.version.low >>> 0, e4.version.high >>> 0).toNumber())), r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if (r4.defaults)
                if (n4.domain = "", y3.Long) {
                  var s4 = new y3.Long(0, 0, false);
                  n4.version = r4.longs === String ? s4.toString() : r4.longs === Number ? s4.toNumber() : s4;
                } else
                  n4.version = r4.longs === String ? "0" : 0;
              return e4.domain != null && e4.hasOwnProperty("domain") && (n4.domain = e4.domain), e4.version != null && e4.hasOwnProperty("version") && (typeof e4.version == "number" ? n4.version = r4.longs === String ? String(e4.version) : e4.version : n4.version = r4.longs === String ? y3.Long.prototype.toString.call(e4.version) : r4.longs === Number ? new y3.LongBits(e4.version.low >>> 0, e4.version.high >>> 0).toNumber() : e4.version), n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.OperatorSetIdProto";
            }, t4;
          }(), a4.OperatorStatus = function() {
            var t4 = {}, o4 = Object.create(t4);
            return o4[t4[0] = "EXPERIMENTAL"] = 0, o4[t4[1] = "STABLE"] = 1, o4;
          }(), a4.FunctionProto = function() {
            function t4(o4) {
              if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], o4)
                for (var e4 = Object.keys(o4), r4 = 0; r4 < e4.length; ++r4)
                  o4[e4[r4]] != null && (this[e4[r4]] = o4[e4[r4]]);
            }
            return t4.prototype.name = "", t4.prototype.input = y3.emptyArray, t4.prototype.output = y3.emptyArray, t4.prototype.attribute = y3.emptyArray, t4.prototype.attributeProto = y3.emptyArray, t4.prototype.node = y3.emptyArray, t4.prototype.docString = "", t4.prototype.opsetImport = y3.emptyArray, t4.prototype.domain = "", t4.create = function(e4) {
              return new t4(e4);
            }, t4.encode = function(e4, r4) {
              if (r4 || (r4 = Ee4.create()), e4.name != null && Object.hasOwnProperty.call(e4, "name") && r4.uint32(10).string(e4.name), e4.input != null && e4.input.length)
                for (var n4 = 0; n4 < e4.input.length; ++n4)
                  r4.uint32(34).string(e4.input[n4]);
              if (e4.output != null && e4.output.length)
                for (var n4 = 0; n4 < e4.output.length; ++n4)
                  r4.uint32(42).string(e4.output[n4]);
              if (e4.attribute != null && e4.attribute.length)
                for (var n4 = 0; n4 < e4.attribute.length; ++n4)
                  r4.uint32(50).string(e4.attribute[n4]);
              if (e4.node != null && e4.node.length)
                for (var n4 = 0; n4 < e4.node.length; ++n4)
                  m4.onnx.NodeProto.encode(e4.node[n4], r4.uint32(58).fork()).ldelim();
              if (e4.docString != null && Object.hasOwnProperty.call(e4, "docString") && r4.uint32(66).string(e4.docString), e4.opsetImport != null && e4.opsetImport.length)
                for (var n4 = 0; n4 < e4.opsetImport.length; ++n4)
                  m4.onnx.OperatorSetIdProto.encode(e4.opsetImport[n4], r4.uint32(74).fork()).ldelim();
              if (e4.domain != null && Object.hasOwnProperty.call(e4, "domain") && r4.uint32(82).string(e4.domain), e4.attributeProto != null && e4.attributeProto.length)
                for (var n4 = 0; n4 < e4.attributeProto.length; ++n4)
                  m4.onnx.AttributeProto.encode(e4.attributeProto[n4], r4.uint32(90).fork()).ldelim();
              return r4;
            }, t4.encodeDelimited = function(e4, r4) {
              return this.encode(e4, r4).ldelim();
            }, t4.decode = function(e4, r4) {
              e4 instanceof N4 || (e4 = N4.create(e4));
              for (var n4 = r4 === void 0 ? e4.len : e4.pos + r4, s4 = new m4.onnx.FunctionProto(); e4.pos < n4; ) {
                var i5 = e4.uint32();
                switch (i5 >>> 3) {
                  case 1: {
                    s4.name = e4.string();
                    break;
                  }
                  case 4: {
                    s4.input && s4.input.length || (s4.input = []), s4.input.push(e4.string());
                    break;
                  }
                  case 5: {
                    s4.output && s4.output.length || (s4.output = []), s4.output.push(e4.string());
                    break;
                  }
                  case 6: {
                    s4.attribute && s4.attribute.length || (s4.attribute = []), s4.attribute.push(e4.string());
                    break;
                  }
                  case 11: {
                    s4.attributeProto && s4.attributeProto.length || (s4.attributeProto = []), s4.attributeProto.push(m4.onnx.AttributeProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 7: {
                    s4.node && s4.node.length || (s4.node = []), s4.node.push(m4.onnx.NodeProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 8: {
                    s4.docString = e4.string();
                    break;
                  }
                  case 9: {
                    s4.opsetImport && s4.opsetImport.length || (s4.opsetImport = []), s4.opsetImport.push(m4.onnx.OperatorSetIdProto.decode(e4, e4.uint32()));
                    break;
                  }
                  case 10: {
                    s4.domain = e4.string();
                    break;
                  }
                  default:
                    e4.skipType(i5 & 7);
                    break;
                }
              }
              return s4;
            }, t4.decodeDelimited = function(e4) {
              return e4 instanceof N4 || (e4 = new N4(e4)), this.decode(e4, e4.uint32());
            }, t4.verify = function(e4) {
              if (typeof e4 != "object" || e4 === null)
                return "object expected";
              if (e4.name != null && e4.hasOwnProperty("name") && !y3.isString(e4.name))
                return "name: string expected";
              if (e4.input != null && e4.hasOwnProperty("input")) {
                if (!Array.isArray(e4.input))
                  return "input: array expected";
                for (var r4 = 0; r4 < e4.input.length; ++r4)
                  if (!y3.isString(e4.input[r4]))
                    return "input: string[] expected";
              }
              if (e4.output != null && e4.hasOwnProperty("output")) {
                if (!Array.isArray(e4.output))
                  return "output: array expected";
                for (var r4 = 0; r4 < e4.output.length; ++r4)
                  if (!y3.isString(e4.output[r4]))
                    return "output: string[] expected";
              }
              if (e4.attribute != null && e4.hasOwnProperty("attribute")) {
                if (!Array.isArray(e4.attribute))
                  return "attribute: array expected";
                for (var r4 = 0; r4 < e4.attribute.length; ++r4)
                  if (!y3.isString(e4.attribute[r4]))
                    return "attribute: string[] expected";
              }
              if (e4.attributeProto != null && e4.hasOwnProperty("attributeProto")) {
                if (!Array.isArray(e4.attributeProto))
                  return "attributeProto: array expected";
                for (var r4 = 0; r4 < e4.attributeProto.length; ++r4) {
                  var n4 = m4.onnx.AttributeProto.verify(e4.attributeProto[r4]);
                  if (n4)
                    return "attributeProto." + n4;
                }
              }
              if (e4.node != null && e4.hasOwnProperty("node")) {
                if (!Array.isArray(e4.node))
                  return "node: array expected";
                for (var r4 = 0; r4 < e4.node.length; ++r4) {
                  var n4 = m4.onnx.NodeProto.verify(e4.node[r4]);
                  if (n4)
                    return "node." + n4;
                }
              }
              if (e4.docString != null && e4.hasOwnProperty("docString") && !y3.isString(e4.docString))
                return "docString: string expected";
              if (e4.opsetImport != null && e4.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(e4.opsetImport))
                  return "opsetImport: array expected";
                for (var r4 = 0; r4 < e4.opsetImport.length; ++r4) {
                  var n4 = m4.onnx.OperatorSetIdProto.verify(e4.opsetImport[r4]);
                  if (n4)
                    return "opsetImport." + n4;
                }
              }
              return e4.domain != null && e4.hasOwnProperty("domain") && !y3.isString(e4.domain) ? "domain: string expected" : null;
            }, t4.fromObject = function(e4) {
              if (e4 instanceof m4.onnx.FunctionProto)
                return e4;
              var r4 = new m4.onnx.FunctionProto();
              if (e4.name != null && (r4.name = String(e4.name)), e4.input) {
                if (!Array.isArray(e4.input))
                  throw TypeError(".onnx.FunctionProto.input: array expected");
                r4.input = [];
                for (var n4 = 0; n4 < e4.input.length; ++n4)
                  r4.input[n4] = String(e4.input[n4]);
              }
              if (e4.output) {
                if (!Array.isArray(e4.output))
                  throw TypeError(".onnx.FunctionProto.output: array expected");
                r4.output = [];
                for (var n4 = 0; n4 < e4.output.length; ++n4)
                  r4.output[n4] = String(e4.output[n4]);
              }
              if (e4.attribute) {
                if (!Array.isArray(e4.attribute))
                  throw TypeError(".onnx.FunctionProto.attribute: array expected");
                r4.attribute = [];
                for (var n4 = 0; n4 < e4.attribute.length; ++n4)
                  r4.attribute[n4] = String(e4.attribute[n4]);
              }
              if (e4.attributeProto) {
                if (!Array.isArray(e4.attributeProto))
                  throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
                r4.attributeProto = [];
                for (var n4 = 0; n4 < e4.attributeProto.length; ++n4) {
                  if (typeof e4.attributeProto[n4] != "object")
                    throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
                  r4.attributeProto[n4] = m4.onnx.AttributeProto.fromObject(e4.attributeProto[n4]);
                }
              }
              if (e4.node) {
                if (!Array.isArray(e4.node))
                  throw TypeError(".onnx.FunctionProto.node: array expected");
                r4.node = [];
                for (var n4 = 0; n4 < e4.node.length; ++n4) {
                  if (typeof e4.node[n4] != "object")
                    throw TypeError(".onnx.FunctionProto.node: object expected");
                  r4.node[n4] = m4.onnx.NodeProto.fromObject(e4.node[n4]);
                }
              }
              if (e4.docString != null && (r4.docString = String(e4.docString)), e4.opsetImport) {
                if (!Array.isArray(e4.opsetImport))
                  throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
                r4.opsetImport = [];
                for (var n4 = 0; n4 < e4.opsetImport.length; ++n4) {
                  if (typeof e4.opsetImport[n4] != "object")
                    throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
                  r4.opsetImport[n4] = m4.onnx.OperatorSetIdProto.fromObject(e4.opsetImport[n4]);
                }
              }
              return e4.domain != null && (r4.domain = String(e4.domain)), r4;
            }, t4.toObject = function(e4, r4) {
              r4 || (r4 = {});
              var n4 = {};
              if ((r4.arrays || r4.defaults) && (n4.input = [], n4.output = [], n4.attribute = [], n4.node = [], n4.opsetImport = [], n4.attributeProto = []), r4.defaults && (n4.name = "", n4.docString = "", n4.domain = ""), e4.name != null && e4.hasOwnProperty("name") && (n4.name = e4.name), e4.input && e4.input.length) {
                n4.input = [];
                for (var s4 = 0; s4 < e4.input.length; ++s4)
                  n4.input[s4] = e4.input[s4];
              }
              if (e4.output && e4.output.length) {
                n4.output = [];
                for (var s4 = 0; s4 < e4.output.length; ++s4)
                  n4.output[s4] = e4.output[s4];
              }
              if (e4.attribute && e4.attribute.length) {
                n4.attribute = [];
                for (var s4 = 0; s4 < e4.attribute.length; ++s4)
                  n4.attribute[s4] = e4.attribute[s4];
              }
              if (e4.node && e4.node.length) {
                n4.node = [];
                for (var s4 = 0; s4 < e4.node.length; ++s4)
                  n4.node[s4] = m4.onnx.NodeProto.toObject(e4.node[s4], r4);
              }
              if (e4.docString != null && e4.hasOwnProperty("docString") && (n4.docString = e4.docString), e4.opsetImport && e4.opsetImport.length) {
                n4.opsetImport = [];
                for (var s4 = 0; s4 < e4.opsetImport.length; ++s4)
                  n4.opsetImport[s4] = m4.onnx.OperatorSetIdProto.toObject(e4.opsetImport[s4], r4);
              }
              if (e4.domain != null && e4.hasOwnProperty("domain") && (n4.domain = e4.domain), e4.attributeProto && e4.attributeProto.length) {
                n4.attributeProto = [];
                for (var s4 = 0; s4 < e4.attributeProto.length; ++s4)
                  n4.attributeProto[s4] = m4.onnx.AttributeProto.toObject(e4.attributeProto[s4], r4);
              }
              return n4;
            }, t4.prototype.toJSON = function() {
              return this.constructor.toObject(this, ge4.util.toJSONOptions);
            }, t4.getTypeUrl = function(e4) {
              return e4 === void 0 && (e4 = "type.googleapis.com"), e4 + "/onnx.FunctionProto";
            }, t4;
          }(), a4;
        }();
        Bu2.exports = m4;
      });
      function kr(a4, t4) {
        if (!a4)
          throw new Error(typeof t4 == "string" ? t4 : t4());
      }
      function ln(a4) {
        return new TextDecoder().decode(a4);
      }
      var ye;
      var hr;
      var mi;
      var Ke;
      var Xn;
      var Ve;
      var nt;
      var U;
      var un;
      var mr;
      var br;
      var gr;
      var fe = E(() => {
        "use strict";
        Wn();
        ti();
        ye = Dr($r());
        yr();
        hr = class {
          static arraysEqual(t4, o4) {
            if (t4.length !== o4.length)
              return false;
            for (let e4 = 0; e4 < t4.length; e4++)
              if (t4[e4] !== o4[e4])
                return false;
            return true;
          }
        }, mi = class {
          static preprocessInputShapes(t4, o4) {
            let e4 = t4.length === 1 ? [1, t4[0]] : t4, r4 = o4.length === 1 ? [o4[0], 1] : o4;
            return [e4, r4];
          }
          static postprocessOutputShape(t4, o4, e4) {
            o4 === 1 && t4.splice(t4.length - 2, 1), e4 === 1 && t4.pop();
          }
          static calcMatMulShape(t4, o4) {
            return t4[1] !== o4[0] ? void 0 : [t4[0], o4[1]];
          }
        }, Ke = class a4 {
          static calcShape(t4, o4, e4 = false) {
            let r4 = t4.length, n4 = o4.length;
            if (r4 === 0)
              return o4;
            if (n4 === 0)
              return t4;
            let s4 = Math.max(t4.length, o4.length), i5 = new Array(s4);
            if (e4) {
              if (r4 < 2 || n4 < 2)
                return;
              let u4 = mi.calcMatMulShape([t4[r4 - 2], t4[r4 - 1]], [o4[n4 - 2], o4[n4 - 1]]);
              if (u4 === void 0)
                return;
              [i5[s4 - 2], i5[s4 - 1]] = u4;
            }
            for (let u4 = e4 ? 3 : 1; u4 <= s4; u4++) {
              let l4 = r4 - u4 < 0 ? 1 : t4[r4 - u4], f3 = n4 - u4 < 0 ? 1 : o4[n4 - u4];
              if (l4 !== f3 && l4 > 1 && f3 > 1)
                return;
              i5[s4 - u4] = Math.max(l4, f3);
            }
            return i5;
          }
          static index(t4, o4) {
            let e4 = new Array(o4.length);
            return a4.fillIndex(t4, o4, e4), e4;
          }
          static fillIndex(t4, o4, e4) {
            let r4 = t4.length - o4.length;
            for (let n4 = 0; n4 < o4.length; n4++)
              e4[n4] = t4[r4 + n4] % o4[n4];
          }
          static calc(t4, o4, e4, r4, n4) {
            let s4 = a4.calcShape(t4.dims, o4.dims);
            if (s4) {
              if (r4 && !U.areEqual(s4, t4.dims))
                return;
              let i5 = U.size(s4), u4 = r4 ? t4 : new Ce(s4, n4 || t4.type);
              if (s4.length === 0)
                u4.set([], e4(t4.get([]), o4.get([])));
              else {
                let l4 = new Array(s4.length), f3 = new Array(t4.dims.length), p4 = new Array(o4.dims.length), d4 = 0, T3 = 0, v5 = false, w3 = false;
                t4.dims.length === 0 && (d4 = t4.get([]), v5 = true), o4.dims.length === 0 && (T3 = o4.get([]), w3 = true);
                let I3;
                for (let L3 = 0; L3 < i5; L3++) {
                  I3 = L3;
                  for (let F4 = s4.length - 1; F4 >= 0; F4--)
                    l4[F4] = I3 % s4[F4], I3 = Math.floor(I3 / s4[F4]);
                  v5 || (a4.fillIndex(l4, t4.dims, f3), d4 = t4.get(f3)), w3 || (a4.fillIndex(l4, o4.dims, p4), T3 = o4.get(p4)), u4.set(l4, e4(d4, T3));
                }
              }
              return u4;
            }
          }
          static isValidBroadcast(t4, o4) {
            let e4 = t4.length, r4 = o4.length;
            if (e4 > r4)
              return false;
            for (let n4 = 1; n4 <= e4; n4++)
              if (t4[e4 - n4] !== 1 && t4[e4 - n4] !== o4[r4 - n4])
                return false;
            return true;
          }
          static getBroadcastDims(t4, o4) {
            let e4 = t4.length, r4 = [];
            for (let n4 = 0; n4 < e4; n4++) {
              let s4 = e4 - 1 - n4, i5 = t4[s4] || 1;
              (o4[o4.length - 1 - n4] || 1) > 1 && i5 === 1 && r4.unshift(s4);
            }
            return r4;
          }
        }, Xn = class {
          static getShapeOfGemmResult(t4, o4, e4, r4, n4) {
            if (t4.length !== 2 || e4.length !== 2)
              throw new Error("shape need to be of size 2");
            let s4, i5, u4;
            o4 ? (s4 = t4[1], i5 = t4[0]) : (s4 = t4[0], i5 = t4[1]);
            let l4 = -1;
            if (r4 ? (u4 = e4[0], l4 = 1) : (u4 = e4[1], l4 = 0), e4[l4] !== i5)
              throw new Error("dimension mismatch");
            if (s4 <= 0 || u4 <= 0 || i5 <= 0)
              throw new Error("invalid shape specified");
            if (n4 && !Ke.isValidBroadcast(n4, [s4, u4]))
              throw new Error("gemm: invalid bias shape for broadcast");
            return [s4, u4, i5];
          }
        }, Ve = class a4 {
          static tensorDataTypeFromProto(t4) {
            switch (t4) {
              case ye.onnx.TensorProto.DataType.INT8:
                return "int8";
              case ye.onnx.TensorProto.DataType.UINT8:
                return "uint8";
              case ye.onnx.TensorProto.DataType.BOOL:
                return "bool";
              case ye.onnx.TensorProto.DataType.INT16:
                return "int16";
              case ye.onnx.TensorProto.DataType.UINT16:
                return "uint16";
              case ye.onnx.TensorProto.DataType.INT32:
                return "int32";
              case ye.onnx.TensorProto.DataType.UINT32:
                return "uint32";
              case ye.onnx.TensorProto.DataType.FLOAT:
                return "float32";
              case ye.onnx.TensorProto.DataType.DOUBLE:
                return "float64";
              case ye.onnx.TensorProto.DataType.STRING:
                return "string";
              case ye.onnx.TensorProto.DataType.INT64:
                return "int32";
              case ye.onnx.TensorProto.DataType.UINT64:
                return "uint32";
              default:
                throw new Error(`unsupported data type: ${ye.onnx.TensorProto.DataType[t4]}`);
            }
          }
          static tensorDataTypeStringToEnum(t4) {
            switch (t4) {
              case "int8":
                return ye.onnx.TensorProto.DataType.INT8;
              case "uint8":
                return ye.onnx.TensorProto.DataType.UINT8;
              case "bool":
                return ye.onnx.TensorProto.DataType.BOOL;
              case "int16":
                return ye.onnx.TensorProto.DataType.INT16;
              case "uint16":
                return ye.onnx.TensorProto.DataType.UINT16;
              case "int32":
                return ye.onnx.TensorProto.DataType.INT32;
              case "uint32":
                return ye.onnx.TensorProto.DataType.UINT32;
              case "float32":
                return ye.onnx.TensorProto.DataType.FLOAT;
              case "float64":
                return ye.onnx.TensorProto.DataType.DOUBLE;
              case "string":
                return ye.onnx.TensorProto.DataType.STRING;
              case "int64":
                return ye.onnx.TensorProto.DataType.INT64;
              case "uint64":
                return ye.onnx.TensorProto.DataType.UINT64;
              default:
                throw new Error(`unsupported data type: ${t4}`);
            }
          }
          static tensorDimsFromProto(t4) {
            return t4.map((o4) => Wt.isLong(o4) ? o4.toNumber() : o4);
          }
          static tensorValueTypeFromProto(t4) {
            return { tensorType: a4.tensorDataTypeFromProto(t4.elemType), shape: { dims: a4.tensorDimsFromProto(t4.shape.dim.map((o4) => o4.dimValue)) } };
          }
          static tensorDimsFromORTFormat(t4) {
            let o4 = [];
            for (let e4 = 0; e4 < t4.dimsLength(); e4++)
              o4.push(nt.longToNumber(t4.dims(e4)));
            return o4;
          }
          static tensorAttributesFromORTFormat(t4) {
            let o4 = [];
            for (let e4 = 0; e4 < t4.attributesLength(); e4++)
              o4.push(t4.attributes(e4));
            return o4;
          }
        }, nt = class {
          static longToNumber(t4, o4) {
            return Wt.isLong(t4) ? t4.toNumber() : t4 instanceof O.Long ? Wt.fromValue({ low: t4.low, high: t4.high, unsigned: o4 ?? false }).toNumber() : t4;
          }
          static isLong(t4) {
            return Wt.isLong(t4) || t4 instanceof O.Long;
          }
        }, U = class a4 {
          static size(t4) {
            return a4.getSizeFromDimensionRange(t4, 0, t4.length);
          }
          static sizeFromDimension(t4, o4) {
            if (o4 < 0 || o4 > t4.length)
              throw new Error(`invalid dimension of ${o4} for sizeFromDimension as Tensor has ${t4.length} dimensions.`);
            return a4.getSizeFromDimensionRange(t4, o4, t4.length);
          }
          static sizeToDimension(t4, o4) {
            if (o4 < 0 || o4 > t4.length)
              throw new Error(`invalid dimension of ${o4} for sizeToDimension as Tensor has ${t4.length} dimensions.`);
            return a4.getSizeFromDimensionRange(t4, 0, o4);
          }
          static getSizeFromDimensionRange(t4, o4, e4) {
            let r4 = 1;
            for (let n4 = o4; n4 < e4; n4++) {
              if (t4[n4] <= 0)
                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
              r4 *= t4[n4];
            }
            return r4;
          }
          static computeStrides(t4) {
            let o4 = t4.length;
            if (o4 === 0)
              return [];
            if (o4 === 1)
              return [1];
            let e4 = new Array(o4);
            e4[o4 - 1] = 1, e4[o4 - 2] = t4[o4 - 1];
            for (let r4 = o4 - 3; r4 >= 0; --r4)
              e4[r4] = e4[r4 + 1] * t4[r4 + 1];
            return e4;
          }
          static transpose(t4) {
            return t4.slice().reverse();
          }
          static indicesToOffset(t4, o4, e4) {
            e4 === void 0 && (e4 = t4.length);
            let r4 = 0;
            for (let n4 = 0; n4 < e4; ++n4)
              r4 += o4[n4] * t4[n4];
            return r4;
          }
          static offsetToIndices(t4, o4) {
            let e4 = o4.length;
            if (e4 === 0)
              return [];
            if (e4 === 1)
              return [t4 * o4[0]];
            let r4 = new Array(o4.length);
            for (let n4 = 0; n4 < r4.length - 1; ++n4)
              r4[n4] = Math.floor(t4 / o4[n4]), t4 -= r4[n4] * o4[n4];
            return r4[r4.length - 1] = t4, r4;
          }
          static normalizeAxis(t4, o4) {
            if (t4 < -o4 && t4 >= o4)
              throw new Error("unsupported axis for this operation.");
            return t4 < 0 ? t4 + o4 : t4;
          }
          static normalizeAxes(t4, o4) {
            return t4.map((e4) => this.normalizeAxis(e4, o4));
          }
          static incrementIndex(t4, o4, e4) {
            if (o4.length === 0 || t4.length === 0)
              throw new Error("Index incrementing unsupported for scalar Tensor");
            if (e4 === void 0)
              e4 = o4.length;
            else if (e4 <= 0 || e4 > o4.length)
              throw new Error("Incorrect axis to increment on");
            for (let r4 = e4 - 1; r4 >= 0 && (t4[r4]++, !(t4[r4] < o4[r4])); --r4)
              t4[r4] = 0;
          }
          static calculateReshapedDims(t4, o4) {
            if (o4.length === 0) {
              if (t4.length === 0 || a4.size(t4) === 1)
                return [];
              throw new Error("cannot reshape to a scalar Tensor");
            }
            let e4 = o4.length, r4 = new Array(e4), n4 = -1, s4 = 1;
            for (let u4 = 0; u4 < e4; u4++) {
              if (o4[u4] < -1)
                throw new Error("a dimension in shape hints cannot be less than -1");
              if (o4[u4] === -1) {
                if (n4 !== -1)
                  throw new Error("at most one dimension in shape hints can be -1");
                n4 = u4;
              } else {
                if (o4[u4] === 0) {
                  if (u4 >= t4.length)
                    throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                  r4[u4] = t4[u4];
                } else
                  r4[u4] = o4[u4];
                s4 *= r4[u4];
              }
            }
            let i5 = a4.size(t4);
            if (n4 !== -1) {
              if (i5 % s4 !== 0)
                throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t4}] Output shape: [${o4}]`);
              r4[n4] = i5 / s4;
            } else if (s4 !== i5)
              throw new Error("reshapedDims and originalDims don't have matching sizes");
            return r4;
          }
          static sortBasedOnPerm(t4, o4) {
            return o4 ? o4.map((e4) => t4[e4]) : t4.slice().reverse();
          }
          static padShape(t4, o4) {
            let e4 = t4.length;
            return t4.map((r4, n4) => r4 + o4[n4] + o4[n4 + e4]);
          }
          static areEqual(t4, o4) {
            return t4.length !== o4.length ? false : t4.every((e4, r4) => e4 === o4[r4]);
          }
          static validateDimsAndCalcSize(t4) {
            if (t4.length > 6)
              throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
            let o4 = 1;
            for (let e4 of t4) {
              if (!Number.isInteger(e4))
                throw new TypeError(`Invalid shape: ${e4} is not an integer`);
              if (e4 < 0 || e4 > 2147483647)
                throw new TypeError(`Invalid shape: length ${e4} is not allowed`);
              o4 *= e4;
            }
            return o4;
          }
          static flattenShape(t4, o4) {
            o4 < 0 && (o4 += t4.length);
            let e4 = t4.reduce((s4, i5) => s4 * i5, 1), r4 = t4.slice(o4).reduce((s4, i5) => s4 * i5, 1);
            return [e4 / r4, r4];
          }
          static squeezeShape(t4, o4) {
            let e4 = new Array();
            o4 = a4.normalizeAxes(o4, t4.length);
            for (let r4 = 0; r4 < t4.length; r4++) {
              let n4 = o4.indexOf(r4) >= 0;
              if (n4 && t4[r4] !== 1)
                throw new Error("squeeze an axis of size different than 1");
              (o4.length === 0 && t4[r4] > 1 || o4.length > 0 && !n4) && e4.push(t4[r4]);
            }
            return e4;
          }
          static unsqueezeShape(t4, o4) {
            let e4 = new Array(t4.length + o4.length);
            e4.fill(0);
            for (let n4 = 0; n4 < o4.length; n4++) {
              let s4 = a4.normalizeAxis(o4[n4], e4.length);
              if (s4 >= e4.length)
                throw new Error("'axes' has an out of range axis");
              if (e4[s4] !== 0)
                throw new Error("'axes' has a duplicate axis");
              e4[s4] = 1;
            }
            let r4 = 0;
            for (let n4 = 0; n4 < e4.length; n4++)
              e4[n4] === 0 && (e4[n4] = t4[r4++]);
            if (r4 !== t4.length)
              throw new Error("the unsqueezed dimension could not be established");
            return e4;
          }
        }, un = class a4 {
          static splitShape(t4, o4, e4, r4) {
            if (e4.length === 0) {
              if (!r4)
                throw new Error("need to know number of outputs when the 'split' attribute is not specified");
              a4.determineSplit(t4[o4], r4, e4);
            }
            let n4 = [], s4 = [0];
            for (let i5 = 0; i5 < e4.length; ++i5) {
              i5 !== 0 && s4.push(s4[i5 - 1] + e4[i5 - 1]);
              let u4 = t4.slice();
              u4[o4] = e4[i5], n4.push(u4);
            }
            return [n4, s4];
          }
          static determineSplit(t4, o4, e4) {
            if (t4 % o4 !== 0)
              throw new Error("cannot split tensor to equal sized parts");
            for (let r4 = 0; r4 < o4; ++r4)
              e4.push(t4 / o4);
          }
        }, mr = class a4 {
          static adjustPoolAttributes(t4, o4, e4, r4, n4, s4) {
            if (!t4 && e4.length !== o4.length - 2)
              throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
            if (t4)
              for (let i5 = 0; i5 < o4.length - 2; i5++)
                i5 >= e4.length ? e4.push(o4[i5 + 2]) : e4[i5] = o4[i5 + 2];
            for (let i5 = 0; i5 < e4.length; i5++)
              if (i5 < r4.length) {
                if (r4[i5] < 0)
                  throw new Error("strides should be greater than or equal to 1");
              } else
                r4.push(1);
            for (let i5 = 0; i5 < e4.length; i5++)
              if (i5 < n4.length) {
                if (n4[i5] < 0)
                  throw new Error("dilations should be greater than or equal to 1");
              } else
                n4.push(1);
            for (let i5 = 0; i5 < e4.length * 2; i5++)
              if (i5 < s4.length) {
                if (s4[i5] < 0)
                  throw new Error("pad should be greater than or equal to 1");
              } else
                s4.push(0);
            for (let i5 = 0; i5 < e4.length; i5++) {
              if (e4[i5] <= 0)
                throw new Error("kernel shapes need to be greater than 0");
              if (s4[i5] >= e4[i5] || s4[i5 + e4.length] >= e4[i5])
                throw new Error("pads should be smaller than kernel");
            }
          }
          static adjustPadsBasedOnAutoPad(t4, o4, e4, r4, n4, s4) {
            if (s4) {
              if (n4.length !== 2 * (t4.length - 2))
                throw new Error("length of pads should be twice the length of data dimensions");
              if (o4.length !== t4.length - 2)
                throw new Error("length of strides should be the length of data dimensions");
              if (r4.length !== t4.length - 2)
                throw new Error("length of kernel shapes should be the length of data dimensions");
              for (let i5 = 0; i5 < t4.length - 2; i5++)
                a4.adjustPadAndReturnShape(t4[i5 + 2], o4[i5], e4[i5], r4[i5], n4, i5, i5 + t4.length - 2, s4);
            }
          }
          static computePoolOutputShape(t4, o4, e4, r4, n4, s4, i5) {
            if (o4.length <= 0)
              throw new Error("input shape must be of size greater than 0");
            let u4 = [o4[0], o4[1]];
            return a4.computeShapeHelper(t4, o4, u4, e4, r4, n4, s4, i5), u4;
          }
          static computeConvOutputShape(t4, o4, e4, r4, n4, s4, i5) {
            if (t4.length <= 0 || o4.length <= 0)
              throw new Error("invalid input tensor dims or invalid filter tensor dims");
            let u4 = [t4[0], o4[0]];
            return a4.computeShapeHelper(false, t4, u4, e4, r4, n4, s4, i5), u4;
          }
          static computeShapeHelper(t4, o4, e4, r4, n4, s4, i5, u4) {
            if (t4)
              for (let l4 = 0; l4 < o4.length - 2; l4++)
                e4.push(1);
            else
              for (let l4 = 0; l4 < o4.length - 2; l4++)
                e4.push(a4.adjustPadAndReturnShape(o4[l4 + 2], r4[l4], n4[l4], s4[l4], i5, l4, l4 + o4.length - 2, u4));
          }
          static adjustPadAndReturnShape(t4, o4, e4, r4, n4, s4, i5, u4) {
            let l4 = e4 * (r4 - 1) + 1;
            if (u4 && u4 !== "NOTSET")
              switch (u4) {
                case "VALID":
                  return n4[s4] = 0, n4[i5] = 0, Math.floor((t4 - l4) / o4 + 1);
                case "SAME_LOWER":
                case "SAME_UPPER":
                  if (e4 !== 1)
                    throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                  {
                    let p4 = ((t4 + o4 - 1) / o4 - 1) * o4 + r4 - t4;
                    return n4[s4] = Math.floor(u4 === "SAME_LOWER" ? (p4 + 1) / 2 : p4 / 2), n4[i5] = p4 - n4[s4], Math.floor((t4 + p4 - r4) / o4 + 1);
                  }
                default:
                  throw new Error("Unsupported AutoPad type");
              }
            else
              return Math.floor((t4 + n4[s4] + n4[i5] - l4) / o4 + 1);
          }
        }, br = -34028234663852886e22, gr = 34028234663852886e22;
      });
      function jd(a4) {
        switch (a4) {
          case "bool":
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          case "float64":
            return 8;
          default:
            throw new Error(`cannot calculate sizeof() on type ${a4}`);
        }
      }
      function Nu(a4) {
        switch (a4) {
          case re.onnx.TensorProto.DataType.UINT8:
          case re.onnx.TensorProto.DataType.INT8:
          case re.onnx.TensorProto.DataType.BOOL:
            return 1;
          case re.onnx.TensorProto.DataType.UINT16:
          case re.onnx.TensorProto.DataType.INT16:
            return 2;
          case re.onnx.TensorProto.DataType.FLOAT:
          case re.onnx.TensorProto.DataType.INT32:
          case re.onnx.TensorProto.DataType.UINT32:
            return 4;
          case re.onnx.TensorProto.DataType.INT64:
          case re.onnx.TensorProto.DataType.DOUBLE:
          case re.onnx.TensorProto.DataType.UINT64:
            return 8;
          default:
            throw new Error(`cannot calculate sizeof() on type ${re.onnx.TensorProto.DataType[a4]}`);
        }
      }
      function Yd(a4, t4) {
        return new (Gu(t4))(a4);
      }
      function Gu(a4) {
        switch (a4) {
          case "bool":
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "int16":
            return Int16Array;
          case "uint16":
            return Uint16Array;
          case "int32":
            return Int32Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "float32":
            return Float32Array;
          case "float64":
            return Float64Array;
          default:
            throw new Error("unspecified error");
        }
      }
      function gi(a4, t4) {
        if (t4 === re.onnx.TensorProto.DataType.INT64 || t4 === bi.TensorDataType.INT64) {
          if (a4.greaterThanOrEqual(2147483648) || a4.lessThan(-2147483648))
            throw new TypeError("int64 is not supported");
        } else if (t4 === re.onnx.TensorProto.DataType.UINT32 || t4 === bi.TensorDataType.UINT32 || t4 === re.onnx.TensorProto.DataType.UINT64 || t4 === bi.TensorDataType.UINT64) {
          if (a4.greaterThanOrEqual(4294967296) || a4.lessThan(0))
            throw new TypeError("uint64 is not supported");
        } else
          throw new TypeError(`not a LONG type: ${re.onnx.TensorProto.DataType[t4]}`);
        return a4.toNumber();
      }
      function Ru(a4, t4, o4) {
        switch (t4) {
          case re.onnx.TensorProto.DataType.BOOL:
          case re.onnx.TensorProto.DataType.UINT8:
            return a4.getUint8(o4);
          case re.onnx.TensorProto.DataType.INT8:
            return a4.getInt8(o4);
          case re.onnx.TensorProto.DataType.UINT16:
            return a4.getUint16(o4, true);
          case re.onnx.TensorProto.DataType.INT16:
            return a4.getInt16(o4, true);
          case re.onnx.TensorProto.DataType.FLOAT:
            return a4.getFloat32(o4, true);
          case re.onnx.TensorProto.DataType.INT32:
            return a4.getInt32(o4, true);
          case re.onnx.TensorProto.DataType.UINT32:
            return a4.getUint32(o4, true);
          case re.onnx.TensorProto.DataType.INT64:
            return gi(Wt.fromBits(a4.getUint32(o4, true), a4.getUint32(o4 + 4, true), false), t4);
          case re.onnx.TensorProto.DataType.DOUBLE:
            return a4.getFloat64(o4, true);
          case re.onnx.TensorProto.DataType.UINT64:
            return gi(Wt.fromBits(a4.getUint32(o4, true), a4.getUint32(o4 + 4, true), true), t4);
          default:
            throw new Error(`cannot read from DataView for type ${re.onnx.TensorProto.DataType[t4]}`);
        }
      }
      var Mu;
      var re;
      var bi;
      var Ce;
      var yr = E(() => {
        "use strict";
        Mu = Dr(Ps());
        ti();
        nn();
        re = Dr($r());
        fe();
        bi = W.experimental.fbs, Ce = class a4 {
          constructor(t4, o4, e4, r4, n4, s4 = Mu.Guid.create()) {
            this.dims = t4;
            this.type = o4;
            this.dataProvider = e4;
            this.asyncDataProvider = r4;
            this.cache = n4;
            this.dataId = s4;
            this.size = U.validateDimsAndCalcSize(t4);
            let i5 = this.size, u4 = e4 === void 0 && r4 === void 0 && n4 === void 0;
            if (n4 !== void 0 && n4.length !== i5)
              throw new RangeError("Input dims doesn't match data length.");
            if (o4 === "string") {
              if (n4 !== void 0 && (!Array.isArray(n4) || !n4.every((l4) => typeof l4 == "string")))
                throw new TypeError("cache should be a string array");
              u4 && (this.cache = new Array(i5));
            } else {
              if (n4 !== void 0) {
                let l4 = Gu(o4);
                if (!(n4 instanceof l4))
                  throw new TypeError(`cache should be type ${l4.name}`);
              }
              if (u4) {
                let l4 = new ArrayBuffer(i5 * jd(o4));
                this.cache = Yd(l4, o4);
              }
            }
          }
          get data() {
            if (this.cache === void 0) {
              let t4 = this.dataProvider(this.dataId);
              if (t4.length !== this.size)
                throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
              this.cache = t4;
            }
            return this.cache;
          }
          get stringData() {
            if (this.type !== "string")
              throw new TypeError("data type is not string");
            return this.data;
          }
          get integerData() {
            switch (this.type) {
              case "uint8":
              case "int8":
              case "uint16":
              case "int16":
              case "int32":
              case "uint32":
              case "bool":
                return this.data;
              default:
                throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
            }
          }
          get floatData() {
            switch (this.type) {
              case "float32":
              case "float64":
                return this.data;
              default:
                throw new TypeError("data type is not float (float32, float64)");
            }
          }
          get numberData() {
            if (this.type !== "string")
              return this.data;
            throw new TypeError("type cannot be non-number (string)");
          }
          get(t4) {
            return this.data[U.indicesToOffset(t4, this.strides)];
          }
          set(t4, o4) {
            this.data[U.indicesToOffset(t4, this.strides)] = o4;
          }
          async getData() {
            return this.cache === void 0 && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
          }
          get strides() {
            return this._strides || (this._strides = U.computeStrides(this.dims)), this._strides;
          }
          static fromProto(t4) {
            if (!t4)
              throw new Error("cannot construct Value from an empty tensor");
            let o4 = Ve.tensorDataTypeFromProto(t4.dataType), e4 = Ve.tensorDimsFromProto(t4.dims), r4 = new a4(e4, o4);
            if (o4 === "string")
              t4.stringData.forEach((n4, s4) => {
                r4.data[s4] = ln(n4);
              });
            else if (t4.rawData && typeof t4.rawData.byteLength == "number" && t4.rawData.byteLength > 0) {
              let n4 = r4.data, s4 = new DataView(t4.rawData.buffer, t4.rawData.byteOffset, t4.rawData.byteLength), i5 = Nu(t4.dataType), u4 = t4.rawData.byteLength / i5;
              if (t4.rawData.byteLength % i5 !== 0)
                throw new Error("invalid buffer length");
              if (n4.length !== u4)
                throw new Error("buffer length mismatch");
              for (let l4 = 0; l4 < u4; l4++) {
                let f3 = Ru(s4, t4.dataType, l4 * i5);
                n4[l4] = f3;
              }
            } else {
              let n4;
              switch (t4.dataType) {
                case re.onnx.TensorProto.DataType.FLOAT:
                  n4 = t4.floatData;
                  break;
                case re.onnx.TensorProto.DataType.INT32:
                case re.onnx.TensorProto.DataType.INT16:
                case re.onnx.TensorProto.DataType.UINT16:
                case re.onnx.TensorProto.DataType.INT8:
                case re.onnx.TensorProto.DataType.UINT8:
                case re.onnx.TensorProto.DataType.BOOL:
                  n4 = t4.int32Data;
                  break;
                case re.onnx.TensorProto.DataType.INT64:
                  n4 = t4.int64Data;
                  break;
                case re.onnx.TensorProto.DataType.DOUBLE:
                  n4 = t4.doubleData;
                  break;
                case re.onnx.TensorProto.DataType.UINT32:
                case re.onnx.TensorProto.DataType.UINT64:
                  n4 = t4.uint64Data;
                  break;
                default:
                  throw new Error("unspecific error");
              }
              if (n4 == null)
                throw new Error("failed to populate data from a tensorproto value");
              let s4 = r4.data;
              if (s4.length !== n4.length)
                throw new Error("array length mismatch");
              for (let i5 = 0; i5 < n4.length; i5++) {
                let u4 = n4[i5];
                Wt.isLong(u4) ? s4[i5] = gi(u4, t4.dataType) : s4[i5] = u4;
              }
            }
            return r4;
          }
          static fromData(t4, o4, e4) {
            return new a4(o4, e4, void 0, void 0, t4);
          }
          static fromOrtTensor(t4) {
            if (!t4)
              throw new Error("cannot construct Value from an empty tensor");
            let o4 = Ve.tensorDimsFromORTFormat(t4), e4 = Ve.tensorDataTypeFromProto(t4.dataType()), r4 = new a4(o4, e4);
            if (e4 === "string")
              for (let n4 = 0; n4 < t4.stringDataLength(); n4++)
                r4.data[n4] = t4.stringData(n4);
            else if (t4.rawDataArray() && typeof t4.rawDataLength() == "number" && t4.rawDataLength() > 0) {
              let n4 = r4.data, s4 = new DataView(t4.rawDataArray().buffer, t4.rawDataArray().byteOffset, t4.rawDataLength()), i5 = Nu(t4.dataType()), u4 = t4.rawDataLength() / i5;
              if (t4.rawDataLength() % i5 !== 0)
                throw new Error("invalid buffer length");
              if (n4.length !== u4)
                throw new Error("buffer length mismatch");
              for (let l4 = 0; l4 < u4; l4++) {
                let f3 = Ru(s4, t4.dataType(), l4 * i5);
                n4[l4] = f3;
              }
            }
            return r4;
          }
        };
      });
      function q(a4) {
        return a4 === 1 ? Xd : Kd;
      }
      function Uu(a4) {
        let t4 = q(a4);
        return `${t4.version}
      precision highp float;
      ${t4.attribute} vec3 position;
      ${t4.attribute} vec2 textureCoord;

      ${t4.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
      }
      function zu(a4) {
        let t4 = q(a4);
        return `${t4.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t4.varyingFrag} vec2 TexCoords;
    ${t4.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
      }
      function Vu(a4, t4) {
        let o4 = q(a4);
        return `
  void main() {
    int indices[${t4}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o4.output} = result;
  }
  `;
      }
      var Xd;
      var Kd;
      var xe = E(() => {
        "use strict";
        Xd = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, Kd = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
      });
      var ae = E(() => {
        "use strict";
      });
      async function yi(a4, t4 = (e4) => 0, o4) {
        return new Promise((e4, r4) => {
          let n4 = 0, s4 = () => {
            if (a4()) {
              e4();
              return;
            }
            n4++;
            let i5 = t4(n4);
            if (o4 != null && n4 >= o4) {
              r4();
              return;
            }
            setTimeout(s4, i5);
          };
          s4();
        });
      }
      function Kn(a4) {
        return kr(typeof a4 < "u" && a4.length !== 0, () => "empty string found for sampler name"), "get" + a4.charAt(0).toUpperCase() + a4.slice(1);
      }
      function Wu(a4) {
        return kr(typeof a4 < "u" && a4.length !== 0, () => "empty string found for sampler name"), "get" + a4.charAt(0).toUpperCase() + a4.slice(1) + "AtOutCoords";
      }
      function Br(a4, t4) {
        let o4 = JSON.parse(JSON.stringify(a4));
        return o4 = t4, o4;
      }
      function Nr(a4, t4) {
        return t4.map((o4) => a4[o4]).join(", ");
      }
      function Je(a4) {
        if (a4 <= 1)
          return "int";
        if (a4 === 2)
          return "ivec2";
        if (a4 === 3)
          return "ivec3";
        if (a4 === 4)
          return "ivec4";
        if (a4 === 5)
          return "ivec5";
        if (a4 === 6)
          return "ivec6";
        throw Error(`GPU for rank ${a4} is not yet supported`);
      }
      function Ot(a4 = 6) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, a4);
      }
      var kt = E(() => {
        "use strict";
        fe();
      });
      function Jd(a4, t4) {
        return Ot(t4).map((o4) => `${a4}.${o4}`);
      }
      function Rr(a4, t4) {
        return t4 === 1 ? [a4] : Jd(a4, t4);
      }
      function Bt() {
        return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
      }
      var Tr = E(() => {
        "use strict";
        kt();
      });
      function Qd(a4, t4, o4) {
        if (a4 === 0)
          return "false";
        if (a4 === 1)
          return `rc > ${t4[0]}`;
        let e4 = "";
        for (let r4 = a4 - 2; r4 < a4; r4++)
          e4 += `${o4[r4]} >= ${t4[r4 - a4 + 2]}`, r4 < a4 - 1 && (e4 += "||");
        return e4;
      }
      function eh(a4, t4) {
        let o4 = a4.length;
        if (o4 === 0)
          return "getA(), 0, 0, 0";
        if (o4 === 1)
          return `getA(rc),
            rc + 1 >= ${a4[0]} ? 0. : getA(rc + 1),
            0, 0`;
        let e4 = "r, c", r4 = "r, cp1", n4 = "rp1, c", s4 = "rp1, cp1", i5 = "";
        if (o4 > 2)
          for (let u4 = 0; u4 < o4 - 2; ++u4)
            i5 = i5 + `${t4[u4]},`;
        return `getA(${i5}${e4}),
          rEdge ? 0. : getA(${i5}${n4}),
          cEdge ? 0. : getA(${i5}${r4}),
          rEdge || cEdge ? 0. : getA(${i5}${s4})`;
      }
      function th(a4, t4, o4, e4) {
        return a4 === 0 || a4 === 1 ? "" : `
    int r = ${t4[a4 - 2]};
    int c = ${t4[a4 - 1]};
    int rp1 = ${t4[a4 - 2]} + 1;
    int cp1 = ${t4[a4 - 1]} + 1;
    bool rEdge = rp1 >= ${e4};
    bool cEdge = cp1 >= ${o4};
    `;
      }
      var Hu;
      var Zd;
      var qu;
      var ju = E(() => {
        "use strict";
        xe();
        ae();
        kt();
        Tr();
        Hu = { name: "pack", inputNames: ["A"], inputTypes: [1] }, Zd = (a4, t4) => {
          let o4 = q(a4.session.backend.glContext.version), e4 = t4.dims, r4 = e4.length, n4 = t4.dims.length, s4 = Je(n4), i5 = Rr("rc", n4), u4 = th(n4, i5, e4[e4.length - 2], e4[e4.length - 1]), l4;
          r4 === 0 ? l4 = [1, 1] : r4 === 1 ? l4 = [e4[0], 1] : l4 = [e4[n4 - 1], e4[n4 - 2]];
          let f3 = Qd(n4, l4, i5), p4 = eh(e4, i5), d4 = `
        void main() {
          ${s4} rc = getOutputCoords();

          if(${f3}) {
            ${o4.output} = vec4(0);
          } else {
            ${u4}

            ${o4.output} = vec4(${p4});
          }
        }
      `;
          return { ...Hu, hasMain: true, output: { dims: t4.dims, type: t4.type, textureType: 2 }, shaderSource: d4 };
        }, qu = (a4, t4) => ({ ...Hu, get: () => Zd(a4, t4) });
      });
      function Ti(a4) {
        if (a4.length === 0)
          return [1, 1, 1];
        let t4 = 1;
        for (let o4 = 0; o4 < a4.length - 2; ++o4)
          t4 *= a4[o4];
        return [t4, a4.length > 1 ? a4[a4.length - 2] : 1, a4[a4.length - 1]];
      }
      function Xu(a4, t4) {
        let o4 = false;
        return a4.length === 0 || t4.length === 0 ? o4 = true : a4.length < 2 || t4.length < 2 ? o4 = a4[a4.length - 1] === t4[t4.length - 1] : o4 = a4[a4.length - 1] === t4[t4.length - 1] && a4[a4.length - 2] === t4[t4.length - 2], o4;
      }
      function oh(a4) {
        let t4 = U.computeStrides(a4), o4 = ["b", "r", "c"], e4 = "index";
        return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t4.map((n4, s4) => {
          let i5 = `int ${o4[s4]} = ${e4} / ${n4}`, u4 = s4 === t4.length - 1 ? `int ${o4[s4 + 1]} = ${e4} - ${o4[s4]} * ${n4}` : `index -= ${o4[s4]} * ${n4}`;
          return `${i5}; ${u4};`;
        }).join("")}
      return ivec3(b, r, c);
    }
  `;
      }
      function ih(a4) {
        let t4 = U.computeStrides(a4);
        return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${t4[0]} + coords.z * ${t4[1]} + coords.y;
  }
`;
      }
      var rh;
      var nh;
      var Yu;
      var Ku = E(() => {
        "use strict";
        fe();
        xe();
        ae();
        Tr();
        rh = (a4) => ({ name: "Reshape (packed)", inputTypes: [2], inputNames: ["A"], cacheHint: `${a4}` }), nh = (a4, t4, o4, e4) => {
          let r4 = t4.dims, n4 = e4, s4 = "";
          for (let l4 = 0; l4 < 4; l4++) {
            let f3 = "";
            switch (l4) {
              case 0:
                f3 = "outputCoords = rc;";
                break;
              case 1:
                f3 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                break;
              case 2:
                f3 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                break;
              case 3:
                f3 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                break;
              default:
                throw new Error();
            }
            s4 += `
        ${f3}
        ${l4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${l4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${l4 > 0 ? "}" : ""}
      `;
          }
          let i5 = q(a4.session.backend.glContext.version), u4 = `
      ${oh(r4)}
      ${ih(n4)}
      ${Bt()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${n4[2]};
        int cols = ${n4[1]};

        ${s4}
        ${i5.output} = result;
      }
    `;
          return { ...o4, output: { dims: n4, type: t4.type, textureType: 2 }, shaderSource: u4, hasMain: true };
        }, Yu = (a4, t4, o4) => {
          let e4 = rh(o4);
          return { ...e4, get: () => nh(a4, t4, e4, o4) };
        };
      });
      var xi;
      var Ju = E(() => {
        "use strict";
        xe();
        ae();
        xi = (a4, t4) => {
          let o4 = t4.shape, e4 = q(a4.session.backend.glContext.version), r4 = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${e4.texture2D}(X,TexCoords).r;
      ${e4.output} = encodeAsUint8(value);
    }`, n4 = { name: "Uint8Encode", inputTypes: [0], inputNames: ["X"], output: { dims: o4, type: t4.tensor.type, textureType: 3 }, shaderSource: r4, hasMain: true };
          return a4.executeProgram(n4, [t4.tensor]);
        };
      });
      function sh(a4, t4) {
        if (a4 === 1)
          return "rc";
        let o4 = "";
        for (let e4 = 0; e4 < a4; e4++)
          o4 += t4[e4], e4 < a4 - 1 && (o4 += ",");
        return o4;
      }
      var Zu;
      var ah;
      var Qu;
      var el = E(() => {
        "use strict";
        xe();
        ae();
        kt();
        Tr();
        Zu = { name: "unpack", inputNames: ["A"], inputTypes: [2] }, ah = (a4, t4) => {
          let o4 = t4.dims.length, e4 = Rr("rc", o4), r4 = e4.slice(-2), n4 = Je(o4), s4 = Bt(), u4 = t4.dims.length === 0 ? "" : sh(o4, e4), l4 = o4 <= 1 ? "rc" : `vec2(${r4.join(",")})`, f3 = q(a4.session.backend.glContext.version), p4 = `
    ${s4}
    void main() {
      ${n4} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${u4});

       ${f3.output} = vec4(getChannel(packedInput, ${l4}), 0, 0, 0);
     }
   `;
          return { ...Zu, hasMain: true, output: { dims: t4.dims, type: t4.type, textureType: 0 }, shaderSource: p4 };
        }, Qu = (a4, t4) => ({ ...Zu, get: () => ah(a4, t4) });
      });
      var Jn;
      var fn;
      var Zn;
      var cn = E(() => {
        "use strict";
        at();
        Jn = class {
          constructor(t4, o4 = 1) {
            if (o4 === 1)
              this.internalFormat = t4.R32F, this.format = t4.RED, this.textureType = t4.FLOAT, this.channelSize = o4;
            else if (o4 === 4)
              this.internalFormat = t4.RGBA32F, this.format = t4.RGBA, this.textureType = t4.FLOAT, this.channelSize = o4;
            else
              throw new Error(`Invalid number of channels: ${o4}`);
          }
          encode(t4, o4) {
            let e4, r4;
            return t4.constructor !== Float32Array && (ce.warning("Encoder", "data was not of type Float32; creating new Float32Array"), r4 = new Float32Array(t4)), o4 * this.channelSize > t4.length ? (ce.warning("Encoder", "Source data too small. Allocating larger array"), r4 = t4, e4 = this.allocate(o4 * this.channelSize), r4.forEach((n4, s4) => e4[s4] = n4)) : (r4 = t4, e4 = r4), e4;
          }
          allocate(t4) {
            return new Float32Array(t4 * 4);
          }
          decode(t4, o4) {
            return this.channelSize === 1 ? t4.filter((r4, n4) => n4 % 4 === 0).subarray(0, o4) : t4.subarray(0, o4);
          }
        }, fn = class {
          constructor(t4, o4 = 1, e4) {
            if (o4 !== 1 && o4 !== 4)
              throw new Error(`Invalid number of channels: ${o4}`);
            this.internalFormat = t4.RGBA, this.format = t4.RGBA, this.channelSize = o4, this.textureType = e4 || t4.FLOAT;
          }
          encode(t4, o4) {
            let e4 = t4;
            return this.channelSize === 1 && (ce.verbose("Encoder", "Exploding into a larger array"), e4 = this.allocate(o4), t4.forEach((r4, n4) => e4[n4 * 4] = r4)), e4;
          }
          allocate(t4) {
            return new Float32Array(t4 * 4);
          }
          decode(t4, o4) {
            return this.channelSize === 1 ? t4.filter((r4, n4) => n4 % 4 === 0).subarray(0, o4) : t4.subarray(0, o4);
          }
        }, Zn = class {
          constructor(t4, o4 = 1) {
            this.channelSize = 4;
            if (o4 === 1)
              this.internalFormat = t4.ALPHA, this.format = t4.ALPHA, this.textureType = t4.UNSIGNED_BYTE, this.channelSize = o4;
            else if (o4 === 4)
              this.internalFormat = t4.RGBA, this.format = t4.RGBA, this.textureType = t4.UNSIGNED_BYTE, this.channelSize = o4;
            else
              throw new Error(`Invalid number of channels: ${o4}`);
          }
          encode(t4, o4) {
            return new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength);
          }
          allocate(t4) {
            return new Uint8Array(t4 * this.channelSize);
          }
          decode(t4, o4) {
            if (t4 instanceof Uint8Array)
              return t4.subarray(0, o4);
            throw new Error(`Invalid array type: ${t4.constructor}`);
          }
        };
      });
      var pn;
      var tl;
      var wi;
      var rl = E(() => {
        "use strict";
        fe();
        ae();
        pn = (a4, t4, o4) => {
          let e4 = o4 === 0 || o4 === 1 ? 1 : 4, r4 = o4 === 2, n4 = o4 === 1 || o4 === 2, s4 = o4 === 4 ? t4.length - 1 : void 0, i5 = o4 === 4 ? t4.map((u4, l4) => l4 === t4.length - 1 ? u4 * 4 : u4) : void 0;
          return wi(a4, t4, e4, i5, { isPacked: r4, reverseWH: n4, breakAxis: s4 });
        }, tl = (a4, t4, o4) => {
          let e4 = pn(a4, t4, o4);
          return [e4.width, e4.height];
        }, wi = (a4, t4, o4 = 1, e4, r4) => {
          let n4 = !!(r4 && r4.isPacked), [s4, i5] = a4.computeTextureWH(n4 && e4 || t4, r4), u4 = t4.length, l4 = t4.slice(0);
          if (u4 === 0 && (l4 = [1]), o4 === 1)
            e4 = t4;
          else if (n4) {
            if (o4 !== 4)
              throw new Error("a packed texture must be 4-channel");
            e4 = t4, u4 > 0 && (l4[u4 - 1] = Math.ceil(l4[u4 - 1] / 2)), u4 > 1 && (l4[u4 - 2] = Math.ceil(l4[u4 - 2] / 2));
          } else if (!e4)
            throw new Error("Unpacked shape is needed when using channels > 1");
          return { width: s4, height: i5, channels: o4, isPacked: n4, shape: l4, strides: U.computeStrides(l4), unpackedShape: e4, reversedWH: r4 && r4.reverseWH };
        };
      });
      var lh;
      var Qn;
      var ol = E(() => {
        "use strict";
        at();
        yr();
        fe();
        ju();
        Ku();
        Ju();
        el();
        cn();
        rl();
        ae();
        lh = (a4, t4) => {
          let o4 = t4.map((r4) => `${r4.unpackedShape.join(",")};${r4.width}x${r4.height}`).join("_"), e4 = a4.name;
          return a4.cacheHint && (e4 += "[" + a4.cacheHint + "]"), e4 += ":" + o4, e4;
        }, Qn = class {
          constructor(t4) {
            this.session = t4;
            this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          calculateTextureWidthAndHeight(t4, o4) {
            return tl(this.session.layoutStrategy, t4, o4);
          }
          executeProgram(t4, o4) {
            if (o4.length < t4.inputNames.length)
              throw new Error(`Input size mustn't be less than ${t4.inputNames.length}.`);
            if (t4.inputNames.length !== t4.inputTypes.length)
              throw new Error("input names size does not match input types");
            let e4 = [];
            for (let l4 = 0; l4 < t4.inputNames.length; ++l4)
              e4[l4] = this.getOrCreateTextureData(o4[l4], t4.inputTypes[l4]);
            let r4 = lh(t4, e4), n4 = this.session.programManager.getArtifact(r4), s4 = n4 ? n4.programInfo : typeof t4.get == "function" ? t4.get() : t4, i5 = pn(this.session.layoutStrategy, s4.output.dims, s4.output.textureType), u4 = this.createTextureData(i5, s4.output.type);
            return n4 || (n4 = this.session.programManager.build(s4, e4, u4), this.session.programManager.setArtifact(r4, n4)), this.runProgram(n4, e4, u4), u4;
          }
          run(t4, o4) {
            return this.executeProgram(t4, o4).tensor;
          }
          runProgram(t4, o4, e4) {
            for (let r4 = 0; r4 < o4.length; ++r4)
              if (!!o4[r4].isPacked != (t4.programInfo.inputTypes[r4] === 2))
                throw new Error(`input[${r4}] property packed inconsistent`);
            if (!!e4.isPacked != (t4.programInfo.output.textureType === 2))
              throw new Error("output property packed inconsistent");
            this.session.programManager.run(t4, o4, e4);
          }
          getOrCreateTextureData(t4, o4) {
            let e4 = this.getTextureData(t4.dataId, o4 === 2);
            if (!e4 && (e4 = this.getTextureData(t4.dataId, o4 !== 2), e4))
              return o4 === 2 ? this.pack(e4) : this.unpack(e4);
            if (!e4) {
              let r4 = pn(this.session.layoutStrategy, t4.dims, o4);
              if (o4 === 4) {
                let i5 = t4.dims;
                if (i5.length === 4) {
                  let u4 = [i5[0], Math.ceil(i5[1] * i5[2] * i5[3] / 4)], l4 = pn(this.session.layoutStrategy, u4, o4), f3 = t4.numberData;
                  if (i5[1] * i5[2] * i5[3] % 4 !== 0) {
                    let p4 = i5[0], d4 = i5[1] * i5[2] * i5[3], T3 = Math.ceil(d4 * 1 / 4) * 4, v5 = p4 * T3;
                    f3 = new Float32Array(v5);
                    for (let w3 = 0; w3 < p4; ++w3) {
                      let I3 = w3 * d4, L3 = w3 * T3 + w3 % 1 * d4;
                      f3.set(t4.numberData.subarray(I3, I3 + d4), L3);
                    }
                  }
                  return this.createTextureData(l4, t4.type, f3, t4, 1);
                }
              }
              if (o4 === 2) {
                let n4 = wi(this.session.layoutStrategy, t4.dims, 1, [], { reverseWH: true }), s4 = this.createTextureData(n4, t4.type, t4.numberData, t4, 1);
                e4 = this.pack(s4);
              } else
                e4 = this.createTextureData(r4, t4.type, t4.numberData, t4, 1);
            }
            return e4;
          }
          createTextureDataFromLayoutBindTensor(t4, o4, e4, r4) {
            return this.createTextureData(t4, o4, e4, r4, 1);
          }
          createTextureData(t4, o4, e4, r4, n4) {
            ce.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(t4)}]`);
            let s4 = this.session.textureManager.createTextureFromLayout(o4, t4, e4, n4);
            return this.createTextureDataFromTexture(t4, o4, s4, r4);
          }
          reshapeUnpacked(t4, o4) {
            let e4 = this.getOrCreateTextureData(t4, 0), r4 = { channels: e4.channels, height: e4.height, width: e4.width, shape: o4.length !== 0 ? o4 : [1], strides: U.computeStrides(o4), unpackedShape: o4 };
            return this.createTextureDataFromTexture(r4, t4.type, e4.texture).tensor;
          }
          reshapePacked(t4, o4) {
            let e4 = this.getOrCreateTextureData(t4, 2);
            if (Xu(t4.dims, o4)) {
              let l4 = { channels: e4.channels, height: e4.height, width: e4.width, shape: o4.length !== 0 ? o4 : [1], strides: U.computeStrides(o4), unpackedShape: o4, isPacked: true };
              return this.createTextureDataFromTexture(l4, t4.type, e4.texture).tensor;
            }
            let r4 = Ti(t4.dims), n4 = Ti(o4), s4 = this.reshapePacked(t4, r4), i5 = this.run(Yu(this, s4, n4), [s4]);
            return this.reshapePacked(i5, o4);
          }
          cast(t4, o4) {
            let e4 = this.getOrCreateTextureData(t4, 0);
            return this.createTextureDataFromTexture(e4, o4, e4.texture).tensor;
          }
          createTextureDataFromTexture(t4, o4, e4, r4, n4) {
            let s4 = { ...t4, tensor: r4 || new Ce(t4.unpackedShape, o4, (i5) => this.readTexture(s4), async (i5) => this.readTextureAsync(s4), void 0, n4), texture: e4 };
            return this.setTextureData(s4.tensor.dataId, s4, t4.isPacked), s4;
          }
          getTextureData(t4, o4 = false) {
            return this.session.isInitializer(t4) ? this.session.getTextureData(t4, o4) : o4 ? this.packedTextureDataCache.get(t4) : this.unpackedTextureDataCache.get(t4);
          }
          setTextureData(t4, o4, e4 = false) {
            this.session.isInitializer(t4) ? this.session.setTextureData(t4, o4, e4) : (e4 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t4, o4);
          }
          isTextureLayoutCached(t4, o4 = false) {
            return !!this.getTextureData(t4.dataId, o4);
          }
          dispose() {
            this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t4) => this.session.textureManager.releaseTexture(t4)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t4) => this.session.textureManager.releaseTexture(t4)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          readTexture(t4) {
            return t4.isPacked ? this.readTexture(this.unpack(t4)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t4, t4.tensor.type, t4.channels) : this.session.textureManager.readUint8TextureAsFloat(xi(this, t4));
          }
          async readTextureAsync(t4) {
            return t4.isPacked ? this.readTextureAsync(this.unpack(t4)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t4, t4.tensor.type, t4.channels) : this.session.textureManager.readUint8TextureAsFloat(xi(this, t4));
          }
          pack(t4) {
            return this.executeProgram(qu(this, t4.tensor), [t4.tensor]);
          }
          unpack(t4) {
            return this.executeProgram(Qu(this, t4.tensor), [t4.tensor]);
          }
        };
      });
      var vi;
      var ee;
      var Ge = E(() => {
        "use strict";
        vi = class {
          constructor(t4) {
            Object.assign(this, t4);
          }
          get cacheKey() {
            return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map((t4) => `${this[t4]}`).join(";")), this.key;
          }
        }, ee = (a4) => new vi(a4);
      });
      var il;
      var al;
      var sl;
      var fh;
      var ch;
      var ul = E(() => {
        "use strict";
        Ge();
        xe();
        ae();
        il = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [0, 0, 0, 0, 0] }, al = (a4, t4, o4) => (ch(t4), [a4.run({ ...il, cacheHint: o4.cacheKey, get: () => fh(a4, t4, o4) }, t4)]), sl = (a4) => {
          let t4 = a4.attributes.getFloat("epsilon", 1e-5), o4 = a4.attributes.getFloat("momentum", 0.9), e4 = a4.attributes.getInt("spatial", 1);
          return ee({ epsilon: t4, momentum: o4, spatial: e4 });
        }, fh = (a4, t4, o4) => {
          let e4 = q(a4.session.backend.glContext.version), r4 = t4[0].dims.length, [n4, s4] = a4.calculateTextureWidthAndHeight(t4[1].dims, 0), i5 = `
  float process(int[${r4}] indices) {
    vec2 position = offsetToCoords(indices[1], ${n4}, ${s4});
    float scale = getColorAsFloat(${e4.texture2D}(Scale, position));
    float mean = getColorAsFloat(${e4.texture2D}(Mean, position));
    float variance = getColorAsFloat(${e4.texture2D}(Variance, position));
    float b = getColorAsFloat(${e4.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o4.epsilon})) ) + b;
  }`;
          return { ...il, output: { dims: t4[0].dims, type: t4[0].type, textureType: 0 }, shaderSource: i5 };
        }, ch = (a4) => {
          if (!a4 || a4.length !== 5)
            throw new Error("BatchNormalization requires 5 inputs.");
          let t4 = a4[0], o4 = a4[1], e4 = a4[2], r4 = a4[3], n4 = a4[4];
          if (t4.dims.length < 3 || o4.dims.length !== 1 || e4.dims.length !== 1 || r4.dims.length !== 1 || n4.dims.length !== 1)
            throw new Error("invalid input shape.");
          if (o4.dims[0] !== t4.dims[1] || e4.dims[0] !== t4.dims[1] || r4.dims[0] !== t4.dims[1] || n4.dims[0] !== t4.dims[1])
            throw new Error("invalid input shape.");
          if (t4.type !== "float32" && t4.type !== "float64" || o4.type !== "float32" && o4.type !== "float64" || e4.type !== "float32" && e4.type !== "float64" || r4.type !== "float32" && r4.type !== "float64" || n4.type !== "float32" && n4.type !== "float64")
            throw new Error("invalid input tensor types.");
        };
      });
      var eo;
      var ft;
      var R;
      var dn;
      var to;
      var Ht = E(() => {
        "use strict";
        eo = class {
          constructor(t4, o4, e4, r4) {
            this.glContext = t4;
            this.programInfo = o4;
            this.inputTextureLayouts = e4;
            this.outputTextureLayout = r4;
          }
        }, ft = class {
          constructor(t4) {
            this.context = t4;
          }
        }, R = class {
          constructor(t4, o4) {
            this.routineBody = t4;
            this.dependencies = o4;
          }
        }, dn = class {
          constructor(t4, o4, e4) {
            this.name = t4;
            e4 ? this.dependencies = e4 : this.dependencies = [], o4 && (this.routineBody = o4);
          }
          addDependency(t4) {
            t4 && this.dependencies.push(t4);
          }
        }, to = class {
          static returnOrderedNodes(t4) {
            if (!t4 || t4.length === 0)
              return [];
            if (t4.length === 1)
              return t4;
            let o4 = /* @__PURE__ */ new Set(), e4 = /* @__PURE__ */ new Set(), r4 = new Array();
            return this.createOrderedNodes(t4, o4, e4, r4), r4;
          }
          static createOrderedNodes(t4, o4, e4, r4) {
            for (let n4 = 0; n4 < t4.length; ++n4)
              this.dfsTraverse(t4[n4], o4, e4, r4);
          }
          static dfsTraverse(t4, o4, e4, r4) {
            if (!t4 || e4.has(t4.name))
              return;
            if (o4.has(t4.name))
              throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
            o4.add(t4.name);
            let n4 = t4.dependencies;
            if (n4 && n4.length > 0)
              for (let s4 = 0; s4 < n4.length; ++s4)
                this.dfsTraverse(n4[s4], o4, e4, r4);
            r4.push(t4), e4.add(t4.name), o4.delete(t4.name);
          }
        };
      });
      function dh() {
        let a4 = "add_";
        return { body: `
  float ${a4}(float a, float b) {
    return a + b;
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: a4, type: 0 };
      }
      function hh() {
        let a4 = "div_";
        return { body: `
  float ${a4}(float a, float b) {
    return a / b;
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: a4, type: 0 };
      }
      function mh() {
        let a4 = "mul_";
        return { body: `
  float ${a4}(float a, float b) {
    return a * b;
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: a4, type: 0 };
      }
      function bh() {
        let a4 = "sub_";
        return { body: `
  float ${a4}(float a, float b) {
    return a - b;
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: a4, type: 0 };
      }
      function gh() {
        let a4 = "equal_";
        return { body: `
  float ${a4}(float a, float b) {
    return float(a == b);
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: a4, type: 0 };
      }
      function yh() {
        let a4 = "greater_";
        return { body: `
  float ${a4}(float a, float b) {
    return float(a > b);
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: a4, type: 0 };
      }
      function Th() {
        let a4 = "less_";
        return { body: `
  float ${a4}(float a, float b) {
    return float(a < b);
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: a4, type: 0 };
      }
      function xh() {
        let a4 = "and_";
        return { body: `
  float ${a4}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: a4, type: 0 };
      }
      function wh() {
        let a4 = "or_";
        return { body: `
  float ${a4}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: a4, type: 0 };
      }
      function vh() {
        let a4 = "xor_";
        return { body: `
  float ${a4}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: a4, type: 0 };
      }
      function _h() {
        return Ih("pow");
      }
      function Oh() {
        let a4 = "prelu_";
        return { body: `
  float ${a4}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${a4}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: a4, type: 0 };
      }
      function Ih(a4) {
        let t4 = `${a4}_`;
        return { body: `
  float ${t4}(float a, float b) {
    return ${a4}(a, b);
  }
  vec4 ${t4}(vec4 v1, vec4 v2) {
    return ${a4}(v1, v2);
  }
  `, name: t4, type: 0 };
      }
      var ct;
      var Sh;
      var ll;
      var fl;
      var cl;
      var pl;
      var dl;
      var hl;
      var ml;
      var bl;
      var gl;
      var yl;
      var Tl;
      var xl;
      var wl = E(() => {
        "use strict";
        fe();
        Ht();
        xe();
        ae();
        ct = (a4, t4, o4, e4 = t4[0].type, r4) => {
          let n4 = a4.session.pack ? 2 : 0;
          return { name: o4.name, inputNames: ["A", "B"], inputTypes: [n4, n4], cacheHint: r4, get: () => Sh(a4, t4, o4, e4) };
        }, Sh = (a4, t4, o4, e4 = t4[0].type) => {
          let r4 = a4.session.pack ? 2 : 0, n4 = !U.areEqual(t4[0].dims, t4[1].dims), s4 = t4[0].dims, i5 = a4.session.pack;
          if (n4) {
            let f3 = Ke.calcShape(t4[0].dims, t4[1].dims, false);
            if (!f3)
              throw new Error("Can't perform binary op on the given tensors");
            s4 = f3;
            let p4 = s4.length, d4 = t4[0].dims.length !== 0 ? t4[0].dims.length : 1, T3 = t4[1].dims.length !== 0 ? t4[1].dims.length : 1, v5 = t4[0].dims.length !== 0 ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", w3 = t4[1].dims.length !== 0 ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", I3 = q(a4.session.backend.glContext.version), L3 = i5 ? `
      ${o4.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${o4.name}(a, b);
        ${I3.output} = result;
      }` : `
      ${o4.body}
      float process(int indices[${p4}]) {
        int aindices[${d4}];
        int bindices[${T3}];
        ${v5}
        ${w3}
        return ${o4.name}(_A(aindices), _B(bindices));
      }`;
            return { name: o4.name, inputNames: ["A", "B"], inputTypes: [r4, r4], output: { dims: s4, type: e4, textureType: r4 }, shaderSource: L3, hasMain: i5 };
          }
          let u4 = q(a4.session.backend.glContext.version), l4 = `
    ${o4.body}
    void main() {
      vec4 v1 = ${u4.texture2D}(A, TexCoords);
      vec4 v2 = ${u4.texture2D}(B, TexCoords);
      vec4 result = ${o4.name}(v1, v2);
      ${u4.output} = result;
    }
    `;
          return { name: o4.name, inputNames: ["A", "B"], inputTypes: [r4, r4], output: { dims: t4[0].dims, type: e4, textureType: r4 }, shaderSource: l4, hasMain: true };
        }, ll = (a4, t4) => [a4.run(ct(a4, t4, dh()), t4)], fl = (a4, t4) => [a4.run(ct(a4, t4, xh(), "bool"), t4)], cl = (a4, t4) => [a4.run(ct(a4, t4, hh()), t4)], pl = (a4, t4) => [a4.run(ct(a4, t4, gh(), "bool"), t4)], dl = (a4, t4) => [a4.run(ct(a4, t4, yh(), "bool"), t4)], hl = (a4, t4) => [a4.run(ct(a4, t4, Th(), "bool"), t4)], ml = (a4, t4) => [a4.run(ct(a4, t4, mh()), t4)], bl = (a4, t4) => [a4.run(ct(a4, t4, wh(), "bool"), t4)], gl = (a4, t4) => [a4.run(ct(a4, t4, _h()), t4)], yl = (a4, t4) => [a4.run(ct(a4, t4, Oh()), t4)], Tl = (a4, t4) => [a4.run(ct(a4, t4, bh()), t4)], xl = (a4, t4) => [a4.run(ct(a4, t4, vh(), "bool"), t4)];
      });
      var vl;
      var _l;
      var Ph;
      var Ol = E(() => {
        "use strict";
        fe();
        vl = (a4, t4, o4) => (Ph(t4), [a4.cast(t4[0], o4)]), _l = (a4) => Ve.tensorDataTypeFromProto(a4.attributes.getInt("to")), Ph = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Cast requires 1 input.");
          if (a4[0].type === "string")
            throw new Error("Invalid input type.");
        };
      });
      var Eh;
      var Dh;
      var Il;
      var ro;
      var Sl = E(() => {
        "use strict";
        xe();
        ae();
        kt();
        Tr();
        Eh = (a4, t4) => ({ name: "Concat (packed)", inputNames: Array.from({ length: a4 }, (o4, e4) => `X${e4}`), inputTypes: Array(a4).fill(2), cacheHint: t4 }), Dh = (a4, t4, o4, e4) => {
          let r4 = o4[0].dims.slice();
          if (e4 >= r4.length || e4 < -1 * r4.length)
            throw new Error("axis specified for concat doesn't match input dimensionality");
          e4 < 0 && (e4 = r4.length + e4);
          let n4 = r4.slice(0);
          for (let j4 = 1; j4 < o4.length; j4++) {
            let M4 = o4[j4].dims.slice();
            for (let ie3 = 0; ie3 < r4.length; ie3++)
              if (ie3 === e4)
                n4[e4] += M4[ie3];
              else if (r4[ie3] !== M4[ie3])
                throw new Error("non concat dimensions must match");
          }
          let s4 = n4.length, i5 = Rr("coords", s4), u4 = Je(s4), l4 = Bt(), f3 = o4.map((j4) => j4.dims), p4 = Ot(s4), d4 = new Array(f3.length - 1);
          d4[0] = f3[0][e4];
          for (let j4 = 1; j4 < d4.length; j4++)
            d4[j4] = d4[j4 - 1] + f3[j4][e4];
          let T3 = p4[e4], v5 = p4.slice(-2), w3 = p4.join(), I3 = `if (${T3} < ${d4[0]}) {
        return getChannel(
            getX0(${w3}), vec2(${v5.join()}));
        }`;
          for (let j4 = 1; j4 < d4.length; j4++) {
            let M4 = d4[j4 - 1];
            I3 += `
            if (${T3} < ${d4[j4]}  && ${T3} >= ${d4[j4 - 1]}) {
              return getChannel(
                getX${j4}(${ro(p4, T3, M4)}),
                vec2(${ro(v5, T3, M4)}));
            }`;
          }
          let L3 = d4.length, F4 = d4[d4.length - 1];
          I3 += `
            return getChannel(
              getX${L3}(${ro(p4, T3, F4)}),
              vec2(${ro(v5, T3, F4)}));`;
          let C3 = q(a4.session.backend.glContext.version), Y5 = `
          ${l4}
          float getValue(${p4.map((j4) => "int " + j4)}) {
            ${I3}
          }

          void main() {
            ${u4} coords = getOutputCoords();
            int lastDim = coords.${p4[s4 - 1]};
            coords.${p4[s4 - 1]} = coords.${p4[s4 - 2]};
            coords.${p4[s4 - 2]} = lastDim;

            vec4 result = vec4(getValue(${i5}), 0., 0., 0.);

            ${i5[s4 - 1]} = ${i5[s4 - 1]} + 1;
            if (${i5[s4 - 1]} < ${n4[s4 - 1]}) {
              result.g = getValue(${i5});
            }

            ${i5[s4 - 2]} = ${i5[s4 - 2]} + 1;
            if (${i5[s4 - 2]} < ${n4[s4 - 2]}) {
              result.a = getValue(${i5});
            }

            ${i5[s4 - 1]} = ${i5[s4 - 1]} - 1;
            if (${i5[s4 - 2]} < ${n4[s4 - 2]} &&
                ${i5[s4 - 1]} < ${n4[s4 - 1]}) {
              result.b = getValue(${i5});
            }
            ${C3.output} = result;
          }
        `;
          return { ...t4, output: { dims: n4, type: o4[0].type, textureType: 2 }, shaderSource: Y5, hasMain: true };
        }, Il = (a4, t4, o4) => {
          let e4 = Eh(t4.length, o4.cacheKey);
          return { ...e4, get: () => Dh(a4, e4, t4, o4.axis) };
        }, ro = (a4, t4, o4) => {
          let e4 = a4.indexOf(t4);
          return a4.map((n4, s4) => s4 === e4 ? `${n4} - ${o4}` : n4).join();
        };
      });
      var Al;
      var Lh;
      var Fh;
      var Ch;
      var Pl;
      var $h;
      var kh;
      var Bh;
      var El;
      var Nh;
      var Dl = E(() => {
        "use strict";
        Ge();
        ae();
        Sl();
        Al = (a4, t4, o4) => (Nh(t4), a4.session.pack && t4[0].dims.length > 1 ? [a4.run(Il(a4, t4, o4), t4)] : [a4.run(Ch(a4, t4, o4), t4)]), Lh = (a4, t4) => ({ name: "Concat", inputNames: Array.from({ length: a4 }, (o4, e4) => `X${e4}`), inputTypes: Array(a4).fill(0), cacheHint: t4 }), Fh = (a4, t4, o4, e4) => {
          let r4 = o4[0].dims.slice();
          if (e4 >= r4.length || e4 < -1 * r4.length)
            throw new Error("axis specified for concat doesn't match input dimensionality");
          e4 < 0 && (e4 = r4.length + e4);
          let n4 = r4.slice(0);
          for (let T3 = 1; T3 < o4.length; T3++) {
            let v5 = o4[T3].dims.slice();
            for (let w3 = 0; w3 < r4.length; w3++)
              if (w3 === e4)
                n4[e4] += v5[w3];
              else if (r4[w3] !== v5[w3])
                throw new Error("non concat dimensions must match");
          }
          let s4 = n4.length, i5 = new Array(o4.length), u4 = 0;
          for (let T3 = 0; T3 < i5.length; ++T3)
            u4 += o4[T3].dims[e4], i5[T3] = u4;
          let l4 = "";
          o4.length < 5 ? l4 = Pl(i5) : l4 = $h(i5);
          let f3 = kh(o4.length, s4), p4 = Bh(i5), d4 = `
        ${f3}
        ${p4}
        ${l4}
        float process(int indices[${s4}]) {
          int textureIndex = getTextureWhereDataResides (indices[${e4}]);

          if(textureIndex != 0) {
            indices[${e4}] = indices[${e4}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
          return { ...t4, output: { dims: n4, type: o4[0].type, textureType: 0 }, shaderSource: d4 };
        }, Ch = (a4, t4, o4) => {
          let e4 = Lh(t4.length, o4.cacheKey);
          return { ...e4, get: () => Fh(a4, e4, t4, o4.axis) };
        }, Pl = (a4) => `int getTextureWhereDataResides(int index) {
      ${a4.map((o4, e4) => `if(index<${o4}) {return ${e4};}
`).join("")}
    }`, $h = (a4) => Pl(a4), kh = (a4, t4) => {
          let o4 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t4}]) {`];
          for (let e4 = 0; e4 < a4; ++e4)
            e4 === 0 ? o4.push(`	if (textureIndex == ${e4}) { return _X${e4}(indices); }`) : e4 === a4 - 1 ? o4.push(`	else { return _X${e4}(indices); }`) : o4.push(`	else if (textureIndex == ${e4}) { return _X${e4}(indices); }`);
          return o4.push("	}"), o4.join(`
`);
        }, Bh = (a4) => {
          let t4 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
          for (let o4 = 0; o4 < a4.length; ++o4)
            o4 === 0 ? t4.push(`	if (index == ${o4}) { return ${a4[o4]}; }`) : o4 === a4.length - 1 ? t4.push(`	else { return ${a4[o4]}; }`) : t4.push(`	else if (index == ${o4}) { return ${a4[o4]}; }`);
          return t4.push("	}"), t4.join(`
`);
        }, El = (a4) => ee({ axis: a4.attributes.getInt("axis") }), Nh = (a4) => {
          if (!a4 || a4.length < 1)
            throw new Error("too few inputs");
          let t4 = a4[0].type, o4 = a4[0].dims.length;
          if (t4 === "string")
            throw new Error("string tensor is not supported yet");
          for (let e4 of a4) {
            if (e4.type !== t4)
              throw new Error("input tensors should be one type");
            if (e4.dims.length !== o4)
              throw new Error("input tensors should have the same shape");
          }
        };
      });
      function Rh() {
        return pt("abs");
      }
      function Mh() {
        return pt("acos");
      }
      function Gh() {
        return pt("asin");
      }
      function Uh() {
        return pt("atan");
      }
      function zh() {
        return pt("ceil");
      }
      function Vh() {
        return pt("cos");
      }
      function Wh(a4) {
        let t4 = "elu";
        return { body: `
  const float alpha = float(${a4});

  float ${t4}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${t4}_(vec4 v) {
    return vec4(${t4}_(v.x), ${t4}_(v.y), ${t4}_(v.z), ${t4}_(v.w));
  }
  `, name: t4, type: 0 };
      }
      function Hh() {
        return pt("exp");
      }
      function qh() {
        return pt("floor");
      }
      function _i(a4, t4) {
        let o4 = "clip";
        return { body: `
  const float min = float(${a4});
  const float max = float(${t4});

  float ${o4}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${o4}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: o4, type: 0 };
      }
      function jh() {
        let a4 = "indentity";
        return { body: `
  float ${a4}_(float a) {
    return a;
  }
  vec4 ${a4}_(vec4 v) {
    return v;
  }
  `, name: a4, type: 0 };
      }
      function Yh(a4) {
        let t4 = "leakyRelu";
        return { body: `
  const float alpha = float(${a4});

  float ${t4}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${t4}_(vec4 v) {
    return vec4(${t4}_(v.x), ${t4}_(v.y), ${t4}_(v.z), ${t4}_(v.w));
  }
  `, name: t4, type: 0 };
      }
      function Xh() {
        return pt("log");
      }
      function Kh() {
        let a4 = "neg";
        return { body: `
  float ${a4}_(float a) {
    return -a;
  }
  vec4 ${a4}_(vec4 v) {
    return -v;
  }
  `, name: a4, type: 0 };
      }
      function Jh() {
        let a4 = "not";
        return { body: `
  float ${a4}_(float a) {
    return float( ! bool(a) );
  }
  bool ${a4}_(bool a) {
    return !a;
  }
  vec4 ${a4}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${a4}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: a4, type: 0 };
      }
      function Zh() {
        return pt("sin");
      }
      function Oi() {
        let a4 = "relu";
        return { body: `
  float ${a4}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${a4}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: a4, type: 0 };
      }
      function Ii() {
        let a4 = "sigmoid";
        return { body: `
  float ${a4}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${a4}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: a4, type: 0 };
      }
      function Qh() {
        return pt("sqrt");
      }
      function em() {
        return pt("tan");
      }
      function tm() {
        let a4 = "tanh";
        return { body: `
  float ${a4}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${a4}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: a4, type: 0 };
      }
      function pt(a4) {
        return { body: `
  float ${a4}_(float a) {
    return ${a4}(a);
  }
  vec4 ${a4}_(vec4 v) {
    return ${a4}(v);
  }
  `, name: a4, type: 0 };
      }
      var rm;
      var De;
      var Ll;
      var Fl;
      var Cl;
      var $l;
      var Si;
      var kl;
      var Bl;
      var nm;
      var Nl;
      var Rl;
      var Ml;
      var Gl;
      var Ul;
      var zl;
      var Ai;
      var Vl;
      var Wl;
      var Hl;
      var ql;
      var jl;
      var Yl;
      var Xl;
      var Kl;
      var Jl;
      var Zl;
      var Ql;
      var Pi = E(() => {
        "use strict";
        Ge();
        fe();
        Ht();
        xe();
        ae();
        rm = (a4, t4, o4, e4) => {
          let r4 = a4.session.pack ? 2 : 0, n4 = q(a4.session.backend.glContext.version);
          return { ...t4, output: { dims: o4.dims, type: o4.type, textureType: r4 }, shaderSource: `
     ${e4.body}
     void main() {
       vec4 v = ${n4.texture2D}(A, TexCoords);
       v = ${e4.name}_(v);
       ${n4.output} = v;
     }
     `, hasMain: true };
        }, De = (a4, t4, o4, e4) => {
          let r4 = a4.session.pack ? 2 : 0, n4 = { name: o4.name, inputTypes: [r4], inputNames: ["A"], cacheHint: e4 };
          return { ...n4, get: () => rm(a4, n4, t4, o4) };
        }, Ll = (a4, t4) => [a4.run(De(a4, t4[0], Rh()), t4)], Fl = (a4, t4) => [a4.run(De(a4, t4[0], Mh()), t4)], Cl = (a4, t4) => [a4.run(De(a4, t4[0], Gh()), t4)], $l = (a4, t4) => [a4.run(De(a4, t4[0], Uh()), t4)], Si = (a4, t4, o4) => [a4.run(De(a4, t4[0], _i(o4.min, o4.max), o4.cacheKey), t4)], kl = (a4) => ee({ min: a4.attributes.getFloat("min", br), max: a4.attributes.getFloat("max", gr) }), Bl = (a4, t4) => {
          let o4 = nm(a4, t4);
          return Si(a4, [t4[0]], o4);
        }, nm = (a4, t4) => {
          if (t4.length >= 3 && (!a4.session.isInitializer(t4[1].dataId) || !a4.session.isInitializer(t4[2].dataId)))
            throw new Error("dynamic clip attributes are not allowed");
          let o4 = t4.length >= 3 ? t4[1].numberData[0] : br, e4 = t4.length >= 3 ? t4[2].numberData[0] : gr;
          return ee({ min: o4, max: e4 });
        }, Nl = (a4, t4) => [a4.run(De(a4, t4[0], zh()), t4)], Rl = (a4, t4) => [a4.run(De(a4, t4[0], Vh()), t4)], Ml = (a4, t4, o4) => [a4.run(De(a4, t4[0], Wh(o4.alpha), o4.cacheKey), t4)], Gl = (a4) => ee({ alpha: a4.attributes.getFloat("alpha", 1) }), Ul = (a4, t4) => [a4.run(De(a4, t4[0], Hh()), t4)], zl = (a4, t4) => [a4.run(De(a4, t4[0], qh()), t4)], Ai = (a4, t4) => [a4.run(De(a4, t4[0], jh()), t4)], Vl = (a4, t4, o4) => [a4.run(De(a4, t4[0], Yh(o4.alpha), o4.cacheKey), t4)], Wl = (a4) => ee({ alpha: a4.attributes.getFloat("alpha", 0.01) }), Hl = (a4, t4) => [a4.run(De(a4, t4[0], Xh()), t4)], ql = (a4, t4) => [a4.run(De(a4, t4[0], Kh()), t4)], jl = (a4, t4) => [a4.run(De(a4, t4[0], Jh()), t4)], Yl = (a4, t4) => [a4.run(De(a4, t4[0], Oi()), t4)], Xl = (a4, t4) => [a4.run(De(a4, t4[0], Ii()), t4)], Kl = (a4, t4) => [a4.run(De(a4, t4[0], Zh()), t4)], Jl = (a4, t4) => [a4.run(De(a4, t4[0], Qh()), t4)], Zl = (a4, t4) => [a4.run(De(a4, t4[0], em()), t4)], Ql = (a4, t4) => [a4.run(De(a4, t4[0], tm()), t4)];
      });
      function Nt(a4) {
        let t4;
        switch (a4.activation) {
          case "Relu":
            t4 = Oi();
            break;
          case "Sigmoid":
            t4 = Ii();
            break;
          case "Clip":
            t4 = _i(a4.clipMin, a4.clipMax);
            break;
          default:
            return { activationFunction: "", applyActivation: "" };
        }
        let o4 = t4.name, e4 = t4.body, r4 = `value = ${o4}_(value);`;
        return { activationFunction: e4, applyActivation: r4 };
      }
      var Mr;
      var xr = E(() => {
        "use strict";
        fe();
        Pi();
        Mr = (a4) => {
          let t4 = a4.getString("activation", "");
          if (t4 === "Clip") {
            let [o4, e4] = a4.getFloats("activation_params", [br, gr]);
            return { activation: t4, clipMax: e4, clipMin: o4, activationCacheKey: `${t4}:${o4},${e4}` };
          }
          return { activation: t4, activationCacheKey: t4 };
        };
      });
      var im;
      var am;
      var ef;
      var tf = E(() => {
        "use strict";
        at();
        xe();
        ae();
        no();
        xr();
        im = (a4, t4) => ({ name: "GroupedConv", inputNames: a4 ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: a4 ? [0, 0, 0] : [0, 0], cacheHint: t4 }), am = (a4, t4, o4, e4) => {
          let n4 = t4.length > 2 ? "value += getBias(output_channel);" : "", s4 = t4[0].dims.slice(), i5 = t4[1].dims.slice(), u4 = i5[0] / e4.group;
          ce.verbose("GroupedConv", `autpPad:${e4.autoPad}, dilations:${e4.dilations}, group:${e4.group}, kernelShape:${e4.kernelShape}, pads:${e4.pads}, strides:${e4.strides}`);
          let l4 = Gr(s4, i5, e4.dilations, e4.pads, e4.strides), f3 = q(a4.session.backend.glContext.version), { activationFunction: p4, applyActivation: d4 } = Nt(e4), T3 = `
  const ivec2 strides = ivec2(${e4.strides[0]}, ${e4.strides[1]});
  const ivec2 pads = ivec2(${e4.pads[0]}, ${e4.pads[1]});
  ${p4}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${u4};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${i5[1]}; wInChannel++) {
      int input_channel = group_id * ${i5[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${i5[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${e4.dilations[0]};

        if (xHeight < 0 || xHeight >= ${s4[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${i5[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${e4.dilations[1]};
          if (xWidth < 0 || xWidth >= ${s4[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${n4}
    ${d4}
    ${f3.output} = vec4(value, .0, .0, .0);
  }
`;
          return { ...o4, output: { dims: l4, type: t4[0].type, textureType: 0 }, shaderSource: T3, hasMain: true };
        }, ef = (a4, t4, o4) => {
          let e4 = im(t4.length > 2, o4.cacheKey);
          return { ...e4, get: () => am(a4, t4, e4, o4) };
        };
      });
      var sm;
      var um;
      var rf;
      var nf = E(() => {
        "use strict";
        xe();
        ae();
        Tr();
        sm = (a4) => ({ name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [2], cacheHint: a4 }), um = (a4, t4, o4, e4, r4, n4) => {
          let s4 = o4.dims, i5 = e4.dims, u4 = 2, l4 = 3, f3 = r4.length, p4 = [i5[1] * i5[2] * i5[3], r4[2] * r4[3]], d4 = i5[2] * i5[3], T3 = Bt(), v5 = q(a4.session.backend.glContext.version), w3 = "";
          for (let L3 = 0; L3 <= 1; L3++)
            for (let F4 = 0; F4 <= 1; F4++)
              w3 += `
            blockIndex = rc.x + ${F4};
            pos = rc.y + ${L3};

            if(blockIndex < ${p4[1]} && pos < ${p4[0]}) {
              offsetY = int(blockIndex / (${r4[f3 - 1]})) * ${n4.strides[0]} -
                ${n4.pads[0]};
              d0 = offsetY + ${n4.dilations[0]} * (imod(pos, ${d4}) / ${i5[2]});

              if(d0 < ${s4[u4]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${r4[f3 - 1]}) * ${n4.strides[1]} -
                  ${n4.pads[1]};
                d1 = offsetX + ${n4.dilations[1]} * imod(imod(pos, ${d4}), ${i5[2]});

                if(d1 < ${s4[l4]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d4}.);
                    innerDims = vec2(d0, d1);
                    result[${L3 * 2 + F4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
          let I3 = `
      ${T3}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${w3}
          ${v5.output} = result;
      }
            `;
          return { ...t4, output: { dims: p4, type: o4.type, textureType: 2 }, shaderSource: I3, hasMain: true };
        }, rf = (a4, t4, o4, e4, r4) => {
          let n4 = sm(r4.cacheKey);
          return { ...n4, get: () => um(a4, n4, t4, o4, e4, r4) };
        };
      });
      function fm(a4, t4, o4) {
        let e4 = t4[0].dims, r4 = t4[1].dims, n4 = Ke.calcShape(e4, r4, true);
        if (!n4)
          throw new Error("Can't use matmul on the given tensors");
        let s4 = Je(n4.length), i5 = Ot(), { activationFunction: u4, applyActivation: l4 } = Nt(o4), f3 = t4.length > 2, p4 = f3 ? "value += getBiasForMatmul();" : "", d4 = f3 ? `${Di(s4, i5, t4[2].dims, n4, false)}` : "", T3 = n4.length, v5 = e4.length, w3 = r4.length, I3 = e4[e4.length - 1], L3 = `
    ${u4}
    ${d4}
    float process(int indices[${T3}]) {
        int a[${v5}];
        int b[${w3}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${I3}; ++k) {
            a[${v5 - 1}] = k;
            b[${w3 - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${p4}
        ${l4}
        return value;
    }`;
        return { ...a4, output: { dims: n4, type: t4[0].type, textureType: 0 }, shaderSource: L3 };
      }
      function Ei(a4, t4) {
        let o4 = lm(a4.length > 2, t4.activationCacheKey);
        return { ...o4, get: () => fm(o4, a4, t4) };
      }
      function Di(a4, t4, o4, e4, r4) {
        let n4 = "", s4 = o4.length, i5 = e4.length, u4 = i5 - s4;
        i5 < 2 && s4 > 0 ? n4 = "coords" : n4 = o4.map((w3, I3) => `coords.${t4[I3 + u4]}`).join(", ");
        let f3 = Ke.getBroadcastDims(o4, e4).map((w3) => `coords.${t4[w3 + u4]} = 0;`).join(`
`), d4 = U.size(o4) === 1, T3 = "vec4(outputValue.xx, outputValue.yy)";
        return d4 && (T3 = "vec4(outputValue.x)"), r4 ? `
vec4 getBiasForMatmul() {
  ${a4} coords = getOutputCoords();
  ${f3}
  vec4 outputValue = getBias(${n4});
  return ${T3};
}` : `
float getBiasForMatmul() {
  ${a4} coords = getOutputCoords();
  ${f3}
  return getBias(coords.x);
}`;
      }
      var of;
      var af;
      var lm;
      var cm;
      var oo = E(() => {
        "use strict";
        fe();
        ae();
        kt();
        xr();
        Li();
        of = (a4, t4, o4) => (cm(t4), a4.session.pack ? [a4.run(io(a4, t4, o4), t4)] : [a4.run(Ei(t4, o4), t4)]), af = (a4) => Mr(a4.attributes), lm = (a4, t4) => ({ name: "MatMul", inputNames: a4 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: a4 ? [0, 0, 0] : [0, 0], cacheHint: t4 });
        cm = (a4) => {
          if (!a4 || a4.length !== 2)
            throw new Error("MatMul requires 2 inputs.");
          if (a4[0].dims[a4[0].dims.length - 1] !== a4[1].dims[a4[1].dims.length - 2])
            throw new Error("shared dimension does not match.");
          if (a4[0].type !== "float32" && a4[0].type !== "float64" || a4[1].type !== "float32" && a4[1].type !== "float64")
            throw new Error("inputs should be float type");
          if (a4[0].type !== a4[1].type)
            throw new Error("inputs types should match");
        };
      });
      function hm(a4, t4, o4, e4) {
        let r4 = [], n4 = [], s4 = o4[0].dims, i5 = o4[1].dims, u4 = s4.length, l4 = i5.length, f3 = e4.length, p4 = f3 - u4, d4 = f3 - l4;
        r4 = s4.map((C3, Y5) => `coords.${t4[Y5 + p4]}`), r4[u4 - 1] = "i*2", r4.join(", "), n4 = i5.map((C3, Y5) => `coords.${t4[Y5 + d4]}`), n4[l4 - 2] = "i*2", n4.join(", ");
        let T3 = Ke.getBroadcastDims(s4, e4), v5 = Ke.getBroadcastDims(i5, e4), w3 = T3.map((C3) => `coords.${t4[C3 + p4]} = 0;`).join(`
`), I3 = v5.map((C3) => `coords.${t4[C3 + d4]} = 0;`).join(`
`), L3 = `int lastDim = coords.${t4[f3 - 1]};
  coords.${t4[f3 - 1]} = coords.${t4[f3 - 2]};
  coords.${t4[f3 - 2]} = lastDim;`;
        return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${a4} coords = getOutputCoords();
  ${L3}
  ${w3}
  vec4 outputValue = getA(${r4});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${a4} coords = getOutputCoords();
  ${L3}
  ${I3}
  vec4 outputValue = getB(${n4});
  return outputValue;
}`;
      }
      function mm(a4, t4) {
        let o4 = "";
        for (let e4 = 0; e4 < t4 - 2; e4++)
          o4 += `rc.${a4[e4]}, `;
        return o4 += `rc.${a4[t4 - 2]}, i*2`, o4;
      }
      function bm(a4, t4) {
        let o4 = "";
        for (let e4 = 0; e4 < t4 - 2; e4++)
          o4 += `rc.${a4[e4]}, `;
        return o4 += `i*2, rc.${a4[t4 - 1]}`, o4;
      }
      var pm;
      var dm;
      var io;
      var Li = E(() => {
        "use strict";
        fe();
        xe();
        ae();
        kt();
        xr();
        oo();
        pm = (a4, t4) => ({ name: "MatMul (packed)", inputNames: a4 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: a4 ? [2, 2, 2] : [2, 2], cacheHint: t4 }), dm = (a4, t4, o4, e4) => {
          let r4 = o4.length > 2, n4 = r4 ? "value += getBiasForMatmul();" : "", s4 = o4[0].dims, i5 = o4[1].dims, u4 = Ke.calcShape(s4, i5, true), l4 = !U.areEqual(o4[0].dims, o4[1].dims);
          if (!u4)
            throw new Error("Can't use matmul on the given tensors");
          let f3 = s4[s4.length - 1], p4 = Math.ceil(f3 / 2), d4 = s4.length, T3 = i5.length, v5 = q(a4.session.backend.glContext.version), w3 = Je(u4.length), I3 = u4.length, L3 = Ot(), { activationFunction: F4, applyActivation: C3 } = Nt(e4), Y5 = r4 ? `${Di(w3, L3, o4[2].dims, u4, true)}` : "", j4 = l4 ? `${hm(w3, L3, o4, u4)}` : "", M4 = l4 ? "getAAtOutCoordsMatmul(i)" : `getA(${mm(L3, d4)})`, ie3 = l4 ? "getBAtOutCoordsMatmul(i)" : `getB(${bm(L3, T3)})`, ot4 = l4 ? "" : `${w3} rc =
          getOutputCoords(); int lastDim = rc.${L3[I3 - 1]}; rc.${L3[I3 - 1]} =
          rc.${L3[I3 - 2]}; rc.${L3[I3 - 2]} = lastDim;
      `, We3 = `
            ${j4}
            ${Y5}
            ${F4}
            void main() {
              ${ot4}

              vec4 value = vec4(0);
              for (int i = 0; i < ${p4}; i++) {
                vec4 a = ${M4};
                vec4 b = ${ie3};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${n4}
              ${C3}
              ${v5.output} = value;
            }`;
          return { ...t4, output: { dims: u4, type: o4[0].type, textureType: 2 }, shaderSource: We3, hasMain: true };
        }, io = (a4, t4, o4) => {
          let e4 = pm(t4.length > 2, o4.activationCacheKey);
          return { ...e4, get: () => dm(a4, e4, t4, o4) };
        };
      });
      var sf;
      var uf = E(() => {
        "use strict";
        no();
        nf();
        Li();
        sf = (a4, t4, o4) => {
          let e4 = t4[0].dims, r4 = t4[1].dims, n4 = Gr(e4, r4, o4.dilations, o4.pads, o4.strides), s4 = a4.run(rf(a4, t4[0], t4[1], n4, o4), [t4[0]]), i5 = a4.reshapePacked(t4[1], [r4[0], r4[1] * r4[2] * r4[3]]), u4 = t4.length === 3 ? [i5, s4, t4[2]] : [i5, s4], l4 = a4.run(io(a4, u4, o4), u4);
          return a4.reshapePacked(l4, n4);
        };
      });
      var gm;
      var ym;
      var lf;
      var Fi;
      var Ci = E(() => {
        "use strict";
        ae();
        gm = (a4) => ({ name: "Im2Col", inputNames: ["X"], inputTypes: [0], cacheHint: a4 }), ym = (a4, t4, o4, e4, r4, n4) => {
          let s4 = o4.dims, i5 = e4.dims, u4 = r4.length, l4 = Fi(s4, i5, r4, 4), f3 = `
        const int XC = ${s4[1]};
        const int XH = ${s4[2]};
        const int XW = ${s4[3]};
        const int KH = ${n4.kernelShape[0]};
        const int KW = ${n4.kernelShape[1]};
        const int dilationH = ${n4.dilations[0]};
        const int dilationW = ${n4.dilations[1]};
        const int strideH = ${n4.strides[0]};
        const int strideW = ${n4.strides[1]};
        const int padH = ${n4.pads[0]};
        const int padW = ${n4.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${u4}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s4.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
          return { ...t4, output: { dims: l4, type: o4.type, textureType: 4 }, shaderSource: f3 };
        }, lf = (a4, t4, o4, e4, r4) => {
          let n4 = gm(r4.cacheKey);
          return { ...n4, get: () => ym(a4, n4, t4, o4, e4, r4) };
        }, Fi = (a4, t4, o4, e4 = 4) => [o4[0], o4[2], o4[3], Math.ceil(a4[1] * t4[2] * t4[3] / e4)];
      });
      var Tm;
      var xm;
      var ff;
      var cf = E(() => {
        "use strict";
        fe();
        xe();
        ae();
        xr();
        Ci();
        Tm = (a4, t4) => ({ name: "ConvDotProduct", inputNames: a4 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: a4 ? [0, 4, 0] : [0, 4], cacheKey: t4.activationCacheKey }), xm = (a4, t4, o4, e4, r4) => {
          let n4 = o4[0].dims, s4 = o4[1].dims, i5 = [s4[0], Math.ceil(n4[1] * s4[2] * s4[3] / 4)], u4 = Fi(n4, s4, e4), [l4, f3] = a4.calculateTextureWidthAndHeight(i5, 4), p4 = U.computeStrides(u4), [d4, T3] = a4.calculateTextureWidthAndHeight(u4, 4), v5 = e4.length, w3 = o4.length < 3 ? "0.0" : "_B(b)", I3 = Math.ceil(n4[1] * s4[2] * s4[3] / 4), { activationFunction: L3, applyActivation: F4 } = Nt(r4), C3 = q(a4.session.backend.glContext.version), Y5 = `
${L3}
float process(int indices[${v5}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${p4[0]} + im2col[1] * ${p4[1]} + im2col[2] * ${p4[2]};
  int kernelOffset = indices[1] * ${i5[1]};
  float value = ${w3};
  for (int i = 0; i < ${I3}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d4}, ${T3});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l4}, ${f3});
    value += dot(${C3.texture2D}(Im2Col, im2colCoords), ${C3.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${F4}
  return value;
}`;
          return { ...t4, output: { dims: e4, type: o4[0].type, textureType: 0 }, shaderSource: Y5 };
        }, ff = (a4, t4, o4, e4) => {
          let r4 = Tm(t4.length > 2, e4);
          return { ...r4, get: () => xm(a4, r4, t4, o4, e4) };
        };
      });
      var Gr;
      var $i;
      var wm;
      var vm;
      var _m;
      var Om;
      var ki;
      var Im;
      var no = E(() => {
        "use strict";
        Ge();
        fe();
        tf();
        uf();
        cf();
        xr();
        Ci();
        oo();
        Gr = (a4, t4, o4, e4, r4) => {
          let n4 = a4[0], s4 = a4.slice(2), i5 = s4.length, u4 = t4[0], f3 = t4.slice(2).map((v5, w3) => v5 + (v5 - 1) * (o4[w3] - 1)), d4 = s4.map((v5, w3) => v5 + e4[w3] + e4[w3 + i5]).map((v5, w3) => Math.floor((v5 - f3[w3] + r4[w3]) / r4[w3]));
          return [n4, u4].concat(...d4);
        }, $i = (a4, t4, o4) => (Im(t4, o4), wm(a4, t4, o4)), wm = (a4, t4, o4) => {
          let e4 = Om(o4, t4), r4 = a4.session.pack, n4 = e4.kernelShape[0] === 1 && e4.kernelShape[1] === 1;
          return e4.group > 1 ? [a4.run(ef(a4, t4, e4), t4)] : n4 && r4 ? [vm(a4, t4, e4)] : r4 && t4[0].dims.length === 4 && t4[0].dims[0] === 1 && !n4 ? [sf(a4, t4, e4)] : [_m(a4, t4, e4)];
        }, vm = (a4, t4, o4) => {
          let e4 = t4[0].dims, r4 = t4[1].dims, n4 = Gr(e4, r4, o4.dilations, o4.pads, o4.strides), s4 = a4.reshapeUnpacked(t4[0], [e4[1], e4[2] * e4[3]]), i5 = a4.reshapeUnpacked(t4[1], [r4[0], r4[1]]), u4 = t4.length > 2 ? [i5, s4, t4[2]] : [i5, s4], l4 = a4.run(Ei(u4, o4), u4);
          return a4.reshapeUnpacked(l4, n4);
        }, _m = (a4, t4, o4) => {
          let e4 = t4[0].dims, r4 = t4[1].dims, n4 = Gr(e4, r4, o4.dilations, o4.pads, o4.strides), s4 = a4.run(lf(a4, t4[0], t4[1], n4, o4), [t4[0]]), i5 = t4.length === 3 ? [s4, t4[1], t4[2]] : [s4, t4[1]];
          return a4.run(ff(a4, t4, n4, o4), i5);
        }, Om = (a4, t4) => {
          let o4 = a4.kernelShape.slice();
          if (a4.kernelShape.length === 0)
            for (let n4 = 2; n4 < t4[1].dims.length; ++n4)
              o4.push(t4[1].dims[n4]);
          let e4 = a4.pads.slice();
          mr.adjustPadsBasedOnAutoPad(t4[0].dims, a4.strides, a4.dilations, o4, e4, a4.autoPad);
          let r4 = Object.assign({}, a4);
          return Object.assign(r4, { kernelShape: o4, pads: e4, cacheKey: a4.cacheKey }), r4;
        }, ki = (a4) => {
          let t4 = a4.attributes, o4 = Mr(t4), e4 = t4.getString("auto_pad", "NOTSET"), r4 = t4.getInts("dilations", [1, 1]), n4 = t4.getInt("group", 1), s4 = t4.getInts("kernel_shape", []), i5 = t4.getInts("pads", [0, 0, 0, 0]), u4 = t4.getInts("strides", [1, 1]);
          return ee({ autoPad: e4, dilations: r4, group: n4, kernelShape: s4, pads: i5, strides: u4, ...o4 });
        }, Im = (a4, t4) => {
          if (!a4 || a4.length !== 2 && a4.length !== 3)
            throw new Error("Conv requires 2 or 3 inputs");
          if (a4[0].dims.length !== 4 || a4[1].dims.length !== 4)
            throw new Error("currently only support 2-dimensional conv");
          let o4 = a4[0].dims[1], e4 = a4[1].dims[1] * t4.group;
          if (o4 !== e4)
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          if (a4.length === 3 && (a4[2].dims.length !== 1 || a4[1].dims[0] !== a4[2].dims[0]))
            throw new Error("invalid bias");
          let r4 = a4[0].dims.length - 2;
          if (t4.dilations.length !== r4)
            throw new Error(`dilations should be ${r4}D`);
          if (t4.strides.length !== r4)
            throw new Error(`strides should be ${r4}D`);
          if (t4.pads.length !== r4 * 2)
            throw new Error(`pads should be ${r4 * 2}D`);
          if (t4.kernelShape.length !== 0 && t4.kernelShape.length !== a4[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if (a4[0].type !== "float32" || a4[1].type !== "float32")
            throw new Error("Conv input(X,W) should be float tensor");
          if (a4.length === 3 && a4[2].type !== "float32")
            throw new Error("Conv input(bias) should be float tensor");
        };
      });
      var Sm;
      var Am;
      var Pm;
      var pf;
      var Em;
      var Dm;
      var Lm;
      var Fm;
      var Cm;
      var $m;
      var df;
      var km;
      var hf = E(() => {
        "use strict";
        Ge();
        xe();
        ae();
        xr();
        Sm = (a4, t4, o4, e4, r4, n4) => (a4 - 1) * t4 + o4 + (e4 - 1) * r4 + 1 - n4, Am = (a4, t4, o4, e4, r4) => {
          let n4 = Math.floor(a4 / 2);
          t4 === "SAME_UPPER" ? (o4[e4] = n4, o4[r4] = a4 - n4) : t4 === "SAME_LOWER" && (o4[e4] = a4 - n4, o4[r4] = n4);
        }, Pm = (a4, t4, o4, e4, r4, n4, s4, i5) => {
          let u4 = a4.length - 2, l4 = i5.length === 0;
          for (let f3 = 0; f3 < u4; ++f3) {
            let p4 = l4 ? a4[f3 + 2] * n4[f3] : i5[f3], d4 = Sm(a4[f3 + 2], n4[f3], r4[f3], t4[f3], o4[f3], p4);
            Am(d4, e4, r4, f3, f3 + u4), l4 && i5.push(n4[f3] * (a4[f3 + 2] - 1) + s4[f3] + (t4[f3] - 1) * o4[f3] + 1 - r4[f3] - r4[f3 + u4]);
          }
        }, pf = (a4, t4, o4) => (km(t4, o4), Em(a4, t4, o4)), Em = (a4, t4, o4) => {
          let e4 = $m(o4, t4);
          return [Cm(a4, t4, e4)];
        }, Dm = (a4, t4) => ({ name: "ConvTranspose", inputNames: a4 ? ["X", "W", "B"] : ["X", "W"], inputTypes: a4 ? [0, 0, 0] : [0, 0], cacheHint: t4 }), Lm = (a4, t4, o4, e4) => {
          let n4 = t4.length > 2 ? "getB(output_channel)" : "0.0", s4 = t4[0].dims, i5 = t4[1].dims, u4 = i5[1], l4 = i5[0] / e4.group, f3 = [t4[0].dims[0], t4[1].dims[1] * e4.group, ...e4.outputShape], p4 = q(a4.session.backend.glContext.version), { activationFunction: d4, applyActivation: T3 } = Nt(e4), v5 = `
  const ivec2 strides = ivec2(${e4.strides[0]}, ${e4.strides[1]});
  const ivec2 pads = ivec2(${e4.pads[0]}, ${e4.pads[1]});
  ${d4}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${u4};
    int wOutChannel = output_channel - group_id * ${u4};

    float value = ${n4};
    for (int inChannelOffset = 0; inChannelOffset < ${l4}; inChannelOffset++) {
      int input_channel = group_id * ${l4} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${i5[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${i5[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${e4.dilations[0]}, wHOff * ${e4.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${s4[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${s4[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${T3}
    ${p4.output} = vec4(value, .0, .0, .0);
  }
`;
          return { ...o4, output: { dims: f3, type: t4[0].type, textureType: 0 }, shaderSource: v5, hasMain: true };
        }, Fm = (a4, t4, o4) => {
          let e4 = Dm(t4.length > 2, o4.cacheKey);
          return { ...e4, get: () => Lm(a4, t4, e4, o4) };
        }, Cm = (a4, t4, o4) => a4.run(Fm(a4, t4, o4), t4), $m = (a4, t4) => {
          let o4 = a4.kernelShape.slice();
          if (a4.kernelShape.length === 0)
            for (let i5 = 2; i5 < t4[1].dims.length; ++i5)
              o4.push(t4[1].dims[i5]);
          let e4 = a4.pads.slice(), r4 = a4.outputShape.slice(), n4 = t4[0].dims;
          Pm(n4, o4, a4.dilations, a4.autoPad, e4, a4.strides, a4.outputPadding, r4);
          let s4 = Object.assign({}, a4);
          return Object.assign(s4, { kernelShape: o4, pads: e4, outputShape: r4, cacheKey: a4.cacheKey }), s4;
        }, df = (a4) => {
          let t4 = a4.attributes, o4 = Mr(t4), e4 = t4.getString("auto_pad", "NOTSET"), r4 = t4.getInts("dilations", [1, 1]), n4 = t4.getInt("group", 1), s4 = t4.getInts("kernel_shape", []), i5 = t4.getInts("output_padding", [0, 0]), u4 = t4.getInts("output_shape", []), l4 = t4.getInts("pads", [0, 0, 0, 0]), f3 = t4.getInts("strides", [1, 1]);
          return ee({ autoPad: e4, dilations: r4, group: n4, kernelShape: s4, outputPadding: i5, outputShape: u4, pads: l4, strides: f3, ...o4 });
        }, km = (a4, t4) => {
          if (!a4 || a4.length !== 2 && a4.length !== 3)
            throw new Error("Conv requires 2 or 3 inputs");
          if (a4[0].dims.length !== 4 || a4[1].dims.length !== 4)
            throw new Error("currently only support 2-dimensional conv");
          let o4 = a4[0].dims[1], e4 = a4[1].dims[0];
          if (o4 !== e4)
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          let r4 = a4[1].dims[1] * t4.group;
          if (a4.length === 3 && (a4[2].dims.length !== 1 || a4[2].dims[0] !== r4))
            throw new Error("invalid bias");
          let n4 = a4[0].dims.length - 2;
          if (t4.dilations.length !== n4)
            throw new Error(`dilations should be ${n4}D`);
          if (t4.strides.length !== n4)
            throw new Error(`strides should be ${n4}D`);
          if (t4.pads.length !== n4 * 2)
            throw new Error(`pads should be ${n4 * 2}D`);
          if (t4.outputPadding.length !== n4)
            throw new Error(`output_padding should be ${n4}D`);
          if (t4.kernelShape.length !== 0 && t4.kernelShape.length !== a4[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if (t4.outputShape.length !== 0 && t4.outputShape.length !== a4[0].dims.length - 2)
            throw new Error("invalid output shape");
          if (a4[0].type !== "float32" || a4[1].type !== "float32")
            throw new Error("ConvTranspose input(X,W) should be float tensor");
          if (a4.length === 3 && a4[2].type !== "float32")
            throw new Error("ConvTranspose input(bias) should be float tensor");
        };
      });
      var mf;
      var wr;
      var bf;
      var Bm;
      var gf;
      var Nm;
      var Rm;
      var Mm;
      var ao = E(() => {
        "use strict";
        Ge();
        fe();
        ae();
        mf = { name: "Transpose", inputNames: ["A"], inputTypes: [0] }, wr = (a4, t4, o4) => (Mm(t4), [a4.run({ ...mf, cacheHint: o4.cacheKey, get: () => Bm(a4, t4[0], o4.perm) }, t4)]), bf = (a4) => ee({ perm: a4.attributes.getInts("perm", []) }), Bm = (a4, t4, o4) => {
          let e4 = t4.dims;
          o4 = gf(e4, o4);
          let r4 = Nm(e4, o4), n4 = e4.length, s4 = `
      ${Rm("perm", o4, n4)}
      float process(int indices[${n4}]) {
        int a[${n4}];
        perm(a, indices);
        return _A(a);
      }`;
          return { ...mf, output: { dims: r4, type: t4.type, textureType: 0 }, shaderSource: s4 };
        }, gf = (a4, t4) => (t4 && t4.length !== a4.length && (t4 = [...a4.keys()].reverse()), t4), Nm = (a4, t4) => (t4 = gf(a4, t4), U.sortBasedOnPerm(a4, t4)), Rm = (a4, t4, o4) => {
          let e4 = [];
          e4.push(`void ${a4}(out int a[${o4}], int src[${o4}]) {`);
          for (let r4 = 0; r4 < o4; ++r4)
            e4.push(`	a[${t4[r4]}]=src[${r4}];`);
          return e4.push("	}"), e4.join(`
`);
        }, Mm = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Transpose requires 1 input.");
          if (a4[0].type !== "float32" && a4[0].type !== "float64")
            throw new Error("input should be float tensor");
        };
      });
      var yf;
      var Tf;
      var Gm;
      var xf = E(() => {
        "use strict";
        ao();
        yf = (a4, t4, o4) => {
          Gm(t4);
          let e4 = o4.blocksize, r4 = e4 * e4, n4 = o4.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], s4 = o4.mode === "DCR" ? [t4[0].dims[0], e4, e4, t4[0].dims[1] / r4, t4[0].dims[2], t4[0].dims[3]] : [t4[0].dims[0], t4[0].dims[1] / r4, e4, e4, t4[0].dims[2], t4[0].dims[3]], i5 = a4.reshapeUnpacked(t4[0], s4), u4 = { perm: n4, cacheKey: `${n4}` }, [l4] = wr(a4, [i5], u4), f3 = [t4[0].dims[0], t4[0].dims[1] / r4, t4[0].dims[2] * e4, t4[0].dims[3] * e4];
          return [a4.reshapeUnpacked(l4, f3)];
        }, Tf = (a4) => {
          let t4 = a4.attributes.getInt("blocksize");
          if (t4 < 1)
            throw new Error(`blocksize must be >= 1, but got : ${t4} for DepthToSpace`);
          let o4 = a4.attributes.getString("mode", "DCR");
          if (o4 !== "DCR" && o4 !== "CRD")
            throw new Error(`unrecognized mode: ${o4} for DepthToSpace`);
          return { mode: o4, blocksize: t4 };
        }, Gm = (a4) => {
          if (a4.length !== 1)
            throw new Error(`DepthToSpace expect 1 inputs, but got ${a4.length}`);
          if (a4[0].type === "string" || a4[0].dims.length !== 4)
            throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
        };
      });
      var wf;
      var vf;
      var Um;
      var _f = E(() => {
        "use strict";
        fe();
        wf = (a4, t4, o4) => {
          Um(t4, o4);
          let e4 = U.flattenShape(t4[0].dims, o4);
          return [a4.reshapeUnpacked(t4[0], e4)];
        }, vf = (a4) => a4.attributes.getInt("axis", 1), Um = (a4, t4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Flatten requires 1 input.");
          let o4 = a4[0].dims.length;
          if (o4 === 0)
            throw new Error("scalar tensor is not supported.");
          if (t4 < -o4 || t4 > o4)
            throw new Error("Invalid axis");
          if (a4[0].type === "string")
            throw new Error("string tensor is not supported.");
        };
      });
      var er;
      var hn = E(() => {
        "use strict";
        er = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"];
      });
      var Of;
      var If;
      var zm;
      var Vm;
      var Wm;
      var Hm;
      var Sf = E(() => {
        "use strict";
        Ge();
        hn();
        fe();
        ae();
        Of = (a4, t4, o4) => (Hm(t4, o4.axis), [a4.run(Wm(a4, t4, o4), t4)]), If = (a4) => ee({ axis: a4.attributes.getInt("axis", 0) }), zm = { name: "Gather", inputNames: ["A", "B"], inputTypes: [0, 0] }, Vm = (a4, t4, o4, e4) => {
          let r4 = o4[0].dims.slice(), n4 = o4[1].dims.slice(), s4 = new Array(r4.length + n4.length - 1);
          e4 = U.normalizeAxis(e4, r4.length);
          let i5 = [];
          for (let d4 = 0; d4 < s4.length; d4++)
            d4 < e4 ? (s4[d4] = r4[d4], i5.push(`inputIdx[${d4}] = outputIdx[${d4}];`)) : d4 < e4 + n4.length ? (s4[d4] = n4[d4 - e4], i5.push(`indexDataIdx[${d4 - e4}] = outputIdx[${d4}];`)) : (s4[d4] = r4[d4 - n4.length + 1], i5.push(`inputIdx[${d4 - n4.length + 1}] = outputIdx[${d4}];`));
          let u4 = s4.length || 1, l4 = r4.length, f3 = n4.length || 1, p4 = `
      float process(int outputIdx[${u4}]) {
        int inputIdx[${l4}];
        int indexDataIdx[${f3}];
        indexDataIdx[0] = 0;
        ${i5.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${e4}] = idx < 0 ? idx + ${r4[e4]} : idx;
        return _A(inputIdx);
      }`;
          return { ...t4, output: { dims: s4, type: o4[0].type, textureType: 0 }, shaderSource: p4 };
        }, Wm = (a4, t4, o4) => {
          let e4 = { ...zm, cacheHint: o4.cacheKey };
          return { ...e4, get: () => Vm(a4, e4, t4, o4.axis) };
        }, Hm = (a4, t4) => {
          if (!a4 || a4.length !== 2)
            throw new Error("Gather requires 2 inputs.");
          let o4 = a4[0].dims.length;
          if (o4 < 1)
            throw new Error("Invalid input shape.");
          if (t4 < -o4 || t4 > o4 - 1)
            throw new Error("Invalid axis.");
          if (er.indexOf(a4[0].type) === -1)
            throw new Error("Invaid input type.");
          if (a4[1].type !== "int32" && a4[1].type !== "int16")
            throw new Error("Invaid input type.");
        };
      });
      var Bi;
      var Af;
      var Pf;
      var Ef;
      var qm;
      var jm;
      var Ym;
      var Df = E(() => {
        "use strict";
        Ge();
        fe();
        ae();
        Bi = (a4, t4, o4) => (Ym(t4, o4), [a4.run(qm(t4, o4), t4)]), Af = (a4, t4) => {
          let o4 = a4.attributes.getInt("transA", 0) !== 0, e4 = a4.attributes.getInt("transB", 0) !== 0, r4 = a4.attributes.getFloat("alpha", 1), n4 = a4.attributes.getFloat("beta", 1);
          return ee({ transA: o4, transB: e4, alpha: r4, beta: n4, isOptionalC: t4 });
        }, Pf = (a4) => Af(a4, false), Ef = (a4) => Af(a4, true), qm = (a4, t4) => {
          let o4 = { name: "Gemm", inputNames: a4.length === 3 ? ["A", "B", "C"] : ["A", "B"], inputTypes: a4.length === 3 ? [0, 0, 0] : [0, 0], key: t4.cacheKey };
          return { ...o4, get: () => jm(o4, a4, t4) };
        }, jm = (a4, t4, o4) => {
          let e4 = t4[0].dims.slice(), r4 = t4[1].dims.slice(), [n4, s4] = Xn.getShapeOfGemmResult(e4, o4.transA, r4, o4.transB, t4.length === 3 ? t4[2].dims : void 0), i5 = [n4, s4];
          if (!i5)
            throw new Error("Can't use gemm on the given tensors");
          let u4 = e4[e4.length - 1], l4 = "";
          o4.transA && (u4 = e4[0]), o4.transA && o4.transB ? l4 = "value += _A_T(a) * _B_T(b);" : o4.transA && !o4.transB ? l4 = "value += _A_T(a) * _B(b);" : !o4.transA && o4.transB ? l4 = "value += _A(a) * _B_T(b);" : !o4.transA && !o4.transB && (l4 = "value += _A(a) * _B(b);");
          let f3 = i5.length, p4 = t4.length === 3 ? `int c[${t4[2].dims.length}];` : "", d4 = t4.length === 3 ? "bcastIndices_C(indices, c);" : "", T3 = t4.length === 3 ? "value += beta * _C(c);" : "", v5 = `
      float process(int indices[${f3}]) {
          int a[${f3}];
          int b[${f3}];
          ${p4}

          copyVec(indices, a);
          copyVec(indices, b);
          ${d4}

          float value = 0.0;
          for (int k=0; k<${u4}; ++k) {
              a[${f3 - 1}] = k;
              b[${f3 - 2}] = k;
              ${l4}
          }

          value = value * alpha;
          ${T3}
          return value;
      }`;
          return { ...a4, output: { dims: i5, type: t4[0].type, textureType: 0 }, variables: [{ name: "alpha", type: "float", data: o4.alpha }, { name: "beta", type: "float", data: o4.beta }], shaderSource: v5 };
        }, Ym = (a4, t4) => {
          if (!a4)
            throw new Error("Input is missing");
          if (t4.isOptionalC && (a4.length < 2 || a4.length > 3))
            throw new Error("Invaid input shape.");
          if (!t4.isOptionalC && a4.length !== 3)
            throw new Error("Gemm requires 3 inputs");
          if (a4.length === 3 && a4[2].dims.length !== 1 && a4[2].dims.length !== 2)
            throw new Error("Invalid input shape of C");
          if (a4[0].type !== "float32" && a4[0].type !== "float64" || a4[1].type !== "float32" && a4[1].type !== "float64" || a4.length === 3 && a4[2].type !== "float32" && a4[2].type !== "float64")
            throw new Error("Invalid input type.");
          if (a4[0].type !== a4[1].type || a4.length === 3 && a4[0].type !== a4[2].type)
            throw new Error("Input types are mismatched");
        };
      });
      var Lf;
      var Ff;
      var Xm;
      var Km;
      var Jm;
      var Zm;
      var Qm;
      var Cf = E(() => {
        "use strict";
        Ge();
        ae();
        Lf = (a4, t4, o4) => (Qm(t4), [a4.run(Jm(a4, t4, o4), t4)]), Ff = (a4) => {
          let t4 = a4.attributes.getFloat("scale"), o4 = a4.attributes.getFloats("bias");
          return ee({ scale: t4, bias: o4 });
        }, Xm = { name: "ImageScaler", inputNames: ["X"], inputTypes: [0] }, Km = (a4, t4, o4, e4) => {
          let r4 = o4[0].dims.slice(), n4 = r4.length, i5 = `
      ${Zm(e4.bias.length)}
      float process(int indices[${n4}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
          return { ...t4, output: { dims: r4, type: o4[0].type, textureType: 0 }, variables: [{ name: "bias", type: "float", arrayLength: e4.bias.length, data: e4.bias }, { name: "scale", type: "float", data: e4.scale }], shaderSource: i5 };
        }, Jm = (a4, t4, o4) => {
          let e4 = { ...Xm, cacheHint: o4.cacheKey };
          return { ...e4, get: () => Km(a4, e4, t4, o4) };
        }, Zm = (a4) => {
          let t4 = [`float getBias(float bias[${a4}], int channel) {`];
          for (let o4 = 0; o4 < a4; ++o4)
            o4 === 0 ? t4.push(`	if (channel == ${o4}) { return bias[${o4}]; }`) : o4 === a4 - 1 ? t4.push(`	else { return bias[${o4}]; }`) : t4.push(`	else if (channel == ${o4}) { return bias[${o4}]; }`);
          return t4.push("	}"), t4.join(`
`);
        }, Qm = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("ImageScaler requires 1 input.");
          if (a4[0].dims.length !== 4)
            throw new Error("Invalid input shape.");
          if (a4[0].type !== "float32" && a4[0].type !== "float64")
            throw new Error("Invalid input type.");
        };
      });
      var kf;
      var Bf;
      var $f;
      var eb;
      var tb;
      var rb;
      var nb;
      var ob;
      var ib;
      var Nf = E(() => {
        "use strict";
        xe();
        ae();
        kf = (a4, t4, o4) => {
          ib(t4);
          let e4 = a4.run(tb(t4[0]), t4);
          return [a4.run(ob(a4, t4[0], o4, e4.dims), [t4[0], e4, t4[1], t4[2]])];
        }, Bf = (a4) => a4.attributes.getFloat("epsilon", 1e-5), $f = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [0] }, eb = (a4, t4) => {
          let o4 = t4.dims.slice(), e4 = o4[1], r4 = o4[2] * o4[3], n4 = [o4[0], e4], s4 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${o4[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o4[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${r4});
        temp = 0.0;
        for(int a2=0; a2<${o4[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o4[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${r4});

        return v;
      }`;
          return { ...a4, output: { dims: n4, type: t4.type, textureType: 4 }, shaderSource: s4 };
        }, tb = (a4) => ({ ...$f, get: () => eb($f, a4) }), rb = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [0, 4, 0, 0] }, nb = (a4, t4, o4, e4, r4) => {
          let n4 = q(a4.session.backend.glContext.version), [s4, i5] = a4.calculateTextureWidthAndHeight(r4, 4), [u4, l4] = [s4 / 4, i5], f3 = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${u4}, ${l4});
        return ${n4.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
          return { ...t4, output: { dims: o4.dims, type: o4.type, textureType: 0 }, variables: [{ name: "epsilon", type: "float", data: e4 }], shaderSource: f3 };
        }, ob = (a4, t4, o4, e4) => {
          let r4 = { ...rb, cacheHint: `${o4}` };
          return { ...r4, get: () => nb(a4, r4, t4, o4, e4) };
        }, ib = (a4) => {
          if (!a4 || a4.length !== 3)
            throw new Error("InstanceNormalization requires 3 inputs.");
          let t4 = a4[0], o4 = a4[1], e4 = a4[2];
          if (t4.dims.length < 3 || o4.dims.length !== 1 || e4.dims.length !== 1)
            throw new Error("Invalid input shape.");
          if (o4.dims[0] !== t4.dims[1] || e4.dims[0] !== t4.dims[1])
            throw new Error("Input shapes are mismatched.");
          if (t4.type !== "float32" && t4.type !== "float64" || o4.type !== "float32" && o4.type !== "float64" || e4.type !== "float32" && e4.type !== "float64")
            throw new Error("Invalid input type.");
          if (a4[0].dims.length !== 4)
            throw new Error("Only support 4-D input shape.");
        };
      });
      function ab(a4, t4) {
        let o4 = a4[0].dims[1], e4 = a4[0].dims.length, r4 = -Math.floor((t4.size - 1) / 2), n4 = Math.ceil((t4.size - 1) / 2), s4 = `float(${t4.alpha}) / float(${t4.size})`, i5 = `float(${t4.bias})`, u4 = `float(${t4.beta})`, l4 = `
    float process(int indices[${e4}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${r4}; i <= ${n4}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${o4}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${i5} + ${s4} * square_sum, ${u4});
    }`;
        return { ...Gf, cacheHint: t4.cacheKey, output: { dims: a4[0].dims, type: a4[0].type, textureType: 0 }, shaderSource: l4 };
      }
      function sb(a4, t4) {
        return { ...Gf, cacheHint: t4.cacheKey, get: () => ab(a4, t4) };
      }
      var Rf;
      var Mf;
      var Gf;
      var ub;
      var Uf = E(() => {
        "use strict";
        Ge();
        ae();
        Rf = (a4, t4, o4) => (ub(t4), [a4.run(sb(t4, o4), t4)]), Mf = (a4) => {
          let t4 = a4.attributes.getFloat("alpha", 1e-4), o4 = a4.attributes.getFloat("beta", 0.75), e4 = a4.attributes.getFloat("bias", 1), r4 = a4.attributes.getInt("size");
          return ee({ alpha: t4, beta: o4, bias: e4, size: r4 });
        }, Gf = { name: "LRN", inputNames: ["X"], inputTypes: [0] };
        ub = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("LRN requires 1 input.");
          if (a4[0].dims.length !== 4)
            throw new Error('currently only support LRN for input with "NCHW" format');
          if (a4[0].type !== "float32")
            throw new Error("input should be float type");
        };
      });
      var lb;
      var Ni;
      var zf;
      var Vf;
      var Wf;
      var fb;
      var cb;
      var pb;
      var db;
      var hb;
      var mb;
      var bb;
      var gb;
      var Hf = E(() => {
        "use strict";
        Ge();
        fe();
        xe();
        ae();
        lb = { name: "Pad", inputNames: ["A"], inputTypes: [0] }, Ni = (a4, t4, o4) => (pb(t4), [a4.run({ ...lb, cacheHint: o4.cacheKey, get: () => cb(a4, t4[0], o4) }, t4)]), zf = (a4) => {
          let t4 = a4.attributes.getString("mode", "constant"), o4 = a4.attributes.getFloat("value", 0), e4 = a4.attributes.getInts("pads");
          return ee({ mode: t4, value: o4, pads: e4 });
        }, Vf = (a4, t4, o4) => {
          db(t4);
          let e4 = fb(a4, t4, o4);
          return Ni(a4, [t4[0]], e4);
        }, Wf = (a4) => a4.attributes.getString("mode", "constant"), fb = (a4, t4, o4) => {
          if (!a4.session.isInitializer(t4[1].dataId) || t4.length >= 3 && !a4.session.isInitializer(t4[2].dataId))
            throw new Error("dynamic pad attributes are not allowed");
          let e4 = Array.from(t4[1].integerData), r4 = t4.length >= 3 ? t4[2].floatData[0] : 0;
          return ee({ mode: o4, pads: e4, value: r4 });
        }, cb = (a4, t4, o4) => {
          let e4 = U.padShape(t4.dims.slice(), o4.pads), r4 = e4.length, s4 = `
      ${hb(a4, t4, o4)}
      float process(int[${r4}] indices) {
          return padA(indices);
      }`;
          return { name: "Pad", inputNames: ["A"], inputTypes: [0], output: { dims: e4, type: t4.type, textureType: 0 }, shaderSource: s4 };
        }, pb = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Pad requires 1 input");
          if (a4[0].type !== "float32" && a4[0].type !== "float64")
            throw new Error("Invalid input type.");
        }, db = (a4) => {
          if (!a4 || a4.length !== 2 && a4.length !== 3)
            throw new Error("Pad requires 2 or 3 inputs");
          if (a4[1].type !== "int32")
            throw new Error("Invalid input type.");
          if (a4.length >= 3 && a4[2].type === "string")
            throw new Error("Invalid input type.");
        }, hb = (a4, t4, o4) => {
          let e4 = q(a4.session.backend.glContext.version), [r4, n4] = a4.calculateTextureWidthAndHeight(t4.dims, 0), s4 = U.computeStrides(t4.dims);
          switch (o4.mode) {
            case "constant":
              return mb(e4, t4.dims, s4, r4, n4, o4.pads, o4.value);
            case "reflect":
              return bb(e4, t4.dims, s4, r4, n4, o4.pads);
            case "edge":
              return gb(e4, t4.dims, s4, r4, n4, o4.pads);
            default:
              throw new Error("Invalid mode");
          }
        }, mb = (a4, t4, o4, e4, r4, n4, s4) => {
          let i5 = t4.length, u4 = "";
          for (let l4 = i5 - 1; l4 >= 0; --l4)
            u4 += `
        k = m[${l4}] - ${n4[l4]};
        if (k < 0)  return constant;
        if (k >= ${t4[l4]}) return constant;
        offset += k * ${o4[l4]};
        `;
          return `
      float padA(int m[${i5}]) {
        const float constant = float(${s4});
        int offset = 0;
        int k = 0;
        ${u4}
        vec2 coords = offsetToCoords(offset, ${e4}, ${r4});
        float value = getColorAsFloat(${a4.texture2D}(A, coords));
        return value;
      }
      `;
        }, bb = (a4, t4, o4, e4, r4, n4) => {
          let s4 = t4.length, i5 = "";
          for (let u4 = s4 - 1; u4 >= 0; --u4)
            i5 += `
        k = m[${u4}] - ${n4[u4]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (t4[u4] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${t4[u4]}) { k = _2n_1 - k; }
        }
        offset += k * ${o4[u4]};
        `;
          return `
      float padA(int m[${s4}]) {
        int offset = 0;
        int k = 0;
        ${i5}
        vec2 coords = offsetToCoords(offset, ${e4}, ${r4});
        float value = getColorAsFloat(${a4.texture2D}(A, coords));
        return value;
      }
      `;
        }, gb = (a4, t4, o4, e4, r4, n4) => {
          let s4 = t4.length, i5 = "";
          for (let u4 = s4 - 1; u4 >= 0; --u4)
            i5 += `
        k = m[${u4}] - ${n4[u4]};
        if (k < 0)  k = 0;
        if (k >= ${t4[u4]}) k = ${t4[u4] - 1};
        offset += k * ${o4[u4]};
      `;
          return `
      float padA(int m[${s4}]) {
        int offset = 0;
        int k = 0;
        ${i5}
        vec2 coords = offsetToCoords(offset, ${e4}, ${r4});
        float value = getColorAsFloat(${a4.texture2D}(A, coords));
        return value;
      }
      `;
        };
      });
      var jf;
      var Yf;
      var Xf;
      var Kf;
      var Jf;
      var Zf;
      var Qf;
      var ec;
      var tc;
      var yb;
      var qf;
      var rc;
      var uo;
      var nc;
      var so;
      var Tb;
      var oc = E(() => {
        "use strict";
        Ge();
        fe();
        ae();
        jf = (a4, t4, o4) => {
          uo(t4);
          let e4 = { name: "AveragePool", inputNames: ["X"], inputTypes: [0], cacheHint: o4.cacheKey };
          return [a4.run({ ...e4, get: () => Xf(t4, e4, false, o4) }, t4)];
        }, Yf = (a4) => {
          let t4 = a4.attributes.getString("auto_pad", "NOTSET"), o4 = a4.attributes.getInt("ceil_mode", 0), e4 = a4.attributes.getInt("count_include_pad", 0) !== 0, r4 = a4.attributes.getInts("kernel_shape"), n4 = a4.attributes.getInts("strides", []), s4 = a4.attributes.getInts("pads", []);
          if (o4 !== 0)
            throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
          return ee({ autoPad: t4, ceilMode: o4, countIncludePad: e4, kernelShape: r4, strides: n4, pads: s4 });
        }, Xf = (a4, t4, o4, e4) => {
          let [r4, n4] = tc(a4, e4, o4), s4 = U.size(r4.kernelShape), i5 = "value += _X(x);", u4 = "";
          r4.countIncludePad ? u4 += `value /= float(${s4});` : u4 += `value /= float(${s4} - pad);`;
          let f3 = `
        ${nc(a4[0].dims, r4, i5, u4, "0.0")}
      `;
          return { ...t4, output: { dims: n4, type: a4[0].type, textureType: 0 }, shaderSource: f3 };
        }, Kf = (a4, t4, o4) => {
          uo(t4);
          let e4 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [0], cacheHint: `${o4.countIncludePad}` };
          return [a4.run({ ...e4, get: () => Xf(t4, e4, true, o4) }, t4)];
        }, Jf = (a4) => {
          let t4 = a4.attributes.getInt("count_include_pad", 0) !== 0;
          return ee({ autoPad: "", ceilMode: 0, countIncludePad: t4, kernelShape: [], strides: [], pads: [] });
        }, Zf = (a4, t4, o4) => {
          uo(t4);
          let e4 = { name: "MaxPool", inputNames: ["X"], inputTypes: [0], cacheHint: o4.cacheKey };
          return [a4.run({ ...e4, get: () => ec(t4, e4, false, o4) }, t4)];
        }, Qf = (a4) => {
          let t4 = a4.attributes.getString("auto_pad", "NOTSET"), o4 = a4.attributes.getInt("ceil_mode", 0), e4 = a4.attributes.getInts("kernel_shape"), r4 = a4.attributes.getInts("strides", []), n4 = a4.attributes.getInts("pads", []), s4 = a4.attributes.getInt("storage_order", 0), i5 = a4.attributes.getInts("dilations", []);
          if (s4 !== 0)
            throw new Error("column major storage order is not yet supported for MaxPool");
          if (o4 !== 0)
            throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
          return ee({ autoPad: t4, ceilMode: o4, countIncludePad: false, kernelShape: e4, strides: r4, pads: n4, storageOrder: s4, dilations: i5 });
        }, ec = (a4, t4, o4, e4) => {
          let [r4, n4] = tc(a4, e4, o4), s4 = `
      value = max(_X(x), value);
    `, i5 = "", l4 = `
      ${nc(a4[0].dims, r4, s4, i5, "-1e5")}
    `;
          return { ...t4, output: { dims: n4, type: a4[0].type, textureType: 0 }, shaderSource: l4 };
        }, tc = (a4, t4, o4) => {
          let e4 = a4[0].dims.slice(), r4 = Object.hasOwnProperty.call(t4, "dilations"), n4 = t4.kernelShape.slice(), s4 = t4.strides.slice(), i5 = r4 ? t4.dilations.slice() : [], u4 = t4.pads.slice();
          mr.adjustPoolAttributes(o4, e4, n4, s4, i5, u4);
          let l4 = mr.computePoolOutputShape(o4, e4, s4, i5, n4, u4, t4.autoPad), f3 = Object.assign({}, t4);
          return r4 ? Object.assign(f3, { kernelShape: n4, strides: s4, pads: u4, dilations: i5, cacheKey: t4.cacheKey }) : Object.assign(f3, { kernelShape: n4, strides: s4, pads: u4, cacheKey: t4.cacheKey }), [f3, l4];
        }, yb = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, qf = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [0] }, rc = (a4, t4) => (uo(t4), [a4.run({ ...qf, get: () => ec(t4, qf, true, yb) }, t4)]), uo = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Pool ops requires 1 input.");
          if (a4[0].type !== "float32" && a4[0].type !== "float64")
            throw new Error("Invalid input type.");
        }, nc = (a4, t4, o4, e4, r4) => {
          let n4 = a4.length;
          if (t4.kernelShape.length <= 2) {
            let s4 = t4.kernelShape[t4.kernelShape.length - 1], i5 = t4.strides[t4.strides.length - 1], u4 = t4.pads[t4.pads.length / 2 - 1], l4 = t4.pads[t4.pads.length - 1], f3 = a4[n4 - 1], p4 = "", d4 = "", T3 = "";
            if (u4 + l4 !== 0 ? p4 = `
          for (int i = 0; i < ${s4}; i++) {
            x[${n4} - 1] = indices[${n4} - 1] * ${i5} - ${u4} + i;
            if (x[${n4} - 1] < 0 || x[${n4} - 1] >= ${f3}) {
              pad++;
              continue;
            }
            ${o4}
          }` : p4 = `
          for (int i = 0; i < ${s4}; i++) {
            x[${n4} - 1] = indices[${n4} - 1] * ${i5} - ${u4} + i;
            ${o4}
          }`, t4.kernelShape.length === 2) {
              let w3 = t4.kernelShape[t4.kernelShape.length - 2], I3 = t4.strides[t4.strides.length - 2], L3 = t4.pads[t4.pads.length / 2 - 2], F4 = t4.pads[t4.pads.length - 2], C3 = a4[n4 - 2];
              L3 + F4 !== 0 ? d4 = `
            for (int j = 0; j < ${w3}; j++) {
              x[${n4} - 2] = indices[${n4} - 2] * ${I3} - ${L3} + j;
              if (x[${n4} - 2] < 0 || x[${n4} - 2] >= ${C3}) {
                pad+= ${s4};
                continue;
              }
          ` : d4 = `
            for (int j = 0; j < ${w3}; j++) {
              x[${n4} - 2] = indices[${n4} - 2] * ${I3} - ${L3} + j;
            `, T3 = `
          }
        `;
            }
            return `
        float process(int indices[${n4}]) {
          int x[${n4}];
          copyVec(indices, x);

          float value = ${r4};
          int pad = 0;
          ${d4}
          ${p4}
          ${T3}
          ${e4}
          return value;
        }
      `;
          } else {
            let s4 = U.size(t4.kernelShape), i5 = U.computeStrides(t4.kernelShape), u4 = i5.length, l4 = t4.pads.length, f3 = Tb(u4), p4 = so(a4, "inputDims"), d4 = so(t4.pads, "pads"), T3 = so(i5, "kernelStrides"), v5 = so(t4.strides, "strides"), w3 = t4.pads.reduce((F4, C3) => F4 + C3), I3 = "";
            return w3 ? I3 = `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${o4}
          }` : I3 = `
          }
          ${o4}
        `, `
        ${f3}
        float process(int indices[${n4}]) {
          int x[${n4}];
          copyVec(indices, x);
          int offset[${u4}];
          int pads[${l4}];
          int inputDims[${n4}];
          int kernelStrides[${u4}];
          int strides[${u4}];
          ${d4}
          ${p4}
          ${v5}
          ${T3}

          float value = ${r4};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s4}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${n4} - ${u4}; j < ${n4}; j++) {
              x[j] = indices[j] * strides[j - ${n4} + ${u4}]
                + offset[j - ${n4} + ${u4}] - pads[j - 2];
              ${I3}
          }
          ${e4}

          return value;
        }
      `;
          }
        }, so = (a4, t4) => {
          let o4 = "";
          for (let e4 = 0; e4 < a4.length; e4++)
            o4 += `
      ${t4}[${e4}] = ${a4[e4]};
    `;
          return o4;
        }, Tb = (a4) => `
  void offsetToIndices(int offset, int[${a4}] strides, out int[${a4}] indices) {
    if (${a4} == 0) {
      return;
    }
    for (int i = 0; i < ${a4} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${a4} - 1] = offset;
  }`;
      });
      var vr;
      var tr;
      var xb;
      var wb;
      var ic;
      var ac;
      var sc;
      var uc;
      var lc;
      var fc;
      var cc;
      var pc = E(() => {
        "use strict";
        Ge();
        hn();
        fe();
        ae();
        vr = (a4, t4, o4, e4, r4) => {
          wb(t4);
          let n4 = { name: e4, inputNames: ["A"], inputTypes: [0] };
          return [a4.run({ ...n4, cacheHint: o4.cacheKey, get: () => xb(a4, t4, o4, e4, r4, n4) }, t4)];
        }, tr = (a4) => {
          let t4 = a4.attributes.getInts("axes", []), o4 = a4.attributes.getInt("keepdims", 1) === 1;
          return ee({ axes: t4, keepDims: o4 });
        }, xb = (a4, t4, o4, e4, r4, n4) => {
          let s4 = [], i5 = t4[0].dims.length || 1, u4 = [], l4 = U.normalizeAxes(o4.axes, t4[0].dims.length), f3 = r4(t4, l4), p4 = f3[1];
          for (let v5 = 0; v5 < t4[0].dims.length; v5++)
            l4.indexOf(v5) >= 0 || l4.length === 0 ? (o4.keepDims && s4.push(1), p4 = `
          for(int j${v5} = 0; j${v5} < ${t4[0].dims[v5]}; j${v5}++) {
            inputIdx[${v5}] = j${v5};
            ${p4}
          }`) : (u4.push(`inputIdx[${v5}] = outputIdx[${s4.length}];`), s4.push(t4[0].dims[v5]));
          let T3 = `
      float process(int outputIdx[${s4.length || 1}]) {
        float value;                 // final result
        int inputIdx[${i5}];      // addressing input data
        ${u4.join(`
`)}
        ${f3[0]}       // init ops for reduce max/min
        ${p4}
        ${f3[2]}       // final computation for reduce mean
        return value;
      }`;
          return { ...n4, output: { dims: s4, type: t4[0].type, textureType: 0 }, shaderSource: T3 };
        }, wb = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Reduce op requires 1 input.");
          if (er.indexOf(a4[0].type) === -1)
            throw new Error("Invalid input type.");
        }, ic = (a4, t4, o4) => vr(a4, t4, o4, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), ac = (a4, t4, o4) => vr(a4, t4, o4, "ReduceMean", (r4, n4) => {
          let s4 = 1;
          for (let i5 = 0; i5 < r4[0].dims.length; i5++)
            (n4.indexOf(i5) >= 0 || n4.length === 0) && (s4 *= r4[0].dims[i5]);
          return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${s4}.;`];
        }), sc = (a4, t4, o4) => vr(a4, t4, o4, "ReduceMax", (r4, n4) => {
          let s4 = [];
          for (let i5 = 0; i5 < r4[0].dims.length; i5++)
            (n4.indexOf(i5) >= 0 || n4.length === 0) && s4.push(`inputIdx[${i5}] = 0;`);
          return [`${s4.join(`
`)}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
        }), uc = (a4, t4, o4) => vr(a4, t4, o4, "ReduceMin", (r4, n4) => {
          let s4 = [];
          for (let i5 = 0; i5 < r4[0].dims.length; i5++)
            (n4.indexOf(i5) >= 0 || n4.length === 0) && s4.push(`inputIdx[${i5}] = 0;`);
          return [`${s4.join(`
`)}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
        }), lc = (a4, t4, o4) => vr(a4, t4, o4, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), fc = (a4, t4, o4) => vr(a4, t4, o4, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), cc = (a4, t4, o4) => vr(a4, t4, o4, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
      });
      var dc;
      var hc = E(() => {
        "use strict";
        fe();
        dc = (a4, t4) => {
          let o4 = U.calculateReshapedDims(t4[0].dims, t4[1].integerData);
          return a4.session.pack ? [a4.reshapePacked(t4[0], o4)] : [a4.reshapeUnpacked(t4[0], o4)];
        };
      });
      var mc;
      var Ri;
      var bc;
      var gc;
      var mn;
      var vb;
      var Mi;
      var lo;
      var Gi = E(() => {
        "use strict";
        Ge();
        xe();
        ae();
        mc = { name: "Upsample", inputNames: ["X"], inputTypes: [0] }, Ri = (a4, t4, o4) => (Mi(t4, o4), [a4.run({ ...mc, cacheHint: o4.cacheKey, get: () => vb(a4, t4, o4) }, t4)]), bc = (a4) => mn(a4, 7), gc = (a4) => mn(a4, 9), mn = (a4, t4) => {
          let o4 = t4 >= 10, e4 = a4.attributes.getString("mode", "nearest");
          if (e4 !== "nearest" && e4 !== "linear" && (t4 < 11 || e4 !== "cubic"))
            throw new Error(`unrecognized mode: ${e4}`);
          let r4 = [];
          t4 < 9 && (r4 = a4.attributes.getFloats("scales"), lo(r4, e4, o4));
          let n4 = a4.attributes.getFloat("extrapolation_value", 0), s4 = t4 > 10 ? a4.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
          if (["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(s4) === -1)
            throw new Error(`coordinate_transform_mode '${s4}' is not supported`);
          let i5 = s4 === "tf_crop_and_resize", u4 = i5, l4 = e4 === "nearest" && t4 >= 11 ? a4.attributes.getString("nearest_mode", "round_prefer_floor") : "";
          if (["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(l4) === -1)
            throw new Error(`nearest_mode '${l4}' is not supported`);
          let f3 = a4.attributes.getFloat("cubic_coeff_a", -0.75), p4 = a4.attributes.getInt("exclude_outside", 0) !== 0;
          if (p4 && e4 !== "cubic")
            throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
          let d4 = t4 < 11 ? true : e4 === "nearest" && s4 === "asymmetric" && l4 === "floor", T3 = 0, v5 = 0, w3 = 0;
          return t4 > 10 ? a4.inputs.length > 2 ? (T3 = 1, v5 = 2, w3 = 3) : (v5 = 1, w3 = 2) : t4 === 9 && (v5 = 1), ee({ opset: t4, isResize: o4, mode: e4, scales: r4, extrapolationValue: n4, coordinateTransformMode: s4, useExtrapolation: u4, needRoiInput: i5, nearestMode: l4, cubicCoefficientA: f3, excludeOutside: p4, useNearest2xOptimization: d4, roiInputIdx: T3, scalesInputIdx: v5, sizesInputIdx: w3 });
        }, vb = (a4, t4, o4) => {
          let e4 = q(a4.session.backend.glContext.version), [r4, n4] = a4.calculateTextureWidthAndHeight(t4[0].dims, 0), s4 = t4[0].dims.map((w3, I3) => Math.floor(w3 * o4.scales[I3])), [i5, u4] = a4.calculateTextureWidthAndHeight(s4, 0), l4 = s4.length, f3 = new Array(l4), p4 = new Array(l4), d4 = `
      int output_pitches[${l4}];
      int input_pitches[${l4}];
      `;
          for (let w3 = l4 - 1; w3 >= 0; w3--)
            f3[w3] = w3 === l4 - 1 ? 1 : f3[w3 + 1] * s4[w3 + 1], p4[w3] = w3 === l4 - 1 ? 1 : p4[w3 + 1] * t4[0].dims[w3 + 1], d4 += `
        output_pitches[${w3}] = ${f3[w3]};
        input_pitches[${w3}] = ${p4[w3]};
        `;
          let T3 = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${r4}, ${n4});
        float value = getColorAsFloat(${e4.texture2D}(X, coords));
        return value;
      }
      `, v5 = o4.mode === "nearest" ? `
    ${T3}
    float process(int indices[${l4}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i5}, ${u4});

      ${d4}

      int d, m;
      for (int dim = 0; dim < ${l4}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : l4 === 4 ? `
    ${T3}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i5}, ${u4});

      ${d4}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${t4[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${T3}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i5}, ${u4});

      ${d4}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${t4[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
          return { ...mc, output: { dims: s4, type: t4[0].type, textureType: 0 }, shaderSource: v5, variables: [{ name: "scales", type: "int", arrayLength: o4.scales.length, data: o4.scales.map((w3) => Math.ceil(w3)) }] };
        }, Mi = (a4, t4) => {
          if (!a4 || t4.opset < 9 && a4.length !== 1 || t4.opset >= 9 && t4.opset < 11 && a4.length !== 2 || t4.opset >= 11 && a4.length < 2)
            throw new Error("invalid inputs.");
          if (t4.scales.length > 0 && a4[0].dims.length !== t4.scales.length)
            throw new Error("Invalid input shape.");
          if (a4[0].type === "string")
            throw new Error("Invalid input tensor types.");
        }, lo = (a4, t4, o4) => {
          if (o4) {
            for (let e4 of a4)
              if (e4 <= 0)
                throw new Error("Scale value should be greater than 0.");
          } else
            for (let e4 of a4)
              if (e4 < 1)
                throw new Error("Scale value should be greater than or equal to 1.");
          if ((t4 === "linear" || t4 === "cubic") && a4.length !== 2 && (a4.length !== 4 || a4[0] !== 1 || a4[1] !== 1))
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o4 ? "Resize" : "Upsample"} opeartor.`);
        };
      });
      var Ui;
      var zi;
      var yc;
      var Tc;
      var _b;
      var Ob;
      var Ib;
      var Sb;
      var xc = E(() => {
        "use strict";
        xe();
        ae();
        kt();
        Tr();
        Gi();
        Ui = { name: "Resize", inputNames: ["A"], inputTypes: [2] }, zi = (a4, t4, o4) => (Mi(t4, o4), [a4.run({ ...Ui, cacheHint: o4.cacheKey, get: () => _b(a4, t4, o4) }, t4)]), yc = (a4) => mn(a4, 10), Tc = (a4) => mn(a4, 11), _b = (a4, t4, o4) => {
          let e4 = q(a4.session.backend.glContext.version), [r4, n4] = Ob(t4, o4);
          if (r4.every((C3) => C3 === 1) && o4.coordinateTransformMode !== "tf_crop_and_resize")
            return { ...Ui, output: { dims: n4, type: t4[0].type, textureType: 2 }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${e4.texture2D}(X, TexCoords);
                    ${e4.output} = v;
                }` };
          let i5 = n4.length;
          if (i5 < 2)
            throw new Error(`output dimension should be at least 2, but got ${i5}`);
          let u4 = n4[i5 - 2], l4 = n4[i5 - 1], f3 = t4[0].dims;
          if (i5 !== f3.length)
            throw new Error(`output dimension should match input ${f3.length}, but got ${i5}`);
          let p4 = f3[i5 - 2], d4 = f3[i5 - 1], T3 = r4[i5 - 2], v5 = r4[i5 - 1], w3 = "";
          if (o4.mode !== "linear")
            throw new Error(`resize (packed) does not support mode: '${o4.mode}'`);
          switch (o4.coordinateTransformMode) {
            case "asymmetric":
              w3 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
              break;
            case "half_pixel":
              w3 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
              break;
            case "pytorch_half_pixel":
              w3 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${l4}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${u4}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${l4}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${u4}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
              break;
            case "align_corners":
              w3 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${l4}.0 - 1.0, ${u4}.0 - 1.0, ${l4}.0 - 1.0,
                            ${u4}.0 - 1.0);
                        vec4 original = vec4(${d4}.0 - 1.0, ${p4}.0 - 1.0, ${d4}.0 - 1.0,
                            ${p4}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
              break;
            default:
              throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o4.coordinateTransformMode}'`);
          }
          let I3 = Je(i5), L3 = Bt(), F4 = `
            const vec2 inputWH = vec2(${p4}.0, ${d4}.0);
            const vec4 scaleWHWH = vec4(float(${T3}), float(${v5}), float(${T3}), float(${v5}));
            ${L3}
            ${w3}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${I3} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${u4 - 1};
                bool hasNextCol = rc.z < ${l4 - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${e4.output} = vec4(newValue);
            }
        `;
          return { ...Ui, output: { dims: n4, type: t4[0].type, textureType: 2 }, hasMain: true, shaderSource: F4 };
        }, Ob = (a4, t4) => {
          let e4 = a4[0].dims, r4 = t4.scales, n4;
          if (r4.length === 0) {
            let i5 = a4[t4.scalesInputIdx];
            if (i5 && i5.size !== 0) {
              if (a4[t4.sizesInputIdx])
                throw new Error("Only one of scales or sizes must be provided as input.");
              r4 = Ib(i5, t4.mode, t4.isResize);
            } else {
              let u4 = a4[t4.sizesInputIdx];
              if (!u4 || u4.size === 0)
                throw new Error("Either scales or sizes MUST be provided as input.");
              n4 = Array.from(u4.integerData), r4 = Sb(n4, e4, t4.mode, t4.isResize);
            }
          } else if (a4[t4.sizesInputIdx])
            throw new Error("Only one of scales or sizes must be provided as input.");
          let s4 = n4 || e4.map((i5, u4) => Math.floor(i5 * r4[u4]));
          return [r4, s4];
        }, Ib = (a4, t4, o4) => {
          let e4 = Array.from(a4.floatData);
          return lo(e4, t4, o4), e4;
        }, Sb = (a4, t4, o4, e4) => {
          let r4 = t4.length, n4 = new Array(r4);
          for (let s4 = 0, i5 = r4; s4 < i5; s4++)
            if (t4[s4] === 0) {
              if (a4[s4] !== 0)
                throw new Error("Input dim is zero but required output dim is non-zero.");
              n4[s4] = 1;
            } else
              n4[s4] = a4[s4] / t4[s4];
          return lo(n4, o4, e4), n4;
        };
      });
      var wc;
      var Ab;
      var vc = E(() => {
        "use strict";
        yr();
        wc = (a4, t4) => (Ab(t4), [new Ce([t4[0].dims.length], "int32", void 0, void 0, new Int32Array(t4[0].dims))]), Ab = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Shape requires 1 input.");
        };
      });
      var Vi;
      var _c;
      var Oc;
      var Ic;
      var Pb;
      var Sc;
      var Eb;
      var Db;
      var Ac = E(() => {
        "use strict";
        Ge();
        hn();
        fe();
        ae();
        Vi = { name: "Slice", inputNames: ["A"], inputTypes: [0] }, _c = (a4, t4, o4) => (Pb(t4), [a4.run({ ...Vi, cacheHint: o4.cacheKey, get: () => Ic(a4, t4[0], o4) }, t4)]), Oc = (a4) => {
          let t4 = a4.attributes.getInts("starts"), o4 = a4.attributes.getInts("ends"), e4 = a4.attributes.getInts("axes", []);
          return ee({ starts: t4, ends: o4, axes: e4 });
        }, Ic = (a4, t4, o4) => {
          let e4 = o4.axes.length === 0 ? t4.dims.slice(0).map((p4, d4) => d4) : o4.axes, r4 = U.normalizeAxes(e4, t4.dims.length), n4 = o4.starts.map((p4, d4) => p4 > t4.dims[r4[d4]] - 1 ? t4.dims[r4[d4]] : U.normalizeAxis(p4, t4.dims[r4[d4]])), s4 = o4.ends.map((p4, d4) => p4 > t4.dims[r4[d4]] - 1 ? t4.dims[r4[d4]] : U.normalizeAxis(p4, t4.dims[r4[d4]])), i5 = t4.dims.slice(), u4 = [];
          for (let p4 = 0; p4 < r4.length; p4++)
            i5[r4[p4]] = s4[p4] - n4[p4], n4[p4] > 0 && u4.push(`outputIdx[${r4[p4]}] += ${n4[p4]};`);
          let f3 = `
      float process(int outputIdx[${i5.length}]) {
        ${u4.join(`
      `)}
        return _A(outputIdx);
      }`;
          return { ...Vi, output: { dims: i5, type: t4.type, textureType: 0 }, shaderSource: f3 };
        }, Pb = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Slice requires 1 input.");
          if (er.indexOf(a4[0].type) === -1)
            throw new Error("Invalid input type.");
        }, Sc = (a4, t4) => {
          Db(t4);
          let o4 = Eb(a4, t4);
          return [a4.run({ ...Vi, cacheHint: o4.cacheKey, get: () => Ic(a4, t4[0], o4) }, [t4[0]])];
        }, Eb = (a4, t4) => {
          if (!a4.session.isInitializer(t4[1].dataId) || !a4.session.isInitializer(t4[2].dataId) || t4.length >= 4 && !a4.session.isInitializer(t4[3].dataId) || t4.length >= 5 && !a4.session.isInitializer(t4[4].dataId))
            throw new Error("dynamic slice attributes are not allowed");
          if (t4.length >= 5 && t4[4].integerData.some((s4) => s4 !== 1))
            throw new Error("currently non-1 steps is not supported for Slice");
          let o4 = Array.from(t4[1].integerData), e4 = Array.from(t4[2].integerData), r4 = t4.length >= 4 ? Array.from(t4[3].integerData) : [], n4 = `${r4};${o4};${e4}`;
          return { starts: o4, ends: e4, axes: r4, cacheKey: n4 };
        }, Db = (a4) => {
          if (!a4 || a4.length < 3 || a4.length > 5)
            throw new Error("Invalid input number.");
          if (a4[1].type !== "int32" || a4[1].dims.length !== 1)
            throw new Error("Invalid input type.");
          if (a4[2].type !== "int32" || a4[2].dims.length !== 1)
            throw new Error("Invalid input type.");
          if (a4.length >= 4 && (a4[3].type !== "int32" || a4[3].dims.length !== 1))
            throw new Error("Invalid input type.");
          if (a4.length >= 5 && (a4[4].type !== "int32" || a4[4].dims.length !== 1))
            throw new Error("Invalid input type.");
        };
      });
      var Pc;
      var Ec;
      var Dc;
      var Lc;
      var Fc;
      var Cc;
      var $c;
      var kc;
      var Lb;
      var Fb;
      var Cb;
      var Bc;
      var Nc = E(() => {
        "use strict";
        Ge();
        fe();
        xe();
        ae();
        ao();
        Pc = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [0] }, Ec = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [0, 0] }, Dc = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [0, 0, 0] }, Lc = (a4, t4, o4) => {
          Bc(t4);
          let e4 = t4[0].dims.slice(), r4 = U.normalizeAxis(o4.axis, e4.length), n4 = U.sizeToDimension(e4, r4), s4 = U.sizeFromDimension(e4, r4);
          return kc(a4, t4, o4, n4, s4);
        }, Fc = (a4) => ee({ axis: a4.attributes.getInt("axis", 1) }), Cc = (a4) => ee({ axis: a4.attributes.getInt("axis", -1) }), $c = (a4, t4, o4) => {
          Bc(t4);
          let e4 = t4[0].dims.slice(), r4 = U.normalizeAxis(o4.axis, e4.length), n4 = e4.length, s4 = r4 !== n4 - 1, i5 = [], u4 = [], l4 = [], f3;
          s4 && (u4 = Array.from({ length: n4 }).map((v5, w3) => w3), u4[r4] = n4 - 1, u4[n4 - 1] = r4, u4.map((v5) => i5.push(e4[v5])), f3 = ee({ perm: u4 }), l4 = wr(a4, t4, f3));
          let p4 = s4 ? U.sizeToDimension(i5, n4 - 1) : U.sizeToDimension(e4, n4 - 1), d4 = s4 ? U.sizeFromDimension(i5, n4 - 1) : U.sizeFromDimension(e4, n4 - 1), T3 = kc(a4, s4 ? l4 : t4, o4, p4, d4);
          return s4 ? wr(a4, T3, f3) : T3;
        }, kc = (a4, t4, o4, e4, r4) => {
          let n4 = Lb(a4, t4[0], e4, r4, [e4]), s4 = a4.run({ ...Pc, cacheHint: o4.cacheKey, get: () => n4 }, t4), i5 = Fb(a4, t4[0], e4, r4, n4.output.dims, [e4]), u4 = a4.run({ ...Ec, cacheHint: o4.cacheKey, get: () => i5 }, [t4[0], s4]), l4 = Cb(a4, t4[0], e4, r4, n4.output.dims, i5.output.dims);
          return [a4.run({ ...Dc, cacheHint: o4.cacheKey, get: () => l4 }, [t4[0], s4, u4])];
        }, Lb = (a4, t4, o4, e4, r4) => {
          let [n4, s4] = a4.calculateTextureWidthAndHeight(t4.dims, 0), i5 = r4.length;
          if (o4 < 1 || e4 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (r4.length !== 1)
            throw new Error("Dimensionality of the output should be 1");
          if (r4[0] !== o4)
            throw new Error("Shape of the output should be equal to logical row count");
          let u4 = q(a4.session.backend.glContext.version), l4 = `
      float process(int[${i5}] indices) {
        int logical_row_start_offset = indices[0] * ${e4};

        float max = getColorAsFloat(${u4.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n4},
        ${s4} )));
        for(int i=1; i<${e4}; ++i)
        {
          float current = getColorAsFloat(${u4.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${n4}, ${s4})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
          return { ...Pc, output: { dims: r4, type: t4.type, textureType: 0 }, shaderSource: l4 };
        }, Fb = (a4, t4, o4, e4, r4, n4) => {
          let [s4, i5] = a4.calculateTextureWidthAndHeight(t4.dims, 0), u4 = n4.length;
          if (o4 < 1 || e4 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (n4.length !== 1)
            throw new Error("Dimensionality of the output should be 1");
          if (n4[0] !== o4)
            throw new Error("Shape of the output should be equal to logical row count");
          if (r4.length !== 1)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (r4[0] !== o4)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          let l4 = q(a4.session.backend.glContext.version), f3 = `
      float process(int[${u4}] indices) {
        int logical_row_start_offset = indices[0] * ${e4};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${e4}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${l4.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s4}, ${i5}))) - max);
        }

        return norm_factor;
      }`;
          return { ...Ec, output: { dims: n4, type: t4.type, textureType: 0 }, shaderSource: f3 };
        }, Cb = (a4, t4, o4, e4, r4, n4) => {
          let [s4, i5] = a4.calculateTextureWidthAndHeight(t4.dims, 0), u4 = t4.dims.length;
          if (o4 < 1 || e4 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (r4.length !== 1 || n4.length !== 1)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (r4[0] !== o4 || n4[0] !== o4)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          let l4 = `
      float process(int[${u4}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s4}, ${i5});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${e4};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
          return { ...Dc, output: { dims: t4.dims, type: t4.type, textureType: 0 }, shaderSource: l4 };
        }, Bc = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Softmax requires 1 input.");
          if (a4[0].type !== "float32" && a4[0].type !== "float64")
            throw new Error("Invalid input type");
        };
      });
      var Rc;
      var Mc;
      var Gc;
      var $b;
      var kb;
      var Bb;
      var Uc = E(() => {
        "use strict";
        Ge();
        fe();
        ae();
        Rc = { name: "Split", inputNames: ["A"], inputTypes: [0] }, Mc = (a4, t4, o4) => {
          Bb(t4);
          let e4 = U.normalizeAxis(o4.axis, t4[0].dims.length), r4 = $b(a4, t4, e4, o4), n4 = [];
          for (let s4 = 0; s4 < r4; ++s4)
            n4.push(a4.run({ ...Rc, cacheHint: `${o4.cacheKey};${s4}`, get: () => kb(a4, t4[0], o4, e4, s4) }, t4));
          return n4;
        }, Gc = (a4) => {
          let t4 = a4.attributes.getInt("axis", 0), o4 = a4.attributes.getInts("split", []), e4 = a4.outputs.length;
          return ee({ axis: t4, split: o4, numOutputs: e4 });
        }, $b = (a4, t4, o4, e4) => {
          let [, r4] = un.splitShape(t4[0].dims, o4, e4.split, e4.numOutputs);
          return r4.length;
        }, kb = (a4, t4, o4, e4, r4) => {
          let [n4, s4] = un.splitShape(t4.dims, e4, o4.split, o4.numOutputs), i5 = s4[r4], u4 = n4[r4], f3 = `
      float process(int indices[${u4.length}]) {
        indices[${e4}] += ${i5};
        return _A(indices);
      }
    `;
          return { ...Rc, cacheHint: `${o4.cacheKey}:${r4}`, output: { dims: u4, type: t4.type, textureType: 0 }, shaderSource: f3 };
        }, Bb = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Split requires one input.");
          if (a4[0].type !== "int8" && a4[0].type !== "uint8" && a4[0].type !== "int16" && a4[0].type !== "uint16" && a4[0].type !== "int32" && a4[0].type !== "uint32" && a4[0].type !== "float32" && a4[0].type !== "float64" && a4[0].type !== "bool")
            throw new Error("Invalid input type.");
        };
      });
      var Wi;
      var zc;
      var Vc;
      var Nb;
      var Rb;
      var Wc = E(() => {
        "use strict";
        fe();
        Wi = (a4, t4, o4) => {
          Nb(t4);
          let e4 = U.squeezeShape(t4[0].dims, o4);
          return [a4.reshapeUnpacked(t4[0], e4)];
        }, zc = (a4, t4) => (Rb(t4), Wi(a4, [t4[0]], Array.from(t4[1].integerData))), Vc = (a4) => a4.attributes.getInts("axes"), Nb = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Squeeze requires 1 input.");
          if (a4[0].type === "string")
            throw new Error("invalid input tensor types.");
        }, Rb = (a4) => {
          if (!a4 || a4.length !== 2)
            throw new Error("Squeeze requires 2 inputs.");
          if (a4[1].type !== "int32")
            throw new Error("Invalid input type.");
        };
      });
      var Hc;
      var Mb;
      var Gb;
      var qc = E(() => {
        "use strict";
        xe();
        ae();
        Hc = (a4, t4) => {
          Gb(t4);
          let o4 = { name: "Sum", inputNames: t4.map((r4, n4) => `X${n4}`), inputTypes: new Array(t4.length).fill(0) };
          return [a4.run({ ...o4, get: () => Mb(a4, t4, o4) }, t4)];
        }, Mb = (a4, t4, o4) => {
          let e4 = q(a4.session.backend.glContext.version), r4 = t4[0].dims.slice(), s4 = `
      void main() {
        vec4 result = ${t4.map((i5, u4) => `${e4.texture2D}(X${u4},TexCoords)`).join(" + ")};
        ${e4.output} = result;
      }
    `;
          return { ...o4, output: { dims: r4, type: t4[0].type, textureType: 0 }, hasMain: true, shaderSource: s4 };
        }, Gb = (a4) => {
          if (!a4 || a4.length === 0)
            throw new Error("Sum requires inputs.");
          let t4 = a4[0].dims.length;
          for (let o4 = 1; o4 < a4.length; o4++) {
            if (t4 !== a4[o4].dims.length)
              throw new Error("Input shapes are mismatched.");
            for (let e4 = 0; e4 < t4; e4++)
              if (a4[0].dims[e4] !== a4[o4].dims[e4])
                throw new Error("Input shapes are not matched.");
          }
          if (a4[0].type !== "float32" && a4[0].type !== "float64")
            throw new Error("Invalid input type.");
          for (let o4 = 1; o4 < a4.length; o4++)
            if (a4[0].type !== a4[o4].type)
              throw new Error("Input types are not matched.");
        };
      });
      var jc;
      var Ub;
      var zb;
      var Yc = E(() => {
        "use strict";
        hn();
        ae();
        jc = (a4, t4) => {
          zb(t4);
          let o4 = { name: "Tile", inputNames: ["A"], inputTypes: [0] };
          return [a4.run({ ...o4, get: () => Ub(a4, t4, o4) }, t4)];
        }, Ub = (a4, t4, o4) => {
          let e4 = t4[0].dims.slice(), r4 = new Array(e4.length), n4 = [];
          for (let u4 = 0; u4 < e4.length; u4++)
            r4[u4] = e4[u4] * t4[1].numberData[u4], n4.push(`inputIdx[${u4}] = int(mod(float(outputIdx[${u4}]), ${e4[u4]}.));`);
          let s4 = r4.length, i5 = `
      float process(int outputIdx[${s4}]) {
        int inputIdx[${s4}];
        ${n4.join(`
`)}
        return _A(inputIdx);
      }
    `;
          return { ...o4, output: { dims: r4, type: t4[0].type, textureType: 0 }, shaderSource: i5 };
        }, zb = (a4) => {
          if (!a4 || a4.length !== 2)
            throw new Error("Tile requires 2 input.");
          if (a4[1].dims.length !== 1)
            throw new Error("The second input shape must 1 dimension.");
          if (a4[1].dims[0] !== a4[0].dims.length)
            throw new Error("Invalid input shape.");
          if (er.indexOf(a4[0].type) === -1)
            throw new Error("Invalid input type.");
          if (a4[1].type !== "int32" && a4[1].type !== "int16")
            throw new Error("Invalid repeat type.");
        };
      });
      var Hi;
      var Xc;
      var Kc;
      var Vb;
      var Wb;
      var Jc = E(() => {
        "use strict";
        fe();
        Hi = (a4, t4, o4) => {
          Vb(t4);
          let e4 = U.unsqueezeShape(t4[0].dims, o4);
          return [a4.reshapeUnpacked(t4[0], e4)];
        }, Xc = (a4, t4) => (Wb(t4), Hi(a4, [t4[0]], Array.from(t4[1].integerData))), Kc = (a4) => a4.attributes.getInts("axes"), Vb = (a4) => {
          if (!a4 || a4.length !== 1)
            throw new Error("Unsqueeze requires 1 input.");
          if (a4[0].type === "string")
            throw new Error("invalid input tensor types.");
        }, Wb = (a4) => {
          if (!a4 || a4.length !== 2)
            throw new Error("Unsqueeze requires 2 inputs.");
          if (a4[1].type !== "int32")
            throw new Error("Invalid input type.");
        };
      });
      var Zc;
      var Qc = E(() => {
        "use strict";
        ul();
        wl();
        Ol();
        Dl();
        no();
        hf();
        xf();
        _f();
        Sf();
        Df();
        Cf();
        Nf();
        Uf();
        oo();
        Hf();
        oc();
        pc();
        hc();
        xc();
        vc();
        Ac();
        Nc();
        Uc();
        Wc();
        qc();
        Yc();
        ao();
        Pi();
        Jc();
        Gi();
        Zc = [["Abs", "", "6+", Ll], ["Acos", "", "7+", Fl], ["Add", "", "7+", ll], ["And", "", "7+", fl], ["Asin", "", "7+", Cl], ["Atan", "", "7+", $l], ["AveragePool", "", "7+", jf, Yf], ["BatchNormalization", "", "7+", al, sl], ["Cast", "", "6+", vl, _l], ["Ceil", "", "6+", Nl], ["Clip", "", "6-10", Si, kl], ["Clip", "", "11+", Bl], ["Concat", "", "4+", Al, El], ["Conv", "", "1+", $i, ki], ["ConvTranspose", "", "1+", pf, df], ["Cos", "", "7+", Rl], ["Div", "", "7+", cl], ["Dropout", "", "7+", Ai], ["DepthToSpace", "", "1+", yf, Tf], ["Equal", "", "7+", pl], ["Elu", "", "6+", Ml, Gl], ["Exp", "", "6+", Ul], ["Flatten", "", "1+", wf, vf], ["Floor", "", "6+", zl], ["FusedConv", "com.microsoft", "1+", $i, ki], ["Gather", "", "1+", Of, If], ["Gemm", "", "7-10", Bi, Pf], ["Gemm", "", "11+", Bi, Ef], ["GlobalAveragePool", "", "1+", Kf, Jf], ["GlobalMaxPool", "", "1+", rc], ["Greater", "", "7+", dl], ["Identity", "", "1+", Ai], ["ImageScaler", "", "1+", Lf, Ff], ["InstanceNormalization", "", "6+", kf, Bf], ["LeakyRelu", "", "6+", Vl, Wl], ["Less", "", "7+", hl], ["LRN", "", "1+", Rf, Mf], ["Log", "", "6+", Hl], ["MatMul", "", "1+", of, af], ["MaxPool", "", "1+", Zf, Qf], ["Mul", "", "7+", ml], ["Neg", "", "6+", ql], ["Not", "", "1+", jl], ["Or", "", "7+", bl], ["Pad", "", "2-10", Ni, zf], ["Pad", "", "11+", Vf, Wf], ["Pow", "", "7+", gl], ["PRelu", "", "7+", yl], ["ReduceLogSum", "", "1+", fc, tr], ["ReduceMax", "", "1+", sc, tr], ["ReduceMean", "", "1+", ac, tr], ["ReduceMin", "", "1+", uc, tr], ["ReduceProd", "", "1+", lc, tr], ["ReduceSum", "", "1-12", ic, tr], ["ReduceSumSquare", "", "1+", cc, tr], ["Relu", "", "6+", Yl], ["Reshape", "", "5+", dc], ["Resize", "", "10", zi, yc], ["Resize", "", "11+", zi, Tc], ["Shape", "", "1+", wc], ["Sigmoid", "", "6+", Xl], ["Sin", "", "7+", Kl], ["Slice", "", "10+", Sc], ["Slice", "", "1-9", _c, Oc], ["Softmax", "", "1-12", Lc, Fc], ["Softmax", "", "13+", $c, Cc], ["Split", "", "2-12", Mc, Gc], ["Sqrt", "", "6+", Jl], ["Squeeze", "", "1-12", Wi, Vc], ["Squeeze", "", "13+", zc], ["Sub", "", "7+", Tl], ["Sum", "", "6+", Hc], ["Tan", "", "7+", Zl], ["Tanh", "", "6+", Ql], ["Tile", "", "6+", jc], ["Transpose", "", "1+", wr, bf], ["Upsample", "", "7-8", Ri, bc], ["Upsample", "", "9", Ri, gc], ["Unsqueeze", "", "1-12", Hi, Kc], ["Unsqueeze", "", "13+", Xc], ["Xor", "", "7+", xl]];
      });
      function tp(a4) {
        let t4 = {}, o4;
        for (; (o4 = ep.exec(a4)) !== null; ) {
          let e4 = o4[3].split(",").map((r4) => {
            let n4 = r4.trim().split(" ");
            return n4 && n4.length === 2 ? { type: n4[0], name: n4[1] } : null;
          }).filter((r4) => r4 !== null);
          t4[o4[2]] = { params: e4, body: o4[4] };
        }
        for (let e4 in t4) {
          let r4 = Hb.replace("__FUNC__", e4), n4 = new RegExp(r4, "gm");
          for (; (o4 = n4.exec(a4)) !== null; ) {
            let s4 = o4[1], i5 = o4[2], u4 = o4[3].split(","), l4 = s4 ? `${s4} ${i5};` : "", f3 = t4[e4].body, p4 = "";
            t4[e4].params.forEach((T3, v5) => {
              T3 && (p4 += `${T3.type} ${T3.name} = ${u4[v5]};
`);
            }), f3 = `${p4}
 ${f3}`, f3 = f3.replace("return", `${i5} = `);
            let d4 = `
      ${l4}
      {
        ${f3}
      }
      `;
            a4 = a4.replace(o4[0], d4);
          }
        }
        return a4 = a4.replace(ep, ""), a4;
      }
      var ep;
      var Hb;
      var rp = E(() => {
        "use strict";
        ep = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm, Hb = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;";
      });
      function Ur(a4, t4) {
        let o4 = [], e4 = [], r4 = t4 != null && Array.isArray(t4) && t4.length === 0, n4 = t4 == null || r4 ? null : qb(t4, a4).sort(), s4 = 0;
        for (let i5 = 0; i5 < a4.length; ++i5) {
          if (n4 != null) {
            if (n4[s4] === i5 && a4[i5] !== 1)
              throw new Error(`Can't squeeze axis ${i5} since its dim '${a4[i5]}' is not 1`);
            (n4[s4] == null || n4[s4] > i5) && a4[i5] === 1 && (o4.push(a4[i5]), e4.push(i5)), n4[s4] <= i5 && s4++;
          }
          a4[i5] !== 1 && (o4.push(a4[i5]), e4.push(i5));
        }
        return { newShape: o4, keptDims: e4 };
      }
      function qb(a4, t4) {
        let o4 = t4.length;
        return a4 = a4 == null ? t4.map((e4, r4) => r4) : [].concat(a4), kr(a4.every((e4) => e4 >= -o4 && e4 < o4), () => `All values in axis param must be in range [-${o4}, ${o4}) but got axis ${a4}`), kr(a4.every(jb), () => `All values in axis param must be integers but got axis ${a4}`), a4.map((e4) => e4 < 0 ? o4 + e4 : e4);
      }
      function jb(a4) {
        return a4 % 1 === 0;
      }
      function Yb(a4) {
        if (a4.length === 0)
          return 1;
        let t4 = a4[0];
        for (let o4 = 1; o4 < a4.length; o4++)
          t4 *= a4[o4];
        return t4;
      }
      function np(a4) {
        let t4 = Math.ceil(Math.sqrt(a4));
        return [t4, Math.ceil(a4 / t4)];
      }
      var fo;
      var qi = E(() => {
        "use strict";
        at();
        fe();
        fo = class {
          constructor(t4) {
            this.maxTextureSize = t4;
          }
          computeTextureWH(t4, o4) {
            let e4 = this.computeTexture(t4, o4);
            return o4 && o4.isPacked && (e4[0] /= 2, e4[1] /= 2), o4 && o4.reverseWH ? [e4[1], e4[0]] : e4;
          }
          computeTexture(t4, o4) {
            let e4 = o4 && o4.isPacked;
            if (t4.length === 0)
              return e4 ? [2, 2] : [1, 1];
            let r4 = this.maxTextureSize;
            if (o4 && o4.breakAxis !== void 0) {
              let i5 = o4.breakAxis >= t4.length ? 1 : t4.slice(o4.breakAxis).reduce((l4, f3) => l4 * f3), u4 = o4.breakAxis <= 0 ? 1 : t4.slice(0, o4.breakAxis).reduce((l4, f3) => l4 * f3);
              if (i5 > r4 || u4 > r4)
                ce.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t4}, breakAxis:${o4.breakAxis}`);
              else
                return [i5, u4];
            }
            let n4 = t4.slice(0);
            e4 && (r4 = r4 * 2, n4 = n4.map((i5, u4) => u4 >= n4.length - 2 ? n4[u4] % 2 === 0 ? n4[u4] : n4[u4] + 1 : n4[u4]), n4.length === 1 && (n4 = [2, n4[0]])), n4.length !== 2 && (n4 = Ur(n4).newShape);
            let s4 = Yb(n4);
            return n4.length <= 1 && s4 <= r4 ? [1, s4] : n4.length === 2 && n4[0] <= r4 && n4[1] <= r4 ? n4 : n4.length === 3 && n4[0] * n4[1] <= r4 && n4[2] <= r4 ? [n4[0] * n4[1], n4[2]] : n4.length === 3 && n4[0] <= r4 && n4[1] * n4[2] <= r4 ? [n4[0], n4[1] * n4[2]] : n4.length === 4 && n4[0] * n4[1] * n4[2] <= r4 && n4[3] <= r4 ? [n4[0] * n4[1] * n4[2], n4[3]] : n4.length === 4 && n4[0] <= r4 && n4[1] * n4[2] * n4[3] <= r4 ? [n4[0], n4[1] * n4[2] * n4[3]] : e4 ? np(s4 / 4).map((i5) => i5 * 2) : np(s4);
          }
        };
      });
      var co;
      var op = E(() => {
        "use strict";
        fe();
        Ht();
        xe();
        qi();
        kt();
        co = class extends ft {
          constructor(o4) {
            super(o4);
          }
          getFunctions() {
            return { ...this.offsetToCoords(), ...this.coordsToOffset(), ...this.toVec(), ...this.valueFrom(), ...this.getCommonUtilFuncs(), ...this.getInputsSamplingSnippets(), ...this.getOutputSamplingSnippet() };
          }
          getCustomTypes() {
            return {};
          }
          offsetToCoords() {
            let o4 = "offsetToCoords";
            return { offsetToCoords: new R(`
      vec2 ${o4}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `) };
          }
          coordsToOffset() {
            let o4 = "coordsToOffset";
            return { coordsToOffset: new R(`
      int ${o4}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `) };
          }
          getOutputSamplingSnippet() {
            let o4 = this.context.outputTextureLayout;
            return o4.isPacked ? this.getPackedOutputSamplingSnippet(o4) : this.getUnpackedOutputSamplingSnippet(o4);
          }
          getPackedOutputSamplingSnippet(o4) {
            let e4 = o4.unpackedShape, r4 = [o4.width, o4.height], n4 = {}, s4 = "getOutputCoords";
            switch (e4.length) {
              case 0:
                n4[s4] = this.getOutputScalarCoords();
                break;
              case 1:
                n4[s4] = this.getOutputPacked1DCoords(e4, r4);
                break;
              case 2:
                n4[s4] = this.getOutputPacked2DCoords(e4, r4);
                break;
              case 3:
                n4[s4] = this.getOutputPacked3DCoords(e4, r4);
                break;
              default:
                n4[s4] = this.getOutputPackedNDCoords(e4, r4);
            }
            let u4 = `
      void setOutput(vec4 val) {
        ${q(this.context.glContext.version).output} = val;
      }
    `, l4 = "floatTextureSetRGBA";
            return n4[l4] = new R(u4), n4;
          }
          getUnpackedOutputSamplingSnippet(o4) {
            let e4 = o4.unpackedShape, r4 = [o4.width, o4.height], n4 = {}, s4 = "getOutputCoords";
            switch (e4.length) {
              case 0:
                n4[s4] = this.getOutputScalarCoords();
                break;
              case 1:
                n4[s4] = this.getOutputUnpacked1DCoords(e4, r4);
                break;
              case 2:
                n4[s4] = this.getOutputUnpacked2DCoords(e4, r4);
                break;
              case 3:
                n4[s4] = this.getOutputUnpacked3DCoords(e4, r4);
                break;
              case 4:
                n4[s4] = this.getOutputUnpacked4DCoords(e4, r4);
                break;
              case 5:
                n4[s4] = this.getOutputUnpacked5DCoords(e4, r4);
                break;
              case 6:
                n4[s4] = this.getOutputUnpacked6DCoords(e4, r4);
                break;
              default:
                throw new Error(`Unsupported output dimensionality: ${e4.length}`);
            }
            let u4 = `
        void setOutput(float val) {
          ${q(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `, l4 = "floatTextureSetR";
            return n4[l4] = new R(u4), n4;
          }
          getOutputScalarCoords() {
            return new R(`
      int getOutputCoords() {
        return 0;
      }
    `);
          }
          getOutputPacked1DCoords(o4, e4) {
            let r4 = e4, n4 = "";
            return r4[0] === 1 ? (n4 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${r4[1]}.0);
          }
        `, new R(n4)) : r4[1] === 1 ? (n4 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${r4[0]}.0);
          }
        `, new R(n4)) : (n4 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${r4[0]}, ${r4[1]}));
          return 2 * (resTexRC.y * ${r4[0]} + resTexRC.x);
        }
      `, new R(n4));
          }
          getOutputPacked2DCoords(o4, e4) {
            let r4 = "";
            if (hr.arraysEqual(o4, e4))
              return r4 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e4[0]}, ${e4[1]}));
        }
      `, new R(r4);
            let n4 = e4, s4 = Math.ceil(o4[1] / 2);
            return r4 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n4[0]}, ${n4[1]}));

          int index = resTexRC.y * ${n4[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${s4}) * 2;
          int c = 2 * (index / ${s4});

          return ivec2(r, c);
        }
      `, new R(r4);
          }
          getOutputPacked3DCoords(o4, e4) {
            let r4 = [e4[0], e4[1]], n4 = Math.ceil(o4[2] / 2), s4 = n4 * Math.ceil(o4[1] / 2), i5 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r4[0]}, ${r4[1]}));
          int index = resTexRC.y * ${r4[0]} + resTexRC.x;

          int b = index / ${s4};
          index -= b * ${s4};

          // reverse r and c order for packed texture
          int r = imod(index, ${n4}) * 2;
          int c = 2 * (index / ${n4});

          return ivec3(b, r, c);
        }
      `;
            return new R(i5);
          }
          getOutputPackedNDCoords(o4, e4) {
            let r4 = [e4[0], e4[1]], n4 = Math.ceil(o4[o4.length - 1] / 2), s4 = n4 * Math.ceil(o4[o4.length - 2] / 2), i5 = s4, u4 = "", l4 = "b, r, c";
            for (let p4 = 2; p4 < o4.length - 1; p4++)
              i5 *= o4[o4.length - p4 - 1], u4 = `
      int b${p4} = index / ${i5};
      index -= b${p4} * ${i5};
    ` + u4, l4 = `b${p4}, ` + l4;
            let f3 = `
      ivec${o4.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${r4[0]}, ${r4[1]}));
        int index = resTexRC.y * ${r4[0]} + resTexRC.x;

        ${u4}

        int b = index / ${s4};
        index -= b * ${s4};

        // reverse r and c order for packed texture
        int r = imod(index, ${n4}) * 2;
        int c = 2 * (index / ${n4});

        return ivec${o4.length}(${l4});
      }
    `;
            return new R(f3);
          }
          getOutputUnpacked1DCoords(o4, e4) {
            let r4 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e4[0]}, ${e4[1]}));
          return resTexRC.y * ${e4[0]} + resTexRC.x;
        }
      `;
            return new R(r4);
          }
          getOutputUnpacked2DCoords(o4, e4) {
            let r4 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e4[0]}, ${e4[1]}));
          int index = resTexRC.y * ${e4[0]} + resTexRC.x;
          int r = index / ${o4[1]};
          int c = index - r * ${o4[1]};
          return ivec2(r, c);
        }
      `;
            return new R(r4);
          }
          getOutputUnpacked3DCoords(o4, e4) {
            let r4 = "", n4 = o4.length, s4 = null;
            n4 < 2 && (s4 = []), s4 = new Array(n4 - 1), s4[n4 - 2] = o4[n4 - 1];
            for (let l4 = n4 - 3; l4 >= 0; --l4)
              s4[l4] = s4[l4 + 1] * o4[l4 + 1];
            let i5 = ["r", "c", "d"], u4 = s4.map((l4, f3) => {
              let p4 = `int ${i5[f3]} = index / ${l4}`, d4 = f3 === s4.length - 1 ? `int ${i5[f3 + 1]} = index - ${i5[f3]} * ${l4}` : `index -= ${i5[f3]} * ${l4}`;
              return `${p4}; ${d4};`;
            }).join("");
            return r4 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e4[0]}, ${e4[1]}));
          int index = resTexRC.y * ${e4[0]} + resTexRC.x;
          ${u4}
          return ivec3(r, c, d);
        }
      `, new R(r4);
          }
          getOutputUnpacked4DCoords(o4, e4) {
            let r4 = "", n4 = o4.length, s4 = null;
            n4 < 2 && (s4 = []), s4 = new Array(n4 - 1), s4[n4 - 2] = o4[n4 - 1];
            for (let l4 = n4 - 3; l4 >= 0; --l4)
              s4[l4] = s4[l4 + 1] * o4[l4 + 1];
            let i5 = ["r", "c", "d", "d2"], u4 = s4.map((l4, f3) => {
              let p4 = `int ${i5[f3]} = index / ${l4}`, d4 = f3 === s4.length - 1 ? `int ${i5[f3 + 1]} = index - ${i5[f3]} * ${l4}` : `index -= ${i5[f3]} * ${l4}`;
              return `${p4}; ${d4};`;
            }).join("");
            return r4 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e4[0]}, ${e4[1]}));
          int index = resTexRC.y * ${e4[0]} + resTexRC.x;
          ${u4}
          return ivec4(r, c, d, d2);
        }
      `, new R(r4);
          }
          getOutputUnpacked5DCoords(o4, e4) {
            let r4 = "", n4 = o4.length, s4 = null;
            n4 < 2 && (s4 = []), s4 = new Array(n4 - 1), s4[n4 - 2] = o4[n4 - 1];
            for (let l4 = n4 - 3; l4 >= 0; --l4)
              s4[l4] = s4[l4 + 1] * o4[l4 + 1];
            let i5 = ["r", "c", "d", "d2", "d3"], u4 = s4.map((l4, f3) => {
              let p4 = `int ${i5[f3]} = index / ${l4}`, d4 = f3 === s4.length - 1 ? `int ${i5[f3 + 1]} = index - ${i5[f3]} * ${l4}` : `index -= ${i5[f3]} * ${l4}`;
              return `${p4}; ${d4};`;
            }).join("");
            return r4 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e4[0]}, ${e4[1]}));
          int index = resTexRC.y * ${e4[0]} + resTexRC.x;
          ${u4}
          return ivec5(r, c, d, d2, d3);
        }
      `, new R(r4);
          }
          getOutputUnpacked6DCoords(o4, e4) {
            let r4 = "", n4 = o4.length, s4 = null;
            n4 < 2 && (s4 = []), s4 = new Array(n4 - 1), s4[n4 - 2] = o4[n4 - 1];
            for (let l4 = n4 - 3; l4 >= 0; --l4)
              s4[l4] = s4[l4 + 1] * o4[l4 + 1];
            let i5 = ["r", "c", "d", "d2", "d3", "d4"], u4 = s4.map((l4, f3) => {
              let p4 = `int ${i5[f3]} = index / ${l4}`, d4 = f3 === s4.length - 1 ? `int ${i5[f3 + 1]} = index - ${i5[f3]} * ${l4}` : `index -= ${i5[f3]} * ${l4}`;
              return `${p4}; ${d4};`;
            }).join("");
            return r4 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e4[0]}, ${e4[1]}));
         int index = resTexRC.y * ${e4[0]} + resTexRC.x;
         ${u4}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new R(r4);
          }
          getCommonUtilFuncs() {
            let o4 = {}, e4 = "uvFromFlat";
            o4[e4] = new R(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `), e4 = "packedUVfrom1D", o4[e4] = new R(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `), e4 = "packedUVfrom2D", o4[e4] = new R(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `), e4 = "packedUVfrom3D", o4[e4] = new R(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `), e4 = "sampleTexture";
            let r4 = q(this.context.glContext.version);
            return o4[e4] = new R(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${r4.texture2D}(textureSampler, uv).r;
        }`), o4;
          }
          getInputsSamplingSnippets() {
            let o4 = {}, e4 = this.context.outputTextureLayout;
            return this.context.programInfo.inputNames.forEach((r4, n4) => {
              let s4 = this.context.inputTextureLayouts[n4], i5 = Kn(r4);
              s4.isPacked ? o4[i5] = this.getPackedSamplerFromInput(i5, r4, s4) : o4[i5] = this.getUnpackedSamplerFromInput(i5, r4, s4);
              let u4 = Wu(r4);
              s4.unpackedShape.length <= e4.unpackedShape.length && (s4.isPacked ? o4[u4] = this.getPackedSamplerAtOutputCoords(u4, s4, e4, r4) : o4[u4] = this.getUnpackedSamplerAtOutputCoords(u4, s4, e4, r4));
            }), o4;
          }
          getPackedSamplerAtOutputCoords(o4, e4, r4, n4) {
            let s4 = e4.unpackedShape, i5 = r4.unpackedShape, l4 = Kn(n4), f3 = s4.length, p4 = i5.length, d4 = Ke.getBroadcastDims(s4, i5), T3 = Je(p4), v5 = p4 - f3, w3, I3 = Ot();
            f3 === 0 ? w3 = "" : p4 < 2 && d4.length >= 1 ? w3 = "coords = 0;" : w3 = d4.map((We3) => `coords.${I3[We3 + v5]} = 0;`).join(`
`);
            let L3 = "";
            p4 < 2 && f3 > 0 ? L3 = "coords" : L3 = s4.map((We3, Fe5) => `coords.${I3[Fe5 + v5]}`).join(", ");
            let F4 = "return outputValue;", Y5 = U.size(s4) === 1, M4 = U.size(i5) === 1;
            if (f3 === 1 && !Y5 && !M4)
              F4 = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
            else if (Y5 && !M4)
              p4 === 1 ? F4 = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        ` : F4 = `
          return vec4(outputValue.x);
        `;
            else if (d4.length) {
              let We3 = f3 - 2, Fe5 = f3 - 1;
              d4.indexOf(We3) > -1 && d4.indexOf(Fe5) > -1 ? F4 = "return vec4(outputValue.x);" : d4.indexOf(We3) > -1 ? F4 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : d4.indexOf(Fe5) > -1 && (F4 = "return vec4(outputValue.xx, outputValue.zz);");
            }
            let ie3 = `
        int lastDim = coords.${I3[p4 - 1]};
        coords.${I3[p4 - 1]} = coords.${I3[p4 - 2]};
        coords.${I3[p4 - 2]} = lastDim;
      `, ot4 = `
      vec4 ${o4}() {
        ${T3} coords = getOutputCoords();
        ${ie3}
        ${w3}
        vec4 outputValue = ${l4}(${L3});
        ${F4}
      }
    `;
            return new R(ot4, ["coordinates.getOutputCoords"]);
          }
          getUnpackedSamplerAtOutputCoords(o4, e4, r4, n4) {
            let s4 = [r4.width, r4.height], i5 = [e4.width, e4.height], u4 = e4.unpackedShape.length, l4 = r4.unpackedShape.length, f3 = e4.unpackedShape, p4 = r4.unpackedShape, d4 = Kn(n4);
            if (u4 === l4 && hr.arraysEqual(i5, s4)) {
              let Y5 = `
          float ${o4}() {
            return sampleTexture(${n4}, TexCoords);
          }
        `;
              return new R(Y5, ["coordinates.sampleTexture"]);
            }
            let T3 = Je(l4), v5 = Ke.getBroadcastDims(f3, p4), w3 = l4 - u4, I3, L3 = Ot();
            u4 === 0 ? I3 = "" : l4 < 2 && v5.length >= 1 ? I3 = "coords = 0;" : I3 = v5.map((Y5) => `coords.${L3[Y5 + w3]} = 0;`).join(`
`);
            let F4 = "";
            l4 < 2 && u4 > 0 ? F4 = "coords" : F4 = e4.unpackedShape.map((Y5, j4) => `coords.${L3[j4 + w3]}`).join(", ");
            let C3 = `
        float ${o4}() {
          ${T3} coords = getOutputCoords();
          ${I3}
          return ${d4}(${F4});
        }
      `;
            return new R(C3, ["coordinates.getOutputCoords"]);
          }
          getPackedSamplerFromInput(o4, e4, r4) {
            switch (r4.unpackedShape.length) {
              case 0:
                return this.getPackedSamplerScalar(o4, e4);
              case 1:
                return this.getPackedSampler1D(o4, e4, r4);
              case 2:
                return this.getPackedSampler2D(o4, e4, r4);
              case 3:
                return this.getPackedSampler3D(o4, e4, r4);
              default:
                return this.getPackedSamplerND(o4, e4, r4);
            }
          }
          getUnpackedSamplerFromInput(o4, e4, r4) {
            let n4 = r4.unpackedShape;
            switch (n4.length) {
              case 0:
                return this.getUnpackedSamplerScalar(o4, e4, r4);
              case 1:
                return this.getUnpackedSampler1D(o4, e4, r4);
              case 2:
                return this.getUnpackedSampler2D(o4, e4, r4);
              case 3:
                return this.getUnpackedSampler3D(o4, e4, r4);
              case 4:
                return this.getUnpackedSampler4D(o4, e4, r4);
              case 5:
                return this.getUnpackedSampler5D(o4, e4, r4);
              case 6:
                return this.getUnpackedSampler6D(o4, e4, r4);
              default:
                throw new Error(`Unsupported dimension ${n4.length}-D`);
            }
          }
          getPackedSamplerScalar(o4, e4) {
            let r4 = q(this.context.glContext.version), n4 = `
          vec4 ${o4}() {
            return ${r4.texture2D}(${e4}, halfCR);
          }
        `;
            return new R(n4);
          }
          getPackedSampler1D(o4, e4, r4) {
            let n4 = [r4.width, r4.height], s4 = [n4[1], n4[0]], i5 = q(this.context.glContext.version), l4 = `vec4 ${o4}(int index) {
      vec2 uv = packedUVfrom1D(
      ${s4[0]}, ${s4[1]}, index);
      return ${i5.texture2D}(${e4}, uv);
    }`;
            return new R(l4, ["coordinates.packedUVfrom1D"]);
          }
          getPackedSampler2D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = [r4.width, r4.height], i5 = q(this.context.glContext.version), u4 = s4[0], l4 = s4[1];
            if (s4 != null && hr.arraysEqual(n4, s4)) {
              let v5 = `vec4 ${o4}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l4}.0, ${u4}.0);
        return ${i5.texture2D}(${e4}, uv);
      }`;
              return new R(v5);
            }
            let f3 = s4, p4 = Math.ceil(n4[1] / 2), T3 = `vec4 ${o4}(int row, int col) {
      vec2 uv = packedUVfrom2D(${f3[1]}, ${f3[0]}, ${p4}, row, col);
      return ${i5.texture2D}(${e4}, uv);
    }`;
            return new R(T3, ["coordinates.packedUVfrom2D"]);
          }
          getPackedSampler3D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = [r4.width, r4.height], i5 = [s4[0], s4[1]], u4 = q(this.context.glContext.version);
            if (n4[0] === 1) {
              let w3 = n4.slice(1), I3 = [1, 2], L3 = Br(n4, w3), F4 = ["b", "row", "col"], C3 = JSON.parse(JSON.stringify(r4));
              C3.unpackedShape = L3;
              let Y5 = this.getPackedSamplerFromInput(o4, e4, C3), M4 = `${Y5.routineBody}
      vec4 ${o4}(int b, int row, int col) {
        return ${o4}(${Nr(F4, I3)});
      } `;
              return new R(M4, Y5.dependencies);
            }
            let l4 = i5[0], f3 = i5[1], p4 = Math.ceil(n4[2] / 2), d4 = p4 * Math.ceil(n4[1] / 2), v5 = `vec4 ${o4}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${f3}, ${l4}, ${d4}, ${p4}, b, row, col);
      return ${u4.texture2D}(${e4}, uv);}`;
            return new R(v5, ["coordinates.packedUVfrom3D"]);
          }
          getPackedSamplerND(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = n4.length, i5 = [r4.width, r4.height], u4 = q(this.context.glContext.version), l4 = [i5[0], i5[1]], f3 = l4[1], p4 = l4[0], d4 = Math.ceil(n4[s4 - 1] / 2), T3 = d4 * Math.ceil(n4[s4 - 2] / 2), v5 = "int b, int row, int col", w3 = `b * ${T3} + (row / 2) * ${d4} + (col / 2)`;
            for (let F4 = 2; F4 < s4 - 1; F4++)
              v5 = `int b${F4}, ` + v5, T3 *= n4[s4 - F4 - 1], w3 = `b${F4} * ${T3} + ` + w3;
            let L3 = `vec4 ${o4}(${v5}) {
      int index = ${w3};
      int texR = index / ${p4};
      int texC = index - texR * ${p4};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p4}, ${f3});
      return ${u4.texture2D}(${e4}, uv);
    }`;
            return new R(L3);
          }
          getUnpackedSamplerScalar(o4, e4, r4) {
            let [n4, s4] = [r4.width, r4.height];
            if (n4 === 1 && s4 === 1) {
              let u4 = `
          float ${o4}() {
            return sampleTexture(${e4}, halfCR);
          }
        `;
              return new R(u4, ["coordinates.sampleTexture"]);
            }
            let i5 = `
        float ${o4}() {
          int offset_${e4} = coordsToOffset(TexCoords, ${n4}, ${s4});
          vec2 uv = uvFromFlat(${n4}, ${s4}, offset_${e4});
          return sampleTexture(${e4}, uv);
        }
      `;
            return new R(i5, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler1D(o4, e4, r4) {
            let n4 = r4.width, s4 = r4.height;
            if (s4 === 1 && n4 === 1) {
              let u4 = `
        float ${o4}(int index) {
          return sampleTexture(${e4}, halfCR);
        }
      `;
              return new R(u4, ["coordinates.sampleTexture"]);
            }
            if (s4 === 1) {
              let u4 = `
          float ${o4}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${n4}.0, 0.5);
            return sampleTexture(${e4}, uv);
          }
        `;
              return new R(u4, ["coordinates.sampleTexture"]);
            }
            if (n4 === 1) {
              let u4 = `
          float ${o4}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s4}.0);
            return sampleTexture(${e4}, uv);
          }
        `;
              return new R(u4, ["coordinates.sampleTexture"]);
            }
            let i5 = `
        float ${o4}(int index) {
          vec2 uv = uvFromFlat(${n4}, ${s4}, index);
          return sampleTexture(${e4}, uv);
        }
      `;
            return new R(i5, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler2D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = [r4.height, r4.width];
            if (s4 != null && hr.arraysEqual(n4, s4)) {
              let T3 = s4[1], v5 = s4[0], w3 = `
          float ${o4}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${T3}.0, ${v5}.0);
            return sampleTexture(${e4}, uv);
          }
        `;
              return new R(w3, ["coordinates.sampleTexture"]);
            }
            let { newShape: i5, keptDims: u4 } = Ur(n4), l4 = i5;
            if (l4.length < n4.length) {
              let T3 = Br(n4, l4), v5 = JSON.parse(JSON.stringify(r4));
              v5.unpackedShape = T3;
              let w3 = ["col", "row"], I3 = `
          ${this.getUnpackedSamplerFromInput(o4, e4, v5).routineBody}
          float ${o4}(int row, int col) {
            return ${o4}(${Nr(w3, u4)});
          }
        `;
              return new R(I3, ["coordinates.sampleTexture"]);
            }
            let f3 = s4[1], p4 = s4[0];
            if (p4 === 1) {
              let T3 = `
          float ${o4}(int row, int col) {
            int offset_${e4} = coordsToOffset(TexCoords, ${f3}, ${p4});
            float index = dot(vec3(row, col, offset_${e4}), vec3(${n4[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f3}.0);
            return sampleTexture(${e4}, uv);
          }
        `;
              return new R(T3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            if (f3 === 1) {
              let T3 = `
          float ${o4}(int row, int col) {
            int offset_${e4} = coordsToOffset(TexCoords, ${f3}, ${p4});
            float index = dot(vec3(row, col, offset_${e4}), vec3(${n4[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${p4}.0, 0.5);
            return sampleTexture(${e4}, uv);
          }
        `;
              return new R(T3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            let d4 = `
        float ${o4}(int row, int col) {
          int index = col * ${n4[1]} + row;
          vec2 uv = uvFromFlat(${f3}, ${p4}, index);
          return sampleTexture(${e4}, uv);
        }
      `;
            return new R(d4, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler3D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = n4[1] * n4[2], i5 = n4[2], { newShape: u4, keptDims: l4 } = Ur(n4), f3 = u4;
            if (f3.length < n4.length) {
              let v5 = Br(n4, f3), w3 = ["batch", "col", "row"], I3 = JSON.parse(JSON.stringify(r4));
              I3.unpackedShape = v5;
              let L3 = this.getUnpackedSamplerFromInput(o4, e4, I3), F4 = l4.reverse(), C3 = `
          ${L3.routineBody}
          float ${o4}(int batch, int row, int col) {
            return ${o4}(${Nr(w3, F4)});
          }
        `;
              return new R(C3, L3.dependencies);
            }
            let p4 = r4.width, d4 = r4.height, T3 = `
          float ${o4}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${s4} + col * ${i5} + row;
            vec2 uv = uvFromFlat(${p4}, ${d4}, index);
            return sampleTexture(${e4}, uv);
          }
      `;
            return new R(T3, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler4D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = n4[3], i5 = n4[2] * s4, u4 = n4[1] * i5, l4 = r4.width, f3 = r4.height, p4 = `
        float ${o4}(int row, int col, int depth, int depth2) {
          int index = row * ${u4} + col * ${i5} +
              depth2 * ${s4} + depth;
          vec2 uv = uvFromFlat(${l4}, ${f3}, index);
          return sampleTexture(${e4}, uv);
        }
      `;
            return new R(p4, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler5D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = n4[4], i5 = n4[3] * s4, u4 = n4[2] * i5, l4 = n4[1] * u4, { newShape: f3, keptDims: p4 } = Ur(n4);
            if (f3.length < n4.length) {
              let w3 = Br(n4, f3), I3 = ["row", "col", "depth", "depth2", "depth3"], L3 = JSON.parse(JSON.stringify(r4));
              L3.unpackedShape = w3;
              let F4 = `
          ${this.getUnpackedSamplerFromInput(o4, e4, L3).routineBody}
          float ${o4}(int row, int col, int depth, int depth2, int depth3) {
            return ${o4}(${Nr(I3, p4)});
          }
        `;
              return new R(F4, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            let d4 = r4.width, T3 = r4.height, v5 = `
        float ${o4}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l4} + col * ${u4} + depth * ${i5} +
          depth3 * ${s4} + depth2;
          vec2 uv = uvFromFlat(${d4}, ${T3}, index);
          return sampleTexture(${e4}, uv);
        }
      `;
            return new R(v5, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          getUnpackedSampler6D(o4, e4, r4) {
            let n4 = r4.unpackedShape, s4 = n4[5], i5 = n4[4] * s4, u4 = n4[3] * i5, l4 = n4[2] * u4, f3 = n4[1] * l4, { newShape: p4, keptDims: d4 } = Ur(n4);
            if (p4.length < n4.length) {
              let I3 = Br(n4, p4), L3 = ["row", "col", "depth", "depth2", "depth3", "depth4"], F4 = JSON.parse(JSON.stringify(r4));
              F4.unpackedShape = I3;
              let C3 = `
            ${this.getUnpackedSamplerFromInput(o4, e4, F4).routineBody}
            float ${o4}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${o4}(${Nr(L3, d4)});
            }
          `;
              return new R(C3, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            let T3 = r4.width, v5 = r4.height, w3 = `
          float ${o4}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${f3} + col * ${l4} + depth * ${u4} +
            depth2 * ${i5} + depth3 * ${s4} + depth4;
            vec2 uv = uvFromFlat(${T3}, ${v5}, index);
            return sampleTexture(${e4}, uv);
          }
        `;
            return new R(w3, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          toVec() {
            let o4 = this.context.outputTextureLayout, e4 = o4.shape.length, r4 = o4.strides, n4 = o4.width, s4 = o4.height, i5 = [];
            for (let l4 = 0; l4 < e4 - 1; ++l4)
              i5.push(`
        c[${l4}] = offset / ${r4[l4]};`), i5.push(`
        offset -= c[${l4}] * ${r4[l4]};`);
            i5.push(`
        c[${e4 - 1}] = offset;`);
            let u4 = `
      void toVec(vec2 texCoords, out int c[${e4}]) {
        int offset = coordsToOffset(texCoords, ${n4}, ${s4});
        ${i5.join("")}
      }
      void toVec(int offset, out int c[${e4}]) {
        ${i5.join("")}
      }
    `;
            return { toVec: new R(u4, ["coordinates.coordsToOffset"]) };
          }
          valueFrom() {
            let o4 = {};
            return this.context.programInfo.inputNames.forEach((e4, r4) => {
              let n4 = this.context.inputTextureLayouts[r4], i5 = (n4.unpackedShape.length > 0 ? n4.unpackedShape : n4.shape).length, u4 = `_${e4}`;
              o4[u4] = new R(this.getValueFromSingle(e4, i5, n4.width, n4.height, false), [`shapeUtils.indicesToOffset${u4}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), u4 = u4 + "_T", o4[u4] = new R(this.getValueFromSingle(e4, i5, n4.width, n4.height, true), [`shapeUtils.indicesToOffset${u4}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
            }), o4;
          }
          getValueFromSingle(o4, e4, r4, n4, s4) {
            let i5 = `_${o4}`;
            s4 && (i5 = i5 + "_T");
            let u4 = q(this.context.glContext.version);
            return `
        float ${i5}(int m[${e4}]) {
          int offset = indicesToOffset${i5}(m);
          vec2 coords = offsetToCoords(offset, ${r4}, ${n4});
          float value = getColorAsFloat(${u4.texture2D}(${o4}, coords));
          return value;
        }
        `;
          }
          getPackedValueFrom(o4, e4, r4, n4, s4) {
            let i5 = `_${o4}_Pack`;
            s4 && (i5 = i5 + "_T");
            let u4 = q(this.context.glContext.version);
            return `
        vec4 ${i5}(int m[${e4}]) {
          int offset = indicesToOffset_${o4}(m);
          vec2 coords = offsetToCoords(offset, ${r4}, ${n4});
          return ${u4.texture2D}(${o4}, coords);
        }
        `;
          }
        };
      });
      var po;
      var ip = E(() => {
        "use strict";
        Ht();
        po = class a4 extends ft {
          constructor(t4) {
            super(t4);
          }
          getFunctions() {
            return { ...this.encodeFloat32(), ...this.decodeFloat32() };
          }
          getCustomTypes() {
            return {};
          }
          encodeFloat32() {
            return { encode: new R(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `) };
          }
          decodeFloat32() {
            return { decode: new R(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `) };
          }
          encodeUint8() {
            let t4 = a4.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { encode: new R(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${t4}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
          }
          decodeUint8() {
            let t4 = a4.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { decode: new R(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${t4}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
          }
          static isLittleEndian() {
            let t4 = new ArrayBuffer(4), o4 = new Uint32Array(t4), e4 = new Uint8Array(t4);
            if (o4[0] = 3735928559, e4[0] === 239)
              return true;
            if (e4[0] === 222)
              return false;
            throw new Error("unknown endianness");
          }
        };
      });
      var ho;
      var ap = E(() => {
        "use strict";
        Ht();
        xe();
        ho = class extends ft {
          constructor(t4) {
            super(t4);
          }
          getFunctions() {
            return { ...this.setFragColor(), ...this.getColorAsFloat() };
          }
          getCustomTypes() {
            return {};
          }
          setFragColor() {
            let t4 = q(this.context.glContext.version);
            return { setFragColor: new R(`
        void setFragColor(float value) {
            ${t4.output} = encode(value);
        }
        `, ["encoding.encode"]) };
          }
          getColorAsFloat() {
            return { getColorAsFloat: new R(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `, ["encoding.decode"]) };
          }
        };
      });
      var mo;
      var sp = E(() => {
        "use strict";
        Ht();
        mo = class a4 extends ft {
          constructor(t4) {
            super(t4);
          }
          getFunctions() {
            return { ...this.bcastIndex(), ...this.bcastMatmulIndex(), ...this.offsetToIndices(), ...this.indicesToOffset(), ...this.incrementIndices() };
          }
          getCustomTypes() {
            return {};
          }
          bcastIndex() {
            let t4 = this.context.outputTextureLayout.shape.length, o4 = {};
            return this.context.programInfo.inputNames.forEach((e4, r4) => {
              let n4 = this.context.inputTextureLayouts[r4].unpackedShape;
              if (n4.length <= t4) {
                let s4 = n4.length, i5 = t4 - s4, u4 = `bcastIndices_${e4}`, l4 = "";
                for (let p4 = 0; p4 < s4; ++p4)
                  l4 += `
          realIndices[${p4}] = int( mod(float(bcastedIndices[${i5 + p4}]), ${n4[p4]}.0) );
          `;
                let f3 = `
        void ${u4} (int bcastedIndices[${t4}], out int realIndices[${s4}]) {
          ${l4}
        }
        `;
                o4[u4] = new R(f3);
              }
            }), o4;
          }
          bcastMatmulIndex() {
            let t4 = this.context.outputTextureLayout.shape.length, o4 = {};
            return this.context.programInfo.inputNames.forEach((e4, r4) => {
              let n4 = this.context.inputTextureLayouts[r4].shape;
              if (!(n4.length < 2 || n4.length > t4)) {
                let s4 = n4.length, i5 = t4 - s4, u4 = `bcastMatmulIndices_${e4}`, l4 = "";
                for (let p4 = 0; p4 < s4 - 2; ++p4)
                  l4 += `
          realIndices[${p4}] = int( mod(float(bcastedIndices[${i5 + p4}]), ${n4[p4]}.0) );
          `;
                let f3 = `
        void ${u4}(int bcastedIndices[${t4}], out int realIndices[${s4}]) {
          ${l4}
          realIndices[${s4 - 1}] = bcastedIndices[${t4 - 1}];
          realIndices[${s4 - 2}] = bcastedIndices[${t4 - 2}];
        }
        `;
                o4[u4] = new R(f3);
              }
            }), o4;
          }
          indicesToOffset() {
            let t4 = {};
            return this.context.programInfo.inputNames.forEach((o4, e4) => {
              let r4 = this.context.inputTextureLayouts[e4].shape, n4 = this.context.inputTextureLayouts[e4].strides, s4 = r4.length, i5 = `indicesToOffset_${o4}`;
              t4[i5] = new R(a4.indexToOffsetSingle(i5, s4, n4)), i5 = `indicesToOffset_${o4}_T`, t4[i5] = new R(a4.indexToOffsetSingle(i5, s4, n4.slice().reverse()));
            }), t4;
          }
          static indexToOffsetSingle(t4, o4, e4) {
            let r4 = "";
            for (let n4 = o4 - 1; n4 >= 0; --n4)
              r4 += `
        offset += indices[${n4}] * ${e4[n4]};
        `;
            return `
      int ${t4}(int indices[${o4}]) {
        int offset = 0;
        ${r4}
        return offset;
      }
      `;
          }
          offsetToIndices() {
            let t4 = {};
            return this.context.programInfo.inputNames.forEach((o4, e4) => {
              let r4 = this.context.inputTextureLayouts[e4].shape, n4 = this.context.inputTextureLayouts[e4].strides, s4 = r4.length, i5 = `offsetToIndices_${o4}`;
              t4[i5] = new R(a4.offsetToIndicesSingle(i5, s4, n4)), i5 = `offsetToIndices_${o4}_T`, t4[i5] = new R(a4.offsetToIndicesSingle(i5, s4, n4.slice().reverse()));
            }), t4;
          }
          static offsetToIndicesSingle(t4, o4, e4) {
            let r4 = [];
            for (let n4 = 0; n4 < o4 - 1; ++n4)
              r4.push(`
      indices[${n4}] = offset / ${e4[n4]};`), r4.push(`
        offset -= indices[${n4}] * ${e4[n4]};`);
            return r4.push(`
      indices[${o4 - 1}] = offset;`), `
      void ${t4}(int offset, out int indices[${o4}]) {
        ${r4.join("")}
      }
      `;
          }
          incrementIndices() {
            let t4 = {};
            return this.context.programInfo.inputNames.forEach((o4, e4) => {
              let r4 = this.context.inputTextureLayouts[e4].shape, n4 = r4.length, s4 = `incrementIndices_${o4}`, i5 = "";
              for (let l4 = 0; l4 < n4; ++l4)
                i5 += `
        shape[${l4}] = ${r4[l4]};`;
              let u4 = `
        void ${s4}(int axis, out int indices[${n4}]) {
          int shape[${n4}];
          ${i5};
          for(int i = ${n4} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
              t4[s4] = new R(u4);
            }), t4;
          }
        };
      });
      var bo;
      var up = E(() => {
        "use strict";
        Ht();
        bo = class extends ft {
          constructor(t4) {
            super(t4);
          }
          getCustomTypes() {
            return {};
          }
          getFunctions() {
            return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };
          }
          binaryVecFunctions() {
            let o4 = this.context.outputTextureLayout.shape.length, e4 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, r4 = {};
            for (let n4 in e4) {
              let s4 = `${n4}Vec`, i5 = "";
              for (let l4 = 0; l4 < o4; ++l4)
                i5 += `
          dest[${l4}] ${e4[n4]} src[${l4}];
          `;
              let u4 = `
        void ${s4}(int src[${o4}], out int dest[${o4}]) {
          ${i5}
        }
        `;
              r4[s4] = new R(u4);
            }
            return r4;
          }
          copyVec() {
            let o4 = this.context.outputTextureLayout.shape.length, e4 = "";
            for (let n4 = 0; n4 < o4; ++n4)
              e4 += `
        dest[${n4}] = src[${n4}];
        `;
            let r4 = `
      void copyVec(int src[${o4}], out int dest[${o4}]) {
        ${e4}
      }
      `;
            return { copyVec: new R(r4) };
          }
          setVecItem() {
            let o4 = this.context.outputTextureLayout.shape.length, e4 = `
        if(index < 0)
            index =${o4} + index;
        if (index == 0)
            m[0] = value;
        `;
            for (let n4 = 1; n4 < o4 - 1; ++n4)
              e4 += `
        else if (index == ${n4})
            m[${n4}] = value;
            `;
            e4 += `
        else
            m[${o4 - 1}] = value;
        `;
            let r4 = `
      void setVecItem(out int m[${o4}], int index, int value) {
        ${e4}
      }
        `;
            return { setVecItem: new R(r4) };
          }
          getVecItem() {
            let o4 = this.context.outputTextureLayout.shape.length, e4 = `
        if(index < 0)
            index = ${o4} + index;
        if (index == 0)
            return m[0];
      `;
            for (let n4 = 1; n4 < o4 - 1; ++n4)
              e4 += `
        else if (index == ${n4})
            return m[${n4}];
      `;
            e4 += `
        else
            return m[${o4 - 1}];
        `;
            let r4 = `
      int getVecItem(int m[${o4}], int index) {
        ${e4}
      }
    `;
            return { getVecItem: new R(r4) };
          }
        };
      });
      var ji;
      var lp = E(() => {
        "use strict";
        op();
        ip();
        ap();
        sp();
        up();
        ji = { encoding: po, fragcolor: ho, vec: bo, shapeUtils: mo, coordinates: co };
      });
      var go;
      var fp = E(() => {
        "use strict";
        Ht();
        rp();
        lp();
        xe();
        go = class {
          constructor(t4, o4, e4, r4) {
            this.libs = {};
            this.glslLibRoutineDependencyGraph = {};
            this.context = new eo(t4, o4, e4, r4), Object.keys(ji).forEach((s4) => {
              let i5 = new ji[s4](this.context);
              this.libs[s4] = i5;
            });
            let n4 = this.glslLibRoutineDependencyGraph;
            for (let s4 in this.libs) {
              let u4 = this.libs[s4].getFunctions();
              for (let l4 in u4) {
                let f3 = s4 + "." + l4, p4;
                n4[f3] ? (p4 = n4[f3], p4.routineBody = u4[l4].routineBody) : (p4 = new dn(f3, u4[l4].routineBody), n4[f3] = p4);
                let d4 = u4[l4].dependencies;
                if (d4)
                  for (let T3 = 0; T3 < d4.length; ++T3)
                    if (n4[d4[T3]])
                      p4.addDependency(n4[d4[T3]]);
                    else {
                      let v5 = new dn(d4[T3]);
                      n4[d4[T3]] = v5, p4.addDependency(v5);
                    }
              }
            }
          }
          preprocess() {
            let t4 = this.context.programInfo, o4 = t4.shaderSource;
            return this.context.programInfo.hasMain || (o4 = `${o4}
      ${Vu(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), o4 = tp(o4), `${zu(this.context.glContext.version)}
    ${this.getUniforms(t4.inputNames, t4.variables)}
    ${this.getImports(o4)}
    ${o4}`;
          }
          getImports(t4) {
            let o4 = this.selectGlslLibRoutinesToBeIncluded(t4);
            if (o4.length === 0)
              return "";
            let e4 = "";
            for (let r4 = 0; r4 < o4.length; ++r4)
              if (o4[r4].routineBody)
                e4 += o4[r4].routineBody + `
`;
              else
                throw new Error(`Missing body for the Glsl Library routine: ${o4[r4].name}`);
            return e4;
          }
          selectGlslLibRoutinesToBeIncluded(t4) {
            let o4 = [];
            return Object.keys(this.glslLibRoutineDependencyGraph).forEach((e4) => {
              let r4 = e4.split(".")[1];
              t4.indexOf(r4) !== -1 && o4.push(this.glslLibRoutineDependencyGraph[e4]);
            }), to.returnOrderedNodes(o4);
          }
          getUniforms(t4, o4) {
            let e4 = [];
            if (t4)
              for (let r4 of t4)
                e4.push(`uniform sampler2D ${r4};`);
            if (o4)
              for (let r4 of o4)
                e4.push(`uniform ${r4.type} ${r4.name}${r4.arrayLength ? `[${r4.arrayLength}]` : ""};`);
            return e4.join(`
`);
          }
        };
      });
      var yo;
      var cp = E(() => {
        "use strict";
        Tt();
        at();
        fp();
        xe();
        yo = class {
          constructor(t4, o4, e4) {
            this.profiler = t4;
            this.glContext = o4;
            this.textureLayoutStrategy = e4;
            this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
          }
          getArtifact(t4) {
            return this.repo.get(t4);
          }
          setArtifact(t4, o4) {
            this.repo.set(t4, o4);
          }
          run(t4, o4, e4) {
            this.profiler.event("op", `ProgramManager.run ${t4.programInfo.name ?? "unknown kernel"}`, () => {
              let r4 = this.glContext.gl, n4 = t4.program;
              r4.useProgram(n4);
              try {
                this.bindOutput(e4), this.attributesBound || this.bindAttributes(t4.attribLocations), this.bindUniforms(t4.uniformLocations, t4.programInfo.variables ?? [], o4);
              } catch (s4) {
                throw ce.error("ProgramManager", t4.programInfo.shaderSource), s4;
              }
              this.profiler.event("backend", "GlContext.draw()", () => {
                this.glContext.draw();
              });
            }, this.glContext);
          }
          dispose() {
            this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t4) => this.glContext.deleteProgram(t4.program));
          }
          build(t4, o4, e4) {
            return this.profiler.event("backend", "ProgramManager.build", () => {
              let r4 = new go(this.glContext, t4, o4, e4), n4 = r4.preprocess(), s4 = this.compile(n4);
              return { programInfo: t4, program: s4, uniformLocations: this.getUniformLocations(s4, r4.context.programInfo.inputNames, r4.context.programInfo.variables), attribLocations: this.getAttribLocations(s4) };
            });
          }
          compile(t4) {
            if (!this.vertexShader) {
              ce.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
              let r4 = Uu(this.glContext.version);
              this.vertexShader = this.glContext.compileShader(r4, this.glContext.gl.VERTEX_SHADER);
            }
            Z.debug && ce.verbose("ProrgramManager", `FragShader:
${t4}
`);
            let o4 = this.glContext.compileShader(t4, this.glContext.gl.FRAGMENT_SHADER), e4 = this.glContext.createProgram(this.vertexShader, o4);
            return this.glContext.deleteShader(o4), e4;
          }
          bindOutput(t4) {
            let o4 = t4.width, e4 = t4.height;
            ce.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${o4}/${e4}, shape=${t4.shape}, type=${t4.tensor.type}`), this.glContext.attachFramebuffer(t4.texture, o4, e4);
          }
          bindAttributes(t4) {
            let o4 = t4.position, e4 = t4.textureCoord;
            this.glContext.setVertexAttributes(o4, e4), this.attributesBound = true;
          }
          bindUniforms(t4, o4, e4) {
            let r4 = this.glContext.gl, n4 = 0;
            for (let { name: s4, type: i5, location: u4, arrayLength: l4 } of t4) {
              let f3 = o4.find((p4) => p4.name === s4)?.data;
              if (i5 !== "sampler2D" && !f3)
                throw new Error(`variable '${s4}' does not have data defined in program info`);
              switch (i5) {
                case "sampler2D":
                  this.bindTexture(e4[n4], u4, n4), n4++;
                  break;
                case "float":
                  l4 ? r4.uniform1fv(u4, f3) : r4.uniform1f(u4, f3);
                  break;
                case "int":
                  l4 ? r4.uniform1iv(u4, f3) : r4.uniform1i(u4, f3);
                  break;
                default:
                  throw new Error(`Uniform not implemented: ${i5}`);
              }
            }
          }
          bindTexture(t4, o4, e4) {
            this.glContext.bindTextureToUniform(t4.texture, e4, o4);
          }
          getAttribLocations(t4) {
            return { position: this.getAttribLocation(t4, "position"), textureCoord: this.getAttribLocation(t4, "textureCoord") };
          }
          getUniformLocations(t4, o4, e4) {
            let r4 = [];
            if (o4)
              for (let n4 of o4)
                r4.push({ name: n4, type: "sampler2D", location: this.getUniformLocation(t4, n4) });
            if (e4)
              for (let n4 of e4)
                r4.push({ ...n4, location: this.getUniformLocation(t4, n4.name) });
            return r4;
          }
          getUniformLocation(t4, o4) {
            let r4 = this.glContext.gl.getUniformLocation(t4, o4);
            if (r4 === null)
              throw new Error(`Uniform ${o4} not found.`);
            return r4;
          }
          getAttribLocation(t4, o4) {
            return this.glContext.gl.getAttribLocation(t4, o4);
          }
        };
      });
      var To;
      var pp = E(() => {
        "use strict";
        at();
        cn();
        To = class {
          constructor(t4, o4, e4, r4) {
            this.glContext = t4;
            this.layoutStrategy = o4;
            this.profiler = e4;
            this.config = r4;
            this.pendingRead = /* @__PURE__ */ new Map();
            r4.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
          }
          createTextureFromLayout(t4, o4, e4, r4) {
            let n4 = this.toEncoderType(t4), s4 = this.glContext.getEncoder(n4, o4.channels || 1, r4);
            if (o4.isPacked && r4 === 1)
              throw new Error("not implemented");
            let i5 = o4.width, u4 = o4.height, l4, f3;
            if (this.config.reuseTextures) {
              l4 = `${i5}x${u4}_${s4.format}_${s4.internalFormat}_${s4.textureType}`, f3 = this.inUseTextures.get(l4), f3 || (f3 = [], this.inUseTextures.set(l4, f3));
              let d4 = this.idleTextures.get(l4);
              if (d4 && d4.length > 0) {
                let T3 = d4.pop();
                return f3.push(T3), r4 === 1 && this.glContext.updateTexture(T3, i5, u4, s4, this.toTextureData(t4, e4)), T3;
              }
            }
            ce.verbose("TextureManager", `Creating new texture of size ${o4.width}x${o4.height}`);
            let p4 = this.glContext.allocateTexture(i5, u4, s4, this.toTextureData(t4, e4));
            return this.config.reuseTextures && (f3.push(p4), this.textureLookup.set(p4, l4)), p4;
          }
          readTexture(t4, o4, e4) {
            return e4 || (e4 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
              let r4 = t4.shape.reduce((s4, i5) => s4 * i5) * e4, n4 = this.glContext.readTexture(t4.texture, t4.width, t4.height, r4, this.toEncoderType(o4), e4);
              return this.toTensorData(o4, n4);
            });
          }
          async readTextureAsync(t4, o4, e4) {
            let r4 = t4.tensor.dataId;
            if (e4 || (e4 = 1), this.pendingRead.has(r4)) {
              let n4 = this.pendingRead.get(r4);
              return new Promise((s4) => n4?.push(s4));
            }
            return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
              this.pendingRead.set(r4, []);
              let n4 = t4.shape.reduce((l4, f3) => l4 * f3) * e4;
              await this.glContext.createAndWaitForFence();
              let s4 = this.glContext.readTexture(t4.texture, t4.width, t4.height, n4, this.toEncoderType(o4), e4), i5 = this.toTensorData(o4, s4), u4 = this.pendingRead.get(r4);
              return this.pendingRead.delete(r4), u4?.forEach((l4) => l4(i5)), i5;
            });
          }
          readUint8TextureAsFloat(t4) {
            return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
              let o4 = t4.shape.reduce((r4, n4) => r4 * n4), e4 = this.glContext.readTexture(t4.texture, t4.width, t4.height, o4 * 4, "byte", 4);
              return new Float32Array(e4.buffer, e4.byteOffset, o4);
            });
          }
          releaseTexture(t4, o4) {
            let e4;
            if (this.config.reuseTextures && (e4 = this.textureLookup.get(t4.texture), e4)) {
              o4 && this.textureLookup.delete(e4);
              let r4 = this.inUseTextures.get(e4);
              if (r4) {
                let n4 = r4.indexOf(t4.texture);
                if (n4 !== -1) {
                  r4.splice(n4, 1);
                  let s4 = this.idleTextures.get(e4);
                  s4 || (s4 = [], this.idleTextures.set(e4, s4)), s4.push(t4.texture);
                }
              }
            }
            (!e4 || o4) && (ce.verbose("TextureManager", `Deleting texture of size ${t4.width}x${t4.height}`), this.glContext.deleteTexture(t4.texture));
          }
          toTensorData(t4, o4) {
            switch (t4) {
              case "int16":
                return o4 instanceof Int16Array ? o4 : Int16Array.from(o4);
              case "int32":
                return o4 instanceof Int32Array ? o4 : Int32Array.from(o4);
              case "int8":
                return o4 instanceof Int8Array ? o4 : Int8Array.from(o4);
              case "uint16":
                return o4 instanceof Uint16Array ? o4 : Uint16Array.from(o4);
              case "uint32":
                return o4 instanceof Uint32Array ? o4 : Uint32Array.from(o4);
              case "uint8":
              case "bool":
                return o4 instanceof Uint8Array ? o4 : Uint8Array.from(o4);
              case "float32":
                return o4 instanceof Float32Array ? o4 : Float32Array.from(o4);
              case "float64":
                return o4 instanceof Float64Array ? o4 : Float64Array.from(o4);
              default:
                throw new Error(`TensorData type ${t4} is not supported`);
            }
          }
          toTextureData(t4, o4) {
            if (o4)
              return o4 instanceof Float32Array ? o4 : new Float32Array(o4);
          }
          toEncoderType(t4) {
            return "float";
          }
          clearActiveTextures() {
            this.glContext.clearActiveTextures();
          }
        };
      });
      var xo;
      var dp = E(() => {
        "use strict";
        at();
        As();
        ol();
        Qc();
        cp();
        qi();
        pp();
        xo = class {
          constructor(t4, o4) {
            this.backend = t4;
            this.context = o4;
            this.layoutStrategy = new fo(t4.glContext.maxTextureSize), this.programManager = new yo(this.context.profiler, t4.glContext, this.layoutStrategy), this.textureManager = new To(t4.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: t4.textureCacheMode === "full" }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = t4.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
          }
          createInferenceHandler() {
            return new Qn(this);
          }
          onGraphInitialized(t4) {
            let o4 = t4.getValues().filter((e4) => e4.from === -1 && e4.tensor).map((e4) => e4.tensor.dataId);
            this.initializers = new Set(o4);
          }
          isInitializer(t4) {
            return this.initializers ? this.initializers.has(t4) : false;
          }
          addInitializer(t4) {
            this.initializers.add(t4);
          }
          getTextureData(t4, o4) {
            return o4 ? this.packedTextureDataCache.get(t4) : this.unpackedTextureDataCache.get(t4);
          }
          setTextureData(t4, o4, e4 = false) {
            ce.verbose("WebGLSessionHandler", "Storing Texture data in cache"), e4 ? this.packedTextureDataCache.set(t4, o4) : this.unpackedTextureDataCache.set(t4, o4);
          }
          dispose() {
            this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t4) => this.textureManager.releaseTexture(t4, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t4) => this.textureManager.releaseTexture(t4, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          resolve(t4, o4, e4) {
            let r4 = Ss(t4, o4, Zc);
            return { impl: r4.opImpl, context: r4.opInit ? r4.opInit(t4, e4) : t4 };
          }
        };
      });
      function Xb(a4) {
        let t4 = 0;
        for (; t4 < a4.length && a4[t4](); ++t4)
          ;
        return t4 - 1;
      }
      var bn;
      var hp = E(() => {
        "use strict";
        Tt();
        cn();
        cn();
        kt();
        bn = class {
          constructor(t4, o4) {
            this.frameBufferBound = false;
            this.itemsToPoll = [];
            this.gl = t4, this.version = o4, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
          }
          allocateTexture(t4, o4, e4, r4) {
            let n4 = this.gl, s4 = n4.createTexture();
            n4.bindTexture(n4.TEXTURE_2D, s4), n4.texParameteri(n4.TEXTURE_2D, n4.TEXTURE_MIN_FILTER, n4.NEAREST), n4.texParameteri(n4.TEXTURE_2D, n4.TEXTURE_MAG_FILTER, n4.NEAREST), n4.texParameteri(n4.TEXTURE_2D, n4.TEXTURE_WRAP_S, n4.CLAMP_TO_EDGE), n4.texParameteri(n4.TEXTURE_2D, n4.TEXTURE_WRAP_T, n4.CLAMP_TO_EDGE);
            let i5 = r4 ? e4.encode(r4, t4 * o4) : null;
            return n4.texImage2D(n4.TEXTURE_2D, 0, e4.internalFormat, t4, o4, 0, e4.format, e4.textureType, i5), this.checkError(), s4;
          }
          updateTexture(t4, o4, e4, r4, n4) {
            let s4 = this.gl;
            s4.bindTexture(s4.TEXTURE_2D, t4);
            let i5 = r4.encode(n4, o4 * e4);
            s4.texSubImage2D(s4.TEXTURE_2D, 0, 0, 0, o4, e4, r4.format, r4.textureType, i5), this.checkError();
          }
          attachFramebuffer(t4, o4, e4) {
            let r4 = this.gl;
            r4.bindTexture(r4.TEXTURE_2D, t4), r4.bindFramebuffer(r4.FRAMEBUFFER, this.framebuffer), r4.framebufferTexture2D(r4.FRAMEBUFFER, r4.COLOR_ATTACHMENT0, r4.TEXTURE_2D, t4, 0), this.checkError(), r4.viewport(0, 0, o4, e4), r4.scissor(0, 0, o4, e4);
          }
          readTexture(t4, o4, e4, r4, n4, s4) {
            let i5 = this.gl;
            s4 || (s4 = 1), this.frameBufferBound || this.attachFramebuffer(t4, o4, e4);
            let u4 = this.getEncoder(n4, s4), l4 = u4.allocate(o4 * e4);
            return i5.bindTexture(i5.TEXTURE_2D, t4), i5.framebufferTexture2D(i5.FRAMEBUFFER, i5.COLOR_ATTACHMENT0, i5.TEXTURE_2D, t4, 0), i5.readPixels(0, 0, o4, e4, i5.RGBA, u4.textureType, l4), this.checkError(), u4.decode(l4, r4);
          }
          isFramebufferReady() {
            return true;
          }
          getActiveTexture() {
            let t4 = this.gl;
            return `TEXTURE${t4.getParameter(this.gl.ACTIVE_TEXTURE) - t4.TEXTURE0}`;
          }
          getTextureBinding() {
            return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
          }
          getFramebufferBinding() {
            return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
          }
          setVertexAttributes(t4, o4) {
            let e4 = this.gl;
            e4.vertexAttribPointer(t4, 3, e4.FLOAT, false, 20, 0), e4.enableVertexAttribArray(t4), o4 !== -1 && (e4.vertexAttribPointer(o4, 2, e4.FLOAT, false, 20, 12), e4.enableVertexAttribArray(o4)), this.checkError();
          }
          createProgram(t4, o4) {
            let e4 = this.gl, r4 = e4.createProgram();
            return e4.attachShader(r4, t4), e4.attachShader(r4, o4), e4.linkProgram(r4), r4;
          }
          compileShader(t4, o4) {
            let e4 = this.gl, r4 = e4.createShader(o4);
            if (!r4)
              throw new Error(`createShader() returned null with type ${o4}`);
            if (e4.shaderSource(r4, t4), e4.compileShader(r4), e4.getShaderParameter(r4, e4.COMPILE_STATUS) === false)
              throw new Error(`Failed to compile shader: ${e4.getShaderInfoLog(r4)}
Shader source:
${t4}`);
            return r4;
          }
          deleteShader(t4) {
            this.gl.deleteShader(t4);
          }
          bindTextureToUniform(t4, o4, e4) {
            let r4 = this.gl;
            r4.activeTexture(r4.TEXTURE0 + o4), this.checkError(), r4.bindTexture(r4.TEXTURE_2D, t4), this.checkError(), r4.uniform1i(e4, o4), this.checkError();
          }
          draw() {
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
          }
          checkError() {
            if (Z.debug) {
              let t4 = this.gl, o4 = t4.getError(), e4 = "";
              switch (o4) {
                case t4.NO_ERROR:
                  return;
                case t4.INVALID_ENUM:
                  e4 = "INVALID_ENUM";
                  break;
                case t4.INVALID_VALUE:
                  e4 = "INVALID_VALUE";
                  break;
                case t4.INVALID_OPERATION:
                  e4 = "INVALID_OPERATION";
                  break;
                case t4.INVALID_FRAMEBUFFER_OPERATION:
                  e4 = "INVALID_FRAMEBUFFER_OPERATION";
                  break;
                case t4.OUT_OF_MEMORY:
                  e4 = "OUT_OF_MEMORY";
                  break;
                case t4.CONTEXT_LOST_WEBGL:
                  e4 = "CONTEXT_LOST_WEBGL";
                  break;
                default:
                  e4 = `Unknown WebGL Error: ${o4.toString(16)}`;
              }
              throw new Error(e4);
            }
          }
          deleteTexture(t4) {
            this.gl.deleteTexture(t4);
          }
          deleteProgram(t4) {
            this.gl.deleteProgram(t4);
          }
          getEncoder(t4, o4, e4 = 0) {
            if (this.version === 2)
              return new Jn(this.gl, o4);
            switch (t4) {
              case "float":
                return e4 === 1 || this.isRenderFloat32Supported ? new fn(this.gl, o4) : new fn(this.gl, o4, this.textureHalfFloatExtension.HALF_FLOAT_OES);
              case "int":
                throw new Error("not implemented");
              case "byte":
                return new Zn(this.gl, o4);
              default:
                throw new Error(`Invalid dataType: ${t4}`);
            }
          }
          clearActiveTextures() {
            let t4 = this.gl;
            for (let o4 = 0; o4 < this.maxTextureImageUnits; ++o4)
              t4.activeTexture(t4.TEXTURE0 + o4), t4.bindTexture(t4.TEXTURE_2D, null);
          }
          dispose() {
            if (this.disposed)
              return;
            let t4 = this.gl;
            t4.bindFramebuffer(t4.FRAMEBUFFER, null), t4.deleteFramebuffer(this.framebuffer), t4.bindBuffer(t4.ARRAY_BUFFER, null), t4.deleteBuffer(this.vertexbuffer), t4.bindBuffer(t4.ELEMENT_ARRAY_BUFFER, null), t4.finish(), this.disposed = true;
          }
          createDefaultGeometry() {
            return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
          }
          createVertexbuffer() {
            let t4 = this.gl, o4 = t4.createBuffer();
            if (!o4)
              throw new Error("createBuffer() returned null");
            let e4 = this.createDefaultGeometry();
            return t4.bindBuffer(t4.ARRAY_BUFFER, o4), t4.bufferData(t4.ARRAY_BUFFER, e4, t4.STATIC_DRAW), this.checkError(), o4;
          }
          createFramebuffer() {
            let t4 = this.gl.createFramebuffer();
            if (!t4)
              throw new Error("createFramebuffer returned null");
            return t4;
          }
          queryVitalParameters() {
            let t4 = this.gl;
            if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
              throw new Error("both float32 and float16 TextureType are not supported");
            this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t4.getParameter(t4.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS), this.version;
          }
          getExtensions() {
            this.version === 2 ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
          }
          checkFloatTextureAttachableToFrameBuffer() {
            let t4 = this.gl, o4 = t4.createTexture();
            t4.bindTexture(t4.TEXTURE_2D, o4);
            let e4 = this.version === 2 ? t4.RGBA32F : t4.RGBA;
            t4.texImage2D(t4.TEXTURE_2D, 0, e4, 1, 1, 0, t4.RGBA, t4.FLOAT, null);
            let r4 = t4.createFramebuffer();
            t4.bindFramebuffer(t4.FRAMEBUFFER, r4), t4.framebufferTexture2D(t4.FRAMEBUFFER, t4.COLOR_ATTACHMENT0, t4.TEXTURE_2D, o4, 0);
            let n4 = t4.checkFramebufferStatus(t4.FRAMEBUFFER) === t4.FRAMEBUFFER_COMPLETE;
            return t4.bindTexture(t4.TEXTURE_2D, null), t4.bindFramebuffer(t4.FRAMEBUFFER, null), t4.deleteTexture(o4), t4.deleteFramebuffer(r4), n4;
          }
          checkRenderFloat32() {
            if (this.version === 2) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else if (!this.textureFloatExtension)
              return false;
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Download() {
            if (this.version === 2) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else if (!this.textureFloatExtension || !this.gl.getExtension("WEBGL_color_buffer_float"))
              return false;
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Blend() {
            let t4 = this.gl, o4, e4, r4, n4, s4;
            try {
              o4 = t4.createTexture(), e4 = t4.createFramebuffer(), t4.bindTexture(t4.TEXTURE_2D, o4);
              let i5 = this.version === 2 ? t4.RGBA32F : t4.RGBA;
              return t4.texImage2D(t4.TEXTURE_2D, 0, i5, 1, 1, 0, t4.RGBA, t4.FLOAT, null), t4.bindFramebuffer(t4.FRAMEBUFFER, e4), t4.framebufferTexture2D(t4.FRAMEBUFFER, t4.COLOR_ATTACHMENT0, t4.TEXTURE_2D, o4, 0), t4.enable(t4.BLEND), r4 = t4.createShader(t4.VERTEX_SHADER), !r4 || (t4.shaderSource(r4, "void main(){}"), t4.compileShader(r4), n4 = t4.createShader(t4.FRAGMENT_SHADER), !n4) || (t4.shaderSource(n4, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), t4.compileShader(n4), s4 = t4.createProgram(), !s4) ? false : (t4.attachShader(s4, r4), t4.attachShader(s4, n4), t4.linkProgram(s4), t4.useProgram(s4), t4.drawArrays(t4.POINTS, 0, 1), t4.getError() === t4.NO_ERROR);
            } finally {
              t4.disable(t4.BLEND), s4 && t4.deleteProgram(s4), r4 && t4.deleteShader(r4), n4 && t4.deleteShader(n4), e4 && (t4.bindFramebuffer(t4.FRAMEBUFFER, null), t4.deleteFramebuffer(e4)), o4 && (t4.bindTexture(t4.TEXTURE_2D, null), t4.deleteTexture(o4));
            }
          }
          beginTimer() {
            if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
              let t4 = this.gl, o4 = this.disjointTimerQueryWebgl2Extension, e4 = t4.createQuery();
              return t4.beginQuery(o4.TIME_ELAPSED_EXT, e4), e4;
            } else
              throw new Error("WebGL1 profiling currently not supported.");
          }
          endTimer() {
            if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
              let t4 = this.gl, o4 = this.disjointTimerQueryWebgl2Extension;
              t4.endQuery(o4.TIME_ELAPSED_EXT);
              return;
            } else
              throw new Error("WebGL1 profiling currently not supported");
          }
          isTimerResultAvailable(t4) {
            let o4 = false, e4 = false;
            if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
              let r4 = this.gl, n4 = this.disjointTimerQueryWebgl2Extension;
              o4 = r4.getQueryParameter(t4, r4.QUERY_RESULT_AVAILABLE), e4 = r4.getParameter(n4.GPU_DISJOINT_EXT);
            } else
              throw new Error("WebGL1 profiling currently not supported");
            return o4 && !e4;
          }
          getTimerResult(t4) {
            let o4 = 0;
            if (this.version === 2) {
              let e4 = this.gl;
              o4 = e4.getQueryParameter(t4, e4.QUERY_RESULT), e4.deleteQuery(t4);
            } else
              throw new Error("WebGL1 profiling currently not supported");
            return o4 / 1e6;
          }
          async waitForQueryAndGetTime(t4) {
            return await yi(() => this.isTimerResultAvailable(t4)), this.getTimerResult(t4);
          }
          async createAndWaitForFence() {
            let t4 = this.createFence(this.gl);
            return this.pollFence(t4);
          }
          createFence(t4) {
            let o4, e4 = t4, r4 = e4.fenceSync(e4.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return t4.flush(), r4 === null ? o4 = () => true : o4 = () => {
              let n4 = e4.clientWaitSync(r4, 0, 0);
              return n4 === e4.ALREADY_SIGNALED || n4 === e4.CONDITION_SATISFIED;
            }, { query: r4, isFencePassed: o4 };
          }
          async pollFence(t4) {
            return new Promise((o4) => {
              this.addItemToPoll(() => t4.isFencePassed(), () => o4());
            });
          }
          pollItems() {
            let t4 = Xb(this.itemsToPoll.map((o4) => o4.isDoneFn));
            for (let o4 = 0; o4 <= t4; ++o4) {
              let { resolveFn: e4 } = this.itemsToPoll[o4];
              e4();
            }
            this.itemsToPoll = this.itemsToPoll.slice(t4 + 1);
          }
          async addItemToPoll(t4, o4) {
            this.itemsToPoll.push({ isDoneFn: t4, resolveFn: o4 }), !(this.itemsToPoll.length > 1) && await yi(() => (this.pollItems(), this.itemsToPoll.length === 0));
          }
        };
      });
      function Yi(a4) {
        let t4;
        if ((!a4 || a4 === "webgl2") && "webgl2" in zr ? t4 = zr.webgl2 : (!a4 || a4 === "webgl") && "webgl" in zr && (t4 = zr.webgl), !t4)
          try {
            let e4 = Jb();
            t4 = mp(e4, a4);
          } catch {
            let r4 = Kb();
            t4 = mp(r4, a4);
          }
        a4 = a4 || t4.version === 1 ? "webgl" : "webgl2";
        let o4 = t4.gl;
        return zr[a4] = t4, o4.isContextLost() ? (delete zr[a4], Yi(a4)) : (o4.disable(o4.DEPTH_TEST), o4.disable(o4.STENCIL_TEST), o4.disable(o4.BLEND), o4.disable(o4.DITHER), o4.disable(o4.POLYGON_OFFSET_FILL), o4.disable(o4.SAMPLE_COVERAGE), o4.enable(o4.SCISSOR_TEST), o4.enable(o4.CULL_FACE), o4.cullFace(o4.BACK), t4);
      }
      function mp(a4, t4) {
        let o4 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false }, e4, r4 = o4;
        if ((!t4 || t4 === "webgl2") && (e4 = a4.getContext("webgl2", r4), e4))
          try {
            return new bn(e4, 2);
          } catch (n4) {
            ce.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${n4}`);
          }
        if ((!t4 || t4 === "webgl") && (e4 = a4.getContext("webgl", r4) || a4.getContext("experimental-webgl", r4), e4))
          try {
            return new bn(e4, 1);
          } catch (n4) {
            ce.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n4}`);
          }
        throw new Error("WebGL is not supported");
      }
      function Kb() {
        if (typeof document > "u")
          throw new TypeError("failed to create canvas: document is not supported");
        let a4 = document.createElement("canvas");
        return a4.width = 1, a4.height = 1, a4;
      }
      function Jb() {
        if (typeof OffscreenCanvas > "u")
          throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
        return new OffscreenCanvas(1, 1);
      }
      var zr;
      var bp = E(() => {
        "use strict";
        at();
        hp();
        zr = {};
      });
      var wo;
      var gp = E(() => {
        "use strict";
        Tt();
        at();
        dp();
        bp();
        wo = class {
          get contextId() {
            return Z.webgl.contextId;
          }
          set contextId(t4) {
            Z.webgl.contextId = t4;
          }
          get matmulMaxBatchSize() {
            return Z.webgl.matmulMaxBatchSize;
          }
          set matmulMaxBatchSize(t4) {
            Z.webgl.matmulMaxBatchSize = t4;
          }
          get textureCacheMode() {
            return Z.webgl.textureCacheMode;
          }
          set textureCacheMode(t4) {
            Z.webgl.textureCacheMode = t4;
          }
          get pack() {
            return Z.webgl.pack;
          }
          set pack(t4) {
            Z.webgl.pack = t4;
          }
          get async() {
            return Z.webgl.async;
          }
          set async(t4) {
            Z.webgl.async = t4;
          }
          initialize() {
            try {
              return this.glContext = Yi(this.contextId), typeof this.matmulMaxBatchSize != "number" && (this.matmulMaxBatchSize = 16), typeof this.textureCacheMode != "string" && (this.textureCacheMode = "full"), typeof this.pack != "boolean" && (this.pack = false), typeof this.async != "boolean" && (this.async = false), ce.setWithEnv(Z), Z.webgl.context || Object.defineProperty(Z.webgl, "context", { value: this.glContext.gl }), ce.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
            } catch (t4) {
              return ce.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${t4}`), false;
            }
          }
          createSessionHandler(t4) {
            return new xo(this, t4);
          }
          dispose() {
            this.glContext.dispose();
          }
        };
      });
      async function Xi(a4) {
        if (a4) {
          let t4 = typeof a4 == "string" ? [a4] : a4;
          for (let o4 of t4) {
            let e4 = yp.get(o4);
            if (e4)
              return e4;
            let r4 = await Qb(o4);
            if (r4)
              return r4;
          }
        } else
          return Xi(["webgl"]);
        throw new Error("no available backend to use");
      }
      async function Qb(a4) {
        let t4 = Zb;
        if (typeof t4[a4] < "u" && eg(t4[a4])) {
          let o4 = t4[a4], e4 = o4.initialize();
          if (typeof e4 == "object" && "then" in e4 && (e4 = await e4), e4)
            return yp.set(a4, o4), o4;
        }
      }
      function eg(a4) {
        let t4 = a4;
        return "initialize" in t4 && typeof t4.initialize == "function" && "createSessionHandler" in t4 && typeof t4.createSessionHandler == "function" && "dispose" in t4 && typeof t4.dispose == "function";
      }
      var yp;
      var Zb;
      var Tp = E(() => {
        "use strict";
        gp();
        yp = /* @__PURE__ */ new Map(), Zb = { webgl: new wo() };
      });
      var Ki;
      var vo;
      var xp = E(() => {
        "use strict";
        at();
        Ki = class {
          constructor(t4, o4) {
            this.op = t4;
            this.node = o4;
          }
        }, vo = class {
          constructor(t4, o4, e4) {
            this.graph = t4;
            this.profiler = e4;
            this.initialize(o4);
          }
          initialize(t4) {
            this.profiler.event("session", "ExecutionPlan.initialize", () => {
              let o4 = this.graph.getNodes();
              if (o4.length !== t4.length)
                throw new Error("The size of nodes and OPs do not match.");
              this._ops = t4.map((e4, r4) => new Ki(e4, o4[r4])), this.reset(), this._starter = [], this._ops.forEach((e4, r4) => {
                let n4 = true;
                for (let s4 of e4.node.inputs)
                  if (!this._values[s4] && this.graph.getInputIndices().indexOf(s4) === -1) {
                    n4 = false;
                    break;
                  }
                n4 && this._starter.push(r4);
              });
            });
          }
          reset() {
            this._values = this.graph.getValues().map((t4) => t4.tensor);
          }
          async execute(t4, o4) {
            return this.profiler.event("session", "ExecutionPlan.execute", async () => {
              this.reset();
              let e4 = t4.createInferenceHandler(), r4 = this.graph.getInputIndices();
              if (o4.length !== r4.length)
                throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${o4.length} expected: ${r4.length}`);
              o4.forEach((f3, p4) => {
                let d4 = r4[p4];
                this._values[d4] = f3;
              });
              let n4 = this._starter.slice(0), s4 = this.graph.getValues(), i5 = this.graph.getNodes(), u4 = 0;
              for (; u4 < n4.length; ) {
                let f3 = n4[u4++], p4 = this._ops[f3], d4 = p4.node.inputs.map((I3) => this._values[I3]);
                if (d4.indexOf(void 0) !== -1)
                  throw new Error(`unresolved input detected: op: ${p4.node}`);
                let T3 = d4;
                ce.verbose("ExecPlan", `Runing op:${p4.node.name} (${T3.map((I3, L3) => `'${p4.node.inputs[L3]}': ${I3.type}[${I3.dims.join(",")}]`).join(", ")})`);
                let v5 = await this.profiler.event("node", p4.node.name, async () => p4.op.impl(e4, T3, p4.op.context));
                if (v5.length !== p4.node.outputs.length)
                  throw new Error("the size of output does not match model definition.");
                v5.forEach((I3, L3) => {
                  let F4 = p4.node.outputs[L3];
                  if (this._values[F4])
                    throw new Error(`output [${F4}] already has value: op:${p4.node.name}`);
                  this._values[F4] = I3;
                });
                let w3 = /* @__PURE__ */ new Set();
                v5.forEach((I3, L3) => {
                  let F4 = p4.node.outputs[L3];
                  for (let C3 of s4[F4].to) {
                    let Y5 = i5[C3], j4 = true;
                    for (let M4 of Y5.inputs)
                      if (!this._values[M4]) {
                        j4 = false;
                        break;
                      }
                    j4 && w3.add(C3);
                  }
                }), n4.push(...w3);
              }
              let l4 = [];
              for (let f3 = 0; f3 < this.graph.getOutputIndices().length; f3++) {
                let p4 = this.graph.getOutputIndices()[f3], d4 = this._values[p4];
                if (d4 === void 0)
                  throw new Error(`required output [${p4}] does not have value`);
                p4 === 0 ? await d4.getData() : d4.data, l4.push(d4);
              }
              return ce.verbose("ExecPlan", "disposing of inferenceHandler"), e4.dispose(), l4;
            });
          }
        };
      });
      var oe;
      var dt;
      var gn;
      var wp = E(() => {
        "use strict";
        nn();
        oe = Dr($r());
        yr();
        fe();
        dt = W.experimental.fbs, gn = class a4 {
          constructor(t4) {
            if (this._attributes = /* @__PURE__ */ new Map(), t4 != null) {
              for (let o4 of t4)
                o4 instanceof oe.onnx.AttributeProto ? this._attributes.set(o4.name, [a4.getValue(o4), a4.getType(o4)]) : o4 instanceof dt.Attribute && this._attributes.set(o4.name(), [a4.getValue(o4), a4.getType(o4)]);
              if (this._attributes.size < t4.length)
                throw new Error("duplicated attribute names");
            }
          }
          set(t4, o4, e4) {
            this._attributes.set(t4, [e4, o4]);
          }
          delete(t4) {
            this._attributes.delete(t4);
          }
          getFloat(t4, o4) {
            return this.get(t4, "float", o4);
          }
          getInt(t4, o4) {
            return this.get(t4, "int", o4);
          }
          getString(t4, o4) {
            return this.get(t4, "string", o4);
          }
          getTensor(t4, o4) {
            return this.get(t4, "tensor", o4);
          }
          getFloats(t4, o4) {
            return this.get(t4, "floats", o4);
          }
          getInts(t4, o4) {
            return this.get(t4, "ints", o4);
          }
          getStrings(t4, o4) {
            return this.get(t4, "strings", o4);
          }
          getTensors(t4, o4) {
            return this.get(t4, "tensors", o4);
          }
          get(t4, o4, e4) {
            let r4 = this._attributes.get(t4);
            if (r4 === void 0) {
              if (e4 !== void 0)
                return e4;
              throw new Error(`required attribute not found: ${t4}`);
            }
            if (r4[1] !== o4)
              throw new Error(`type mismatch: expected ${o4} but got ${r4[1]}`);
            return r4[0];
          }
          static getType(t4) {
            let o4 = t4 instanceof oe.onnx.AttributeProto ? t4.type : t4.type();
            switch (o4) {
              case oe.onnx.AttributeProto.AttributeType.FLOAT:
                return "float";
              case oe.onnx.AttributeProto.AttributeType.INT:
                return "int";
              case oe.onnx.AttributeProto.AttributeType.STRING:
                return "string";
              case oe.onnx.AttributeProto.AttributeType.TENSOR:
                return "tensor";
              case oe.onnx.AttributeProto.AttributeType.FLOATS:
                return "floats";
              case oe.onnx.AttributeProto.AttributeType.INTS:
                return "ints";
              case oe.onnx.AttributeProto.AttributeType.STRINGS:
                return "strings";
              case oe.onnx.AttributeProto.AttributeType.TENSORS:
                return "tensors";
              default:
                throw new Error(`attribute type is not supported yet: ${oe.onnx.AttributeProto.AttributeType[o4]}`);
            }
          }
          static getValue(t4) {
            let o4 = t4 instanceof oe.onnx.AttributeProto ? t4.type : t4.type();
            if (o4 === oe.onnx.AttributeProto.AttributeType.GRAPH || o4 === oe.onnx.AttributeProto.AttributeType.GRAPHS)
              throw new Error("graph attribute is not supported yet");
            let e4 = this.getValueNoCheck(t4);
            if (o4 === oe.onnx.AttributeProto.AttributeType.INT && nt.isLong(e4))
              return nt.longToNumber(e4);
            if (o4 === oe.onnx.AttributeProto.AttributeType.INTS) {
              let r4 = e4, n4 = new Array(r4.length);
              for (let s4 = 0; s4 < r4.length; s4++) {
                let i5 = r4[s4];
                n4[s4] = nt.longToNumber(i5);
              }
              return n4;
            }
            if (o4 === oe.onnx.AttributeProto.AttributeType.TENSOR)
              return t4 instanceof oe.onnx.AttributeProto ? Ce.fromProto(e4) : Ce.fromOrtTensor(e4);
            if (o4 === oe.onnx.AttributeProto.AttributeType.TENSORS) {
              if (t4 instanceof oe.onnx.AttributeProto)
                return e4.map((n4) => Ce.fromProto(n4));
              if (t4 instanceof dt.Attribute)
                return e4.map((n4) => Ce.fromOrtTensor(n4));
            }
            return o4 === oe.onnx.AttributeProto.AttributeType.STRING && t4 instanceof oe.onnx.AttributeProto ? ln(e4) : o4 === oe.onnx.AttributeProto.AttributeType.STRINGS && t4 instanceof oe.onnx.AttributeProto ? e4.map(ln) : e4;
          }
          static getValueNoCheck(t4) {
            return t4 instanceof oe.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t4) : this.getValueNoCheckFromOrtFormat(t4);
          }
          static getValueNoCheckFromOnnxFormat(t4) {
            switch (t4.type) {
              case oe.onnx.AttributeProto.AttributeType.FLOAT:
                return t4.f;
              case oe.onnx.AttributeProto.AttributeType.INT:
                return t4.i;
              case oe.onnx.AttributeProto.AttributeType.STRING:
                return t4.s;
              case oe.onnx.AttributeProto.AttributeType.TENSOR:
                return t4.t;
              case oe.onnx.AttributeProto.AttributeType.GRAPH:
                return t4.g;
              case oe.onnx.AttributeProto.AttributeType.FLOATS:
                return t4.floats;
              case oe.onnx.AttributeProto.AttributeType.INTS:
                return t4.ints;
              case oe.onnx.AttributeProto.AttributeType.STRINGS:
                return t4.strings;
              case oe.onnx.AttributeProto.AttributeType.TENSORS:
                return t4.tensors;
              case oe.onnx.AttributeProto.AttributeType.GRAPHS:
                return t4.graphs;
              default:
                throw new Error(`unsupported attribute type: ${oe.onnx.AttributeProto.AttributeType[t4.type]}`);
            }
          }
          static getValueNoCheckFromOrtFormat(t4) {
            switch (t4.type()) {
              case dt.AttributeType.FLOAT:
                return t4.f();
              case dt.AttributeType.INT:
                return t4.i();
              case dt.AttributeType.STRING:
                return t4.s();
              case dt.AttributeType.TENSOR:
                return t4.t();
              case dt.AttributeType.GRAPH:
                return t4.g();
              case dt.AttributeType.FLOATS:
                return t4.floatsArray();
              case dt.AttributeType.INTS: {
                let o4 = [];
                for (let e4 = 0; e4 < t4.intsLength(); e4++)
                  o4.push(t4.ints(e4));
                return o4;
              }
              case dt.AttributeType.STRINGS: {
                let o4 = [];
                for (let e4 = 0; e4 < t4.stringsLength(); e4++)
                  o4.push(t4.strings(e4));
                return o4;
              }
              case dt.AttributeType.TENSORS: {
                let o4 = [];
                for (let e4 = 0; e4 < t4.tensorsLength(); e4++)
                  o4.push(t4.tensors(e4));
                return o4;
              }
              default:
                throw new Error(`unsupported attribute type: ${dt.AttributeType[t4.type()]}`);
            }
          }
        };
      });
      var Zi;
      var _o;
      var Qi;
      var Rt;
      var Oo;
      var Ji;
      var vp = E(() => {
        "use strict";
        wp();
        nn();
        Zi = Dr($r());
        yr();
        fe();
        _o = W.experimental.fbs, Qi = { from: (a4, t4) => new Ji(a4, t4) }, Rt = class {
          constructor(t4) {
            this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t4 && (this.type = Ve.tensorValueTypeFromProto(t4.type.tensorType));
          }
          get from() {
            return this._from;
          }
          get to() {
            return this._to;
          }
        }, Oo = class {
          constructor(t4, o4) {
            t4 instanceof Zi.onnx.NodeProto ? (this.name = t4.name, this.opType = t4.opType, this.attributes = new gn(t4.attribute)) : t4 instanceof _o.Node && (this.name = o4 ?? t4.name(), this.opType = t4.opType(), this.attributes = new gn(Ve.tensorAttributesFromORTFormat(t4))), this.inputs = [], this.outputs = [], this.executeNode = true;
          }
        }, Ji = class {
          constructor(t4, o4) {
            if (!t4)
              throw new TypeError("graph is empty");
            this.buildGraph(t4), this.transformGraph(o4), this.checkIsAcyclic();
          }
          getInputIndices() {
            return this._allInputIndices;
          }
          getInputNames() {
            return this._allInputNames;
          }
          getOutputIndices() {
            return this._allOutputIndices;
          }
          getOutputNames() {
            return this._allOutputNames;
          }
          getValues() {
            return this._allData;
          }
          getNodes() {
            return this._nodes;
          }
          buildGraph(t4) {
            if (t4 instanceof Zi.onnx.GraphProto)
              this.buildGraphFromOnnxFormat(t4);
            else if (t4 instanceof _o.Graph)
              this.buildGraphFromOrtFormat(t4);
            else
              throw new TypeError("Graph type is not supported.");
          }
          buildGraphFromOnnxFormat(t4) {
            let o4 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            let e4 = /* @__PURE__ */ new Map();
            if (!t4.input)
              throw new Error("missing information in graph: input");
            let r4 = [];
            for (let n4 of t4.input) {
              if (o4.has(n4.name))
                throw new Error(`duplicated input name: ${n4.name}`);
              let s4 = this._allData.push(new Rt(n4)) - 1;
              o4.set(n4.name, s4), r4.push(n4.name);
            }
            if (!t4.initializer)
              throw new Error("missing information in graph: initializer");
            for (let n4 of t4.initializer) {
              let s4 = o4.get(n4.name);
              if (s4 === void 0) {
                let i5 = new Rt();
                i5.type = { shape: { dims: Ve.tensorDimsFromProto(n4.dims) }, tensorType: Ve.tensorDataTypeFromProto(n4.dataType) }, s4 = this._allData.push(i5) - 1, o4.set(n4.name, s4);
              }
              this._allData[s4]._from = -1, this._allData[s4].tensor = Ce.fromProto(n4);
            }
            for (let n4 = 0; n4 < this._allData.length; n4++)
              this._allData[n4].tensor || (this._allInputIndices.push(n4), this._allInputNames.push(r4[n4]));
            if (!t4.output)
              throw new Error("missing information in graph: output");
            for (let n4 of t4.output) {
              if (o4.has(n4.name))
                throw new Error(`duplicated output name: ${n4.name}`);
              let s4 = this._allData.push(new Rt(n4)) - 1;
              o4.set(n4.name, s4), this._allOutputIndices.push(s4), this._allOutputNames.push(n4.name);
            }
            if (!t4.node)
              throw new Error("missing information in graph: node");
            for (let n4 of t4.node) {
              if (!n4.name)
                for (let i5 = 0; ; i5++) {
                  let u4 = `unnamed_${n4.opType}_${i5}`;
                  if (!e4.has(u4)) {
                    n4.name = u4;
                    break;
                  }
                }
              if (e4.has(n4.name))
                throw new Error(`duplicated node name: ${n4.name}`);
              let s4 = this._nodes.push(new Oo(n4)) - 1;
              e4.set(n4.name, s4);
            }
            for (let n4 = 0; n4 < this._nodes.length; n4++) {
              let s4 = this._nodes[n4], i5 = t4.node[n4];
              if (!i5.output)
                throw new Error(`missing output for node: ${i5.name}`);
              for (let u4 of i5.output) {
                let l4 = o4.get(u4);
                if (typeof l4 > "u" && (l4 = this._allData.push(new Rt()) - 1, o4.set(u4, l4)), s4.outputs.push(l4), this._allData[l4]._from !== void 0)
                  throw new Error(`multiple nodes output to one data value: ${l4}`);
                if (this._allData[l4]._from = n4, i5.opType === "Constant") {
                  if (!i5.attribute || i5.attribute.length !== 1 || !i5.attribute[0].t)
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (!i5.output || i5.output.length !== 1)
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  s4.outputs.pop(), s4.executeNode = false, this._allData[l4]._from = -1, this._allData[l4].tensor = Ce.fromProto(i5.attribute[0].t);
                }
              }
            }
            for (let n4 = 0; n4 < this._nodes.length; n4++) {
              let s4 = this._nodes[n4], i5 = t4.node[n4];
              if (!i5.input)
                throw new Error(`missing input for node: ${i5.name}`);
              for (let u4 of i5.input) {
                let l4 = o4.get(u4);
                if (typeof l4 > "u") {
                  if (u4 === "" && (i5.input.length === 3 || i5.input.length === 4) && i5.opType === "Resize")
                    continue;
                  throw new Error(`unrecognized input '${u4}' for node: ${i5.name}`);
                }
                s4.inputs.push(l4), this._allData[l4]._to.push(n4);
              }
            }
            return true;
          }
          buildGraphFromOrtFormat(t4) {
            let o4 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            let e4 = /* @__PURE__ */ new Map(), r4 = [];
            for (let n4 = 0; n4 < t4.inputsLength(); n4++) {
              let s4 = t4.inputs(n4);
              if (o4.has(s4))
                throw new Error(`duplicated input name: ${s4}`);
              for (let i5 = 0; i5 < t4.nodeArgsLength(); i5++)
                if (t4.nodeArgs(i5)?.name() === s4) {
                  let u4 = new Rt();
                  if (t4.nodeArgs(i5)?.type()?.valueType() !== _o.TypeInfoValue.tensor_type)
                    throw new Error("Unexpected value type for the nodeArg.");
                  let f3 = t4.nodeArgs(i5).type().value(new _o.TensorTypeAndShape()), p4 = Ve.tensorDataTypeFromProto(f3.elemType()), d4 = f3.shape(), T3 = [];
                  for (let w3 = 0; w3 < d4.dimLength(); w3++)
                    T3.push(nt.longToNumber(d4.dim(w3).value().dimValue()));
                  u4.type = { shape: { dims: T3 }, tensorType: p4 };
                  let v5 = this._allData.push(u4) - 1;
                  o4.set(s4, v5), r4.push(s4);
                }
            }
            for (let n4 = 0; n4 < t4.initializersLength(); n4++) {
              let s4 = t4.initializers(n4), i5 = o4.get(s4.name());
              if (i5 === void 0) {
                let u4 = new Rt(), l4 = Ve.tensorDimsFromORTFormat(s4), f3 = Ve.tensorDataTypeFromProto(s4.dataType());
                u4.type = { shape: { dims: l4 }, tensorType: f3 }, i5 = this._allData.push(u4) - 1, o4.set(s4.name(), i5);
              }
              this._allData[i5]._from = -1, this._allData[i5].tensor = Ce.fromOrtTensor(s4);
            }
            for (let n4 = 0; n4 < this._allData.length; n4++)
              this._allData[n4].tensor || (this._allInputIndices.push(n4), this._allInputNames.push(r4[n4]));
            for (let n4 = 0; n4 < t4.outputsLength(); n4++) {
              let s4 = t4.outputs(n4);
              if (o4.has(s4))
                throw new Error(`duplicated output name: ${s4}`);
              let i5 = this._allData.push(new Rt()) - 1;
              o4.set(s4, i5), this._allOutputIndices.push(i5), this._allOutputNames.push(s4);
            }
            if (!t4.nodes)
              throw new Error("missing information in graph: node");
            for (let n4 = 0; n4 < t4.nodesLength(); n4++) {
              let s4 = t4.nodes(n4), i5 = s4.name();
              if (!i5)
                for (let l4 = 0; i5 = `unnamed_${s4.opType()}_${l4}`, !!e4.has(i5); l4++)
                  ;
              if (e4.has(i5))
                throw new Error(`duplicated node name: ${i5}`);
              let u4 = this._nodes.push(new Oo(s4, i5)) - 1;
              e4.set(i5, u4);
            }
            for (let n4 = 0; n4 < this._nodes.length; n4++) {
              let s4 = this._nodes[n4], i5 = t4.nodes(n4);
              if (i5 == null)
                throw new Error(`No node exists at index ${n4}`);
              if (i5?.outputsLength() === 0)
                throw new Error(`missing output for node: ${i5.name}`);
              for (let u4 = 0; u4 < i5?.outputsLength(); u4++) {
                let l4 = i5?.outputs(u4), f3 = o4.get(l4);
                if (typeof f3 > "u" && (f3 = this._allData.push(new Rt()) - 1, o4.set(l4, f3)), s4.outputs.push(f3), this._allData[f3]._from !== void 0)
                  throw new Error(`multiple nodes output to one data value: ${f3}`);
                if (this._allData[f3]._from = n4, i5.opType() === "Constant") {
                  if (i5.attributesLength() !== 1 || !i5.attributes(0).t())
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (i5.outputsLength() !== 1)
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  s4.outputs.pop(), s4.executeNode = false, this._allData[f3]._from = -1, this._allData[f3].tensor = Ce.fromOrtTensor(i5.attributes(0).t());
                }
              }
            }
            for (let n4 = 0; n4 < this._nodes.length; n4++) {
              let s4 = this._nodes[n4], i5 = t4.nodes(n4);
              if (i5.inputsLength() === 0)
                throw new Error(`missing input for node: ${i5.name}`);
              for (let u4 = 0; u4 < i5.inputsLength(); u4++) {
                let l4 = i5.inputs(u4), f3 = o4.get(l4);
                if (typeof f3 > "u")
                  throw new Error(`unrecognized input '${l4}' for node: ${i5.name()}`);
                s4.inputs.push(f3), this._allData[f3]._to.push(n4);
              }
            }
          }
          checkIsAcyclic() {
            let t4 = /* @__PURE__ */ new Set();
            this._allInputIndices.forEach((r4) => {
              this._allData[r4]._to.forEach((s4) => {
                t4.add(s4);
              });
            });
            let o4 = Array.from(t4), e4 = new Array(this._nodes.length).fill("white");
            for (; o4.length > 0; ) {
              let r4 = o4.pop();
              e4[r4] === "gray" ? e4[r4] = "black" : (o4.push(r4), e4[r4] = "gray", this._nodes[r4].outputs.forEach((n4) => {
                let s4 = this._allData[n4];
                if (typeof s4.tensor < "u")
                  throw new Error("node outputs should not be initialized");
                if (s4._from !== r4)
                  throw new Error("from property of the Value object doesn't match index of Node being processed");
                s4._to.forEach((i5) => {
                  if (e4[i5] === "gray")
                    throw new Error("model graph is cyclic");
                  e4[i5] === "white" && o4.push(i5);
                });
              }));
            }
          }
          transformGraph(t4) {
            this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t4 && t4.transformGraph(this), this.finalizeGraph();
          }
          finalizeGraph() {
            let t4 = 0, o4 = new Array(this._nodes.length, 0), e4 = 0;
            for (let r4 = 0; r4 < this._nodes.length; r4++)
              o4[r4] = e4, this._nodes[r4].executeNode ? (e4 !== r4 && (this._nodes[e4] = this._nodes[r4]), e4++) : this._nodes[r4].outputs.forEach((n4) => {
                this._allData[n4]._from = -2;
              });
            this._nodes.splice(e4, this._nodes.length - e4);
            for (let r4 = 0; r4 < this._allData.length; r4++) {
              let n4 = this._allData[r4];
              n4._from !== void 0 && n4._from !== -1 && n4._from !== -2 && (n4._from = o4[n4._from]);
              for (let s4 = 0; s4 < n4._to.length; s4++)
                if (n4._to[s4] >= 0)
                  n4._to[s4] = o4[n4._to[s4]];
                else
                  throw new Error("Trying to update a removed node");
            }
            t4 = 0;
            for (let r4 = 0; r4 < this._allData.length; r4++) {
              if (this._allData[r4].from === -2 && this._allOutputIndices.indexOf(r4 + t4) === -1) {
                t4++, this._allData.splice(r4, 1), r4--;
                continue;
              }
              if (t4 > 0) {
                let n4 = -1;
                this._allData[r4].from !== void 0 && this._allData[r4].from !== -1 ? (n4 = this._nodes[this._allData[r4].from].outputs.indexOf(r4 + t4), n4 !== -1 && (this._nodes[this._allData[r4].from].outputs[n4] = r4)) : (n4 = this._allInputIndices.indexOf(r4 + t4), n4 !== -1 && (this._allInputIndices[n4] = r4)), this._allData[r4].to.forEach((s4) => {
                  n4 = this._nodes[s4].inputs.indexOf(r4 + t4), n4 !== -1 && (this._nodes[s4].inputs[n4] = r4);
                }), this._allData[r4].to.length === 0 && (n4 = this._allOutputIndices.indexOf(r4 + t4), n4 !== -1 && (this._allOutputIndices[n4] = r4));
              }
            }
          }
          deleteNode(t4) {
            let o4 = this._nodes[t4];
            if (o4.outputs.length > 1) {
              for (let i5 = 1; i5 < o4.outputs.length; i5++)
                if (this._allData[o4.outputs[i5]].to.length > 0)
                  throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
            }
            o4.executeNode = false;
            let e4 = o4.inputs[0], r4 = o4.outputs[0], n4 = this._allData[r4].to;
            for (let i5 = 0; i5 < o4.inputs.length; i5++) {
              let u4 = this._allData[o4.inputs[i5]].to.indexOf(t4);
              if (u4 === -1)
                throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[o4.inputs[i5]].to.splice(u4, 1);
            }
            this._allData[r4]._to = [];
            let s4 = this._allOutputIndices.indexOf(r4);
            if (s4 !== -1 && (this._allOutputIndices[s4] = e4), n4 && n4.length > 0)
              for (let i5 of n4) {
                let u4 = this._nodes[i5].inputs.indexOf(r4);
                if (u4 === -1)
                  throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                this._nodes[i5].inputs[u4] = e4, this._allData[e4].to.push(i5);
              }
          }
          removeAllDropoutNodes() {
            let t4 = 0;
            for (let o4 of this._nodes) {
              if (o4.opType === "Dropout") {
                if (o4.inputs.length !== 1)
                  throw new Error("Dropout nodes should only contain one input. ");
                if (o4.outputs.length !== 1 && o4.outputs.length !== 2)
                  throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                if (o4.outputs.length === 2 && this._allData[o4.outputs[1]]._to.length !== 0)
                  throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                this.deleteNode(t4);
              }
              t4++;
            }
          }
          removeAllIdentityNodes() {
            let t4 = 0;
            for (let o4 of this._nodes)
              o4.opType === "Identity" && this.deleteNode(t4), t4++;
          }
          isActivation(t4) {
            switch (t4.opType) {
              case "Relu":
              case "Sigmoid":
              case "Clip":
                return true;
              default:
                return false;
            }
          }
          fuseConvActivationNodes() {
            for (let t4 of this._nodes)
              if (t4.opType === "Conv") {
                let o4 = this._allData[t4.outputs[0]]._to;
                if (o4.length === 1 && this.isActivation(this._nodes[o4[0]])) {
                  let e4 = this._nodes[o4[0]];
                  if (e4.opType === "Clip")
                    if (e4.inputs.length === 1)
                      try {
                        t4.attributes.set("activation_params", "floats", [e4.attributes.getFloat("min"), e4.attributes.getFloat("max")]);
                      } catch {
                        t4.attributes.set("activation_params", "floats", [br, gr]);
                      }
                    else if (e4.inputs.length >= 3 && this._allData[e4.inputs[1]].tensor !== void 0 && this._allData[e4.inputs[2]].tensor !== void 0)
                      t4.attributes.set("activation_params", "floats", [this._allData[e4.inputs[1]].tensor.floatData[0], this._allData[e4.inputs[2]].tensor.floatData[0]]);
                    else
                      continue;
                  t4.attributes.set("activation", "string", e4.opType), this.deleteNode(o4[0]);
                }
              }
          }
        };
      });
      var _p;
      var tg;
      var Io;
      var Op = E(() => {
        "use strict";
        Wn();
        vp();
        nn();
        _p = Dr($r());
        fe();
        tg = W.experimental.fbs, Io = class {
          constructor() {
          }
          load(t4, o4, e4) {
            if (!e4)
              try {
                this.loadFromOnnxFormat(t4, o4);
                return;
              } catch (r4) {
                if (e4 !== void 0)
                  throw r4;
              }
            this.loadFromOrtFormat(t4, o4);
          }
          loadFromOnnxFormat(t4, o4) {
            let e4 = _p.onnx.ModelProto.decode(t4);
            if (nt.longToNumber(e4.irVersion) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = e4.opsetImport.map((n4) => ({ domain: n4.domain, version: nt.longToNumber(n4.version) })), this._graph = Qi.from(e4.graph, o4);
          }
          loadFromOrtFormat(t4, o4) {
            let e4 = new O.ByteBuffer(t4), r4 = tg.InferenceSession.getRootAsInferenceSession(e4).model();
            if (nt.longToNumber(r4.irVersion()) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = [];
            for (let s4 = 0; s4 < r4.opsetImportLength(); s4++) {
              let i5 = r4.opsetImport(s4);
              this._opsets.push({ domain: i5?.domain(), version: nt.longToNumber(i5.version()) });
            }
            this._graph = Qi.from(r4.graph(), o4);
          }
          get graph() {
            return this._graph;
          }
          get opsets() {
            return this._opsets;
          }
        };
      });
      var So;
      var Ip = E(() => {
        "use strict";
        Tp();
        xp();
        at();
        Op();
        So = class {
          constructor(t4 = {}) {
            this._initialized = false, this.backendHint = t4.backendHint, this.profiler = zn.create(t4.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
          }
          get inputNames() {
            return this._model.graph.getInputNames();
          }
          get outputNames() {
            return this._model.graph.getOutputNames();
          }
          startProfiling() {
            this.profiler.start();
          }
          endProfiling() {
            this.profiler.stop();
          }
          async loadModel(t4, o4, e4) {
            await this.profiler.event("session", "Session.loadModel", async () => {
              let r4 = await Xi(this.backendHint);
              if (this.sessionHandler = r4.createSessionHandler(this.context), this._model = new Io(), typeof t4 == "string") {
                let n4 = t4.endsWith(".ort");
                if (typeof process < "u" && process.versions && process.versions.node) {
                  let s4 = await (void 0)(t4);
                  this.initialize(s4, n4);
                } else {
                  let i5 = await (await fetch(t4)).arrayBuffer();
                  this.initialize(new Uint8Array(i5), n4);
                }
              } else if (ArrayBuffer.isView(t4))
                this.initialize(t4);
              else {
                let n4 = new Uint8Array(t4, o4 || 0, e4 || t4.byteLength);
                this.initialize(n4);
              }
            });
          }
          initialize(t4, o4) {
            if (this._initialized)
              throw new Error("already initialized");
            this.profiler.event("session", "Session.initialize", () => {
              let e4 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
              this._model.load(t4, e4, o4), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new vo(this._model.graph, this._ops, this.profiler);
            }), this._initialized = true;
          }
          async run(t4) {
            if (!this._initialized)
              throw new Error("session not initialized yet");
            return this.profiler.event("session", "Session.run", async () => {
              let o4 = this.normalizeAndValidateInputs(t4), e4 = await this._executionPlan.execute(this.sessionHandler, o4);
              return this.createOutput(e4);
            });
          }
          normalizeAndValidateInputs(t4) {
            let o4 = this._model.graph.getInputNames();
            if (Array.isArray(t4)) {
              if (t4.length !== o4.length)
                throw new Error(`incorrect input array length: expected ${o4.length} but got ${t4.length}`);
            } else {
              if (t4.size !== o4.length)
                throw new Error(`incorrect input map size: expected ${o4.length} but got ${t4.size}`);
              let e4 = new Array(t4.size), r4 = 0;
              for (let n4 = 0; n4 < o4.length; ++n4) {
                let s4 = t4.get(o4[n4]);
                if (!s4)
                  throw new Error(`missing input tensor for: '${name}'`);
                e4[r4++] = s4;
              }
              t4 = e4;
            }
            if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {
              let e4 = this._model.graph.getInputIndices(), r4 = this._model.graph.getValues(), n4 = new Array(e4.length);
              for (let s4 = 0; s4 < e4.length; ++s4) {
                let i5 = r4[e4[s4]];
                n4[s4] = i5.type.shape.dims, this.context.graphInputTypes.push(i5.type.tensorType), this.context.graphInputDims.push(t4[s4].dims);
              }
              this.validateInputTensorDims(n4, t4, true);
            } else
              this.validateInputTensorDims(this.context.graphInputDims, t4, false);
            return this.validateInputTensorTypes(this.context.graphInputTypes, t4), t4;
          }
          validateInputTensorTypes(t4, o4) {
            for (let e4 = 0; e4 < o4.length; e4++) {
              let r4 = t4[e4], n4 = o4[e4].type;
              if (r4 !== n4)
                throw new Error(`input tensor[${e4}] check failed: expected type '${r4}' but got ${n4}`);
            }
          }
          validateInputTensorDims(t4, o4, e4) {
            for (let r4 = 0; r4 < o4.length; r4++) {
              let n4 = t4[r4], s4 = o4[r4].dims;
              if (!this.compareTensorDims(n4, s4, e4))
                throw new Error(`input tensor[${r4}] check failed: expected shape '[${n4.join(",")}]' but got [${s4.join(",")}]`);
            }
          }
          compareTensorDims(t4, o4, e4) {
            if (t4.length !== o4.length)
              return false;
            for (let r4 = 0; r4 < t4.length; ++r4)
              if (t4[r4] !== o4[r4] && (!e4 || t4[r4] !== 0))
                return false;
            return true;
          }
          createOutput(t4) {
            let o4 = this._model.graph.getOutputNames();
            if (t4.length !== o4.length)
              throw new Error("expected number of outputs do not match number of generated outputs");
            let e4 = /* @__PURE__ */ new Map();
            for (let r4 = 0; r4 < o4.length; ++r4)
              e4.set(o4[r4], t4[r4]);
            return e4;
          }
          initializeOps(t4) {
            let o4 = t4.getNodes();
            this._ops = new Array(o4.length);
            for (let e4 = 0; e4 < o4.length; e4++)
              this._ops[e4] = this.sessionHandler.resolve(o4[e4], this._model.opsets, t4);
          }
        };
      });
      var Ao;
      var Sp = E(() => {
        "use strict";
        Tt();
        yr();
        Ao = class {
          constructor(t4) {
            this.session = t4;
            this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
          }
          async dispose() {
          }
          async run(t4, o4, e4) {
            let r4 = /* @__PURE__ */ new Map();
            for (let i5 in t4)
              if (Object.hasOwnProperty.call(t4, i5)) {
                let u4 = t4[i5];
                r4.set(i5, new Ce(u4.dims, u4.type, void 0, void 0, u4.data));
              }
            let n4 = await this.session.run(r4), s4 = {};
            return n4.forEach((i5, u4) => {
              s4[u4] = new Be(i5.type, i5.data, i5.dims);
            }), s4;
          }
          startProfiling() {
            this.session.startProfiling();
          }
          endProfiling() {
            this.session.endProfiling();
          }
        };
      });
      var Ap = {};
      sr(Ap, { onnxjsBackend: () => ng });
      var ea;
      var ng;
      var Pp = E(() => {
        "use strict";
        Ip();
        Sp();
        ea = class {
          async init() {
          }
          async createInferenceSessionHandler(t4, o4) {
            let e4 = new So(o4);
            return typeof t4 == "string" ? await e4.loadModel(t4) : await e4.loadModel(t4), new Ao(e4);
          }
        }, ng = new ea();
      });
      var ta = {};
      sr(ta, { createReadStream: () => Ep, readFile: () => og, readFileSync: () => ig });
      var og;
      var ig;
      var Ep;
      var ra = E(() => {
        og = void 0, ig = void 0, Ep = void 0;
      });
      var na = {};
      sr(na, { join: () => ag });
      var ag;
      var oa = E(() => {
        ag = void 0;
      });
      var Fp = me((Lp, ia2) => {
        "use strict";
        var Dp = (() => {
          var a4 = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
          return typeof __filename < "u" && (a4 = a4 || __filename), function(t4 = {}) {
            var o4 = t4, e4, r4;
            o4.ready = new Promise((b3, x4) => {
              e4 = b3, r4 = x4;
            });
            var n4 = Object.assign({}, o4), s4 = "./this.program", i5 = typeof window == "object", u4 = typeof importScripts == "function", l4 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", f3 = "", p4, d4, T3;
            if (l4) {
              var v5 = (ra(), jt(ta)), w3 = (oa(), jt(na));
              f3 = u4 ? w3.dirname(f3) + "/" : __dirname + "/", p4 = (b3, x4) => (b3 = St4(b3) ? new URL(b3) : w3.normalize(b3), v5.readFileSync(b3, x4 ? void 0 : "utf8")), T3 = (b3) => (b3 = p4(b3, true), b3.buffer || (b3 = new Uint8Array(b3)), b3), d4 = (b3, x4, _4, D3 = true) => {
                b3 = St4(b3) ? new URL(b3) : w3.normalize(b3), v5.readFile(b3, D3 ? void 0 : "utf8", (G4, X4) => {
                  G4 ? _4(G4) : x4(D3 ? X4.buffer : X4);
                });
              }, !o4.thisProgram && 1 < process.argv.length && (s4 = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), o4.inspect = () => "[Emscripten Module object]";
            } else
              (i5 || u4) && (u4 ? f3 = self.location.href : typeof document < "u" && document.currentScript && (f3 = document.currentScript.src), a4 && (f3 = a4), f3.indexOf("blob:") !== 0 ? f3 = f3.substr(0, f3.replace(/[?#].*/, "").lastIndexOf("/") + 1) : f3 = "", p4 = (b3) => {
                var x4 = new XMLHttpRequest();
                return x4.open("GET", b3, false), x4.send(null), x4.responseText;
              }, u4 && (T3 = (b3) => {
                var x4 = new XMLHttpRequest();
                return x4.open("GET", b3, false), x4.responseType = "arraybuffer", x4.send(null), new Uint8Array(x4.response);
              }), d4 = (b3, x4, _4) => {
                var D3 = new XMLHttpRequest();
                D3.open("GET", b3, true), D3.responseType = "arraybuffer", D3.onload = () => {
                  D3.status == 200 || D3.status == 0 && D3.response ? x4(D3.response) : _4();
                }, D3.onerror = _4, D3.send(null);
              });
            var I3 = console.log.bind(console), L3 = console.error.bind(console);
            Object.assign(o4, n4), n4 = null, typeof WebAssembly != "object" && te3("no native wasm support detected");
            var F4, C3 = false, Y5, j4, M4, ie3, ot4;
            function We3() {
              var b3 = F4.buffer;
              o4.HEAP8 = Y5 = new Int8Array(b3), o4.HEAP16 = new Int16Array(b3), o4.HEAPU8 = j4 = new Uint8Array(b3), o4.HEAPU16 = new Uint16Array(b3), o4.HEAP32 = M4 = new Int32Array(b3), o4.HEAPU32 = ie3 = new Uint32Array(b3), o4.HEAPF32 = new Float32Array(b3), o4.HEAPF64 = ot4 = new Float64Array(b3);
            }
            var Fe5 = [], V4 = [], Ae3 = [], It3 = 0, mt3 = null, Ne3 = null;
            function te3(b3) {
              throw b3 = "Aborted(" + b3 + ")", L3(b3), C3 = true, b3 = new WebAssembly.RuntimeError(b3 + ". Build with -sASSERTIONS for more info."), r4(b3), b3;
            }
            var bt4 = (b3) => b3.startsWith("data:application/octet-stream;base64,"), St4 = (b3) => b3.startsWith("file://"), He3;
            if (He3 = "ort-wasm.wasm", !bt4(He3)) {
              var At4 = He3;
              He3 = o4.locateFile ? o4.locateFile(At4, f3) : f3 + At4;
            }
            function we5(b3) {
              if (T3)
                return T3(b3);
              throw "both async and sync fetching of the wasm failed";
            }
            function Ze3(b3) {
              if (i5 || u4) {
                if (typeof fetch == "function" && !St4(b3))
                  return fetch(b3, { credentials: "same-origin" }).then((x4) => {
                    if (!x4.ok)
                      throw "failed to load wasm binary file at '" + b3 + "'";
                    return x4.arrayBuffer();
                  }).catch(() => we5(b3));
                if (d4)
                  return new Promise((x4, _4) => {
                    d4(b3, (D3) => x4(new Uint8Array(D3)), _4);
                  });
              }
              return Promise.resolve().then(() => we5(b3));
            }
            function rr4(b3, x4, _4) {
              return Ze3(b3).then((D3) => WebAssembly.instantiate(D3, x4)).then((D3) => D3).then(_4, (D3) => {
                L3(`failed to asynchronously prepare wasm: ${D3}`), te3(D3);
              });
            }
            function Pt4(b3, x4) {
              var _4 = He3;
              return typeof WebAssembly.instantiateStreaming != "function" || bt4(_4) || St4(_4) || l4 || typeof fetch != "function" ? rr4(_4, b3, x4) : fetch(_4, { credentials: "same-origin" }).then((D3) => WebAssembly.instantiateStreaming(D3, b3).then(x4, function(G4) {
                return L3(`wasm streaming compile failed: ${G4}`), L3("falling back to ArrayBuffer instantiation"), rr4(_4, b3, x4);
              }));
            }
            var gt4, yt3 = { 920016: (b3, x4, _4, D3) => {
              if (typeof o4 > "u" || !o4.za)
                return 1;
              if (b3 = ve4(b3 >>> 0), b3.startsWith("./") && (b3 = b3.substring(2)), b3 = o4.za.get(b3), !b3)
                return 2;
              if (x4 >>>= 0, _4 >>>= 0, x4 + _4 > b3.byteLength)
                return 3;
              try {
                return j4.set(b3.subarray(x4, x4 + _4), D3 >>> 0 >>> 0), 0;
              } catch {
                return 4;
              }
            } };
            function nr4(b3) {
              this.xa = b3 - 24, this.Ha = function(x4) {
                ie3[this.xa + 4 >>> 2 >>> 0] = x4;
              }, this.Ga = function(x4) {
                ie3[this.xa + 8 >>> 2 >>> 0] = x4;
              }, this.Aa = function(x4, _4) {
                this.Fa(), this.Ha(x4), this.Ga(_4);
              }, this.Fa = function() {
                ie3[this.xa + 16 >>> 2 >>> 0] = 0;
              };
            }
            var Qe3 = 0, Et4 = 0, Mt3 = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, $e4 = (b3, x4, _4) => {
              x4 >>>= 0;
              var D3 = x4 + _4;
              for (_4 = x4; b3[_4] && !(_4 >= D3); )
                ++_4;
              if (16 < _4 - x4 && b3.buffer && Mt3)
                return Mt3.decode(b3.subarray(x4, _4));
              for (D3 = ""; x4 < _4; ) {
                var G4 = b3[x4++];
                if (G4 & 128) {
                  var X4 = b3[x4++] & 63;
                  if ((G4 & 224) == 192)
                    D3 += String.fromCharCode((G4 & 31) << 6 | X4);
                  else {
                    var ne4 = b3[x4++] & 63;
                    G4 = (G4 & 240) == 224 ? (G4 & 15) << 12 | X4 << 6 | ne4 : (G4 & 7) << 18 | X4 << 12 | ne4 << 6 | b3[x4++] & 63, 65536 > G4 ? D3 += String.fromCharCode(G4) : (G4 -= 65536, D3 += String.fromCharCode(55296 | G4 >> 10, 56320 | G4 & 1023));
                  }
                } else
                  D3 += String.fromCharCode(G4);
              }
              return D3;
            }, ve4 = (b3, x4) => (b3 >>>= 0) ? $e4(j4, b3, x4) : "", qe3 = (b3) => {
              for (var x4 = 0, _4 = 0; _4 < b3.length; ++_4) {
                var D3 = b3.charCodeAt(_4);
                127 >= D3 ? x4++ : 2047 >= D3 ? x4 += 2 : 55296 <= D3 && 57343 >= D3 ? (x4 += 4, ++_4) : x4 += 3;
              }
              return x4;
            }, Gt3 = (b3, x4, _4, D3) => {
              if (_4 >>>= 0, !(0 < D3))
                return 0;
              var G4 = _4;
              D3 = _4 + D3 - 1;
              for (var X4 = 0; X4 < b3.length; ++X4) {
                var ne4 = b3.charCodeAt(X4);
                if (55296 <= ne4 && 57343 >= ne4) {
                  var ke5 = b3.charCodeAt(++X4);
                  ne4 = 65536 + ((ne4 & 1023) << 10) | ke5 & 1023;
                }
                if (127 >= ne4) {
                  if (_4 >= D3)
                    break;
                  x4[_4++ >>> 0] = ne4;
                } else {
                  if (2047 >= ne4) {
                    if (_4 + 1 >= D3)
                      break;
                    x4[_4++ >>> 0] = 192 | ne4 >> 6;
                  } else {
                    if (65535 >= ne4) {
                      if (_4 + 2 >= D3)
                        break;
                      x4[_4++ >>> 0] = 224 | ne4 >> 12;
                    } else {
                      if (_4 + 3 >= D3)
                        break;
                      x4[_4++ >>> 0] = 240 | ne4 >> 18, x4[_4++ >>> 0] = 128 | ne4 >> 12 & 63;
                    }
                    x4[_4++ >>> 0] = 128 | ne4 >> 6 & 63;
                  }
                  x4[_4++ >>> 0] = 128 | ne4 & 63;
                }
              }
              return x4[_4 >>> 0] = 0, _4 - G4;
            }, Dt3 = (b3) => b3 % 4 === 0 && (b3 % 100 !== 0 || b3 % 400 === 0), jr3 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], wn3 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Ut4 = (b3) => {
              var x4 = qe3(b3) + 1, _4 = _n3(x4);
              return _4 && Gt3(b3, j4, _4, x4), _4;
            }, Or3 = [], qt3 = {}, Ir4 = () => {
              if (!Sr3) {
                var b3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: s4 || "./this.program" }, x4;
                for (x4 in qt3)
                  qt3[x4] === void 0 ? delete b3[x4] : b3[x4] = qt3[x4];
                var _4 = [];
                for (x4 in b3)
                  _4.push(`${x4}=${b3[x4]}`);
                Sr3 = _4;
              }
              return Sr3;
            }, Sr3, or4 = [null, [], []], Yr3 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Xr3 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function Ar3(b3) {
              var x4 = Array(qe3(b3) + 1);
              return Gt3(b3, x4, 0, x4.length), x4;
            }
            function vn3(b3, x4, _4, D3) {
              function G4(A3, pe3, Te4) {
                for (A3 = typeof A3 == "number" ? A3.toString() : A3 || ""; A3.length < pe3; )
                  A3 = Te4[0] + A3;
                return A3;
              }
              function X4(A3, pe3) {
                return G4(A3, pe3, "0");
              }
              function ne4(A3, pe3) {
                function Te4(en3) {
                  return 0 > en3 ? -1 : 0 < en3 ? 1 : 0;
                }
                var Lt4;
                return (Lt4 = Te4(A3.getFullYear() - pe3.getFullYear())) === 0 && (Lt4 = Te4(A3.getMonth() - pe3.getMonth())) === 0 && (Lt4 = Te4(A3.getDate() - pe3.getDate())), Lt4;
              }
              function ke5(A3) {
                switch (A3.getDay()) {
                  case 0:
                    return new Date(A3.getFullYear() - 1, 11, 29);
                  case 1:
                    return A3;
                  case 2:
                    return new Date(A3.getFullYear(), 0, 3);
                  case 3:
                    return new Date(A3.getFullYear(), 0, 2);
                  case 4:
                    return new Date(A3.getFullYear(), 0, 1);
                  case 5:
                    return new Date(A3.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(A3.getFullYear() - 1, 11, 30);
                }
              }
              function Ye3(A3) {
                var pe3 = A3.ta;
                for (A3 = new Date(new Date(A3.ua + 1900, 0, 1).getTime()); 0 < pe3; ) {
                  var Te4 = A3.getMonth(), Lt4 = (Dt3(A3.getFullYear()) ? Yr3 : Xr3)[Te4];
                  if (pe3 > Lt4 - A3.getDate())
                    pe3 -= Lt4 - A3.getDate() + 1, A3.setDate(1), 11 > Te4 ? A3.setMonth(Te4 + 1) : (A3.setMonth(0), A3.setFullYear(A3.getFullYear() + 1));
                  else {
                    A3.setDate(A3.getDate() + pe3);
                    break;
                  }
                }
                return Te4 = new Date(A3.getFullYear() + 1, 0, 4), pe3 = ke5(new Date(A3.getFullYear(), 0, 4)), Te4 = ke5(Te4), 0 >= ne4(pe3, A3) ? 0 >= ne4(Te4, A3) ? A3.getFullYear() + 1 : A3.getFullYear() : A3.getFullYear() - 1;
              }
              b3 >>>= 0, x4 >>>= 0, _4 >>>= 0, D3 >>>= 0;
              var Ue3 = ie3[D3 + 40 >>> 2 >>> 0];
              D3 = { Da: M4[D3 >>> 2 >>> 0], Ca: M4[D3 + 4 >>> 2 >>> 0], va: M4[D3 + 8 >>> 2 >>> 0], ya: M4[D3 + 12 >>> 2 >>> 0], wa: M4[D3 + 16 >>> 2 >>> 0], ua: M4[D3 + 20 >>> 2 >>> 0], oa: M4[D3 + 24 >>> 2 >>> 0], ta: M4[D3 + 28 >>> 2 >>> 0], Ia: M4[D3 + 32 >>> 2 >>> 0], Ba: M4[D3 + 36 >>> 2 >>> 0], Ea: Ue3 ? ve4(Ue3) : "" }, _4 = ve4(_4), Ue3 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
              for (var ze3 in Ue3)
                _4 = _4.replace(new RegExp(ze3, "g"), Ue3[ze3]);
              var Zr3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), Qr3 = "January February March April May June July August September October November December".split(" ");
              Ue3 = { "%a": (A3) => Zr3[A3.oa].substring(0, 3), "%A": (A3) => Zr3[A3.oa], "%b": (A3) => Qr3[A3.wa].substring(0, 3), "%B": (A3) => Qr3[A3.wa], "%C": (A3) => X4((A3.ua + 1900) / 100 | 0, 2), "%d": (A3) => X4(A3.ya, 2), "%e": (A3) => G4(A3.ya, 2, " "), "%g": (A3) => Ye3(A3).toString().substring(2), "%G": (A3) => Ye3(A3), "%H": (A3) => X4(A3.va, 2), "%I": (A3) => (A3 = A3.va, A3 == 0 ? A3 = 12 : 12 < A3 && (A3 -= 12), X4(A3, 2)), "%j": (A3) => {
                for (var pe3 = 0, Te4 = 0; Te4 <= A3.wa - 1; pe3 += (Dt3(A3.ua + 1900) ? Yr3 : Xr3)[Te4++])
                  ;
                return X4(A3.ya + pe3, 3);
              }, "%m": (A3) => X4(A3.wa + 1, 2), "%M": (A3) => X4(A3.Ca, 2), "%n": () => `
`, "%p": (A3) => 0 <= A3.va && 12 > A3.va ? "AM" : "PM", "%S": (A3) => X4(A3.Da, 2), "%t": () => "	", "%u": (A3) => A3.oa || 7, "%U": (A3) => X4(Math.floor((A3.ta + 7 - A3.oa) / 7), 2), "%V": (A3) => {
                var pe3 = Math.floor((A3.ta + 7 - (A3.oa + 6) % 7) / 7);
                if (2 >= (A3.oa + 371 - A3.ta - 2) % 7 && pe3++, pe3)
                  pe3 == 53 && (Te4 = (A3.oa + 371 - A3.ta) % 7, Te4 == 4 || Te4 == 3 && Dt3(A3.ua) || (pe3 = 1));
                else {
                  pe3 = 52;
                  var Te4 = (A3.oa + 7 - A3.ta - 1) % 7;
                  (Te4 == 4 || Te4 == 5 && Dt3(A3.ua % 400 - 1)) && pe3++;
                }
                return X4(pe3, 2);
              }, "%w": (A3) => A3.oa, "%W": (A3) => X4(Math.floor((A3.ta + 7 - (A3.oa + 6) % 7) / 7), 2), "%y": (A3) => (A3.ua + 1900).toString().substring(2), "%Y": (A3) => A3.ua + 1900, "%z": (A3) => {
                A3 = A3.Ba;
                var pe3 = 0 <= A3;
                return A3 = Math.abs(A3) / 60, (pe3 ? "+" : "-") + ("0000" + (A3 / 60 * 100 + A3 % 60)).slice(-4);
              }, "%Z": (A3) => A3.Ea, "%%": () => "%" }, _4 = _4.replace(/%%/g, "\0\0");
              for (ze3 in Ue3)
                _4.includes(ze3) && (_4 = _4.replace(new RegExp(ze3, "g"), Ue3[ze3](D3)));
              return _4 = _4.replace(/\0\0/g, "%"), ze3 = Ar3(_4), ze3.length > x4 ? 0 : (Y5.set(ze3, b3 >>> 0), ze3.length - 1);
            }
            var he3 = { a: function(b3, x4, _4) {
              throw b3 >>>= 0, new nr4(b3).Aa(x4 >>> 0, _4 >>> 0), Qe3 = b3, Et4++, Qe3;
            }, e: function() {
              return 0;
            }, H: function() {
            }, x: function() {
            }, z: function() {
            }, J: function() {
              return 0;
            }, F: function() {
            }, A: function() {
            }, E: function() {
            }, g: function() {
            }, y: function() {
            }, v: function() {
            }, G: function() {
            }, w: function() {
            }, k: () => 1, n: function(b3, x4, _4) {
              b3 = x4 + 2097152 >>> 0 < 4194305 - !!b3 ? (b3 >>> 0) + 4294967296 * x4 : NaN, _4 >>>= 0, b3 = new Date(1e3 * b3), M4[_4 >>> 2 >>> 0] = b3.getUTCSeconds(), M4[_4 + 4 >>> 2 >>> 0] = b3.getUTCMinutes(), M4[_4 + 8 >>> 2 >>> 0] = b3.getUTCHours(), M4[_4 + 12 >>> 2 >>> 0] = b3.getUTCDate(), M4[_4 + 16 >>> 2 >>> 0] = b3.getUTCMonth(), M4[_4 + 20 >>> 2 >>> 0] = b3.getUTCFullYear() - 1900, M4[_4 + 24 >>> 2 >>> 0] = b3.getUTCDay(), M4[_4 + 28 >>> 2 >>> 0] = (b3.getTime() - Date.UTC(b3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
            }, o: function(b3, x4, _4) {
              b3 = x4 + 2097152 >>> 0 < 4194305 - !!b3 ? (b3 >>> 0) + 4294967296 * x4 : NaN, _4 >>>= 0, b3 = new Date(1e3 * b3), M4[_4 >>> 2 >>> 0] = b3.getSeconds(), M4[_4 + 4 >>> 2 >>> 0] = b3.getMinutes(), M4[_4 + 8 >>> 2 >>> 0] = b3.getHours(), M4[_4 + 12 >>> 2 >>> 0] = b3.getDate(), M4[_4 + 16 >>> 2 >>> 0] = b3.getMonth(), M4[_4 + 20 >>> 2 >>> 0] = b3.getFullYear() - 1900, M4[_4 + 24 >>> 2 >>> 0] = b3.getDay(), M4[_4 + 28 >>> 2 >>> 0] = (Dt3(b3.getFullYear()) ? jr3 : wn3)[b3.getMonth()] + b3.getDate() - 1 | 0, M4[_4 + 36 >>> 2 >>> 0] = -(60 * b3.getTimezoneOffset()), x4 = new Date(b3.getFullYear(), 6, 1).getTimezoneOffset();
              var D3 = new Date(b3.getFullYear(), 0, 1).getTimezoneOffset();
              M4[_4 + 32 >>> 2 >>> 0] = (x4 != D3 && b3.getTimezoneOffset() == Math.min(D3, x4)) | 0;
            }, p: function(b3) {
              b3 >>>= 0;
              var x4 = new Date(M4[b3 + 20 >>> 2 >>> 0] + 1900, M4[b3 + 16 >>> 2 >>> 0], M4[b3 + 12 >>> 2 >>> 0], M4[b3 + 8 >>> 2 >>> 0], M4[b3 + 4 >>> 2 >>> 0], M4[b3 >>> 2 >>> 0], 0), _4 = M4[b3 + 32 >>> 2 >>> 0], D3 = x4.getTimezoneOffset(), G4 = new Date(x4.getFullYear(), 6, 1).getTimezoneOffset(), X4 = new Date(x4.getFullYear(), 0, 1).getTimezoneOffset(), ne4 = Math.min(X4, G4);
              return 0 > _4 ? M4[b3 + 32 >>> 2 >>> 0] = +(G4 != X4 && ne4 == D3) : 0 < _4 != (ne4 == D3) && (G4 = Math.max(X4, G4), x4.setTime(x4.getTime() + 6e4 * ((0 < _4 ? ne4 : G4) - D3))), M4[b3 + 24 >>> 2 >>> 0] = x4.getDay(), M4[b3 + 28 >>> 2 >>> 0] = (Dt3(x4.getFullYear()) ? jr3 : wn3)[x4.getMonth()] + x4.getDate() - 1 | 0, M4[b3 >>> 2 >>> 0] = x4.getSeconds(), M4[b3 + 4 >>> 2 >>> 0] = x4.getMinutes(), M4[b3 + 8 >>> 2 >>> 0] = x4.getHours(), M4[b3 + 12 >>> 2 >>> 0] = x4.getDate(), M4[b3 + 16 >>> 2 >>> 0] = x4.getMonth(), M4[b3 + 20 >>> 2 >>> 0] = x4.getYear(), b3 = x4.getTime(), isNaN(b3) ? (M4[Pr3() >>> 2 >>> 0] = 61, b3 = -1) : b3 /= 1e3, Kr3((gt4 = b3, 1 <= +Math.abs(gt4) ? 0 < gt4 ? +Math.floor(gt4 / 4294967296) >>> 0 : ~~+Math.ceil((gt4 - +(~~gt4 >>> 0)) / 4294967296) >>> 0 : 0)), b3 >>> 0;
            }, l: function() {
              return -52;
            }, m: function() {
            }, t: function(b3, x4, _4) {
              function D3(Ye3) {
                return (Ye3 = Ye3.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? Ye3[1] : "GMT";
              }
              _4 >>>= 0;
              var G4 = (/* @__PURE__ */ new Date()).getFullYear(), X4 = new Date(G4, 0, 1), ne4 = new Date(G4, 6, 1);
              G4 = X4.getTimezoneOffset();
              var ke5 = ne4.getTimezoneOffset();
              ie3[b3 >>> 0 >>> 2 >>> 0] = 60 * Math.max(G4, ke5), M4[x4 >>> 0 >>> 2 >>> 0] = +(G4 != ke5), b3 = D3(X4), x4 = D3(ne4), b3 = Ut4(b3), x4 = Ut4(x4), ke5 < G4 ? (ie3[_4 >>> 2 >>> 0] = b3, ie3[_4 + 4 >>> 2 >>> 0] = x4) : (ie3[_4 >>> 2 >>> 0] = x4, ie3[_4 + 4 >>> 2 >>> 0] = b3);
            }, d: () => {
              te3("");
            }, B: function(b3, x4, _4) {
              b3 >>>= 0, x4 >>>= 0, _4 >>>= 0, Or3.length = 0;
              for (var D3; D3 = j4[x4++ >>> 0]; ) {
                var G4 = D3 != 105;
                G4 &= D3 != 112, _4 += G4 && _4 % 8 ? 4 : 0, Or3.push(D3 == 112 ? ie3[_4 >>> 2 >>> 0] : D3 == 105 ? M4[_4 >>> 2 >>> 0] : ot4[_4 >>> 3 >>> 0]), _4 += G4 ? 8 : 4;
              }
              return yt3[b3].apply(null, Or3);
            }, h: () => Date.now(), u: function() {
              return 4294901760;
            }, b: () => performance.now(), I: function(b3, x4, _4) {
              return x4 >>>= 0, j4.copyWithin(b3 >>> 0 >>> 0, x4 >>> 0, x4 + (_4 >>> 0) >>> 0);
            }, s: function(b3) {
              b3 >>>= 0;
              var x4 = j4.length;
              if (4294901760 < b3)
                return false;
              for (var _4 = 1; 4 >= _4; _4 *= 2) {
                var D3 = x4 * (1 + 0.2 / _4);
                D3 = Math.min(D3, b3 + 100663296);
                var G4 = Math;
                D3 = Math.max(b3, D3);
                e: {
                  G4 = (G4.min.call(G4, 4294901760, D3 + (65536 - D3 % 65536) % 65536) - F4.buffer.byteLength + 65535) / 65536;
                  try {
                    F4.grow(G4), We3();
                    var X4 = 1;
                    break e;
                  } catch {
                  }
                  X4 = void 0;
                }
                if (X4)
                  return true;
              }
              return false;
            }, C: function(b3, x4) {
              b3 >>>= 0, x4 >>>= 0;
              var _4 = 0;
              return Ir4().forEach((D3, G4) => {
                var X4 = x4 + _4;
                for (G4 = ie3[b3 + 4 * G4 >>> 2 >>> 0] = X4, X4 = 0; X4 < D3.length; ++X4)
                  Y5[G4++ >>> 0 >>> 0] = D3.charCodeAt(X4);
                Y5[G4 >>> 0 >>> 0] = 0, _4 += D3.length + 1;
              }), 0;
            }, D: function(b3, x4) {
              b3 >>>= 0, x4 >>>= 0;
              var _4 = Ir4();
              ie3[b3 >>> 2 >>> 0] = _4.length;
              var D3 = 0;
              return _4.forEach((G4) => D3 += G4.length + 1), ie3[x4 >>> 2 >>> 0] = D3, 0;
            }, f: () => 52, j: function() {
              return 52;
            }, q: function() {
              return 70;
            }, i: function(b3, x4, _4, D3) {
              x4 >>>= 0, _4 >>>= 0, D3 >>>= 0;
              for (var G4 = 0, X4 = 0; X4 < _4; X4++) {
                var ne4 = ie3[x4 >>> 2 >>> 0], ke5 = ie3[x4 + 4 >>> 2 >>> 0];
                x4 += 8;
                for (var Ye3 = 0; Ye3 < ke5; Ye3++) {
                  var Ue3 = j4[ne4 + Ye3 >>> 0], ze3 = or4[b3];
                  Ue3 === 0 || Ue3 === 10 ? ((b3 === 1 ? I3 : L3)($e4(ze3, 0)), ze3.length = 0) : ze3.push(Ue3);
                }
                G4 += ke5;
              }
              return ie3[D3 >>> 2 >>> 0] = G4, 0;
            }, r: vn3, c: function(b3, x4, _4, D3) {
              return vn3(b3 >>> 0, x4 >>> 0, _4 >>> 0, D3 >>> 0);
            } }, Q3 = function() {
              function b3(_4) {
                return Q3 = _4.exports, Q3 = In3(), F4 = Q3.K, We3(), V4.unshift(Q3.L), It3--, It3 == 0 && (mt3 !== null && (clearInterval(mt3), mt3 = null), Ne3 && (_4 = Ne3, Ne3 = null, _4())), Q3;
              }
              var x4 = { a: he3 };
              if (It3++, o4.instantiateWasm)
                try {
                  return o4.instantiateWasm(x4, b3);
                } catch (_4) {
                  L3(`Module.instantiateWasm callback failed with error: ${_4}`), r4(_4);
                }
              return Pt4(x4, function(_4) {
                b3(_4.instance);
              }).catch(r4), {};
            }();
            o4._OrtInit = (b3, x4) => (o4._OrtInit = Q3.M)(b3, x4), o4._OrtGetLastError = (b3, x4) => (o4._OrtGetLastError = Q3.N)(b3, x4), o4._OrtCreateSessionOptions = (b3, x4, _4, D3, G4, X4, ne4, ke5, Ye3, Ue3) => (o4._OrtCreateSessionOptions = Q3.O)(b3, x4, _4, D3, G4, X4, ne4, ke5, Ye3, Ue3), o4._OrtAppendExecutionProvider = (b3, x4) => (o4._OrtAppendExecutionProvider = Q3.P)(b3, x4), o4._OrtAddFreeDimensionOverride = (b3, x4, _4) => (o4._OrtAddFreeDimensionOverride = Q3.Q)(b3, x4, _4), o4._OrtAddSessionConfigEntry = (b3, x4, _4) => (o4._OrtAddSessionConfigEntry = Q3.R)(b3, x4, _4), o4._OrtReleaseSessionOptions = (b3) => (o4._OrtReleaseSessionOptions = Q3.S)(b3), o4._OrtCreateSession = (b3, x4, _4) => (o4._OrtCreateSession = Q3.T)(b3, x4, _4), o4._OrtReleaseSession = (b3) => (o4._OrtReleaseSession = Q3.U)(b3), o4._OrtGetInputOutputCount = (b3, x4, _4) => (o4._OrtGetInputOutputCount = Q3.V)(b3, x4, _4), o4._OrtGetInputName = (b3, x4) => (o4._OrtGetInputName = Q3.W)(b3, x4), o4._OrtGetOutputName = (b3, x4) => (o4._OrtGetOutputName = Q3.X)(b3, x4), o4._OrtFree = (b3) => (o4._OrtFree = Q3.Y)(b3), o4._OrtCreateTensor = (b3, x4, _4, D3, G4, X4) => (o4._OrtCreateTensor = Q3.Z)(b3, x4, _4, D3, G4, X4), o4._OrtGetTensorData = (b3, x4, _4, D3, G4) => (o4._OrtGetTensorData = Q3._)(b3, x4, _4, D3, G4), o4._OrtReleaseTensor = (b3) => (o4._OrtReleaseTensor = Q3.$)(b3), o4._OrtCreateRunOptions = (b3, x4, _4, D3) => (o4._OrtCreateRunOptions = Q3.aa)(b3, x4, _4, D3), o4._OrtAddRunConfigEntry = (b3, x4, _4) => (o4._OrtAddRunConfigEntry = Q3.ba)(b3, x4, _4), o4._OrtReleaseRunOptions = (b3) => (o4._OrtReleaseRunOptions = Q3.ca)(b3), o4._OrtCreateBinding = (b3) => (o4._OrtCreateBinding = Q3.da)(b3), o4._OrtBindInput = (b3, x4, _4) => (o4._OrtBindInput = Q3.ea)(b3, x4, _4), o4._OrtBindOutput = (b3, x4, _4, D3) => (o4._OrtBindOutput = Q3.fa)(b3, x4, _4, D3), o4._OrtClearBoundOutputs = (b3) => (o4._OrtClearBoundOutputs = Q3.ga)(b3), o4._OrtReleaseBinding = (b3) => (o4._OrtReleaseBinding = Q3.ha)(b3), o4._OrtRunWithBinding = (b3, x4, _4, D3, G4) => (o4._OrtRunWithBinding = Q3.ia)(b3, x4, _4, D3, G4), o4._OrtRun = (b3, x4, _4, D3, G4, X4, ne4, ke5) => (o4._OrtRun = Q3.ja)(b3, x4, _4, D3, G4, X4, ne4, ke5), o4._OrtEndProfiling = (b3) => (o4._OrtEndProfiling = Q3.ka)(b3);
            var Pr3 = () => (Pr3 = Q3.la)(), _n3 = o4._malloc = (b3) => (_n3 = o4._malloc = Q3.ma)(b3);
            o4._free = (b3) => (o4._free = Q3.na)(b3);
            var Kr3 = (b3) => (Kr3 = Q3.pa)(b3), On3 = () => (On3 = Q3.qa)(), J3 = (b3) => (J3 = Q3.ra)(b3), ir4 = (b3) => (ir4 = Q3.sa)(b3);
            function In3() {
              var b3 = Q3;
              b3 = Object.assign({}, b3);
              var x4 = (D3) => () => D3() >>> 0, _4 = (D3) => (G4) => D3(G4) >>> 0;
              return b3.la = x4(b3.la), b3.ma = _4(b3.ma), b3.qa = x4(b3.qa), b3.sa = _4(b3.sa), b3;
            }
            o4.stackAlloc = ir4, o4.stackSave = On3, o4.stackRestore = J3, o4.UTF8ToString = ve4, o4.stringToUTF8 = (b3, x4, _4) => Gt3(b3, j4, x4, _4), o4.lengthBytesUTF8 = qe3;
            var zt4;
            Ne3 = function b3() {
              zt4 || Jr4(), zt4 || (Ne3 = b3);
            };
            function Jr4() {
              if (!(0 < It3)) {
                if (o4.preRun)
                  for (typeof o4.preRun == "function" && (o4.preRun = [o4.preRun]); o4.preRun.length; ) {
                    var b3 = o4.preRun.shift();
                    Fe5.unshift(b3);
                  }
                for (; 0 < Fe5.length; )
                  Fe5.shift()(o4);
                if (!(0 < It3 || zt4 || (zt4 = true, o4.calledRun = true, C3))) {
                  for (; 0 < V4.length; )
                    V4.shift()(o4);
                  for (e4(o4); 0 < Ae3.length; )
                    Ae3.shift()(o4);
                }
              }
            }
            return Jr4(), t4.ready;
          };
        })();
        typeof Lp == "object" && typeof ia2 == "object" ? ia2.exports = Dp : typeof define == "function" && define.amd && define([], () => Dp);
      });
      var Cp = me(() => {
      });
      var $p = me(() => {
      });
      var kp = {};
      sr(kp, { cpus: () => sg });
      var sg;
      var Bp = E(() => {
        sg = void 0;
      });
      var Mp = me((Rp, aa2) => {
        "use strict";
        var Np = (() => {
          var a4 = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
          return typeof __filename < "u" && (a4 = a4 || __filename), function(t4 = {}) {
            function o4() {
              return Ae3.buffer != te3.buffer && we5(), te3;
            }
            function e4() {
              return Ae3.buffer != te3.buffer && we5(), bt4;
            }
            function r4() {
              return Ae3.buffer != te3.buffer && we5(), St4;
            }
            function n4() {
              return Ae3.buffer != te3.buffer && we5(), He3;
            }
            function s4() {
              return Ae3.buffer != te3.buffer && we5(), At4;
            }
            var i5 = t4, u4, l4;
            i5.ready = new Promise((c5, h4) => {
              u4 = c5, l4 = h4;
            });
            var f3 = Object.assign({}, i5), p4 = "./this.program", d4 = (c5, h4) => {
              throw h4;
            }, T3 = typeof window == "object", v5 = typeof importScripts == "function", w3 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", I3 = i5.ENVIRONMENT_IS_PTHREAD || false, L3 = "";
            function F4(c5) {
              return i5.locateFile ? i5.locateFile(c5, L3) : L3 + c5;
            }
            var C3, Y5, j4;
            if (w3) {
              var M4 = (ra(), jt(ta)), ie3 = (oa(), jt(na));
              L3 = v5 ? ie3.dirname(L3) + "/" : __dirname + "/", C3 = (h4, g4) => (h4 = ve4(h4) ? new URL(h4) : ie3.normalize(h4), M4.readFileSync(h4, g4 ? void 0 : "utf8")), j4 = (h4) => (h4 = C3(h4, true), h4.buffer || (h4 = new Uint8Array(h4)), h4), Y5 = (h4, g4, S3, k4 = true) => {
                h4 = ve4(h4) ? new URL(h4) : ie3.normalize(h4), M4.readFile(h4, k4 ? void 0 : "utf8", (B5, z4) => {
                  B5 ? S3(B5) : g4(k4 ? z4.buffer : z4);
                });
              }, !i5.thisProgram && 1 < process.argv.length && (p4 = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), d4 = (h4, g4) => {
                throw process.exitCode = h4, g4;
              }, i5.inspect = () => "[Emscripten Module object]";
              let c5;
              try {
                c5 = Cp();
              } catch (h4) {
                throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), h4;
              }
              global.Worker = c5.Worker;
            } else
              (T3 || v5) && (v5 ? L3 = self.location.href : typeof document < "u" && document.currentScript && (L3 = document.currentScript.src), typeof a4 < "u" && a4 && (L3 = a4), L3.indexOf("blob:") !== 0 ? L3 = L3.substr(0, L3.replace(/[?#].*/, "").lastIndexOf("/") + 1) : L3 = "", w3 || (C3 = (c5) => {
                var h4 = new XMLHttpRequest();
                return h4.open("GET", c5, false), h4.send(null), h4.responseText;
              }, v5 && (j4 = (c5) => {
                var h4 = new XMLHttpRequest();
                return h4.open("GET", c5, false), h4.responseType = "arraybuffer", h4.send(null), new Uint8Array(h4.response);
              }), Y5 = (c5, h4, g4) => {
                var S3 = new XMLHttpRequest();
                S3.open("GET", c5, true), S3.responseType = "arraybuffer", S3.onload = () => {
                  S3.status == 200 || S3.status == 0 && S3.response ? h4(S3.response) : g4();
                }, S3.onerror = g4, S3.send(null);
              }));
            w3 && typeof performance > "u" && (global.performance = $p().performance);
            var ot4 = console.log.bind(console), We3 = console.error.bind(console);
            w3 && (ot4 = (...c5) => M4.writeSync(1, c5.join(" ") + `
`), We3 = (...c5) => M4.writeSync(2, c5.join(" ") + `
`));
            var Fe5 = ot4, V4 = We3;
            Object.assign(i5, f3), f3 = null, typeof WebAssembly != "object" && Mt3("no native wasm support detected");
            var Ae3, It3, mt3 = false, Ne3, te3, bt4, St4, He3, At4;
            function we5() {
              var c5 = Ae3.buffer;
              i5.HEAP8 = te3 = new Int8Array(c5), i5.HEAP16 = new Int16Array(c5), i5.HEAPU8 = bt4 = new Uint8Array(c5), i5.HEAPU16 = new Uint16Array(c5), i5.HEAP32 = St4 = new Int32Array(c5), i5.HEAPU32 = He3 = new Uint32Array(c5), i5.HEAPF32 = new Float32Array(c5), i5.HEAPF64 = At4 = new Float64Array(c5);
            }
            var Ze3 = 16777216;
            if (I3)
              Ae3 = i5.wasmMemory;
            else if (i5.wasmMemory)
              Ae3 = i5.wasmMemory;
            else if (Ae3 = new WebAssembly.Memory({ initial: Ze3 / 65536, maximum: 65536, shared: true }), !(Ae3.buffer instanceof SharedArrayBuffer))
              throw V4("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w3 && V4("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
            we5(), Ze3 = Ae3.buffer.byteLength;
            var rr4 = [], Pt4 = [], gt4 = [], yt3 = 0, nr4 = null, Qe3 = null;
            function Et4() {
              if (yt3--, yt3 == 0 && (nr4 !== null && (clearInterval(nr4), nr4 = null), Qe3)) {
                var c5 = Qe3;
                Qe3 = null, c5();
              }
            }
            function Mt3(c5) {
              throw c5 = "Aborted(" + c5 + ")", V4(c5), mt3 = true, Ne3 = 1, c5 = new WebAssembly.RuntimeError(c5 + ". Build with -sASSERTIONS for more info."), l4(c5), c5;
            }
            var $e4 = (c5) => c5.startsWith("data:application/octet-stream;base64,"), ve4 = (c5) => c5.startsWith("file://"), qe3;
            qe3 = "ort-wasm-threaded.wasm", $e4(qe3) || (qe3 = F4(qe3));
            function Gt3(c5) {
              if (j4)
                return j4(c5);
              throw "both async and sync fetching of the wasm failed";
            }
            function Dt3(c5) {
              if (T3 || v5) {
                if (typeof fetch == "function" && !ve4(c5))
                  return fetch(c5, { credentials: "same-origin" }).then((h4) => {
                    if (!h4.ok)
                      throw "failed to load wasm binary file at '" + c5 + "'";
                    return h4.arrayBuffer();
                  }).catch(() => Gt3(c5));
                if (Y5)
                  return new Promise((h4, g4) => {
                    Y5(c5, (S3) => h4(new Uint8Array(S3)), g4);
                  });
              }
              return Promise.resolve().then(() => Gt3(c5));
            }
            function jr3(c5, h4, g4) {
              return Dt3(c5).then((S3) => WebAssembly.instantiate(S3, h4)).then((S3) => S3).then(g4, (S3) => {
                V4(`failed to asynchronously prepare wasm: ${S3}`), Mt3(S3);
              });
            }
            function wn3(c5, h4) {
              var g4 = qe3;
              return typeof WebAssembly.instantiateStreaming != "function" || $e4(g4) || ve4(g4) || w3 || typeof fetch != "function" ? jr3(g4, c5, h4) : fetch(g4, { credentials: "same-origin" }).then((S3) => WebAssembly.instantiateStreaming(S3, c5).then(h4, function(k4) {
                return V4(`wasm streaming compile failed: ${k4}`), V4("falling back to ArrayBuffer instantiation"), jr3(g4, c5, h4);
              }));
            }
            var Ut4, Or3 = { 921388: (c5, h4, g4, S3) => {
              if (typeof i5 > "u" || !i5.cb)
                return 1;
              if (c5 = Ar3(c5 >>> 0), c5.startsWith("./") && (c5 = c5.substring(2)), c5 = i5.cb.get(c5), !c5)
                return 2;
              if (h4 >>>= 0, g4 >>>= 0, S3 >>>= 0, h4 + g4 > c5.byteLength)
                return 3;
              try {
                return e4().set(c5.subarray(h4, h4 + g4), S3 >>> 0), 0;
              } catch {
                return 4;
              }
            } };
            function qt3(c5) {
              this.name = "ExitStatus", this.message = `Program terminated with exit(${c5})`, this.status = c5;
            }
            var Ir4 = (c5) => {
              c5.terminate(), c5.onmessage = () => {
              };
            }, Sr3 = (c5) => {
              J3.Pa.length == 0 && (Kr3(), J3.Ya(J3.Pa[0]));
              var h4 = J3.Pa.pop();
              if (!h4)
                return 6;
              J3.Qa.push(h4), J3.Ma[c5.Oa] = h4, h4.Oa = c5.Oa;
              var g4 = { cmd: "run", start_routine: c5.kb, arg: c5.hb, pthread_ptr: c5.Oa };
              return w3 && h4.unref(), h4.postMessage(g4, c5.qb), 0;
            }, or4 = 0, Yr3 = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, Xr3 = (c5, h4, g4) => {
              h4 >>>= 0;
              var S3 = h4 + g4;
              for (g4 = h4; c5[g4] && !(g4 >= S3); )
                ++g4;
              if (16 < g4 - h4 && c5.buffer && Yr3)
                return Yr3.decode(c5.buffer instanceof SharedArrayBuffer ? c5.slice(h4, g4) : c5.subarray(h4, g4));
              for (S3 = ""; h4 < g4; ) {
                var k4 = c5[h4++];
                if (k4 & 128) {
                  var B5 = c5[h4++] & 63;
                  if ((k4 & 224) == 192)
                    S3 += String.fromCharCode((k4 & 31) << 6 | B5);
                  else {
                    var z4 = c5[h4++] & 63;
                    k4 = (k4 & 240) == 224 ? (k4 & 15) << 12 | B5 << 6 | z4 : (k4 & 7) << 18 | B5 << 12 | z4 << 6 | c5[h4++] & 63, 65536 > k4 ? S3 += String.fromCharCode(k4) : (k4 -= 65536, S3 += String.fromCharCode(55296 | k4 >> 10, 56320 | k4 & 1023));
                  }
                } else
                  S3 += String.fromCharCode(k4);
              }
              return S3;
            }, Ar3 = (c5, h4) => (c5 >>>= 0) ? Xr3(e4(), c5, h4) : "", vn3 = (c5) => {
              var h4 = Vo3();
              return c5 = c5(), Pn3(h4), c5;
            };
            function he3(c5, h4) {
              var g4 = arguments.length - 2, S3 = arguments;
              return vn3(() => {
                for (var k4 = Wo3(8 * g4), B5 = k4 >>> 3, z4 = 0; z4 < g4; z4++) {
                  var Ie3 = S3[2 + z4];
                  s4()[B5 + z4 >>> 0] = Ie3;
                }
                return Ra3(c5, g4, k4, h4);
              });
            }
            function Q3(c5) {
              if (I3)
                return he3(0, 1, c5);
              Ne3 = c5, 0 < or4 || (J3.lb(), i5.onExit?.(c5), mt3 = true), d4(c5, new qt3(c5));
            }
            var Pr3 = (c5) => {
              if (Ne3 = c5, I3)
                throw In3(c5), "unwind";
              Q3(c5);
            };
            function _n3() {
              for (var c5 = i5.numThreads; c5--; )
                Kr3();
              rr4.unshift(() => {
                yt3++, On3(() => Et4());
              });
            }
            function Kr3() {
              var c5 = F4("ort-wasm-threaded.worker.js");
              c5 = new Worker(c5), J3.Pa.push(c5);
            }
            function On3(c5) {
              I3 ? c5() : Promise.all(J3.Pa.map(J3.Ya)).then(c5);
            }
            var J3 = { Pa: [], Qa: [], bb: [], Ma: {}, Wa() {
              I3 ? (J3.receiveObjectTransfer = J3.jb, J3.threadInitTLS = J3.ab, J3.setExitStatus = J3.$a) : _n3();
            }, $a: (c5) => Ne3 = c5, tb: ["$terminateWorker"], lb: () => {
              for (var c5 of J3.Qa)
                Ir4(c5);
              for (c5 of J3.Pa)
                Ir4(c5);
              J3.Pa = [], J3.Qa = [], J3.Ma = [];
            }, Za: (c5) => {
              var h4 = c5.Oa;
              delete J3.Ma[h4], J3.Pa.push(c5), J3.Qa.splice(J3.Qa.indexOf(c5), 1), c5.Oa = 0, Uo3(h4);
            }, jb() {
            }, ab() {
              J3.bb.forEach((c5) => c5());
            }, Ya: (c5) => new Promise((h4) => {
              c5.onmessage = (B5) => {
                B5 = B5.data;
                var z4 = B5.cmd;
                if (B5.targetThread && B5.targetThread != An3()) {
                  var Ie3 = J3.Ma[B5.targetThread];
                  Ie3 ? Ie3.postMessage(B5, B5.transferList) : V4(`Internal error! Worker sent a message "${z4}" to target pthread ${B5.targetThread}, but that thread no longer exists!`);
                } else
                  z4 === "checkMailbox" ? Sn3() : z4 === "spawnThread" ? Sr3(B5) : z4 === "cleanupThread" ? J3.Za(J3.Ma[B5.thread]) : z4 === "killThread" ? (B5 = B5.thread, z4 = J3.Ma[B5], delete J3.Ma[B5], Ir4(z4), Uo3(B5), J3.Qa.splice(J3.Qa.indexOf(z4), 1), z4.Oa = 0) : z4 === "cancelThread" ? J3.Ma[B5.thread].postMessage({ cmd: "cancel" }) : z4 === "loaded" ? (c5.loaded = true, w3 && !c5.Oa && c5.unref(), h4(c5)) : z4 === "alert" ? alert(`Thread ${B5.threadId}: ${B5.text}`) : B5.target === "setimmediate" ? c5.postMessage(B5) : z4 === "callHandler" ? i5[B5.handler](...B5.args) : z4 && V4(`worker sent an unknown command ${z4}`);
              }, c5.onerror = (B5) => {
                throw V4(`worker sent an error! ${B5.filename}:${B5.lineno}: ${B5.message}`), B5;
              }, w3 && (c5.on("message", (B5) => c5.onmessage({ data: B5 })), c5.on("error", (B5) => c5.onerror(B5)));
              var g4 = [], S3 = ["onExit"], k4;
              for (k4 of S3)
                i5.hasOwnProperty(k4) && g4.push(k4);
              c5.postMessage({ cmd: "load", handlers: g4, urlOrBlob: i5.mainScriptUrlOrBlob || a4, wasmMemory: Ae3, wasmModule: It3 });
            }) };
            i5.PThread = J3;
            var ir4 = (c5) => {
              for (; 0 < c5.length; )
                c5.shift()(i5);
            };
            i5.establishStackSpace = () => {
              var c5 = An3(), h4 = n4()[c5 + 52 >>> 2 >>> 0];
              c5 = n4()[c5 + 56 >>> 2 >>> 0], Ua2(h4, h4 - c5), Pn3(h4);
            };
            function In3(c5) {
              if (I3)
                return he3(1, 0, c5);
              Pr3(c5);
            }
            var zt4 = [], Jr4;
            i5.invokeEntryPoint = (c5, h4) => {
              var g4 = zt4[c5];
              g4 || (c5 >= zt4.length && (zt4.length = c5 + 1), zt4[c5] = g4 = Jr4.get(c5)), c5 = g4(h4), 0 < or4 ? J3.$a(c5) : zo2(c5);
            };
            function b3(c5) {
              this.Va = c5 - 24, this.gb = function(h4) {
                n4()[this.Va + 4 >>> 2 >>> 0] = h4;
              }, this.fb = function(h4) {
                n4()[this.Va + 8 >>> 2 >>> 0] = h4;
              }, this.Wa = function(h4, g4) {
                this.eb(), this.gb(h4), this.fb(g4);
              }, this.eb = function() {
                n4()[this.Va + 16 >>> 2 >>> 0] = 0;
              };
            }
            var x4 = 0, _4 = 0;
            function D3(c5, h4, g4, S3) {
              return I3 ? he3(2, 1, c5, h4, g4, S3) : G4(c5, h4, g4, S3);
            }
            function G4(c5, h4, g4, S3) {
              if (c5 >>>= 0, h4 >>>= 0, g4 >>>= 0, S3 >>>= 0, typeof SharedArrayBuffer > "u")
                return V4("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
              var k4 = [];
              return I3 && k4.length === 0 ? D3(c5, h4, g4, S3) : (c5 = { kb: g4, Oa: c5, hb: S3, qb: k4 }, I3 ? (c5.sb = "spawnThread", postMessage(c5, k4), 0) : Sr3(c5));
            }
            function X4(c5, h4, g4) {
              return I3 ? he3(3, 1, c5, h4, g4) : 0;
            }
            function ne4(c5, h4) {
              if (I3)
                return he3(4, 1, c5, h4);
            }
            var ke5 = (c5) => {
              for (var h4 = 0, g4 = 0; g4 < c5.length; ++g4) {
                var S3 = c5.charCodeAt(g4);
                127 >= S3 ? h4++ : 2047 >= S3 ? h4 += 2 : 55296 <= S3 && 57343 >= S3 ? (h4 += 4, ++g4) : h4 += 3;
              }
              return h4;
            }, Ye3 = (c5, h4, g4, S3) => {
              if (g4 >>>= 0, !(0 < S3))
                return 0;
              var k4 = g4;
              S3 = g4 + S3 - 1;
              for (var B5 = 0; B5 < c5.length; ++B5) {
                var z4 = c5.charCodeAt(B5);
                if (55296 <= z4 && 57343 >= z4) {
                  var Ie3 = c5.charCodeAt(++B5);
                  z4 = 65536 + ((z4 & 1023) << 10) | Ie3 & 1023;
                }
                if (127 >= z4) {
                  if (g4 >= S3)
                    break;
                  h4[g4++ >>> 0] = z4;
                } else {
                  if (2047 >= z4) {
                    if (g4 + 1 >= S3)
                      break;
                    h4[g4++ >>> 0] = 192 | z4 >> 6;
                  } else {
                    if (65535 >= z4) {
                      if (g4 + 2 >= S3)
                        break;
                      h4[g4++ >>> 0] = 224 | z4 >> 12;
                    } else {
                      if (g4 + 3 >= S3)
                        break;
                      h4[g4++ >>> 0] = 240 | z4 >> 18, h4[g4++ >>> 0] = 128 | z4 >> 12 & 63;
                    }
                    h4[g4++ >>> 0] = 128 | z4 >> 6 & 63;
                  }
                  h4[g4++ >>> 0] = 128 | z4 & 63;
                }
              }
              return h4[g4 >>> 0] = 0, g4 - k4;
            }, Ue3 = (c5, h4, g4) => Ye3(c5, e4(), h4, g4);
            function ze3(c5, h4) {
              if (I3)
                return he3(5, 1, c5, h4);
            }
            function Zr3(c5, h4, g4) {
              if (I3)
                return he3(6, 1, c5, h4, g4);
            }
            function Qr3(c5, h4, g4) {
              return I3 ? he3(7, 1, c5, h4, g4) : 0;
            }
            function A3(c5, h4) {
              if (I3)
                return he3(8, 1, c5, h4);
            }
            function pe3(c5, h4, g4) {
              if (I3)
                return he3(9, 1, c5, h4, g4);
            }
            function Te4(c5, h4, g4, S3) {
              if (I3)
                return he3(10, 1, c5, h4, g4, S3);
            }
            function Lt4(c5, h4, g4, S3) {
              if (I3)
                return he3(11, 1, c5, h4, g4, S3);
            }
            function en3(c5, h4, g4, S3) {
              if (I3)
                return he3(12, 1, c5, h4, g4, S3);
            }
            function ga3(c5) {
              if (I3)
                return he3(13, 1, c5);
            }
            function ya2(c5, h4) {
              if (I3)
                return he3(14, 1, c5, h4);
            }
            function Ta2(c5, h4, g4) {
              if (I3)
                return he3(15, 1, c5, h4, g4);
            }
            function Bo3(c5) {
              c5 >>>= 0, typeof Atomics.rb == "function" && (Atomics.rb(r4(), c5 >>> 2, c5).value.then(Sn3), c5 += 128, Atomics.store(r4(), c5 >>> 2, 1));
            }
            i5.__emscripten_thread_mailbox_await = Bo3;
            var Sn3 = () => {
              var c5 = An3();
              if (c5 && (Bo3(c5), c5 = Ma3, !mt3))
                try {
                  if (c5(), !(0 < or4))
                    try {
                      I3 ? zo2(Ne3) : Pr3(Ne3);
                    } catch (h4) {
                      h4 instanceof qt3 || h4 == "unwind" || d4(1, h4);
                    }
                } catch (h4) {
                  h4 instanceof qt3 || h4 == "unwind" || d4(1, h4);
                }
            };
            i5.checkMailbox = Sn3;
            var No2 = [], Er3 = (c5) => c5 % 4 === 0 && (c5 % 100 !== 0 || c5 % 400 === 0), xa2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], wa2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            function va3(c5, h4, g4, S3, k4, B5, z4, Ie3) {
              return I3 ? he3(16, 1, c5, h4, g4, S3, k4, B5, z4, Ie3) : -52;
            }
            function _a3(c5, h4, g4, S3, k4, B5, z4) {
              if (I3)
                return he3(17, 1, c5, h4, g4, S3, k4, B5, z4);
            }
            var Oa3 = (c5) => {
              var h4 = ke5(c5) + 1, g4 = Ba2(h4);
              return g4 && Ue3(c5, g4, h4), g4;
            }, Ro2 = [], Mo3 = {}, Ia2 = () => {
              if (!Go2) {
                var c5 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: p4 || "./this.program" }, h4;
                for (h4 in Mo3)
                  Mo3[h4] === void 0 ? delete c5[h4] : c5[h4] = Mo3[h4];
                var g4 = [];
                for (h4 in c5)
                  g4.push(`${h4}=${c5[h4]}`);
                Go2 = g4;
              }
              return Go2;
            }, Go2;
            function Sa3(c5, h4) {
              if (I3)
                return he3(18, 1, c5, h4);
              c5 >>>= 0, h4 >>>= 0;
              var g4 = 0;
              return Ia2().forEach((S3, k4) => {
                var B5 = h4 + g4;
                for (k4 = n4()[c5 + 4 * k4 >>> 2 >>> 0] = B5, B5 = 0; B5 < S3.length; ++B5)
                  o4()[k4++ >>> 0 >>> 0] = S3.charCodeAt(B5);
                o4()[k4 >>> 0 >>> 0] = 0, g4 += S3.length + 1;
              }), 0;
            }
            function Aa2(c5, h4) {
              if (I3)
                return he3(19, 1, c5, h4);
              c5 >>>= 0, h4 >>>= 0;
              var g4 = Ia2();
              n4()[c5 >>> 2 >>> 0] = g4.length;
              var S3 = 0;
              return g4.forEach((k4) => S3 += k4.length + 1), n4()[h4 >>> 2 >>> 0] = S3, 0;
            }
            function Pa2(c5) {
              return I3 ? he3(20, 1, c5) : 52;
            }
            function Ea2(c5, h4, g4, S3) {
              return I3 ? he3(21, 1, c5, h4, g4, S3) : 52;
            }
            function Da2(c5, h4, g4, S3, k4) {
              return I3 ? he3(22, 1, c5, h4, g4, S3, k4) : 70;
            }
            var xd = [null, [], []];
            function La2(c5, h4, g4, S3) {
              if (I3)
                return he3(23, 1, c5, h4, g4, S3);
              h4 >>>= 0, g4 >>>= 0, S3 >>>= 0;
              for (var k4 = 0, B5 = 0; B5 < g4; B5++) {
                var z4 = n4()[h4 >>> 2 >>> 0], Ie3 = n4()[h4 + 4 >>> 2 >>> 0];
                h4 += 8;
                for (var Ft3 = 0; Ft3 < Ie3; Ft3++) {
                  var Re4 = e4()[z4 + Ft3 >>> 0], et4 = xd[c5];
                  Re4 === 0 || Re4 === 10 ? ((c5 === 1 ? Fe5 : V4)(Xr3(et4, 0)), et4.length = 0) : et4.push(Re4);
                }
                k4 += Ie3;
              }
              return n4()[S3 >>> 2 >>> 0] = k4, 0;
            }
            var Fa2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ca2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function wd(c5) {
              var h4 = Array(ke5(c5) + 1);
              return Ye3(c5, h4, 0, h4.length), h4;
            }
            var vd = (c5, h4) => {
              o4().set(c5, h4 >>> 0);
            };
            function $a2(c5, h4, g4, S3) {
              function k4(P4, de3, Se5) {
                for (P4 = typeof P4 == "number" ? P4.toString() : P4 || ""; P4.length < de3; )
                  P4 = Se5[0] + P4;
                return P4;
              }
              function B5(P4, de3) {
                return k4(P4, de3, "0");
              }
              function z4(P4, de3) {
                function Se5(Ha2) {
                  return 0 > Ha2 ? -1 : 0 < Ha2 ? 1 : 0;
                }
                var ar4;
                return (ar4 = Se5(P4.getFullYear() - de3.getFullYear())) === 0 && (ar4 = Se5(P4.getMonth() - de3.getMonth())) === 0 && (ar4 = Se5(P4.getDate() - de3.getDate())), ar4;
              }
              function Ie3(P4) {
                switch (P4.getDay()) {
                  case 0:
                    return new Date(P4.getFullYear() - 1, 11, 29);
                  case 1:
                    return P4;
                  case 2:
                    return new Date(P4.getFullYear(), 0, 3);
                  case 3:
                    return new Date(P4.getFullYear(), 0, 2);
                  case 4:
                    return new Date(P4.getFullYear(), 0, 1);
                  case 5:
                    return new Date(P4.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(P4.getFullYear() - 1, 11, 30);
                }
              }
              function Ft3(P4) {
                var de3 = P4.Ra;
                for (P4 = new Date(new Date(P4.Sa + 1900, 0, 1).getTime()); 0 < de3; ) {
                  var Se5 = P4.getMonth(), ar4 = (Er3(P4.getFullYear()) ? Fa2 : Ca2)[Se5];
                  if (de3 > ar4 - P4.getDate())
                    de3 -= ar4 - P4.getDate() + 1, P4.setDate(1), 11 > Se5 ? P4.setMonth(Se5 + 1) : (P4.setMonth(0), P4.setFullYear(P4.getFullYear() + 1));
                  else {
                    P4.setDate(P4.getDate() + de3);
                    break;
                  }
                }
                return Se5 = new Date(P4.getFullYear() + 1, 0, 4), de3 = Ie3(new Date(P4.getFullYear(), 0, 4)), Se5 = Ie3(Se5), 0 >= z4(de3, P4) ? 0 >= z4(Se5, P4) ? P4.getFullYear() + 1 : P4.getFullYear() : P4.getFullYear() - 1;
              }
              c5 >>>= 0, h4 >>>= 0, g4 >>>= 0, S3 >>>= 0;
              var Re4 = n4()[S3 + 40 >>> 2 >>> 0];
              S3 = { ob: r4()[S3 >>> 2 >>> 0], nb: r4()[S3 + 4 >>> 2 >>> 0], Ta: r4()[S3 + 8 >>> 2 >>> 0], Xa: r4()[S3 + 12 >>> 2 >>> 0], Ua: r4()[S3 + 16 >>> 2 >>> 0], Sa: r4()[S3 + 20 >>> 2 >>> 0], Na: r4()[S3 + 24 >>> 2 >>> 0], Ra: r4()[S3 + 28 >>> 2 >>> 0], ub: r4()[S3 + 32 >>> 2 >>> 0], mb: r4()[S3 + 36 >>> 2 >>> 0], pb: Re4 ? Ar3(Re4) : "" }, g4 = Ar3(g4), Re4 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
              for (var et4 in Re4)
                g4 = g4.replace(new RegExp(et4, "g"), Re4[et4]);
              var Va3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), Wa2 = "January February March April May June July August September October November December".split(" ");
              Re4 = { "%a": (P4) => Va3[P4.Na].substring(0, 3), "%A": (P4) => Va3[P4.Na], "%b": (P4) => Wa2[P4.Ua].substring(0, 3), "%B": (P4) => Wa2[P4.Ua], "%C": (P4) => B5((P4.Sa + 1900) / 100 | 0, 2), "%d": (P4) => B5(P4.Xa, 2), "%e": (P4) => k4(P4.Xa, 2, " "), "%g": (P4) => Ft3(P4).toString().substring(2), "%G": (P4) => Ft3(P4), "%H": (P4) => B5(P4.Ta, 2), "%I": (P4) => (P4 = P4.Ta, P4 == 0 ? P4 = 12 : 12 < P4 && (P4 -= 12), B5(P4, 2)), "%j": (P4) => {
                for (var de3 = 0, Se5 = 0; Se5 <= P4.Ua - 1; de3 += (Er3(P4.Sa + 1900) ? Fa2 : Ca2)[Se5++])
                  ;
                return B5(P4.Xa + de3, 3);
              }, "%m": (P4) => B5(P4.Ua + 1, 2), "%M": (P4) => B5(P4.nb, 2), "%n": () => `
`, "%p": (P4) => 0 <= P4.Ta && 12 > P4.Ta ? "AM" : "PM", "%S": (P4) => B5(P4.ob, 2), "%t": () => "	", "%u": (P4) => P4.Na || 7, "%U": (P4) => B5(Math.floor((P4.Ra + 7 - P4.Na) / 7), 2), "%V": (P4) => {
                var de3 = Math.floor((P4.Ra + 7 - (P4.Na + 6) % 7) / 7);
                if (2 >= (P4.Na + 371 - P4.Ra - 2) % 7 && de3++, de3)
                  de3 == 53 && (Se5 = (P4.Na + 371 - P4.Ra) % 7, Se5 == 4 || Se5 == 3 && Er3(P4.Sa) || (de3 = 1));
                else {
                  de3 = 52;
                  var Se5 = (P4.Na + 7 - P4.Ra - 1) % 7;
                  (Se5 == 4 || Se5 == 5 && Er3(P4.Sa % 400 - 1)) && de3++;
                }
                return B5(de3, 2);
              }, "%w": (P4) => P4.Na, "%W": (P4) => B5(Math.floor((P4.Ra + 7 - (P4.Na + 6) % 7) / 7), 2), "%y": (P4) => (P4.Sa + 1900).toString().substring(2), "%Y": (P4) => P4.Sa + 1900, "%z": (P4) => {
                P4 = P4.mb;
                var de3 = 0 <= P4;
                return P4 = Math.abs(P4) / 60, (de3 ? "+" : "-") + ("0000" + (P4 / 60 * 100 + P4 % 60)).slice(-4);
              }, "%Z": (P4) => P4.pb, "%%": () => "%" }, g4 = g4.replace(/%%/g, "\0\0");
              for (et4 in Re4)
                g4.includes(et4) && (g4 = g4.replace(new RegExp(et4, "g"), Re4[et4](S3)));
              return g4 = g4.replace(/\0\0/g, "%"), et4 = wd(g4), et4.length > h4 ? 0 : (vd(et4, c5), et4.length - 1);
            }
            J3.Wa();
            var _d = [Q3, In3, D3, X4, ne4, ze3, Zr3, Qr3, A3, pe3, Te4, Lt4, en3, ga3, ya2, Ta2, va3, _a3, Sa3, Aa2, Pa2, Ea2, Da2, La2], Od = { b: function(c5, h4, g4) {
              throw c5 >>>= 0, new b3(c5).Wa(h4 >>> 0, g4 >>> 0), x4 = c5, _4++, x4;
            }, L: function(c5) {
              Na2(c5 >>> 0, !v5, 1, !T3, 131072, false), J3.ab();
            }, j: function(c5) {
              c5 >>>= 0, I3 ? postMessage({ cmd: "cleanupThread", thread: c5 }) : J3.Za(J3.Ma[c5]);
            }, H: G4, h: X4, S: ne4, D: ze3, F: Zr3, T: Qr3, Q: A3, J: pe3, P: Te4, n: Lt4, E: en3, B: ga3, R: ya2, C: Ta2, p: () => 1, z: function(c5, h4) {
              c5 >>>= 0, c5 == h4 >>> 0 ? setTimeout(() => Sn3()) : I3 ? postMessage({ targetThread: c5, cmd: "checkMailbox" }) : (c5 = J3.Ma[c5]) && c5.postMessage({ cmd: "checkMailbox" });
            }, I: function(c5, h4, g4, S3) {
              h4 >>>= 0, No2.length = g4, S3 = S3 >>> 0 >>> 3;
              for (var k4 = 0; k4 < g4; k4++)
                No2[k4] = s4()[S3 + k4 >>> 0];
              return c5 = 0 > c5 ? Or3[-c5 - 1] : _d[c5], J3.ib = h4, h4 = c5.apply(null, No2), J3.ib = 0, h4;
            }, K: Bo3, o: function(c5) {
              w3 && J3.Ma[c5 >>> 0].ref();
            }, s: function(c5, h4, g4) {
              c5 = h4 + 2097152 >>> 0 < 4194305 - !!c5 ? (c5 >>> 0) + 4294967296 * h4 : NaN, g4 >>>= 0, c5 = new Date(1e3 * c5), r4()[g4 >>> 2 >>> 0] = c5.getUTCSeconds(), r4()[g4 + 4 >>> 2 >>> 0] = c5.getUTCMinutes(), r4()[g4 + 8 >>> 2 >>> 0] = c5.getUTCHours(), r4()[g4 + 12 >>> 2 >>> 0] = c5.getUTCDate(), r4()[g4 + 16 >>> 2 >>> 0] = c5.getUTCMonth(), r4()[g4 + 20 >>> 2 >>> 0] = c5.getUTCFullYear() - 1900, r4()[g4 + 24 >>> 2 >>> 0] = c5.getUTCDay(), c5 = (c5.getTime() - Date.UTC(c5.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, r4()[g4 + 28 >>> 2 >>> 0] = c5;
            }, t: function(c5, h4, g4) {
              c5 = h4 + 2097152 >>> 0 < 4194305 - !!c5 ? (c5 >>> 0) + 4294967296 * h4 : NaN, g4 >>>= 0, c5 = new Date(1e3 * c5), r4()[g4 >>> 2 >>> 0] = c5.getSeconds(), r4()[g4 + 4 >>> 2 >>> 0] = c5.getMinutes(), r4()[g4 + 8 >>> 2 >>> 0] = c5.getHours(), r4()[g4 + 12 >>> 2 >>> 0] = c5.getDate(), r4()[g4 + 16 >>> 2 >>> 0] = c5.getMonth(), r4()[g4 + 20 >>> 2 >>> 0] = c5.getFullYear() - 1900, r4()[g4 + 24 >>> 2 >>> 0] = c5.getDay(), h4 = (Er3(c5.getFullYear()) ? xa2 : wa2)[c5.getMonth()] + c5.getDate() - 1 | 0, r4()[g4 + 28 >>> 2 >>> 0] = h4, r4()[g4 + 36 >>> 2 >>> 0] = -(60 * c5.getTimezoneOffset()), h4 = new Date(c5.getFullYear(), 6, 1).getTimezoneOffset();
              var S3 = new Date(c5.getFullYear(), 0, 1).getTimezoneOffset();
              c5 = (h4 != S3 && c5.getTimezoneOffset() == Math.min(S3, h4)) | 0, r4()[g4 + 32 >>> 2 >>> 0] = c5;
            }, u: function(c5) {
              c5 >>>= 0;
              var h4 = new Date(r4()[c5 + 20 >>> 2 >>> 0] + 1900, r4()[c5 + 16 >>> 2 >>> 0], r4()[c5 + 12 >>> 2 >>> 0], r4()[c5 + 8 >>> 2 >>> 0], r4()[c5 + 4 >>> 2 >>> 0], r4()[c5 >>> 2 >>> 0], 0), g4 = r4()[c5 + 32 >>> 2 >>> 0], S3 = h4.getTimezoneOffset(), k4 = new Date(h4.getFullYear(), 6, 1).getTimezoneOffset(), B5 = new Date(h4.getFullYear(), 0, 1).getTimezoneOffset(), z4 = Math.min(B5, k4);
              return 0 > g4 ? r4()[c5 + 32 >>> 2 >>> 0] = +(k4 != B5 && z4 == S3) : 0 < g4 != (z4 == S3) && (k4 = Math.max(B5, k4), h4.setTime(h4.getTime() + 6e4 * ((0 < g4 ? z4 : k4) - S3))), r4()[c5 + 24 >>> 2 >>> 0] = h4.getDay(), g4 = (Er3(h4.getFullYear()) ? xa2 : wa2)[h4.getMonth()] + h4.getDate() - 1 | 0, r4()[c5 + 28 >>> 2 >>> 0] = g4, r4()[c5 >>> 2 >>> 0] = h4.getSeconds(), r4()[c5 + 4 >>> 2 >>> 0] = h4.getMinutes(), r4()[c5 + 8 >>> 2 >>> 0] = h4.getHours(), r4()[c5 + 12 >>> 2 >>> 0] = h4.getDate(), r4()[c5 + 16 >>> 2 >>> 0] = h4.getMonth(), r4()[c5 + 20 >>> 2 >>> 0] = h4.getYear(), c5 = h4.getTime(), isNaN(c5) ? (r4()[ka2() >>> 2 >>> 0] = 61, c5 = -1) : c5 /= 1e3, Ga3((Ut4 = c5, 1 <= +Math.abs(Ut4) ? 0 < Ut4 ? +Math.floor(Ut4 / 4294967296) >>> 0 : ~~+Math.ceil((Ut4 - +(~~Ut4 >>> 0)) / 4294967296) >>> 0 : 0)), c5 >>> 0;
            }, q: va3, r: _a3, y: function(c5, h4, g4) {
              function S3(Re4) {
                return (Re4 = Re4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? Re4[1] : "GMT";
              }
              c5 >>>= 0, h4 >>>= 0, g4 >>>= 0;
              var k4 = (/* @__PURE__ */ new Date()).getFullYear(), B5 = new Date(k4, 0, 1), z4 = new Date(k4, 6, 1);
              k4 = B5.getTimezoneOffset();
              var Ie3 = z4.getTimezoneOffset(), Ft3 = Math.max(k4, Ie3);
              n4()[c5 >>> 2 >>> 0] = 60 * Ft3, r4()[h4 >>> 2 >>> 0] = +(k4 != Ie3), c5 = S3(B5), h4 = S3(z4), c5 = Oa3(c5), h4 = Oa3(h4), Ie3 < k4 ? (n4()[g4 >>> 2 >>> 0] = c5, n4()[g4 + 4 >>> 2 >>> 0] = h4) : (n4()[g4 >>> 2 >>> 0] = h4, n4()[g4 + 4 >>> 2 >>> 0] = c5);
            }, c: () => {
              Mt3("");
            }, O: function(c5, h4, g4) {
              c5 >>>= 0, h4 >>>= 0, g4 >>>= 0, Ro2.length = 0;
              for (var S3; S3 = e4()[h4++ >>> 0]; ) {
                var k4 = S3 != 105;
                k4 &= S3 != 112, g4 += k4 && g4 % 8 ? 4 : 0, Ro2.push(S3 == 112 ? n4()[g4 >>> 2 >>> 0] : S3 == 105 ? r4()[g4 >>> 2 >>> 0] : s4()[g4 >>> 3 >>> 0]), g4 += k4 ? 8 : 4;
              }
              return Or3[c5].apply(null, Ro2);
            }, k: () => {
            }, i: () => Date.now(), U: () => {
              throw or4 += 1, "unwind";
            }, A: function() {
              return 4294901760;
            }, e: () => performance.timeOrigin + performance.now(), f: () => w3 ? (Bp(), jt(kp)).cpus().length : navigator.hardwareConcurrency, x: function(c5) {
              c5 >>>= 0;
              var h4 = e4().length;
              if (c5 <= h4 || 4294901760 < c5)
                return false;
              for (var g4 = 1; 4 >= g4; g4 *= 2) {
                var S3 = h4 * (1 + 0.2 / g4);
                S3 = Math.min(S3, c5 + 100663296);
                var k4 = Math;
                S3 = Math.max(c5, S3);
                e: {
                  k4 = (k4.min.call(k4, 4294901760, S3 + (65536 - S3 % 65536) % 65536) - Ae3.buffer.byteLength + 65535) / 65536;
                  try {
                    Ae3.grow(k4), we5();
                    var B5 = 1;
                    break e;
                  } catch {
                  }
                  B5 = void 0;
                }
                if (B5)
                  return true;
              }
              return false;
            }, M: Sa3, N: Aa2, G: Pr3, g: Pa2, m: Ea2, v: Da2, l: La2, a: Ae3 || i5.wasmMemory, w: $a2, d: function(c5, h4, g4, S3) {
              return $a2(c5 >>> 0, h4 >>> 0, g4 >>> 0, S3 >>> 0);
            } }, K5 = function() {
              function c5(g4, S3) {
                return K5 = g4.exports, K5 = Id2(), J3.bb.push(K5.za), Jr4 = K5.Aa, Pt4.unshift(K5.V), It3 = S3, Et4(), K5;
              }
              var h4 = { a: Od };
              if (yt3++, i5.instantiateWasm)
                try {
                  return i5.instantiateWasm(h4, c5);
                } catch (g4) {
                  V4(`Module.instantiateWasm callback failed with error: ${g4}`), l4(g4);
                }
              return wn3(h4, function(g4) {
                c5(g4.instance, g4.module);
              }).catch(l4), {};
            }();
            i5._OrtInit = (c5, h4) => (i5._OrtInit = K5.W)(c5, h4), i5._OrtGetLastError = (c5, h4) => (i5._OrtGetLastError = K5.X)(c5, h4), i5._OrtCreateSessionOptions = (c5, h4, g4, S3, k4, B5, z4, Ie3, Ft3, Re4) => (i5._OrtCreateSessionOptions = K5.Y)(c5, h4, g4, S3, k4, B5, z4, Ie3, Ft3, Re4), i5._OrtAppendExecutionProvider = (c5, h4) => (i5._OrtAppendExecutionProvider = K5.Z)(c5, h4), i5._OrtAddFreeDimensionOverride = (c5, h4, g4) => (i5._OrtAddFreeDimensionOverride = K5._)(c5, h4, g4), i5._OrtAddSessionConfigEntry = (c5, h4, g4) => (i5._OrtAddSessionConfigEntry = K5.$)(c5, h4, g4), i5._OrtReleaseSessionOptions = (c5) => (i5._OrtReleaseSessionOptions = K5.aa)(c5), i5._OrtCreateSession = (c5, h4, g4) => (i5._OrtCreateSession = K5.ba)(c5, h4, g4), i5._OrtReleaseSession = (c5) => (i5._OrtReleaseSession = K5.ca)(c5), i5._OrtGetInputOutputCount = (c5, h4, g4) => (i5._OrtGetInputOutputCount = K5.da)(c5, h4, g4), i5._OrtGetInputName = (c5, h4) => (i5._OrtGetInputName = K5.ea)(c5, h4), i5._OrtGetOutputName = (c5, h4) => (i5._OrtGetOutputName = K5.fa)(c5, h4), i5._OrtFree = (c5) => (i5._OrtFree = K5.ga)(c5), i5._OrtCreateTensor = (c5, h4, g4, S3, k4, B5) => (i5._OrtCreateTensor = K5.ha)(c5, h4, g4, S3, k4, B5), i5._OrtGetTensorData = (c5, h4, g4, S3, k4) => (i5._OrtGetTensorData = K5.ia)(c5, h4, g4, S3, k4), i5._OrtReleaseTensor = (c5) => (i5._OrtReleaseTensor = K5.ja)(c5), i5._OrtCreateRunOptions = (c5, h4, g4, S3) => (i5._OrtCreateRunOptions = K5.ka)(c5, h4, g4, S3), i5._OrtAddRunConfigEntry = (c5, h4, g4) => (i5._OrtAddRunConfigEntry = K5.la)(c5, h4, g4), i5._OrtReleaseRunOptions = (c5) => (i5._OrtReleaseRunOptions = K5.ma)(c5), i5._OrtCreateBinding = (c5) => (i5._OrtCreateBinding = K5.na)(c5), i5._OrtBindInput = (c5, h4, g4) => (i5._OrtBindInput = K5.oa)(c5, h4, g4), i5._OrtBindOutput = (c5, h4, g4, S3) => (i5._OrtBindOutput = K5.pa)(c5, h4, g4, S3), i5._OrtClearBoundOutputs = (c5) => (i5._OrtClearBoundOutputs = K5.qa)(c5), i5._OrtReleaseBinding = (c5) => (i5._OrtReleaseBinding = K5.ra)(c5), i5._OrtRunWithBinding = (c5, h4, g4, S3, k4) => (i5._OrtRunWithBinding = K5.sa)(c5, h4, g4, S3, k4), i5._OrtRun = (c5, h4, g4, S3, k4, B5, z4, Ie3) => (i5._OrtRun = K5.ta)(c5, h4, g4, S3, k4, B5, z4, Ie3), i5._OrtEndProfiling = (c5) => (i5._OrtEndProfiling = K5.ua)(c5);
            var ka2 = () => (ka2 = K5.va)(), An3 = i5._pthread_self = () => (An3 = i5._pthread_self = K5.wa)(), Ba2 = i5._malloc = (c5) => (Ba2 = i5._malloc = K5.xa)(c5);
            i5._free = (c5) => (i5._free = K5.ya)(c5), i5.__emscripten_tls_init = () => (i5.__emscripten_tls_init = K5.za)();
            var Na2 = i5.__emscripten_thread_init = (c5, h4, g4, S3, k4, B5) => (Na2 = i5.__emscripten_thread_init = K5.Ba)(c5, h4, g4, S3, k4, B5);
            i5.__emscripten_thread_crashed = () => (i5.__emscripten_thread_crashed = K5.Ca)();
            var Ra3 = (c5, h4, g4, S3) => (Ra3 = K5.Da)(c5, h4, g4, S3), Uo3 = (c5) => (Uo3 = K5.Ea)(c5), zo2 = i5.__emscripten_thread_exit = (c5) => (zo2 = i5.__emscripten_thread_exit = K5.Fa)(c5), Ma3 = () => (Ma3 = K5.Ga)(), Ga3 = (c5) => (Ga3 = K5.Ha)(c5), Ua2 = (c5, h4) => (Ua2 = K5.Ia)(c5, h4), Vo3 = () => (Vo3 = K5.Ja)(), Pn3 = (c5) => (Pn3 = K5.Ka)(c5), Wo3 = (c5) => (Wo3 = K5.La)(c5);
            function Id2() {
              var c5 = K5;
              c5 = Object.assign({}, c5);
              var h4 = (S3) => () => S3() >>> 0, g4 = (S3) => (k4) => S3(k4) >>> 0;
              return c5.va = h4(c5.va), c5.wa = h4(c5.wa), c5.xa = g4(c5.xa), c5.emscripten_main_runtime_thread_id = h4(c5.emscripten_main_runtime_thread_id), c5.Ja = h4(c5.Ja), c5.La = g4(c5.La), c5;
            }
            i5.wasmMemory = Ae3, i5.stackAlloc = Wo3, i5.stackSave = Vo3, i5.stackRestore = Pn3, i5.keepRuntimeAlive = () => 0 < or4, i5.UTF8ToString = Ar3, i5.stringToUTF8 = Ue3, i5.lengthBytesUTF8 = ke5, i5.ExitStatus = qt3, i5.PThread = J3;
            var En3;
            Qe3 = function c5() {
              En3 || za3(), En3 || (Qe3 = c5);
            };
            function za3() {
              if (!(0 < yt3))
                if (I3)
                  u4(i5), I3 || ir4(Pt4), startWorker(i5);
                else {
                  if (i5.preRun)
                    for (typeof i5.preRun == "function" && (i5.preRun = [i5.preRun]); i5.preRun.length; )
                      rr4.unshift(i5.preRun.shift());
                  ir4(rr4), 0 < yt3 || En3 || (En3 = true, i5.calledRun = true, mt3 || (I3 || ir4(Pt4), u4(i5), I3 || ir4(gt4)));
                }
            }
            return za3(), t4.ready;
          };
        })();
        typeof Rp == "object" && typeof aa2 == "object" ? aa2.exports = Np : typeof define == "function" && define.amd && define([], () => Np);
      });
      var Gp = me((fO, ug2) => {
        ug2.exports = '"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\n';
      });
      var zp;
      var lg;
      var sa;
      var ua;
      var Po;
      var Up;
      var fg;
      var cg;
      var pg;
      var Vp;
      var Le;
      var Vr = E(() => {
        "use strict";
        zp = Fp();
        lg = Mp(), ua = false, Po = false, Up = false, fg = (a4) => {
          if (a4 === 1)
            return false;
          if (typeof SharedArrayBuffer > "u")
            return typeof self < "u" && !self.crossOriginIsolated && console.warn("env.wasm.numThreads is set to " + a4 + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."), false;
          typeof process < "u" && process.versions && process.versions.node && console.warn("env.wasm.numThreads is set to " + a4 + ", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");
          try {
            return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
          } catch {
            return false;
          }
        }, cg = () => {
          try {
            return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
          } catch {
            return false;
          }
        }, pg = (a4, t4) => a4 ? t4 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-simd.wasm" : t4 ? "ort-wasm-threaded.wasm" : "ort-wasm.wasm", Vp = async (a4) => {
          if (ua)
            return Promise.resolve();
          if (Po)
            throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
          if (Up)
            throw new Error("previous call to 'initializeWebAssembly()' failed.");
          Po = true;
          let t4 = a4.initTimeout, o4 = a4.numThreads, e4 = a4.simd, r4 = fg(o4), n4 = e4 && cg(), s4 = a4.wasmPaths, i5 = typeof s4 == "string" ? s4 : void 0, u4 = pg(n4, r4), l4 = typeof s4 == "object" ? s4[u4] : void 0, f3 = false, p4 = [];
          if (t4 > 0 && p4.push(new Promise((d4) => {
            setTimeout(() => {
              f3 = true, d4();
            }, t4);
          })), p4.push(new Promise((d4, T3) => {
            let v5 = r4 ? lg : zp, w3 = { locateFile: (I3, L3) => r4 && I3.endsWith(".worker.js") && typeof Blob < "u" ? URL.createObjectURL(new Blob([Gp()], { type: "text/javascript" })) : I3.endsWith(".wasm") ? l4 || (i5 ?? L3) + u4 : L3 + I3 };
            if (r4)
              if (w3.numThreads = o4, typeof Blob > "u")
                w3.mainScriptUrlOrBlob = (void 0)(__dirname, "ort-wasm-threaded.js");
              else {
                let I3 = `var ortWasmThreaded=${v5.toString()};`;
                w3.mainScriptUrlOrBlob = new Blob([I3], { type: "text/javascript" });
              }
            v5(w3).then((I3) => {
              Po = false, ua = true, sa = I3, d4();
            }, (I3) => {
              Po = false, Up = true, T3(I3);
            });
          })), await Promise.race(p4), f3)
            throw new Error(`WebAssembly backend initializing failed due to timeout: ${t4}ms`);
        }, Le = () => {
          if (ua && sa)
            return sa;
          throw new Error("WebAssembly is not initialized yet.");
        };
      });
      var _e;
      var yn;
      var Oe;
      var Eo = E(() => {
        "use strict";
        Vr();
        _e = (a4, t4) => {
          let o4 = Le(), e4 = o4.lengthBytesUTF8(a4) + 1, r4 = o4._malloc(e4);
          return o4.stringToUTF8(a4, r4, e4), t4.push(r4), r4;
        }, yn = (a4, t4, o4, e4) => {
          if (typeof a4 == "object" && a4 !== null) {
            if (o4.has(a4))
              throw new Error("Circular reference in options");
            o4.add(a4);
          }
          Object.entries(a4).forEach(([r4, n4]) => {
            let s4 = t4 ? t4 + r4 : r4;
            if (typeof n4 == "object")
              yn(n4, s4 + ".", o4, e4);
            else if (typeof n4 == "string" || typeof n4 == "number")
              e4(s4, n4.toString());
            else if (typeof n4 == "boolean")
              e4(s4, n4 ? "1" : "0");
            else
              throw new Error(`Can't handle extra config type: ${typeof n4}`);
          });
        }, Oe = (a4) => {
          let t4 = Le(), o4 = t4.stackSave();
          try {
            let e4 = t4.stackAlloc(8);
            t4._OrtGetLastError(e4, e4 + 4);
            let r4 = t4.HEAP32[e4 / 4], n4 = t4.HEAPU32[e4 / 4 + 1], s4 = n4 ? t4.UTF8ToString(n4) : "";
            throw new Error(`${a4} ERROR_CODE: ${r4}, ERROR_MESSAGE: ${s4}`);
          } finally {
            t4.stackRestore(o4);
          }
        };
      });
      var Wp;
      var Hp = E(() => {
        "use strict";
        Vr();
        Eo();
        Wp = (a4) => {
          let t4 = Le(), o4 = 0, e4 = [], r4 = a4 || {};
          try {
            if (a4?.logSeverityLevel === void 0)
              r4.logSeverityLevel = 2;
            else if (typeof a4.logSeverityLevel != "number" || !Number.isInteger(a4.logSeverityLevel) || a4.logSeverityLevel < 0 || a4.logSeverityLevel > 4)
              throw new Error(`log serverity level is not valid: ${a4.logSeverityLevel}`);
            if (a4?.logVerbosityLevel === void 0)
              r4.logVerbosityLevel = 0;
            else if (typeof a4.logVerbosityLevel != "number" || !Number.isInteger(a4.logVerbosityLevel))
              throw new Error(`log verbosity level is not valid: ${a4.logVerbosityLevel}`);
            a4?.terminate === void 0 && (r4.terminate = false);
            let n4 = 0;
            return a4?.tag !== void 0 && (n4 = _e(a4.tag, e4)), o4 = t4._OrtCreateRunOptions(r4.logSeverityLevel, r4.logVerbosityLevel, !!r4.terminate, n4), o4 === 0 && Oe("Can't create run options."), a4?.extra !== void 0 && yn(a4.extra, "", /* @__PURE__ */ new WeakSet(), (s4, i5) => {
              let u4 = _e(s4, e4), l4 = _e(i5, e4);
              t4._OrtAddRunConfigEntry(o4, u4, l4) !== 0 && Oe(`Can't set a run config entry: ${s4} - ${i5}.`);
            }), [o4, e4];
          } catch (n4) {
            throw o4 !== 0 && t4._OrtReleaseRunOptions(o4), e4.forEach((s4) => t4._free(s4)), n4;
          }
        };
      });
      var dg;
      var hg;
      var mg;
      var bg;
      var qp;
      var jp = E(() => {
        "use strict";
        Vr();
        Eo();
        dg = (a4) => {
          switch (a4) {
            case "disabled":
              return 0;
            case "basic":
              return 1;
            case "extended":
              return 2;
            case "all":
              return 99;
            default:
              throw new Error(`unsupported graph optimization level: ${a4}`);
          }
        }, hg = (a4) => {
          switch (a4) {
            case "sequential":
              return 0;
            case "parallel":
              return 1;
            default:
              throw new Error(`unsupported execution mode: ${a4}`);
          }
        }, mg = (a4) => {
          a4.extra || (a4.extra = {}), a4.extra.session || (a4.extra.session = {});
          let t4 = a4.extra.session;
          t4.use_ort_model_bytes_directly || (t4.use_ort_model_bytes_directly = "1"), a4.executionProviders && a4.executionProviders.some((o4) => (typeof o4 == "string" ? o4 : o4.name) === "webgpu") && (a4.enableMemPattern = false);
        }, bg = (a4, t4, o4) => {
          for (let e4 of t4) {
            let r4 = typeof e4 == "string" ? e4 : e4.name;
            switch (r4) {
              case "webnn":
                if (r4 = "WEBNN", typeof e4 != "string") {
                  let s4 = e4;
                  if (s4?.deviceType) {
                    let i5 = _e("deviceType", o4), u4 = _e(s4.deviceType, o4);
                    Le()._OrtAddSessionConfigEntry(a4, i5, u4) !== 0 && Oe(`Can't set a session config entry: 'deviceType' - ${s4.deviceType}.`);
                  }
                  if (s4?.numThreads) {
                    let i5 = s4.numThreads;
                    (typeof i5 != "number" || !Number.isInteger(i5) || i5 < 0) && (i5 = 0);
                    let u4 = _e("numThreads", o4), l4 = _e(i5.toString(), o4);
                    Le()._OrtAddSessionConfigEntry(a4, u4, l4) !== 0 && Oe(`Can't set a session config entry: 'numThreads' - ${s4.numThreads}.`);
                  }
                  if (s4?.powerPreference) {
                    let i5 = _e("powerPreference", o4), u4 = _e(s4.powerPreference, o4);
                    Le()._OrtAddSessionConfigEntry(a4, i5, u4) !== 0 && Oe(`Can't set a session config entry: 'powerPreference' - ${s4.powerPreference}.`);
                  }
                }
                break;
              case "webgpu":
                if (r4 = "JS", typeof e4 != "string") {
                  let s4 = e4;
                  if (s4?.preferredLayout) {
                    if (s4.preferredLayout !== "NCHW" && s4.preferredLayout !== "NHWC")
                      throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s4.preferredLayout}`);
                    let i5 = _e("preferredLayout", o4), u4 = _e(s4.preferredLayout, o4);
                    Le()._OrtAddSessionConfigEntry(a4, i5, u4) !== 0 && Oe(`Can't set a session config entry: 'preferredLayout' - ${s4.preferredLayout}.`);
                  }
                }
                break;
              case "wasm":
              case "cpu":
                continue;
              default:
                throw new Error(`not supported execution provider: ${r4}`);
            }
            let n4 = _e(r4, o4);
            Le()._OrtAppendExecutionProvider(a4, n4) !== 0 && Oe(`Can't append execution provider: ${r4}.`);
          }
        }, qp = (a4) => {
          let t4 = Le(), o4 = 0, e4 = [], r4 = a4 || {};
          mg(r4);
          try {
            let n4 = dg(r4.graphOptimizationLevel ?? "all"), s4 = hg(r4.executionMode ?? "sequential"), i5 = typeof r4.logId == "string" ? _e(r4.logId, e4) : 0, u4 = r4.logSeverityLevel ?? 2;
            if (!Number.isInteger(u4) || u4 < 0 || u4 > 4)
              throw new Error(`log serverity level is not valid: ${u4}`);
            let l4 = r4.logVerbosityLevel ?? 0;
            if (!Number.isInteger(l4) || l4 < 0 || l4 > 4)
              throw new Error(`log verbosity level is not valid: ${l4}`);
            let f3 = typeof r4.optimizedModelFilePath == "string" ? _e(r4.optimizedModelFilePath, e4) : 0;
            if (o4 = t4._OrtCreateSessionOptions(n4, !!r4.enableCpuMemArena, !!r4.enableMemPattern, s4, !!r4.enableProfiling, 0, i5, u4, l4, f3), o4 === 0 && Oe("Can't create session options."), r4.executionProviders && bg(o4, r4.executionProviders, e4), r4.enableGraphCapture !== void 0) {
              if (typeof r4.enableGraphCapture != "boolean")
                throw new Error(`enableGraphCapture must be a boolean value: ${r4.enableGraphCapture}`);
              let p4 = _e("enableGraphCapture", e4), d4 = _e(r4.enableGraphCapture.toString(), e4);
              t4._OrtAddSessionConfigEntry(o4, p4, d4) !== 0 && Oe(`Can't set a session config entry: 'enableGraphCapture' - ${r4.enableGraphCapture}.`);
            }
            if (r4.freeDimensionOverrides)
              for (let [p4, d4] of Object.entries(r4.freeDimensionOverrides)) {
                if (typeof p4 != "string")
                  throw new Error(`free dimension override name must be a string: ${p4}`);
                if (typeof d4 != "number" || !Number.isInteger(d4) || d4 < 0)
                  throw new Error(`free dimension override value must be a non-negative integer: ${d4}`);
                let T3 = _e(p4, e4);
                t4._OrtAddFreeDimensionOverride(o4, T3, d4) !== 0 && Oe(`Can't set a free dimension override: ${p4} - ${d4}.`);
              }
            return r4.extra !== void 0 && yn(r4.extra, "", /* @__PURE__ */ new WeakSet(), (p4, d4) => {
              let T3 = _e(p4, e4), v5 = _e(d4, e4);
              t4._OrtAddSessionConfigEntry(o4, T3, v5) !== 0 && Oe(`Can't set a session config entry: ${p4} - ${d4}.`);
            }), [o4, e4];
          } catch (n4) {
            throw o4 !== 0 && t4._OrtReleaseSessionOptions(o4), e4.forEach((s4) => t4._free(s4)), n4;
          }
        };
      });
      var la;
      var Yp;
      var fa;
      var Xp;
      var Kp;
      var Do;
      var Jp;
      var ca = E(() => {
        "use strict";
        la = (a4) => {
          switch (a4) {
            case "int8":
              return 3;
            case "uint8":
              return 2;
            case "bool":
              return 9;
            case "int16":
              return 5;
            case "uint16":
              return 4;
            case "int32":
              return 6;
            case "uint32":
              return 12;
            case "float16":
              return 10;
            case "float32":
              return 1;
            case "float64":
              return 11;
            case "string":
              return 8;
            case "int64":
              return 7;
            case "uint64":
              return 13;
            default:
              throw new Error(`unsupported data type: ${a4}`);
          }
        }, Yp = (a4) => {
          switch (a4) {
            case 3:
              return "int8";
            case 2:
              return "uint8";
            case 9:
              return "bool";
            case 5:
              return "int16";
            case 4:
              return "uint16";
            case 6:
              return "int32";
            case 12:
              return "uint32";
            case 10:
              return "float16";
            case 1:
              return "float32";
            case 11:
              return "float64";
            case 8:
              return "string";
            case 7:
              return "int64";
            case 13:
              return "uint64";
            default:
              throw new Error(`unsupported data type: ${a4}`);
          }
        }, fa = (a4) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][a4], Xp = (a4) => {
          switch (a4) {
            case "float16":
              return typeof Float16Array < "u" && Float16Array.from ? Float16Array : Uint16Array;
            case "float32":
              return Float32Array;
            case "uint8":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "uint16":
              return Uint16Array;
            case "int16":
              return Int16Array;
            case "int32":
              return Int32Array;
            case "bool":
              return Uint8Array;
            case "float64":
              return Float64Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "uint64":
              return BigUint64Array;
            default:
              throw new Error(`unsupported type: ${a4}`);
          }
        }, Kp = (a4) => {
          switch (a4) {
            case "verbose":
              return 0;
            case "info":
              return 1;
            case "warning":
              return 2;
            case "error":
              return 3;
            case "fatal":
              return 4;
            default:
              throw new Error(`unsupported logging level: ${a4}`);
          }
        }, Do = (a4) => a4 === "float32" || a4 === "float16" || a4 === "int32" || a4 === "int64" || a4 === "uint32" || a4 === "uint8" || a4 === "bool", Jp = (a4) => {
          switch (a4) {
            case "none":
              return 0;
            case "cpu":
              return 1;
            case "cpu-pinned":
              return 2;
            case "texture":
              return 3;
            case "gpu-buffer":
              return 4;
            default:
              throw new Error(`unsupported data location: ${a4}`);
          }
        };
      });
      var Tn;
      var pa = E(() => {
        "use strict";
        Tn = async (a4) => {
          if (typeof a4 == "string")
            if (typeof process < "u" && process.versions && process.versions.node)
              try {
                return new Uint8Array(await (void 0)(a4));
              } catch (t4) {
                if (t4.code === "ERR_FS_FILE_TOO_LARGE") {
                  let o4 = (void 0)(a4), e4 = [];
                  for await (let r4 of o4)
                    e4.push(r4);
                  return new Uint8Array(Buffer.concat(e4));
                }
                throw t4;
              }
            else {
              let t4 = await fetch(a4);
              if (!t4.ok)
                throw new Error(`failed to load external data file: ${a4}`);
              let o4 = t4.headers.get("Content-Length"), e4 = o4 ? parseInt(o4, 10) : 0;
              if (e4 < 1073741824)
                return new Uint8Array(await t4.arrayBuffer());
              {
                if (!t4.body)
                  throw new Error(`failed to load external data file: ${a4}, no response body.`);
                let r4 = t4.body.getReader(), n4;
                try {
                  n4 = new ArrayBuffer(e4);
                } catch (i5) {
                  if (i5 instanceof RangeError) {
                    let u4 = Math.ceil(e4 / 65536);
                    n4 = new WebAssembly.Memory({ initial: u4, maximum: u4 }).buffer;
                  } else
                    throw i5;
                }
                let s4 = 0;
                for (; ; ) {
                  let { done: i5, value: u4 } = await r4.read();
                  if (i5)
                    break;
                  let l4 = u4.byteLength;
                  new Uint8Array(n4, s4, l4).set(u4), s4 += l4;
                }
                return new Uint8Array(n4, 0, e4);
              }
            }
          else
            return a4 instanceof Blob ? new Uint8Array(await a4.arrayBuffer()) : a4 instanceof Uint8Array ? a4 : new Uint8Array(a4);
        };
      });
      var gg;
      var Qp;
      var ed;
      var Wr;
      var yg;
      var da;
      var td;
      var rd;
      var Zp;
      var nd;
      var od;
      var id;
      var ad = E(() => {
        "use strict";
        Hp();
        jp();
        ca();
        Vr();
        Eo();
        pa();
        gg = (a4, t4) => {
          Le()._OrtInit(a4, t4) !== 0 && Oe("Can't initialize onnxruntime.");
        }, Qp = async (a4) => {
          gg(a4.wasm.numThreads, Kp(a4.logLevel));
        }, ed = async (a4, t4) => {
        }, Wr = /* @__PURE__ */ new Map(), yg = (a4) => {
          let t4 = Le(), o4 = t4.stackSave();
          try {
            let e4 = t4.stackAlloc(8);
            return t4._OrtGetInputOutputCount(a4, e4, e4 + 4) !== 0 && Oe("Can't get session input/output count."), [t4.HEAP32[e4 / 4], t4.HEAP32[e4 / 4 + 1]];
          } finally {
            t4.stackRestore(o4);
          }
        }, da = (a4) => {
          let t4 = Le(), o4 = t4._malloc(a4.byteLength);
          if (o4 === 0)
            throw new Error(`Can't create a session. failed to allocate a buffer of size ${a4.byteLength}.`);
          return t4.HEAPU8.set(a4, o4), [o4, a4.byteLength];
        }, td = async (a4, t4) => {
          let o4, e4, r4 = Le();
          Array.isArray(a4) ? [o4, e4] = a4 : a4.buffer === r4.HEAPU8.buffer ? [o4, e4] = [a4.byteOffset, a4.byteLength] : [o4, e4] = da(a4);
          let n4 = 0, s4 = 0, i5 = 0, u4 = [], l4 = [], f3 = [];
          try {
            if ([s4, u4] = qp(t4), t4?.externalData && r4.mountExternalData) {
              let F4 = [];
              for (let C3 of t4.externalData) {
                let Y5 = typeof C3 == "string" ? C3 : C3.path;
                F4.push(Tn(typeof C3 == "string" ? C3 : C3.data).then((j4) => {
                  r4.mountExternalData(Y5, j4);
                }));
              }
              await Promise.all(F4);
            }
            n4 = await r4._OrtCreateSession(o4, e4, s4), n4 === 0 && Oe("Can't create a session.");
            let [p4, d4] = yg(n4), T3 = !!t4?.enableGraphCapture, v5 = [], w3 = [], I3 = [];
            for (let F4 = 0; F4 < p4; F4++) {
              let C3 = r4._OrtGetInputName(n4, F4);
              C3 === 0 && Oe("Can't get an input name."), l4.push(C3), v5.push(r4.UTF8ToString(C3));
            }
            for (let F4 = 0; F4 < d4; F4++) {
              let C3 = r4._OrtGetOutputName(n4, F4);
              C3 === 0 && Oe("Can't get an output name."), f3.push(C3);
              let Y5 = r4.UTF8ToString(C3);
              w3.push(Y5);
            }
            let L3 = null;
            return Wr.set(n4, [n4, l4, f3, L3, T3, false]), [n4, v5, w3];
          } catch (p4) {
            throw l4.forEach((d4) => r4._OrtFree(d4)), f3.forEach((d4) => r4._OrtFree(d4)), i5 !== 0 && r4._OrtReleaseBinding(i5), n4 !== 0 && r4._OrtReleaseSession(n4), p4;
          } finally {
            r4._free(o4), s4 !== 0 && r4._OrtReleaseSessionOptions(s4), u4.forEach((p4) => r4._free(p4)), r4.unmountExternalData?.();
          }
        }, rd = (a4) => {
          let t4 = Le(), o4 = Wr.get(a4);
          if (!o4)
            throw new Error(`cannot release session. invalid session id: ${a4}`);
          let [e4, r4, n4, s4, i5] = o4;
          s4 && (i5 && t4._OrtClearBoundOutputs(s4.handle), t4._OrtReleaseBinding(s4.handle)), t4.jsepOnReleaseSession?.(a4), r4.forEach((u4) => t4._OrtFree(u4)), n4.forEach((u4) => t4._OrtFree(u4)), t4._OrtReleaseSession(e4), Wr.delete(a4);
        }, Zp = (a4, t4, o4, e4, r4, n4 = false) => {
          if (!a4) {
            t4.push(0);
            return;
          }
          let s4 = Le(), i5 = a4[0], u4 = a4[1], l4 = a4[3], f3, p4;
          if (i5 === "string" && l4 === "gpu-buffer")
            throw new Error("String tensor is not supported on GPU.");
          if (n4 && l4 !== "gpu-buffer")
            throw new Error(`External buffer must be provided for input/output index ${r4} when enableGraphCapture is true.`);
          if (l4 === "gpu-buffer") {
            let v5 = a4[2].gpuBuffer, w3 = fa(la(i5));
            p4 = u4.reduce((L3, F4) => L3 * F4, 1) * w3;
            let I3 = s4.jsepRegisterBuffer;
            if (!I3)
              throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            f3 = I3(e4, r4, v5, p4);
          } else {
            let v5 = a4[2];
            if (Array.isArray(v5)) {
              p4 = 4 * v5.length, f3 = s4._malloc(p4), o4.push(f3);
              let w3 = f3 / 4;
              for (let I3 = 0; I3 < v5.length; I3++) {
                if (typeof v5[I3] != "string")
                  throw new TypeError(`tensor data at index ${I3} is not a string`);
                s4.HEAPU32[w3++] = _e(v5[I3], o4);
              }
            } else
              p4 = v5.byteLength, f3 = s4._malloc(p4), o4.push(f3), s4.HEAPU8.set(new Uint8Array(v5.buffer, v5.byteOffset, p4), f3);
          }
          let d4 = s4.stackSave(), T3 = s4.stackAlloc(4 * u4.length);
          try {
            let v5 = T3 / 4;
            u4.forEach((I3) => s4.HEAP32[v5++] = I3);
            let w3 = s4._OrtCreateTensor(la(i5), f3, p4, T3, u4.length, Jp(l4));
            w3 === 0 && Oe(`Can't create tensor for input/output. session=${e4}, index=${r4}.`), t4.push(w3);
          } finally {
            s4.stackRestore(d4);
          }
        }, nd = async (a4, t4, o4, e4, r4, n4) => {
          let s4 = Le(), i5 = Wr.get(a4);
          if (!i5)
            throw new Error(`cannot run inference. invalid session id: ${a4}`);
          let u4 = i5[0], l4 = i5[1], f3 = i5[2], p4 = i5[3], d4 = i5[4], T3 = i5[5], v5 = t4.length, w3 = e4.length, I3 = 0, L3 = [], F4 = [], C3 = [], Y5 = [], j4 = s4.stackSave(), M4 = s4.stackAlloc(v5 * 4), ie3 = s4.stackAlloc(v5 * 4), ot4 = s4.stackAlloc(w3 * 4), We3 = s4.stackAlloc(w3 * 4);
          try {
            [I3, L3] = Wp(n4);
            for (let te3 = 0; te3 < v5; te3++)
              Zp(o4[te3], F4, Y5, a4, t4[te3], d4);
            for (let te3 = 0; te3 < w3; te3++)
              Zp(r4[te3], C3, Y5, a4, v5 + e4[te3], d4);
            let Fe5 = M4 / 4, V4 = ie3 / 4, Ae3 = ot4 / 4, It3 = We3 / 4;
            for (let te3 = 0; te3 < v5; te3++)
              s4.HEAPU32[Fe5++] = F4[te3], s4.HEAPU32[V4++] = l4[t4[te3]];
            for (let te3 = 0; te3 < w3; te3++)
              s4.HEAPU32[Ae3++] = C3[te3], s4.HEAPU32[It3++] = f3[e4[te3]];
            s4.jsepOnRunStart?.(u4);
            let mt3;
            mt3 = await s4._OrtRun(u4, ie3, M4, v5, We3, w3, ot4, I3), mt3 !== 0 && Oe("failed to call OrtRun().");
            let Ne3 = [];
            for (let te3 = 0; te3 < w3; te3++) {
              let bt4 = s4.HEAPU32[ot4 / 4 + te3];
              if (bt4 === C3[te3]) {
                Ne3.push(r4[te3]);
                continue;
              }
              let St4 = s4.stackSave(), He3 = s4.stackAlloc(4 * 4), At4 = false, we5, Ze3 = 0;
              try {
                s4._OrtGetTensorData(bt4, He3, He3 + 4, He3 + 8, He3 + 12) !== 0 && Oe(`Can't access output tensor data on index ${te3}.`);
                let Pt4 = He3 / 4, gt4 = s4.HEAPU32[Pt4++];
                Ze3 = s4.HEAPU32[Pt4++];
                let yt3 = s4.HEAPU32[Pt4++], nr4 = s4.HEAPU32[Pt4++], Qe3 = [];
                for (let $e4 = 0; $e4 < nr4; $e4++)
                  Qe3.push(s4.HEAPU32[yt3 / 4 + $e4]);
                s4._OrtFree(yt3);
                let Et4 = Qe3.reduce(($e4, ve4) => $e4 * ve4, 1);
                we5 = Yp(gt4);
                let Mt3 = p4?.outputPreferredLocations[e4[te3]];
                if (we5 === "string") {
                  if (Mt3 === "gpu-buffer")
                    throw new Error("String tensor is not supported on GPU.");
                  let $e4 = [], ve4 = Ze3 / 4;
                  for (let qe3 = 0; qe3 < Et4; qe3++) {
                    let Gt3 = s4.HEAPU32[ve4++], Dt3 = qe3 === Et4 - 1 ? void 0 : s4.HEAPU32[ve4] - Gt3;
                    $e4.push(s4.UTF8ToString(Gt3, Dt3));
                  }
                  Ne3.push([we5, Qe3, $e4, "cpu"]);
                } else if (Mt3 === "gpu-buffer" && Et4 > 0) {
                  let $e4 = s4.jsepGetBuffer;
                  if (!$e4)
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  let ve4 = $e4(Ze3), qe3 = fa(gt4);
                  if (qe3 === void 0 || !Do(we5))
                    throw new Error(`Unsupported data type: ${we5}`);
                  At4 = true, Ne3.push([we5, Qe3, { gpuBuffer: ve4, download: s4.jsepCreateDownloader(ve4, Et4 * qe3, we5), dispose: () => {
                    s4._OrtReleaseTensor(bt4);
                  } }, "gpu-buffer"]);
                } else {
                  let $e4 = Xp(we5), ve4 = new $e4(Et4);
                  new Uint8Array(ve4.buffer, ve4.byteOffset, ve4.byteLength).set(s4.HEAPU8.subarray(Ze3, Ze3 + ve4.byteLength)), Ne3.push([we5, Qe3, ve4, "cpu"]);
                }
              } finally {
                s4.stackRestore(St4), we5 === "string" && Ze3 && s4._free(Ze3), At4 || s4._OrtReleaseTensor(bt4);
              }
            }
            return p4 && !d4 && (s4._OrtClearBoundOutputs(p4.handle), Wr.set(a4, [u4, l4, f3, p4, d4, false])), Ne3;
          } finally {
            s4.stackRestore(j4), F4.forEach((Fe5) => s4._OrtReleaseTensor(Fe5)), C3.forEach((Fe5) => s4._OrtReleaseTensor(Fe5)), Y5.forEach((Fe5) => s4._free(Fe5)), I3 !== 0 && s4._OrtReleaseRunOptions(I3), L3.forEach((Fe5) => s4._free(Fe5));
          }
        }, od = (a4) => {
          let t4 = Le(), o4 = Wr.get(a4);
          if (!o4)
            throw new Error("invalid session id");
          let e4 = o4[0], r4 = t4._OrtEndProfiling(e4);
          r4 === 0 && Oe("Can't get an profile file name."), t4._OrtFree(r4);
        }, id = (a4) => {
          let t4 = [];
          for (let o4 of a4) {
            let e4 = o4[2];
            !Array.isArray(e4) && "buffer" in e4 && t4.push(e4.buffer);
          }
          return t4;
        };
      });
      var sd = me((EO, xg) => {
        xg.exports = '/*!\n * ONNX Runtime Web v1.17.3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var Et=Object.defineProperty;var Jr=Object.getOwnPropertyDescriptor;var Xr=Object.getOwnPropertyNames;var Qr=Object.prototype.hasOwnProperty;var St=(u,c)=>()=>(u&&(c=u(u=0)),c);var tt=(u,c)=>()=>(c||u((c={exports:{}}).exports,c),c.exports),At=(u,c)=>{for(var a in c)Et(u,a,{get:c[a],enumerable:!0})},Zr=(u,c,a,h)=>{if(c&&typeof c=="object"||typeof c=="function")for(let f of Xr(c))!Qr.call(u,f)&&f!==a&&Et(u,f,{get:()=>c[f],enumerable:!(h=Jr(c,f))||h.enumerable});return u};var rt=u=>Zr(Et({},"__esModule",{value:!0}),u);var Tt={};At(Tt,{createReadStream:()=>dr,readFile:()=>Kr,readFileSync:()=>en});var Kr,en,dr,Mt=St(()=>{Kr=void 0,en=void 0,dr=void 0});var Ct={};At(Ct,{join:()=>tn});var tn,Dt=St(()=>{tn=void 0});var gr=tt((mr,Ft)=>{"use strict";var pr=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(u=u||__filename),function(c={}){var a=c,h,f;a.ready=new Promise((r,o)=>{h=r,f=o});var w=Object.assign({},a),g="./this.program",i=typeof window=="object",E=typeof importScripts=="function",P=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",U="",D,x,K;if(P){var R=(Mt(),rt(Tt)),I=(Dt(),rt(Ct));U=E?I.dirname(U)+"/":__dirname+"/",D=(r,o)=>(r=ve(r)?new URL(r):I.normalize(r),R.readFileSync(r,o?void 0:"utf8")),K=r=>(r=D(r,!0),r.buffer||(r=new Uint8Array(r)),r),x=(r,o,s,m=!0)=>{r=ve(r)?new URL(r):I.normalize(r),R.readFile(r,m?void 0:"utf8",(O,A)=>{O?s(O):o(m?A.buffer:A)})},!a.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),a.inspect=()=>"[Emscripten Module object]"}else(i||E)&&(E?U=self.location.href:typeof document<"u"&&document.currentScript&&(U=document.currentScript.src),u&&(U=u),U.indexOf("blob:")!==0?U=U.substr(0,U.replace(/[?#].*/,"").lastIndexOf("/")+1):U="",D=r=>{var o=new XMLHttpRequest;return o.open("GET",r,!1),o.send(null),o.responseText},E&&(K=r=>{var o=new XMLHttpRequest;return o.open("GET",r,!1),o.responseType="arraybuffer",o.send(null),new Uint8Array(o.response)}),x=(r,o,s)=>{var m=new XMLHttpRequest;m.open("GET",r,!0),m.responseType="arraybuffer",m.onload=()=>{m.status==200||m.status==0&&m.response?o(m.response):s()},m.onerror=s,m.send(null)});var v=console.log.bind(console),k=console.error.bind(console);Object.assign(a,w),w=null,typeof WebAssembly!="object"&&F("no native wasm support detected");var W,H=!1,se,ee,S,j,Ce;function Ue(){var r=W.buffer;a.HEAP8=se=new Int8Array(r),a.HEAP16=new Int16Array(r),a.HEAPU8=ee=new Uint8Array(r),a.HEAPU16=new Uint16Array(r),a.HEAP32=S=new Int32Array(r),a.HEAPU32=j=new Uint32Array(r),a.HEAPF32=new Float32Array(r),a.HEAPF64=Ce=new Float64Array(r)}var ce=[],ne=[],Q=[],Oe=0,he=null,ae=null;function F(r){throw r="Aborted("+r+")",k(r),H=!0,r=new WebAssembly.RuntimeError(r+". Build with -sASSERTIONS for more info."),f(r),r}var ye=r=>r.startsWith("data:application/octet-stream;base64,"),ve=r=>r.startsWith("file://"),fe;if(fe="ort-wasm.wasm",!ye(fe)){var _e=fe;fe=a.locateFile?a.locateFile(_e,U):U+_e}function Y(r){if(K)return K(r);throw"both async and sync fetching of the wasm failed"}function pe(r){if(i||E){if(typeof fetch=="function"&&!ve(r))return fetch(r,{credentials:"same-origin"}).then(o=>{if(!o.ok)throw"failed to load wasm binary file at \'"+r+"\'";return o.arrayBuffer()}).catch(()=>Y(r));if(x)return new Promise((o,s)=>{x(r,m=>o(new Uint8Array(m)),s)})}return Promise.resolve().then(()=>Y(r))}function Ie(r,o,s){return pe(r).then(m=>WebAssembly.instantiate(m,o)).then(m=>m).then(s,m=>{k(`failed to asynchronously prepare wasm: ${m}`),F(m)})}function Ee(r,o){var s=fe;return typeof WebAssembly.instantiateStreaming!="function"||ye(s)||ve(s)||P||typeof fetch!="function"?Ie(s,r,o):fetch(s,{credentials:"same-origin"}).then(m=>WebAssembly.instantiateStreaming(m,r).then(o,function(O){return k(`wasm streaming compile failed: ${O}`),k("falling back to ArrayBuffer instantiation"),Ie(s,r,o)}))}var be,we={920016:(r,o,s,m)=>{if(typeof a>"u"||!a.za)return 1;if(r=z(r>>>0),r.startsWith("./")&&(r=r.substring(2)),r=a.za.get(r),!r)return 2;if(o>>>=0,s>>>=0,o+s>r.byteLength)return 3;try{return ee.set(r.subarray(o,o+s),m>>>0>>>0),0}catch{return 4}}};function Le(r){this.xa=r-24,this.Ha=function(o){j[this.xa+4>>>2>>>0]=o},this.Ga=function(o){j[this.xa+8>>>2>>>0]=o},this.Aa=function(o,s){this.Fa(),this.Ha(o),this.Ga(s)},this.Fa=function(){j[this.xa+16>>>2>>>0]=0}}var me=0,Se=0,De=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,te=(r,o,s)=>{o>>>=0;var m=o+s;for(s=o;r[s]&&!(s>=m);)++s;if(16<s-o&&r.buffer&&De)return De.decode(r.subarray(o,s));for(m="";o<s;){var O=r[o++];if(O&128){var A=r[o++]&63;if((O&224)==192)m+=String.fromCharCode((O&31)<<6|A);else{var L=r[o++]&63;O=(O&240)==224?(O&15)<<12|A<<6|L:(O&7)<<18|A<<12|L<<6|r[o++]&63,65536>O?m+=String.fromCharCode(O):(O-=65536,m+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else m+=String.fromCharCode(O)}return m},z=(r,o)=>(r>>>=0)?te(ee,r,o):"",le=r=>{for(var o=0,s=0;s<r.length;++s){var m=r.charCodeAt(s);127>=m?o++:2047>=m?o+=2:55296<=m&&57343>=m?(o+=4,++s):o+=3}return o},Fe=(r,o,s,m)=>{if(s>>>=0,!(0<m))return 0;var O=s;m=s+m-1;for(var A=0;A<r.length;++A){var L=r.charCodeAt(A);if(55296<=L&&57343>=L){var re=r.charCodeAt(++A);L=65536+((L&1023)<<10)|re&1023}if(127>=L){if(s>=m)break;o[s++>>>0]=L}else{if(2047>=L){if(s+1>=m)break;o[s++>>>0]=192|L>>6}else{if(65535>=L){if(s+2>=m)break;o[s++>>>0]=224|L>>12}else{if(s+3>=m)break;o[s++>>>0]=240|L>>18,o[s++>>>0]=128|L>>12&63}o[s++>>>0]=128|L>>6&63}o[s++>>>0]=128|L&63}}return o[s>>>0]=0,s-O},Ae=r=>r%4===0&&(r%100!==0||r%400===0),qe=[0,31,60,91,121,152,182,213,244,274,305,335],at=[0,31,59,90,120,151,181,212,243,273,304,334],xe=r=>{var o=le(r)+1,s=st(o);return s&&Fe(r,ee,s,o),s},Ne=[],Re={},He=()=>{if(!Ge){var r={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},o;for(o in Re)Re[o]===void 0?delete r[o]:r[o]=Re[o];var s=[];for(o in r)s.push(`${o}=${r[o]}`);Ge=s}return Ge},Ge,Be=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],Je=[31,28,31,30,31,30,31,31,30,31,30,31];function $e(r){var o=Array(le(r)+1);return Fe(r,o,0,o.length),o}function ot(r,o,s,m){function O(d,B,$){for(d=typeof d=="number"?d.toString():d||"";d.length<B;)d=$[0]+d;return d}function A(d,B){return O(d,B,"0")}function L(d,B){function $(et){return 0>et?-1:0<et?1:0}var Te;return(Te=$(d.getFullYear()-B.getFullYear()))===0&&(Te=$(d.getMonth()-B.getMonth()))===0&&(Te=$(d.getDate()-B.getDate())),Te}function re(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function de(d){var B=d.ta;for(d=new Date(new Date(d.ua+1900,0,1).getTime());0<B;){var $=d.getMonth(),Te=(Ae(d.getFullYear())?Ve:Je)[$];if(B>Te-d.getDate())B-=Te-d.getDate()+1,d.setDate(1),11>$?d.setMonth($+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+B);break}}return $=new Date(d.getFullYear()+1,0,4),B=re(new Date(d.getFullYear(),0,4)),$=re($),0>=L(B,d)?0>=L($,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}r>>>=0,o>>>=0,s>>>=0,m>>>=0;var ie=j[m+40>>>2>>>0];m={Da:S[m>>>2>>>0],Ca:S[m+4>>>2>>>0],va:S[m+8>>>2>>>0],ya:S[m+12>>>2>>>0],wa:S[m+16>>>2>>>0],ua:S[m+20>>>2>>>0],oa:S[m+24>>>2>>>0],ta:S[m+28>>>2>>>0],Ia:S[m+32>>>2>>>0],Ba:S[m+36>>>2>>>0],Ea:ie?z(ie):""},s=z(s),ie={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ue in ie)s=s.replace(new RegExp(ue,"g"),ie[ue]);var Ze="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ke="January February March April May June July August September October November December".split(" ");ie={"%a":d=>Ze[d.oa].substring(0,3),"%A":d=>Ze[d.oa],"%b":d=>Ke[d.wa].substring(0,3),"%B":d=>Ke[d.wa],"%C":d=>A((d.ua+1900)/100|0,2),"%d":d=>A(d.ya,2),"%e":d=>O(d.ya,2," "),"%g":d=>de(d).toString().substring(2),"%G":d=>de(d),"%H":d=>A(d.va,2),"%I":d=>(d=d.va,d==0?d=12:12<d&&(d-=12),A(d,2)),"%j":d=>{for(var B=0,$=0;$<=d.wa-1;B+=(Ae(d.ua+1900)?Ve:Je)[$++]);return A(d.ya+B,3)},"%m":d=>A(d.wa+1,2),"%M":d=>A(d.Ca,2),"%n":()=>`\n`,"%p":d=>0<=d.va&&12>d.va?"AM":"PM","%S":d=>A(d.Da,2),"%t":()=>"	","%u":d=>d.oa||7,"%U":d=>A(Math.floor((d.ta+7-d.oa)/7),2),"%V":d=>{var B=Math.floor((d.ta+7-(d.oa+6)%7)/7);if(2>=(d.oa+371-d.ta-2)%7&&B++,B)B==53&&($=(d.oa+371-d.ta)%7,$==4||$==3&&Ae(d.ua)||(B=1));else{B=52;var $=(d.oa+7-d.ta-1)%7;($==4||$==5&&Ae(d.ua%400-1))&&B++}return A(B,2)},"%w":d=>d.oa,"%W":d=>A(Math.floor((d.ta+7-(d.oa+6)%7)/7),2),"%y":d=>(d.ua+1900).toString().substring(2),"%Y":d=>d.ua+1900,"%z":d=>{d=d.Ba;var B=0<=d;return d=Math.abs(d)/60,(B?"+":"-")+("0000"+(d/60*100+d%60)).slice(-4)},"%Z":d=>d.Ea,"%%":()=>"%"},s=s.replace(/%%/g,"\\0\\0");for(ue in ie)s.includes(ue)&&(s=s.replace(new RegExp(ue,"g"),ie[ue](m)));return s=s.replace(/\\0\\0/g,"%"),ue=$e(s),ue.length>o?0:(se.set(ue,r>>>0),ue.length-1)}var G={a:function(r,o,s){throw r>>>=0,new Le(r).Aa(o>>>0,s>>>0),me=r,Se++,me},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,n:function(r,o,s){r=o+2097152>>>0<4194305-!!r?(r>>>0)+4294967296*o:NaN,s>>>=0,r=new Date(1e3*r),S[s>>>2>>>0]=r.getUTCSeconds(),S[s+4>>>2>>>0]=r.getUTCMinutes(),S[s+8>>>2>>>0]=r.getUTCHours(),S[s+12>>>2>>>0]=r.getUTCDate(),S[s+16>>>2>>>0]=r.getUTCMonth(),S[s+20>>>2>>>0]=r.getUTCFullYear()-1900,S[s+24>>>2>>>0]=r.getUTCDay(),S[s+28>>>2>>>0]=(r.getTime()-Date.UTC(r.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(r,o,s){r=o+2097152>>>0<4194305-!!r?(r>>>0)+4294967296*o:NaN,s>>>=0,r=new Date(1e3*r),S[s>>>2>>>0]=r.getSeconds(),S[s+4>>>2>>>0]=r.getMinutes(),S[s+8>>>2>>>0]=r.getHours(),S[s+12>>>2>>>0]=r.getDate(),S[s+16>>>2>>>0]=r.getMonth(),S[s+20>>>2>>>0]=r.getFullYear()-1900,S[s+24>>>2>>>0]=r.getDay(),S[s+28>>>2>>>0]=(Ae(r.getFullYear())?qe:at)[r.getMonth()]+r.getDate()-1|0,S[s+36>>>2>>>0]=-(60*r.getTimezoneOffset()),o=new Date(r.getFullYear(),6,1).getTimezoneOffset();var m=new Date(r.getFullYear(),0,1).getTimezoneOffset();S[s+32>>>2>>>0]=(o!=m&&r.getTimezoneOffset()==Math.min(m,o))|0},p:function(r){r>>>=0;var o=new Date(S[r+20>>>2>>>0]+1900,S[r+16>>>2>>>0],S[r+12>>>2>>>0],S[r+8>>>2>>>0],S[r+4>>>2>>>0],S[r>>>2>>>0],0),s=S[r+32>>>2>>>0],m=o.getTimezoneOffset(),O=new Date(o.getFullYear(),6,1).getTimezoneOffset(),A=new Date(o.getFullYear(),0,1).getTimezoneOffset(),L=Math.min(A,O);return 0>s?S[r+32>>>2>>>0]=+(O!=A&&L==m):0<s!=(L==m)&&(O=Math.max(A,O),o.setTime(o.getTime()+6e4*((0<s?L:O)-m))),S[r+24>>>2>>>0]=o.getDay(),S[r+28>>>2>>>0]=(Ae(o.getFullYear())?qe:at)[o.getMonth()]+o.getDate()-1|0,S[r>>>2>>>0]=o.getSeconds(),S[r+4>>>2>>>0]=o.getMinutes(),S[r+8>>>2>>>0]=o.getHours(),S[r+12>>>2>>>0]=o.getDate(),S[r+16>>>2>>>0]=o.getMonth(),S[r+20>>>2>>>0]=o.getYear(),r=o.getTime(),isNaN(r)?(S[je()>>>2>>>0]=61,r=-1):r/=1e3,Xe((be=r,1<=+Math.abs(be)?0<be?+Math.floor(be/4294967296)>>>0:~~+Math.ceil((be-+(~~be>>>0))/4294967296)>>>0:0)),r>>>0},l:function(){return-52},m:function(){},t:function(r,o,s){function m(de){return(de=de.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?de[1]:"GMT"}s>>>=0;var O=new Date().getFullYear(),A=new Date(O,0,1),L=new Date(O,6,1);O=A.getTimezoneOffset();var re=L.getTimezoneOffset();j[r>>>0>>>2>>>0]=60*Math.max(O,re),S[o>>>0>>>2>>>0]=+(O!=re),r=m(A),o=m(L),r=xe(r),o=xe(o),re<O?(j[s>>>2>>>0]=r,j[s+4>>>2>>>0]=o):(j[s>>>2>>>0]=o,j[s+4>>>2>>>0]=r)},d:()=>{F("")},B:function(r,o,s){r>>>=0,o>>>=0,s>>>=0,Ne.length=0;for(var m;m=ee[o++>>>0];){var O=m!=105;O&=m!=112,s+=O&&s%8?4:0,Ne.push(m==112?j[s>>>2>>>0]:m==105?S[s>>>2>>>0]:Ce[s>>>3>>>0]),s+=O?8:4}return we[r].apply(null,Ne)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),I:function(r,o,s){return o>>>=0,ee.copyWithin(r>>>0>>>0,o>>>0,o+(s>>>0)>>>0)},s:function(r){r>>>=0;var o=ee.length;if(4294901760<r)return!1;for(var s=1;4>=s;s*=2){var m=o*(1+.2/s);m=Math.min(m,r+100663296);var O=Math;m=Math.max(r,m);e:{O=(O.min.call(O,4294901760,m+(65536-m%65536)%65536)-W.buffer.byteLength+65535)/65536;try{W.grow(O),Ue();var A=1;break e}catch{}A=void 0}if(A)return!0}return!1},C:function(r,o){r>>>=0,o>>>=0;var s=0;return He().forEach((m,O)=>{var A=o+s;for(O=j[r+4*O>>>2>>>0]=A,A=0;A<m.length;++A)se[O++>>>0>>>0]=m.charCodeAt(A);se[O>>>0>>>0]=0,s+=m.length+1}),0},D:function(r,o){r>>>=0,o>>>=0;var s=He();j[r>>>2>>>0]=s.length;var m=0;return s.forEach(O=>m+=O.length+1),j[o>>>2>>>0]=m,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(r,o,s,m){o>>>=0,s>>>=0,m>>>=0;for(var O=0,A=0;A<s;A++){var L=j[o>>>2>>>0],re=j[o+4>>>2>>>0];o+=8;for(var de=0;de<re;de++){var ie=ee[L+de>>>0],ue=Be[r];ie===0||ie===10?((r===1?v:k)(te(ue,0)),ue.length=0):ue.push(ie)}O+=re}return j[m>>>2>>>0]=O,0},r:ot,c:function(r,o,s,m){return ot(r>>>0,o>>>0,s>>>0,m>>>0)}},C=function(){function r(s){return C=s.exports,C=ut(),W=C.K,Ue(),ne.unshift(C.L),Oe--,Oe==0&&(he!==null&&(clearInterval(he),he=null),ae&&(s=ae,ae=null,s())),C}var o={a:G};if(Oe++,a.instantiateWasm)try{return a.instantiateWasm(o,r)}catch(s){k(`Module.instantiateWasm callback failed with error: ${s}`),f(s)}return Ee(o,function(s){r(s.instance)}).catch(f),{}}();a._OrtInit=(r,o)=>(a._OrtInit=C.M)(r,o),a._OrtGetLastError=(r,o)=>(a._OrtGetLastError=C.N)(r,o),a._OrtCreateSessionOptions=(r,o,s,m,O,A,L,re,de,ie)=>(a._OrtCreateSessionOptions=C.O)(r,o,s,m,O,A,L,re,de,ie),a._OrtAppendExecutionProvider=(r,o)=>(a._OrtAppendExecutionProvider=C.P)(r,o),a._OrtAddFreeDimensionOverride=(r,o,s)=>(a._OrtAddFreeDimensionOverride=C.Q)(r,o,s),a._OrtAddSessionConfigEntry=(r,o,s)=>(a._OrtAddSessionConfigEntry=C.R)(r,o,s),a._OrtReleaseSessionOptions=r=>(a._OrtReleaseSessionOptions=C.S)(r),a._OrtCreateSession=(r,o,s)=>(a._OrtCreateSession=C.T)(r,o,s),a._OrtReleaseSession=r=>(a._OrtReleaseSession=C.U)(r),a._OrtGetInputOutputCount=(r,o,s)=>(a._OrtGetInputOutputCount=C.V)(r,o,s),a._OrtGetInputName=(r,o)=>(a._OrtGetInputName=C.W)(r,o),a._OrtGetOutputName=(r,o)=>(a._OrtGetOutputName=C.X)(r,o),a._OrtFree=r=>(a._OrtFree=C.Y)(r),a._OrtCreateTensor=(r,o,s,m,O,A)=>(a._OrtCreateTensor=C.Z)(r,o,s,m,O,A),a._OrtGetTensorData=(r,o,s,m,O)=>(a._OrtGetTensorData=C._)(r,o,s,m,O),a._OrtReleaseTensor=r=>(a._OrtReleaseTensor=C.$)(r),a._OrtCreateRunOptions=(r,o,s,m)=>(a._OrtCreateRunOptions=C.aa)(r,o,s,m),a._OrtAddRunConfigEntry=(r,o,s)=>(a._OrtAddRunConfigEntry=C.ba)(r,o,s),a._OrtReleaseRunOptions=r=>(a._OrtReleaseRunOptions=C.ca)(r),a._OrtCreateBinding=r=>(a._OrtCreateBinding=C.da)(r),a._OrtBindInput=(r,o,s)=>(a._OrtBindInput=C.ea)(r,o,s),a._OrtBindOutput=(r,o,s,m)=>(a._OrtBindOutput=C.fa)(r,o,s,m),a._OrtClearBoundOutputs=r=>(a._OrtClearBoundOutputs=C.ga)(r),a._OrtReleaseBinding=r=>(a._OrtReleaseBinding=C.ha)(r),a._OrtRunWithBinding=(r,o,s,m,O)=>(a._OrtRunWithBinding=C.ia)(r,o,s,m,O),a._OrtRun=(r,o,s,m,O,A,L,re)=>(a._OrtRun=C.ja)(r,o,s,m,O,A,L,re),a._OrtEndProfiling=r=>(a._OrtEndProfiling=C.ka)(r);var je=()=>(je=C.la)(),st=a._malloc=r=>(st=a._malloc=C.ma)(r);a._free=r=>(a._free=C.na)(r);var Xe=r=>(Xe=C.pa)(r),it=()=>(it=C.qa)(),M=r=>(M=C.ra)(r),ke=r=>(ke=C.sa)(r);function ut(){var r=C;r=Object.assign({},r);var o=m=>()=>m()>>>0,s=m=>O=>m(O)>>>0;return r.la=o(r.la),r.ma=s(r.ma),r.qa=o(r.qa),r.sa=s(r.sa),r}a.stackAlloc=ke,a.stackSave=it,a.stackRestore=M,a.UTF8ToString=z,a.stringToUTF8=(r,o,s)=>Fe(r,ee,o,s),a.lengthBytesUTF8=le;var Pe;ae=function r(){Pe||Qe(),Pe||(ae=r)};function Qe(){if(!(0<Oe)){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;){var r=a.preRun.shift();ce.unshift(r)}for(;0<ce.length;)ce.shift()(a);if(!(0<Oe||Pe||(Pe=!0,a.calledRun=!0,H))){for(;0<ne.length;)ne.shift()(a);for(h(a);0<Q.length;)Q.shift()(a)}}}return Qe(),c.ready}})();typeof mr=="object"&&typeof Ft=="object"?Ft.exports=pr:typeof define=="function"&&define.amd&&define([],()=>pr)});var hr=tt(()=>{});var yr=tt(()=>{});var br={};At(br,{cpus:()=>rn});var rn,wr=St(()=>{rn=void 0});var _r=tt((vr,xt)=>{"use strict";var Or=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(u=u||__filename),function(c={}){function a(){return Q.buffer!=F.buffer&&Y(),F}function h(){return Q.buffer!=F.buffer&&Y(),ye}function f(){return Q.buffer!=F.buffer&&Y(),ve}function w(){return Q.buffer!=F.buffer&&Y(),fe}function g(){return Q.buffer!=F.buffer&&Y(),_e}var i=c,E,P;i.ready=new Promise((e,t)=>{E=e,P=t});var U=Object.assign({},i),D="./this.program",x=(e,t)=>{throw t},K=typeof window=="object",R=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=i.ENVIRONMENT_IS_PTHREAD||!1,k="";function W(e){return i.locateFile?i.locateFile(e,k):k+e}var H,se,ee;if(I){var S=(Mt(),rt(Tt)),j=(Dt(),rt(Ct));k=R?j.dirname(k)+"/":__dirname+"/",H=(t,n)=>(t=z(t)?new URL(t):j.normalize(t),S.readFileSync(t,n?void 0:"utf8")),ee=t=>(t=H(t,!0),t.buffer||(t=new Uint8Array(t)),t),se=(t,n,l,y=!0)=>{t=z(t)?new URL(t):j.normalize(t),S.readFile(t,y?void 0:"utf8",(b,_)=>{b?l(b):n(y?_.buffer:_)})},!i.thisProgram&&1<process.argv.length&&(D=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(t,n)=>{throw process.exitCode=t,n},i.inspect=()=>"[Emscripten Module object]";let e;try{e=hr()}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}global.Worker=e.Worker}else(K||R)&&(R?k=self.location.href:typeof document<"u"&&document.currentScript&&(k=document.currentScript.src),typeof u<"u"&&u&&(k=u),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",I||(H=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},R&&(ee=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),se=(e,t,n)=>{var l=new XMLHttpRequest;l.open("GET",e,!0),l.responseType="arraybuffer",l.onload=()=>{l.status==200||l.status==0&&l.response?t(l.response):n()},l.onerror=n,l.send(null)}));I&&typeof performance>"u"&&(global.performance=yr().performance);var Ce=console.log.bind(console),Ue=console.error.bind(console);I&&(Ce=(...e)=>S.writeSync(1,e.join(" ")+`\n`),Ue=(...e)=>S.writeSync(2,e.join(" ")+`\n`));var ce=Ce,ne=Ue;Object.assign(i,U),U=null,typeof WebAssembly!="object"&&De("no native wasm support detected");var Q,Oe,he=!1,ae,F,ye,ve,fe,_e;function Y(){var e=Q.buffer;i.HEAP8=F=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAPU8=ye=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAP32=ve=new Int32Array(e),i.HEAPU32=fe=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=_e=new Float64Array(e)}var pe=16777216;if(v)Q=i.wasmMemory;else if(i.wasmMemory)Q=i.wasmMemory;else if(Q=new WebAssembly.Memory({initial:pe/65536,maximum:65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw ne("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&ne("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),pe=Q.buffer.byteLength;var Ie=[],Ee=[],be=[],we=0,Le=null,me=null;function Se(){if(we--,we==0&&(Le!==null&&(clearInterval(Le),Le=null),me)){var e=me;me=null,e()}}function De(e){throw e="Aborted("+e+")",ne(e),he=!0,ae=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),P(e),e}var te=e=>e.startsWith("data:application/octet-stream;base64,"),z=e=>e.startsWith("file://"),le;le="ort-wasm-threaded.wasm",te(le)||(le=W(le));function Fe(e){if(ee)return ee(e);throw"both async and sync fetching of the wasm failed"}function Ae(e){if(K||R){if(typeof fetch=="function"&&!z(e))return fetch(e,{credentials:"same-origin"}).then(t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()}).catch(()=>Fe(e));if(se)return new Promise((t,n)=>{se(e,l=>t(new Uint8Array(l)),n)})}return Promise.resolve().then(()=>Fe(e))}function qe(e,t,n){return Ae(e).then(l=>WebAssembly.instantiate(l,t)).then(l=>l).then(n,l=>{ne(`failed to asynchronously prepare wasm: ${l}`),De(l)})}function at(e,t){var n=le;return typeof WebAssembly.instantiateStreaming!="function"||te(n)||z(n)||I||typeof fetch!="function"?qe(n,e,t):fetch(n,{credentials:"same-origin"}).then(l=>WebAssembly.instantiateStreaming(l,e).then(t,function(y){return ne(`wasm streaming compile failed: ${y}`),ne("falling back to ArrayBuffer instantiation"),qe(n,e,t)}))}var xe,Ne={921388:(e,t,n,l)=>{if(typeof i>"u"||!i.cb)return 1;if(e=$e(e>>>0),e.startsWith("./")&&(e=e.substring(2)),e=i.cb.get(e),!e)return 2;if(t>>>=0,n>>>=0,l>>>=0,t+n>e.byteLength)return 3;try{return h().set(e.subarray(t,t+n),l>>>0),0}catch{return 4}}};function Re(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var He=e=>{e.terminate(),e.onmessage=()=>{}},Ge=e=>{M.Pa.length==0&&(Xe(),M.Ya(M.Pa[0]));var t=M.Pa.pop();if(!t)return 6;M.Qa.push(t),M.Ma[e.Oa]=t,t.Oa=e.Oa;var n={cmd:"run",start_routine:e.kb,arg:e.hb,pthread_ptr:e.Oa};return I&&t.unref(),t.postMessage(n,e.qb),0},Be=0,Ve=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Je=(e,t,n)=>{t>>>=0;var l=t+n;for(n=t;e[n]&&!(n>=l);)++n;if(16<n-t&&e.buffer&&Ve)return Ve.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(l="";t<n;){var y=e[t++];if(y&128){var b=e[t++]&63;if((y&224)==192)l+=String.fromCharCode((y&31)<<6|b);else{var _=e[t++]&63;y=(y&240)==224?(y&15)<<12|b<<6|_:(y&7)<<18|b<<12|_<<6|e[t++]&63,65536>y?l+=String.fromCharCode(y):(y-=65536,l+=String.fromCharCode(55296|y>>10,56320|y&1023))}}else l+=String.fromCharCode(y)}return l},$e=(e,t)=>(e>>>=0)?Je(h(),e,t):"",ot=e=>{var t=vt();return e=e(),ct(t),e};function G(e,t){var n=arguments.length-2,l=arguments;return ot(()=>{for(var y=_t(8*n),b=y>>>3,_=0;_<n;_++){var J=l[2+_];g()[b+_>>>0]=J}return ar(e,n,y,t)})}function C(e){if(v)return G(0,1,e);ae=e,0<Be||(M.lb(),i.onExit?.(e),he=!0),x(e,new Re(e))}var je=e=>{if(ae=e,v)throw ut(e),"unwind";C(e)};function st(){for(var e=i.numThreads;e--;)Xe();Ie.unshift(()=>{we++,it(()=>Se())})}function Xe(){var e=W("ort-wasm-threaded.worker.js");e=new Worker(e),M.Pa.push(e)}function it(e){v?e():Promise.all(M.Pa.map(M.Ya)).then(e)}var M={Pa:[],Qa:[],bb:[],Ma:{},Wa(){v?(M.receiveObjectTransfer=M.jb,M.threadInitTLS=M.ab,M.setExitStatus=M.$a):st()},$a:e=>ae=e,tb:["$terminateWorker"],lb:()=>{for(var e of M.Qa)He(e);for(e of M.Pa)He(e);M.Pa=[],M.Qa=[],M.Ma=[]},Za:e=>{var t=e.Oa;delete M.Ma[t],M.Pa.push(e),M.Qa.splice(M.Qa.indexOf(e),1),e.Oa=0,wt(t)},jb(){},ab(){M.bb.forEach(e=>e())},Ya:e=>new Promise(t=>{e.onmessage=b=>{b=b.data;var _=b.cmd;if(b.targetThread&&b.targetThread!=lt()){var J=M.Ma[b.targetThread];J?J.postMessage(b,b.transferList):ne(`Internal error! Worker sent a message "${_}" to target pthread ${b.targetThread}, but that thread no longer exists!`)}else _==="checkMailbox"?ft():_==="spawnThread"?Ge(b):_==="cleanupThread"?M.Za(M.Ma[b.thread]):_==="killThread"?(b=b.thread,_=M.Ma[b],delete M.Ma[b],He(_),wt(b),M.Qa.splice(M.Qa.indexOf(_),1),_.Oa=0):_==="cancelThread"?M.Ma[b.thread].postMessage({cmd:"cancel"}):_==="loaded"?(e.loaded=!0,I&&!e.Oa&&e.unref(),t(e)):_==="alert"?alert(`Thread ${b.threadId}: ${b.text}`):b.target==="setimmediate"?e.postMessage(b):_==="callHandler"?i[b.handler](...b.args):_&&ne(`worker sent an unknown command ${_}`)},e.onerror=b=>{throw ne(`worker sent an error! ${b.filename}:${b.lineno}: ${b.message}`),b},I&&(e.on("message",b=>e.onmessage({data:b})),e.on("error",b=>e.onerror(b)));var n=[],l=["onExit"],y;for(y of l)i.hasOwnProperty(y)&&n.push(y);e.postMessage({cmd:"load",handlers:n,urlOrBlob:i.mainScriptUrlOrBlob||u,wasmMemory:Q,wasmModule:Oe})})};i.PThread=M;var ke=e=>{for(;0<e.length;)e.shift()(i)};i.establishStackSpace=()=>{var e=lt(),t=w()[e+52>>>2>>>0];e=w()[e+56>>>2>>>0],ir(t,t-e),ct(t)};function ut(e){if(v)return G(1,0,e);je(e)}var Pe=[],Qe;i.invokeEntryPoint=(e,t)=>{var n=Pe[e];n||(e>=Pe.length&&(Pe.length=e+1),Pe[e]=n=Qe.get(e)),e=n(t),0<Be?M.$a(e):Ot(e)};function r(e){this.Va=e-24,this.gb=function(t){w()[this.Va+4>>>2>>>0]=t},this.fb=function(t){w()[this.Va+8>>>2>>>0]=t},this.Wa=function(t,n){this.eb(),this.gb(t),this.fb(n)},this.eb=function(){w()[this.Va+16>>>2>>>0]=0}}var o=0,s=0;function m(e,t,n,l){return v?G(2,1,e,t,n,l):O(e,t,n,l)}function O(e,t,n,l){if(e>>>=0,t>>>=0,n>>>=0,l>>>=0,typeof SharedArrayBuffer>"u")return ne("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var y=[];return v&&y.length===0?m(e,t,n,l):(e={kb:n,Oa:e,hb:l,qb:y},v?(e.sb="spawnThread",postMessage(e,y),0):Ge(e))}function A(e,t,n){return v?G(3,1,e,t,n):0}function L(e,t){if(v)return G(4,1,e,t)}var re=e=>{for(var t=0,n=0;n<e.length;++n){var l=e.charCodeAt(n);127>=l?t++:2047>=l?t+=2:55296<=l&&57343>=l?(t+=4,++n):t+=3}return t},de=(e,t,n,l)=>{if(n>>>=0,!(0<l))return 0;var y=n;l=n+l-1;for(var b=0;b<e.length;++b){var _=e.charCodeAt(b);if(55296<=_&&57343>=_){var J=e.charCodeAt(++b);_=65536+((_&1023)<<10)|J&1023}if(127>=_){if(n>=l)break;t[n++>>>0]=_}else{if(2047>=_){if(n+1>=l)break;t[n++>>>0]=192|_>>6}else{if(65535>=_){if(n+2>=l)break;t[n++>>>0]=224|_>>12}else{if(n+3>=l)break;t[n++>>>0]=240|_>>18,t[n++>>>0]=128|_>>12&63}t[n++>>>0]=128|_>>6&63}t[n++>>>0]=128|_&63}}return t[n>>>0]=0,n-y},ie=(e,t,n)=>de(e,h(),t,n);function ue(e,t){if(v)return G(5,1,e,t)}function Ze(e,t,n){if(v)return G(6,1,e,t,n)}function Ke(e,t,n){return v?G(7,1,e,t,n):0}function d(e,t){if(v)return G(8,1,e,t)}function B(e,t,n){if(v)return G(9,1,e,t,n)}function $(e,t,n,l){if(v)return G(10,1,e,t,n,l)}function Te(e,t,n,l){if(v)return G(11,1,e,t,n,l)}function et(e,t,n,l){if(v)return G(12,1,e,t,n,l)}function Bt(e){if(v)return G(13,1,e)}function kt(e,t){if(v)return G(14,1,e,t)}function Wt(e,t,n){if(v)return G(15,1,e,t,n)}function mt(e){e>>>=0,typeof Atomics.rb=="function"&&(Atomics.rb(f(),e>>>2,e).value.then(ft),e+=128,Atomics.store(f(),e>>>2,1))}i.__emscripten_thread_mailbox_await=mt;var ft=()=>{var e=lt();if(e&&(mt(e),e=or,!he))try{if(e(),!(0<Be))try{v?Ot(ae):je(ae)}catch(t){t instanceof Re||t=="unwind"||x(1,t)}}catch(t){t instanceof Re||t=="unwind"||x(1,t)}};i.checkMailbox=ft;var gt=[],Ye=e=>e%4===0&&(e%100!==0||e%400===0),Nt=[0,31,60,91,121,152,182,213,244,274,305,335],Ht=[0,31,59,90,120,151,181,212,243,273,304,334];function Gt(e,t,n,l,y,b,_,J){return v?G(16,1,e,t,n,l,y,b,_,J):-52}function $t(e,t,n,l,y,b,_){if(v)return G(17,1,e,t,n,l,y,b,_)}var jt=e=>{var t=re(e)+1,n=rr(t);return n&&ie(e,n,t),n},ht=[],yt={},Yt=()=>{if(!bt){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:D||"./this.program"},t;for(t in yt)yt[t]===void 0?delete e[t]:e[t]=yt[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);bt=n}return bt},bt;function zt(e,t){if(v)return G(18,1,e,t);e>>>=0,t>>>=0;var n=0;return Yt().forEach((l,y)=>{var b=t+n;for(y=w()[e+4*y>>>2>>>0]=b,b=0;b<l.length;++b)a()[y++>>>0>>>0]=l.charCodeAt(b);a()[y>>>0>>>0]=0,n+=l.length+1}),0}function qt(e,t){if(v)return G(19,1,e,t);e>>>=0,t>>>=0;var n=Yt();w()[e>>>2>>>0]=n.length;var l=0;return n.forEach(y=>l+=y.length+1),w()[t>>>2>>>0]=l,0}function Vt(e){return v?G(20,1,e):52}function Jt(e,t,n,l){return v?G(21,1,e,t,n,l):52}function Xt(e,t,n,l,y){return v?G(22,1,e,t,n,l,y):70}var $r=[null,[],[]];function Qt(e,t,n,l){if(v)return G(23,1,e,t,n,l);t>>>=0,n>>>=0,l>>>=0;for(var y=0,b=0;b<n;b++){var _=w()[t>>>2>>>0],J=w()[t+4>>>2>>>0];t+=8;for(var Me=0;Me<J;Me++){var oe=h()[_+Me>>>0],ge=$r[e];oe===0||oe===10?((e===1?ce:ne)(Je(ge,0)),ge.length=0):ge.push(oe)}y+=J}return w()[l>>>2>>>0]=y,0}var Zt=[31,29,31,30,31,30,31,31,30,31,30,31],Kt=[31,28,31,30,31,30,31,31,30,31,30,31];function jr(e){var t=Array(re(e)+1);return de(e,t,0,t.length),t}var Yr=(e,t)=>{a().set(e,t>>>0)};function er(e,t,n,l){function y(p,N,X){for(p=typeof p=="number"?p.toString():p||"";p.length<N;)p=X[0]+p;return p}function b(p,N){return y(p,N,"0")}function _(p,N){function X(cr){return 0>cr?-1:0<cr?1:0}var We;return(We=X(p.getFullYear()-N.getFullYear()))===0&&(We=X(p.getMonth()-N.getMonth()))===0&&(We=X(p.getDate()-N.getDate())),We}function J(p){switch(p.getDay()){case 0:return new Date(p.getFullYear()-1,11,29);case 1:return p;case 2:return new Date(p.getFullYear(),0,3);case 3:return new Date(p.getFullYear(),0,2);case 4:return new Date(p.getFullYear(),0,1);case 5:return new Date(p.getFullYear()-1,11,31);case 6:return new Date(p.getFullYear()-1,11,30)}}function Me(p){var N=p.Ra;for(p=new Date(new Date(p.Sa+1900,0,1).getTime());0<N;){var X=p.getMonth(),We=(Ye(p.getFullYear())?Zt:Kt)[X];if(N>We-p.getDate())N-=We-p.getDate()+1,p.setDate(1),11>X?p.setMonth(X+1):(p.setMonth(0),p.setFullYear(p.getFullYear()+1));else{p.setDate(p.getDate()+N);break}}return X=new Date(p.getFullYear()+1,0,4),N=J(new Date(p.getFullYear(),0,4)),X=J(X),0>=_(N,p)?0>=_(X,p)?p.getFullYear()+1:p.getFullYear():p.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,l>>>=0;var oe=w()[l+40>>>2>>>0];l={ob:f()[l>>>2>>>0],nb:f()[l+4>>>2>>>0],Ta:f()[l+8>>>2>>>0],Xa:f()[l+12>>>2>>>0],Ua:f()[l+16>>>2>>>0],Sa:f()[l+20>>>2>>>0],Na:f()[l+24>>>2>>>0],Ra:f()[l+28>>>2>>>0],ub:f()[l+32>>>2>>>0],mb:f()[l+36>>>2>>>0],pb:oe?$e(oe):""},n=$e(n),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ge in oe)n=n.replace(new RegExp(ge,"g"),oe[ge]);var fr="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),lr="January February March April May June July August September October November December".split(" ");oe={"%a":p=>fr[p.Na].substring(0,3),"%A":p=>fr[p.Na],"%b":p=>lr[p.Ua].substring(0,3),"%B":p=>lr[p.Ua],"%C":p=>b((p.Sa+1900)/100|0,2),"%d":p=>b(p.Xa,2),"%e":p=>y(p.Xa,2," "),"%g":p=>Me(p).toString().substring(2),"%G":p=>Me(p),"%H":p=>b(p.Ta,2),"%I":p=>(p=p.Ta,p==0?p=12:12<p&&(p-=12),b(p,2)),"%j":p=>{for(var N=0,X=0;X<=p.Ua-1;N+=(Ye(p.Sa+1900)?Zt:Kt)[X++]);return b(p.Xa+N,3)},"%m":p=>b(p.Ua+1,2),"%M":p=>b(p.nb,2),"%n":()=>`\n`,"%p":p=>0<=p.Ta&&12>p.Ta?"AM":"PM","%S":p=>b(p.ob,2),"%t":()=>"	","%u":p=>p.Na||7,"%U":p=>b(Math.floor((p.Ra+7-p.Na)/7),2),"%V":p=>{var N=Math.floor((p.Ra+7-(p.Na+6)%7)/7);if(2>=(p.Na+371-p.Ra-2)%7&&N++,N)N==53&&(X=(p.Na+371-p.Ra)%7,X==4||X==3&&Ye(p.Sa)||(N=1));else{N=52;var X=(p.Na+7-p.Ra-1)%7;(X==4||X==5&&Ye(p.Sa%400-1))&&N++}return b(N,2)},"%w":p=>p.Na,"%W":p=>b(Math.floor((p.Ra+7-(p.Na+6)%7)/7),2),"%y":p=>(p.Sa+1900).toString().substring(2),"%Y":p=>p.Sa+1900,"%z":p=>{p=p.mb;var N=0<=p;return p=Math.abs(p)/60,(N?"+":"-")+("0000"+(p/60*100+p%60)).slice(-4)},"%Z":p=>p.pb,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0");for(ge in oe)n.includes(ge)&&(n=n.replace(new RegExp(ge,"g"),oe[ge](l)));return n=n.replace(/\\0\\0/g,"%"),ge=jr(n),ge.length>t?0:(Yr(ge,e),ge.length-1)}M.Wa();var zr=[C,ut,m,A,L,ue,Ze,Ke,d,B,$,Te,et,Bt,kt,Wt,Gt,$t,zt,qt,Vt,Jt,Xt,Qt],qr={b:function(e,t,n){throw e>>>=0,new r(e).Wa(t>>>0,n>>>0),o=e,s++,o},L:function(e){nr(e>>>0,!R,1,!K,131072,!1),M.ab()},j:function(e){e>>>=0,v?postMessage({cmd:"cleanupThread",thread:e}):M.Za(M.Ma[e])},H:O,h:A,S:L,D:ue,F:Ze,T:Ke,Q:d,J:B,P:$,n:Te,E:et,B:Bt,R:kt,C:Wt,p:()=>1,z:function(e,t){e>>>=0,e==t>>>0?setTimeout(()=>ft()):v?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=M.Ma[e])&&e.postMessage({cmd:"checkMailbox"})},I:function(e,t,n,l){t>>>=0,gt.length=n,l=l>>>0>>>3;for(var y=0;y<n;y++)gt[y]=g()[l+y>>>0];return e=0>e?Ne[-e-1]:zr[e],M.ib=t,t=e.apply(null,gt),M.ib=0,t},K:mt,o:function(e){I&&M.Ma[e>>>0].ref()},s:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getUTCSeconds(),f()[n+4>>>2>>>0]=e.getUTCMinutes(),f()[n+8>>>2>>>0]=e.getUTCHours(),f()[n+12>>>2>>>0]=e.getUTCDate(),f()[n+16>>>2>>>0]=e.getUTCMonth(),f()[n+20>>>2>>>0]=e.getUTCFullYear()-1900,f()[n+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,f()[n+28>>>2>>>0]=e},t:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getSeconds(),f()[n+4>>>2>>>0]=e.getMinutes(),f()[n+8>>>2>>>0]=e.getHours(),f()[n+12>>>2>>>0]=e.getDate(),f()[n+16>>>2>>>0]=e.getMonth(),f()[n+20>>>2>>>0]=e.getFullYear()-1900,f()[n+24>>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?Nt:Ht)[e.getMonth()]+e.getDate()-1|0,f()[n+28>>>2>>>0]=t,f()[n+36>>>2>>>0]=-(60*e.getTimezoneOffset()),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var l=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=(t!=l&&e.getTimezoneOffset()==Math.min(l,t))|0,f()[n+32>>>2>>>0]=e},u:function(e){e>>>=0;var t=new Date(f()[e+20>>>2>>>0]+1900,f()[e+16>>>2>>>0],f()[e+12>>>2>>>0],f()[e+8>>>2>>>0],f()[e+4>>>2>>>0],f()[e>>>2>>>0],0),n=f()[e+32>>>2>>>0],l=t.getTimezoneOffset(),y=new Date(t.getFullYear(),6,1).getTimezoneOffset(),b=new Date(t.getFullYear(),0,1).getTimezoneOffset(),_=Math.min(b,y);return 0>n?f()[e+32>>>2>>>0]=+(y!=b&&_==l):0<n!=(_==l)&&(y=Math.max(b,y),t.setTime(t.getTime()+6e4*((0<n?_:y)-l))),f()[e+24>>>2>>>0]=t.getDay(),n=(Ye(t.getFullYear())?Nt:Ht)[t.getMonth()]+t.getDate()-1|0,f()[e+28>>>2>>>0]=n,f()[e>>>2>>>0]=t.getSeconds(),f()[e+4>>>2>>>0]=t.getMinutes(),f()[e+8>>>2>>>0]=t.getHours(),f()[e+12>>>2>>>0]=t.getDate(),f()[e+16>>>2>>>0]=t.getMonth(),f()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),isNaN(e)?(f()[tr()>>>2>>>0]=61,e=-1):e/=1e3,sr((xe=e,1<=+Math.abs(xe)?0<xe?+Math.floor(xe/4294967296)>>>0:~~+Math.ceil((xe-+(~~xe>>>0))/4294967296)>>>0:0)),e>>>0},q:Gt,r:$t,y:function(e,t,n){function l(oe){return(oe=oe.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?oe[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var y=new Date().getFullYear(),b=new Date(y,0,1),_=new Date(y,6,1);y=b.getTimezoneOffset();var J=_.getTimezoneOffset(),Me=Math.max(y,J);w()[e>>>2>>>0]=60*Me,f()[t>>>2>>>0]=+(y!=J),e=l(b),t=l(_),e=jt(e),t=jt(t),J<y?(w()[n>>>2>>>0]=e,w()[n+4>>>2>>>0]=t):(w()[n>>>2>>>0]=t,w()[n+4>>>2>>>0]=e)},c:()=>{De("")},O:function(e,t,n){e>>>=0,t>>>=0,n>>>=0,ht.length=0;for(var l;l=h()[t++>>>0];){var y=l!=105;y&=l!=112,n+=y&&n%8?4:0,ht.push(l==112?w()[n>>>2>>>0]:l==105?f()[n>>>2>>>0]:g()[n>>>3>>>0]),n+=y?8:4}return Ne[e].apply(null,ht)},k:()=>{},i:()=>Date.now(),U:()=>{throw Be+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>I?(wr(),rt(br)).cpus().length:navigator.hardwareConcurrency,x:function(e){e>>>=0;var t=h().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var l=t*(1+.2/n);l=Math.min(l,e+100663296);var y=Math;l=Math.max(e,l);e:{y=(y.min.call(y,4294901760,l+(65536-l%65536)%65536)-Q.buffer.byteLength+65535)/65536;try{Q.grow(y),Y();var b=1;break e}catch{}b=void 0}if(b)return!0}return!1},M:zt,N:qt,G:je,g:Vt,m:Jt,v:Xt,l:Qt,a:Q||i.wasmMemory,w:er,d:function(e,t,n,l){return er(e>>>0,t>>>0,n>>>0,l>>>0)}},T=function(){function e(n,l){return T=n.exports,T=Vr(),M.bb.push(T.za),Qe=T.Aa,Ee.unshift(T.V),Oe=l,Se(),T}var t={a:qr};if(we++,i.instantiateWasm)try{return i.instantiateWasm(t,e)}catch(n){ne(`Module.instantiateWasm callback failed with error: ${n}`),P(n)}return at(t,function(n){e(n.instance,n.module)}).catch(P),{}}();i._OrtInit=(e,t)=>(i._OrtInit=T.W)(e,t),i._OrtGetLastError=(e,t)=>(i._OrtGetLastError=T.X)(e,t),i._OrtCreateSessionOptions=(e,t,n,l,y,b,_,J,Me,oe)=>(i._OrtCreateSessionOptions=T.Y)(e,t,n,l,y,b,_,J,Me,oe),i._OrtAppendExecutionProvider=(e,t)=>(i._OrtAppendExecutionProvider=T.Z)(e,t),i._OrtAddFreeDimensionOverride=(e,t,n)=>(i._OrtAddFreeDimensionOverride=T._)(e,t,n),i._OrtAddSessionConfigEntry=(e,t,n)=>(i._OrtAddSessionConfigEntry=T.$)(e,t,n),i._OrtReleaseSessionOptions=e=>(i._OrtReleaseSessionOptions=T.aa)(e),i._OrtCreateSession=(e,t,n)=>(i._OrtCreateSession=T.ba)(e,t,n),i._OrtReleaseSession=e=>(i._OrtReleaseSession=T.ca)(e),i._OrtGetInputOutputCount=(e,t,n)=>(i._OrtGetInputOutputCount=T.da)(e,t,n),i._OrtGetInputName=(e,t)=>(i._OrtGetInputName=T.ea)(e,t),i._OrtGetOutputName=(e,t)=>(i._OrtGetOutputName=T.fa)(e,t),i._OrtFree=e=>(i._OrtFree=T.ga)(e),i._OrtCreateTensor=(e,t,n,l,y,b)=>(i._OrtCreateTensor=T.ha)(e,t,n,l,y,b),i._OrtGetTensorData=(e,t,n,l,y)=>(i._OrtGetTensorData=T.ia)(e,t,n,l,y),i._OrtReleaseTensor=e=>(i._OrtReleaseTensor=T.ja)(e),i._OrtCreateRunOptions=(e,t,n,l)=>(i._OrtCreateRunOptions=T.ka)(e,t,n,l),i._OrtAddRunConfigEntry=(e,t,n)=>(i._OrtAddRunConfigEntry=T.la)(e,t,n),i._OrtReleaseRunOptions=e=>(i._OrtReleaseRunOptions=T.ma)(e),i._OrtCreateBinding=e=>(i._OrtCreateBinding=T.na)(e),i._OrtBindInput=(e,t,n)=>(i._OrtBindInput=T.oa)(e,t,n),i._OrtBindOutput=(e,t,n,l)=>(i._OrtBindOutput=T.pa)(e,t,n,l),i._OrtClearBoundOutputs=e=>(i._OrtClearBoundOutputs=T.qa)(e),i._OrtReleaseBinding=e=>(i._OrtReleaseBinding=T.ra)(e),i._OrtRunWithBinding=(e,t,n,l,y)=>(i._OrtRunWithBinding=T.sa)(e,t,n,l,y),i._OrtRun=(e,t,n,l,y,b,_,J)=>(i._OrtRun=T.ta)(e,t,n,l,y,b,_,J),i._OrtEndProfiling=e=>(i._OrtEndProfiling=T.ua)(e);var tr=()=>(tr=T.va)(),lt=i._pthread_self=()=>(lt=i._pthread_self=T.wa)(),rr=i._malloc=e=>(rr=i._malloc=T.xa)(e);i._free=e=>(i._free=T.ya)(e),i.__emscripten_tls_init=()=>(i.__emscripten_tls_init=T.za)();var nr=i.__emscripten_thread_init=(e,t,n,l,y,b)=>(nr=i.__emscripten_thread_init=T.Ba)(e,t,n,l,y,b);i.__emscripten_thread_crashed=()=>(i.__emscripten_thread_crashed=T.Ca)();var ar=(e,t,n,l)=>(ar=T.Da)(e,t,n,l),wt=e=>(wt=T.Ea)(e),Ot=i.__emscripten_thread_exit=e=>(Ot=i.__emscripten_thread_exit=T.Fa)(e),or=()=>(or=T.Ga)(),sr=e=>(sr=T.Ha)(e),ir=(e,t)=>(ir=T.Ia)(e,t),vt=()=>(vt=T.Ja)(),ct=e=>(ct=T.Ka)(e),_t=e=>(_t=T.La)(e);function Vr(){var e=T;e=Object.assign({},e);var t=l=>()=>l()>>>0,n=l=>y=>l(y)>>>0;return e.va=t(e.va),e.wa=t(e.wa),e.xa=n(e.xa),e.emscripten_main_runtime_thread_id=t(e.emscripten_main_runtime_thread_id),e.Ja=t(e.Ja),e.La=n(e.La),e}i.wasmMemory=Q,i.stackAlloc=_t,i.stackSave=vt,i.stackRestore=ct,i.keepRuntimeAlive=()=>0<Be,i.UTF8ToString=$e,i.stringToUTF8=ie,i.lengthBytesUTF8=re,i.ExitStatus=Re,i.PThread=M;var dt;me=function e(){dt||ur(),dt||(me=e)};function ur(){if(!(0<we))if(v)E(i),v||ke(Ee),startWorker(i);else{if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)Ie.unshift(i.preRun.shift());ke(Ie),0<we||dt||(dt=!0,i.calledRun=!0,he||(v||ke(Ee),E(i),v||ke(be)))}}return ur(),c.ready}})();typeof vr=="object"&&typeof xt=="object"?xt.exports=Or:typeof define=="function"&&define.amd&&define([],()=>Or)});var Er=tt((On,nn)=>{nn.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\n\'});var Ar;Ar=gr();var an=_r(),Pt,Ut=!1,pt=!1,Sr=!1,on=u=>{if(u===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+u+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+u+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},sn=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},un=(u,c)=>u?c?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":c?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Tr=async u=>{if(Ut)return Promise.resolve();if(pt)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Sr)throw new Error("previous call to \'initializeWebAssembly()\' failed.");pt=!0;let c=u.initTimeout,a=u.numThreads,h=u.simd,f=on(a),w=h&&sn(),g=u.wasmPaths,i=typeof g=="string"?g:void 0,E=un(w,f),P=typeof g=="object"?g[E]:void 0,U=!1,D=[];if(c>0&&D.push(new Promise(x=>{setTimeout(()=>{U=!0,x()},c)})),D.push(new Promise((x,K)=>{let R=f?an:Ar,I={locateFile:(v,k)=>f&&v.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([Er()],{type:"text/javascript"})):v.endsWith(".wasm")?P||(i??k)+E:k+v};if(f)if(I.numThreads=a,typeof Blob>"u")I.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let v=`var ortWasmThreaded=${R.toString()};`;I.mainScriptUrlOrBlob=new Blob([v],{type:"text/javascript"})}R(I).then(v=>{pt=!1,Ut=!0,Pt=v,x()},v=>{pt=!1,Sr=!0,K(v)})})),await Promise.race(D),U)throw new Error(`WebAssembly backend initializing failed due to timeout: ${c}ms`)},Z=()=>{if(Ut&&Pt)return Pt;throw new Error("WebAssembly is not initialized yet.")};var q=(u,c)=>{let a=Z(),h=a.lengthBytesUTF8(u)+1,f=a._malloc(h);return a.stringToUTF8(u,f,h),c.push(f),f},nt=(u,c,a,h)=>{if(typeof u=="object"&&u!==null){if(a.has(u))throw new Error("Circular reference in options");a.add(u)}Object.entries(u).forEach(([f,w])=>{let g=c?c+f:f;if(typeof w=="object")nt(w,g+".",a,h);else if(typeof w=="string"||typeof w=="number")h(g,w.toString());else if(typeof w=="boolean")h(g,w?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof w}`)})},V=u=>{let c=Z(),a=c.stackSave();try{let h=c.stackAlloc(8);c._OrtGetLastError(h,h+4);let f=c.HEAP32[h/4],w=c.HEAPU32[h/4+1],g=w?c.UTF8ToString(w):"";throw new Error(`${u} ERROR_CODE: ${f}, ERROR_MESSAGE: ${g}`)}finally{c.stackRestore(a)}};var Mr=u=>{let c=Z(),a=0,h=[],f=u||{};try{if(u?.logSeverityLevel===void 0)f.logSeverityLevel=2;else if(typeof u.logSeverityLevel!="number"||!Number.isInteger(u.logSeverityLevel)||u.logSeverityLevel<0||u.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${u.logSeverityLevel}`);if(u?.logVerbosityLevel===void 0)f.logVerbosityLevel=0;else if(typeof u.logVerbosityLevel!="number"||!Number.isInteger(u.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${u.logVerbosityLevel}`);u?.terminate===void 0&&(f.terminate=!1);let w=0;return u?.tag!==void 0&&(w=q(u.tag,h)),a=c._OrtCreateRunOptions(f.logSeverityLevel,f.logVerbosityLevel,!!f.terminate,w),a===0&&V("Can\'t create run options."),u?.extra!==void 0&&nt(u.extra,"",new WeakSet,(g,i)=>{let E=q(g,h),P=q(i,h);c._OrtAddRunConfigEntry(a,E,P)!==0&&V(`Can\'t set a run config entry: ${g} - ${i}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseRunOptions(a),h.forEach(g=>c._free(g)),w}};var fn=u=>{switch(u){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${u}`)}},ln=u=>{switch(u){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${u}`)}},cn=u=>{u.extra||(u.extra={}),u.extra.session||(u.extra.session={});let c=u.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1"),u.executionProviders&&u.executionProviders.some(a=>(typeof a=="string"?a:a.name)==="webgpu")&&(u.enableMemPattern=!1)},dn=(u,c,a)=>{for(let h of c){let f=typeof h=="string"?h:h.name;switch(f){case"webnn":if(f="WEBNN",typeof h!="string"){let g=h;if(g?.deviceType){let i=q("deviceType",a),E=q(g.deviceType,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\'t set a session config entry: \'deviceType\' - ${g.deviceType}.`)}if(g?.numThreads){let i=g.numThreads;(typeof i!="number"||!Number.isInteger(i)||i<0)&&(i=0);let E=q("numThreads",a),P=q(i.toString(),a);Z()._OrtAddSessionConfigEntry(u,E,P)!==0&&V(`Can\'t set a session config entry: \'numThreads\' - ${g.numThreads}.`)}if(g?.powerPreference){let i=q("powerPreference",a),E=q(g.powerPreference,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\'t set a session config entry: \'powerPreference\' - ${g.powerPreference}.`)}}break;case"webgpu":if(f="JS",typeof h!="string"){let g=h;if(g?.preferredLayout){if(g.preferredLayout!=="NCHW"&&g.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${g.preferredLayout}`);let i=q("preferredLayout",a),E=q(g.preferredLayout,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\'t set a session config entry: \'preferredLayout\' - ${g.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${f}`)}let w=q(f,a);Z()._OrtAppendExecutionProvider(u,w)!==0&&V(`Can\'t append execution provider: ${f}.`)}},Cr=u=>{let c=Z(),a=0,h=[],f=u||{};cn(f);try{let w=fn(f.graphOptimizationLevel??"all"),g=ln(f.executionMode??"sequential"),i=typeof f.logId=="string"?q(f.logId,h):0,E=f.logSeverityLevel??2;if(!Number.isInteger(E)||E<0||E>4)throw new Error(`log serverity level is not valid: ${E}`);let P=f.logVerbosityLevel??0;if(!Number.isInteger(P)||P<0||P>4)throw new Error(`log verbosity level is not valid: ${P}`);let U=typeof f.optimizedModelFilePath=="string"?q(f.optimizedModelFilePath,h):0;if(a=c._OrtCreateSessionOptions(w,!!f.enableCpuMemArena,!!f.enableMemPattern,g,!!f.enableProfiling,0,i,E,P,U),a===0&&V("Can\'t create session options."),f.executionProviders&&dn(a,f.executionProviders,h),f.enableGraphCapture!==void 0){if(typeof f.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${f.enableGraphCapture}`);let D=q("enableGraphCapture",h),x=q(f.enableGraphCapture.toString(),h);c._OrtAddSessionConfigEntry(a,D,x)!==0&&V(`Can\'t set a session config entry: \'enableGraphCapture\' - ${f.enableGraphCapture}.`)}if(f.freeDimensionOverrides)for(let[D,x]of Object.entries(f.freeDimensionOverrides)){if(typeof D!="string")throw new Error(`free dimension override name must be a string: ${D}`);if(typeof x!="number"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let K=q(D,h);c._OrtAddFreeDimensionOverride(a,K,x)!==0&&V(`Can\'t set a free dimension override: ${D} - ${x}.`)}return f.extra!==void 0&&nt(f.extra,"",new WeakSet,(D,x)=>{let K=q(D,h),R=q(x,h);c._OrtAddSessionConfigEntry(a,K,R)!==0&&V(`Can\'t set a session config entry: ${D} - ${x}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseSessionOptions(a),h.forEach(g=>c._free(g)),w}};var Rt=u=>{switch(u){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${u}`)}},Dr=u=>{switch(u){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${u}`)}},It=u=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][u],Fr=u=>{switch(u){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${u}`)}},xr=u=>{switch(u){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${u}`)}},Pr=u=>u==="float32"||u==="float16"||u==="int32"||u==="int64"||u==="uint32"||u==="uint8"||u==="bool",Ur=u=>{switch(u){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${u}`)}};var Rr=async u=>{if(typeof u=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(u))}catch(c){if(c.code==="ERR_FS_FILE_TOO_LARGE"){let a=(void 0)(u),h=[];for await(let f of a)h.push(f);return new Uint8Array(Buffer.concat(h))}throw c}else{let c=await fetch(u);if(!c.ok)throw new Error(`failed to load external data file: ${u}`);let a=c.headers.get("Content-Length"),h=a?parseInt(a,10):0;if(h<1073741824)return new Uint8Array(await c.arrayBuffer());{if(!c.body)throw new Error(`failed to load external data file: ${u}, no response body.`);let f=c.body.getReader(),w;try{w=new ArrayBuffer(h)}catch(i){if(i instanceof RangeError){let E=Math.ceil(h/65536);w=new WebAssembly.Memory({initial:E,maximum:E}).buffer}else throw i}let g=0;for(;;){let{done:i,value:E}=await f.read();if(i)break;let P=E.byteLength;new Uint8Array(w,g,P).set(E),g+=P}return new Uint8Array(w,0,h)}}else return u instanceof Blob?new Uint8Array(await u.arrayBuffer()):u instanceof Uint8Array?u:new Uint8Array(u)};var pn=(u,c)=>{Z()._OrtInit(u,c)!==0&&V("Can\'t initialize onnxruntime.")},Lr=async u=>{pn(u.wasm.numThreads,xr(u.logLevel))},Br=async(u,c)=>{},ze=new Map,mn=u=>{let c=Z(),a=c.stackSave();try{let h=c.stackAlloc(8);return c._OrtGetInputOutputCount(u,h,h+4)!==0&&V("Can\'t get session input/output count."),[c.HEAP32[h/4],c.HEAP32[h/4+1]]}finally{c.stackRestore(a)}},Lt=u=>{let c=Z(),a=c._malloc(u.byteLength);if(a===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${u.byteLength}.`);return c.HEAPU8.set(u,a),[a,u.byteLength]},kr=async(u,c)=>{let a,h,f=Z();Array.isArray(u)?[a,h]=u:u.buffer===f.HEAPU8.buffer?[a,h]=[u.byteOffset,u.byteLength]:[a,h]=Lt(u);let w=0,g=0,i=0,E=[],P=[],U=[];try{if([g,E]=Cr(c),c?.externalData&&f.mountExternalData){let W=[];for(let H of c.externalData){let se=typeof H=="string"?H:H.path;W.push(Rr(typeof H=="string"?H:H.data).then(ee=>{f.mountExternalData(se,ee)}))}await Promise.all(W)}w=await f._OrtCreateSession(a,h,g),w===0&&V("Can\'t create a session.");let[D,x]=mn(w),K=!!c?.enableGraphCapture,R=[],I=[],v=[];for(let W=0;W<D;W++){let H=f._OrtGetInputName(w,W);H===0&&V("Can\'t get an input name."),P.push(H),R.push(f.UTF8ToString(H))}for(let W=0;W<x;W++){let H=f._OrtGetOutputName(w,W);H===0&&V("Can\'t get an output name."),U.push(H);let se=f.UTF8ToString(H);I.push(se)}let k=null;return ze.set(w,[w,P,U,k,K,!1]),[w,R,I]}catch(D){throw P.forEach(x=>f._OrtFree(x)),U.forEach(x=>f._OrtFree(x)),i!==0&&f._OrtReleaseBinding(i),w!==0&&f._OrtReleaseSession(w),D}finally{f._free(a),g!==0&&f._OrtReleaseSessionOptions(g),E.forEach(D=>f._free(D)),f.unmountExternalData?.()}},Wr=u=>{let c=Z(),a=ze.get(u);if(!a)throw new Error(`cannot release session. invalid session id: ${u}`);let[h,f,w,g,i]=a;g&&(i&&c._OrtClearBoundOutputs(g.handle),c._OrtReleaseBinding(g.handle)),c.jsepOnReleaseSession?.(u),f.forEach(E=>c._OrtFree(E)),w.forEach(E=>c._OrtFree(E)),c._OrtReleaseSession(h),ze.delete(u)},Ir=(u,c,a,h,f,w=!1)=>{if(!u){c.push(0);return}let g=Z(),i=u[0],E=u[1],P=u[3],U,D;if(i==="string"&&P==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(w&&P!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${f} when enableGraphCapture is true.`);if(P==="gpu-buffer"){let R=u[2].gpuBuffer,I=It(Rt(i));D=E.reduce((k,W)=>k*W,1)*I;let v=g.jsepRegisterBuffer;if(!v)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');U=v(h,f,R,D)}else{let R=u[2];if(Array.isArray(R)){D=4*R.length,U=g._malloc(D),a.push(U);let I=U/4;for(let v=0;v<R.length;v++){if(typeof R[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);g.HEAPU32[I++]=q(R[v],a)}}else D=R.byteLength,U=g._malloc(D),a.push(U),g.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,D),U)}let x=g.stackSave(),K=g.stackAlloc(4*E.length);try{let R=K/4;E.forEach(v=>g.HEAP32[R++]=v);let I=g._OrtCreateTensor(Rt(i),U,D,K,E.length,Ur(P));I===0&&V(`Can\'t create tensor for input/output. session=${h}, index=${f}.`),c.push(I)}finally{g.stackRestore(x)}},Nr=async(u,c,a,h,f,w)=>{let g=Z(),i=ze.get(u);if(!i)throw new Error(`cannot run inference. invalid session id: ${u}`);let E=i[0],P=i[1],U=i[2],D=i[3],x=i[4],K=i[5],R=c.length,I=h.length,v=0,k=[],W=[],H=[],se=[],ee=g.stackSave(),S=g.stackAlloc(R*4),j=g.stackAlloc(R*4),Ce=g.stackAlloc(I*4),Ue=g.stackAlloc(I*4);try{[v,k]=Mr(w);for(let F=0;F<R;F++)Ir(a[F],W,se,u,c[F],x);for(let F=0;F<I;F++)Ir(f[F],H,se,u,R+h[F],x);let ce=S/4,ne=j/4,Q=Ce/4,Oe=Ue/4;for(let F=0;F<R;F++)g.HEAPU32[ce++]=W[F],g.HEAPU32[ne++]=P[c[F]];for(let F=0;F<I;F++)g.HEAPU32[Q++]=H[F],g.HEAPU32[Oe++]=U[h[F]];g.jsepOnRunStart?.(E);let he;he=await g._OrtRun(E,j,S,R,Ue,I,Ce,v),he!==0&&V("failed to call OrtRun().");let ae=[];for(let F=0;F<I;F++){let ye=g.HEAPU32[Ce/4+F];if(ye===H[F]){ae.push(f[F]);continue}let ve=g.stackSave(),fe=g.stackAlloc(4*4),_e=!1,Y,pe=0;try{g._OrtGetTensorData(ye,fe,fe+4,fe+8,fe+12)!==0&&V(`Can\'t access output tensor data on index ${F}.`);let Ee=fe/4,be=g.HEAPU32[Ee++];pe=g.HEAPU32[Ee++];let we=g.HEAPU32[Ee++],Le=g.HEAPU32[Ee++],me=[];for(let te=0;te<Le;te++)me.push(g.HEAPU32[we/4+te]);g._OrtFree(we);let Se=me.reduce((te,z)=>te*z,1);Y=Dr(be);let De=D?.outputPreferredLocations[h[F]];if(Y==="string"){if(De==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let te=[],z=pe/4;for(let le=0;le<Se;le++){let Fe=g.HEAPU32[z++],Ae=le===Se-1?void 0:g.HEAPU32[z]-Fe;te.push(g.UTF8ToString(Fe,Ae))}ae.push([Y,me,te,"cpu"])}else if(De==="gpu-buffer"&&Se>0){let te=g.jsepGetBuffer;if(!te)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let z=te(pe),le=It(be);if(le===void 0||!Pr(Y))throw new Error(`Unsupported data type: ${Y}`);_e=!0,ae.push([Y,me,{gpuBuffer:z,download:g.jsepCreateDownloader(z,Se*le,Y),dispose:()=>{g._OrtReleaseTensor(ye)}},"gpu-buffer"])}else{let te=Fr(Y),z=new te(Se);new Uint8Array(z.buffer,z.byteOffset,z.byteLength).set(g.HEAPU8.subarray(pe,pe+z.byteLength)),ae.push([Y,me,z,"cpu"])}}finally{g.stackRestore(ve),Y==="string"&&pe&&g._free(pe),_e||g._OrtReleaseTensor(ye)}}return D&&!x&&(g._OrtClearBoundOutputs(D.handle),ze.set(u,[E,P,U,D,x,!1])),ae}finally{g.stackRestore(ee),W.forEach(ce=>g._OrtReleaseTensor(ce)),H.forEach(ce=>g._OrtReleaseTensor(ce)),se.forEach(ce=>g._free(ce)),v!==0&&g._OrtReleaseRunOptions(v),k.forEach(ce=>g._free(ce))}},Hr=u=>{let c=Z(),a=ze.get(u);if(!a)throw new Error("invalid session id");let h=a[0],f=c._OrtEndProfiling(h);f===0&&V("Can\'t get an profile file name."),c._OrtFree(f)},Gr=u=>{let c=[];for(let a of u){let h=a[2];!Array.isArray(h)&&"buffer"in h&&c.push(h.buffer)}return c};self.onmessage=u=>{let{type:c,in:a}=u.data;try{switch(c){case"init-wasm":Tr(a.wasm).then(()=>{Lr(a).then(()=>{postMessage({type:c})},h=>{postMessage({type:c,err:h})})},h=>{postMessage({type:c,err:h})});break;case"init-ep":{let{epName:h,env:f}=a;Br(f,h).then(()=>{postMessage({type:c})},w=>{postMessage({type:c,err:w})});break}case"copy-from":{let{buffer:h}=a,f=Lt(h);postMessage({type:c,out:f});break}case"create":{let{model:h,options:f}=a;kr(h,f).then(w=>{postMessage({type:c,out:w})},w=>{postMessage({type:c,err:w})});break}case"release":Wr(a),postMessage({type:c});break;case"run":{let{sessionId:h,inputIndices:f,inputs:w,outputIndices:g,options:i}=a;Nr(h,f,w,g,new Array(g.length).fill(null),i).then(E=>{E.some(P=>P[3]!=="cpu")?postMessage({type:c,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:c,out:E},Gr([...w,...E]))},E=>{postMessage({type:c,err:E})});break}case"end-profiling":Hr(a),postMessage({type:c});break;default:}}catch(h){postMessage({type:c,err:h})}};})();\n';
      });
      var _r;
      var ht;
      var xn;
      var Fo;
      var Co;
      var ha;
      var ma;
      var Hr;
      var qr;
      var wg;
      var Lo;
      var ud;
      var ld;
      var fd;
      var cd;
      var pd;
      var dd;
      var hd;
      var ba = E(() => {
        "use strict";
        Tt();
        ad();
        Vr();
        _r = () => !!Z.wasm.proxy && typeof document < "u", xn = false, Fo = false, Co = false, ma = /* @__PURE__ */ new Map(), Hr = (a4, t4) => {
          let o4 = ma.get(a4);
          o4 ? o4.push(t4) : ma.set(a4, [t4]);
        }, qr = () => {
          if (xn || !Fo || Co || !ht)
            throw new Error("worker not ready");
        }, wg = (a4) => {
          switch (a4.data.type) {
            case "init-wasm":
              xn = false, a4.data.err ? (Co = true, ha[1](a4.data.err)) : (Fo = true, ha[0]());
              break;
            case "init-ep":
            case "copy-from":
            case "create":
            case "release":
            case "run":
            case "end-profiling": {
              let t4 = ma.get(a4.data.type);
              a4.data.err ? t4.shift()[1](a4.data.err) : t4.shift()[0](a4.data.out);
              break;
            }
            default:
          }
        }, Lo = typeof document < "u" ? document?.currentScript?.src : void 0, ud = async () => {
          if (!Fo) {
            if (xn)
              throw new Error("multiple calls to 'initWasm()' detected.");
            if (Co)
              throw new Error("previous call to 'initWasm()' failed.");
            if (xn = true, _r())
              return Z.wasm.wasmPaths === void 0 && Lo && Lo.indexOf("blob:") !== 0 && (Z.wasm.wasmPaths = Lo.substr(0, +Lo.lastIndexOf("/") + 1)), new Promise((a4, t4) => {
                ht?.terminate();
                let o4 = URL.createObjectURL(new Blob([sd()], { type: "text/javascript" }));
                ht = new Worker(o4, { name: "ort-wasm-proxy-worker" }), ht.onerror = (r4) => t4(r4), ht.onmessage = wg, URL.revokeObjectURL(o4), ha = [a4, t4];
                let e4 = { type: "init-wasm", in: Z };
                ht.postMessage(e4);
              });
            try {
              await Vp(Z.wasm), await Qp(Z), Fo = true;
            } catch (a4) {
              throw Co = true, a4;
            } finally {
              xn = false;
            }
          }
        }, ld = async (a4) => {
          if (_r())
            return qr(), new Promise((t4, o4) => {
              Hr("init-ep", [t4, o4]);
              let e4 = { type: "init-ep", in: { epName: a4, env: Z } };
              ht.postMessage(e4);
            });
          await ed(Z, a4);
        }, fd = async (a4) => _r() ? (qr(), new Promise((t4, o4) => {
          Hr("copy-from", [t4, o4]);
          let e4 = { type: "copy-from", in: { buffer: a4 } };
          ht.postMessage(e4, [a4.buffer]);
        })) : da(a4), cd = async (a4, t4) => {
          if (_r()) {
            if (t4?.preferredOutputLocation)
              throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
            return qr(), new Promise((o4, e4) => {
              Hr("create", [o4, e4]);
              let r4 = { type: "create", in: { model: a4, options: { ...t4 } } }, n4 = [];
              a4 instanceof Uint8Array && n4.push(a4.buffer), ht.postMessage(r4, n4);
            });
          } else
            return td(a4, t4);
        }, pd = async (a4) => {
          if (_r())
            return qr(), new Promise((t4, o4) => {
              Hr("release", [t4, o4]);
              let e4 = { type: "release", in: a4 };
              ht.postMessage(e4);
            });
          rd(a4);
        }, dd = async (a4, t4, o4, e4, r4, n4) => {
          if (_r()) {
            if (o4.some((s4) => s4[3] !== "cpu"))
              throw new Error("input tensor on GPU is not supported for proxy.");
            if (r4.some((s4) => s4))
              throw new Error("pre-allocated output tensor is not supported for proxy.");
            return qr(), new Promise((s4, i5) => {
              Hr("run", [s4, i5]);
              let u4 = o4, l4 = { type: "run", in: { sessionId: a4, inputIndices: t4, inputs: u4, outputIndices: e4, options: n4 } };
              ht.postMessage(l4, id(u4));
            });
          } else
            return nd(a4, t4, o4, e4, r4, n4);
        }, hd = async (a4) => {
          if (_r())
            return qr(), new Promise((t4, o4) => {
              Hr("end-profiling", [t4, o4]);
              let e4 = { type: "end-profiling", in: a4 };
              ht.postMessage(e4);
            });
          od(a4);
        };
      });
      var md;
      var vg;
      var $o;
      var bd = E(() => {
        "use strict";
        Tt();
        ba();
        ca();
        pa();
        md = (a4, t4) => {
          switch (a4.location) {
            case "cpu":
              return [a4.type, a4.dims, a4.data, "cpu"];
            case "gpu-buffer":
              return [a4.type, a4.dims, { gpuBuffer: a4.gpuBuffer }, "gpu-buffer"];
            default:
              throw new Error(`invalid data location: ${a4.location} for ${t4()}`);
          }
        }, vg = (a4) => {
          switch (a4[3]) {
            case "cpu":
              return new Be(a4[0], a4[2], a4[1]);
            case "gpu-buffer": {
              let t4 = a4[0];
              if (!Do(t4))
                throw new Error(`not supported data type: ${t4} for deserializing GPU tensor`);
              let { gpuBuffer: o4, download: e4, dispose: r4 } = a4[2];
              return Be.fromGpuBuffer(o4, { dataType: t4, dims: a4[1], download: e4, dispose: r4 });
            }
            default:
              throw new Error(`invalid data location: ${a4[3]}`);
          }
        }, $o = class {
          async fetchModelAndCopyToWasmMemory(t4) {
            return fd(await Tn(t4));
          }
          async loadModel(t4, o4) {
            Yt();
            let e4;
            typeof t4 == "string" ? typeof process < "u" && process.versions && process.versions.node ? e4 = await Tn(t4) : e4 = await this.fetchModelAndCopyToWasmMemory(t4) : e4 = t4, [this.sessionId, this.inputNames, this.outputNames] = await cd(e4, o4), Xt();
          }
          async dispose() {
            return pd(this.sessionId);
          }
          async run(t4, o4, e4) {
            Yt();
            let r4 = [], n4 = [];
            Object.entries(t4).forEach((d4) => {
              let T3 = d4[0], v5 = d4[1], w3 = this.inputNames.indexOf(T3);
              if (w3 === -1)
                throw new Error(`invalid input '${T3}'`);
              r4.push(v5), n4.push(w3);
            });
            let s4 = [], i5 = [];
            Object.entries(o4).forEach((d4) => {
              let T3 = d4[0], v5 = d4[1], w3 = this.outputNames.indexOf(T3);
              if (w3 === -1)
                throw new Error(`invalid output '${T3}'`);
              s4.push(v5), i5.push(w3);
            });
            let u4 = r4.map((d4, T3) => md(d4, () => `input "${this.inputNames[n4[T3]]}"`)), l4 = s4.map((d4, T3) => d4 ? md(d4, () => `output "${this.outputNames[i5[T3]]}"`) : null), f3 = await dd(this.sessionId, n4, u4, i5, l4, e4), p4 = {};
            for (let d4 = 0; d4 < f3.length; d4++)
              p4[this.outputNames[i5[d4]]] = s4[d4] ?? vg(f3[d4]);
            return Xt(), p4;
          }
          startProfiling() {
          }
          endProfiling() {
            hd(this.sessionId);
          }
        };
      });
      var _g;
      var ko;
      var gd = E(() => {
        "use strict";
        Tt();
        ba();
        bd();
        _g = () => {
          if ((typeof Z.wasm.initTimeout != "number" || Z.wasm.initTimeout < 0) && (Z.wasm.initTimeout = 0), typeof Z.wasm.simd != "boolean" && (Z.wasm.simd = true), typeof Z.wasm.proxy != "boolean" && (Z.wasm.proxy = false), typeof Z.wasm.trace != "boolean" && (Z.wasm.trace = false), typeof Z.wasm.numThreads != "number" || !Number.isInteger(Z.wasm.numThreads) || Z.wasm.numThreads <= 0) {
            (typeof self < "u" && !self.crossOriginIsolated || typeof process < "u" && process.versions && process.versions.node) && (Z.wasm.numThreads = 1);
            let a4 = typeof navigator > "u" ? (void 0)().length : navigator.hardwareConcurrency;
            Z.wasm.numThreads = Math.min(4, Math.ceil((a4 || 1) / 2));
          }
        }, ko = class {
          async init(t4) {
            _g(), await ud(), await ld(t4);
          }
          async createInferenceSessionHandler(t4, o4) {
            let e4 = new $o();
            return await e4.loadModel(t4, o4), Promise.resolve(e4);
          }
        };
      });
      var yd = {};
      sr(yd, { wasmBackend: () => Og });
      var Og;
      var Td = E(() => {
        "use strict";
        gd();
        Og = new ko();
      });
      var Sg = {};
      sr(Sg, { InferenceSession: () => hs, TRACE: () => jo, TRACE_FUNC_BEGIN: () => Yt, TRACE_FUNC_END: () => Xt, Tensor: () => Be, TrainingSession: () => ws, default: () => Ig, env: () => Z, registerBackend: () => lr });
      module.exports = jt(Sg);
      Tt();
      Tt();
      Tt();
      var _s = "1.17.3";
      var Ig = Xo;
      {
        let a4 = (Pp(), jt(Ap)).onnxjsBackend;
        lr("webgl", a4, -10);
      }
      {
        let a4 = (Td(), jt(yd)).wasmBackend;
        lr("cpu", a4, 10), lr("wasm", a4, 10);
      }
      Object.defineProperty(Z.versions, "web", { value: _s, enumerable: true });
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/utils.js
  var require_utils = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/utils.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encodeWAV = exports2.arrayBufferToBase64 = exports2.minFramesForTargetMS = void 0;
      function minFramesForTargetMS(targetDuration, frameSamples, sr5 = 16e3) {
        return Math.ceil(targetDuration * sr5 / 1e3 / frameSamples);
      }
      exports2.minFramesForTargetMS = minFramesForTargetMS;
      function arrayBufferToBase64(buffer) {
        var binary = "";
        var bytes = new Uint8Array(buffer);
        var len2 = bytes.byteLength;
        for (var i5 = 0; i5 < len2; i5++) {
          binary += String.fromCharCode(bytes[i5]);
        }
        return btoa(binary);
      }
      exports2.arrayBufferToBase64 = arrayBufferToBase64;
      function encodeWAV(samples, format = 3, sampleRate = 16e3, numChannels = 1, bitDepth = 32) {
        var bytesPerSample = bitDepth / 8;
        var blockAlign = numChannels * bytesPerSample;
        var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
        var view = new DataView(buffer);
        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + samples.length * bytesPerSample, true);
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * blockAlign, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitDepth, true);
        writeString(view, 36, "data");
        view.setUint32(40, samples.length * bytesPerSample, true);
        if (format === 1) {
          floatTo16BitPCM(view, 44, samples);
        } else {
          writeFloat32(view, 44, samples);
        }
        return buffer;
      }
      exports2.encodeWAV = encodeWAV;
      function writeFloat32(output, offset, input) {
        for (var i5 = 0; i5 < input.length; i5++, offset += 4) {
          output.setFloat32(offset, input[i5], true);
        }
      }
      function floatTo16BitPCM(output, offset, input) {
        for (var i5 = 0; i5 < input.length; i5++, offset += 2) {
          var s4 = Math.max(-1, Math.min(1, input[i5]));
          output.setInt16(offset, s4 < 0 ? s4 * 32768 : s4 * 32767, true);
        }
      }
      function writeString(view, offset, string) {
        for (var i5 = 0; i5 < string.length; i5++) {
          view.setUint8(offset + i5, string.charCodeAt(i5));
        }
      }
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/messages.js
  var require_messages = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Message = void 0;
      var Message2;
      (function(Message3) {
        Message3["AudioFrame"] = "AUDIO_FRAME";
        Message3["SpeechStart"] = "SPEECH_START";
        Message3["VADMisfire"] = "VAD_MISFIRE";
        Message3["SpeechEnd"] = "SPEECH_END";
        Message3["SpeechStop"] = "SPEECH_STOP";
      })(Message2 || (exports2.Message = Message2 = {}));
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/logging.js
  var require_logging = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/logging.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.log = exports2.LOG_PREFIX = void 0;
      exports2.LOG_PREFIX = "[VAD]";
      var levels2 = ["error", "debug", "warn"];
      function getLog(level) {
        return (...args) => {
          console[level](exports2.LOG_PREFIX, ...args);
        };
      }
      var _log = levels2.reduce((acc, level) => {
        acc[level] = getLog(level);
        return acc;
      }, {});
      exports2.log = _log;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js
  var require_frame_processor = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FrameProcessor = exports2.validateOptions = exports2.defaultFrameProcessorOptions = void 0;
      var messages_1 = require_messages();
      var logging_1 = require_logging();
      var RECOMMENDED_FRAME_SAMPLES = [512, 1024, 1536];
      exports2.defaultFrameProcessorOptions = {
        positiveSpeechThreshold: 0.5,
        negativeSpeechThreshold: 0.5 - 0.15,
        preSpeechPadFrames: 1,
        redemptionFrames: 8,
        frameSamples: 1536,
        minSpeechFrames: 3,
        submitUserSpeechOnPause: false
      };
      function validateOptions(options) {
        if (!RECOMMENDED_FRAME_SAMPLES.includes(options.frameSamples)) {
          logging_1.log.warn("You are using an unusual frame size");
        }
        if (options.positiveSpeechThreshold < 0 || options.negativeSpeechThreshold > 1) {
          logging_1.log.error("postiveSpeechThreshold should be a number between 0 and 1");
        }
        if (options.negativeSpeechThreshold < 0 || options.negativeSpeechThreshold > options.positiveSpeechThreshold) {
          logging_1.log.error("negativeSpeechThreshold should be between 0 and postiveSpeechThreshold");
        }
        if (options.preSpeechPadFrames < 0) {
          logging_1.log.error("preSpeechPadFrames should be positive");
        }
        if (options.redemptionFrames < 0) {
          logging_1.log.error("preSpeechPadFrames should be positive");
        }
      }
      exports2.validateOptions = validateOptions;
      var concatArrays = (arrays) => {
        const sizes = arrays.reduce((out, next) => {
          out.push(out.at(-1) + next.length);
          return out;
        }, [0]);
        const outArray = new Float32Array(sizes.at(-1));
        arrays.forEach((arr, index) => {
          const place = sizes[index];
          outArray.set(arr, place);
        });
        return outArray;
      };
      var FrameProcessor = class {
        constructor(modelProcessFunc, modelResetFunc, options) {
          this.modelProcessFunc = modelProcessFunc;
          this.modelResetFunc = modelResetFunc;
          this.options = options;
          this.speaking = false;
          this.redemptionCounter = 0;
          this.active = false;
          this.reset = () => {
            this.speaking = false;
            this.audioBuffer = [];
            this.modelResetFunc();
            this.redemptionCounter = 0;
          };
          this.pause = () => {
            this.active = false;
            if (this.options.submitUserSpeechOnPause) {
              return this.endSegment();
            } else {
              this.reset();
              return {};
            }
          };
          this.resume = () => {
            this.active = true;
          };
          this.endSegment = () => {
            const audioBuffer = this.audioBuffer;
            this.audioBuffer = [];
            const speaking = this.speaking;
            this.reset();
            const speechFrameCount = audioBuffer.reduce((acc, item) => {
              return acc + +item.isSpeech;
            }, 0);
            if (speaking) {
              if (speechFrameCount >= this.options.minSpeechFrames) {
                const audio = concatArrays(audioBuffer.map((item) => item.frame));
                return { msg: messages_1.Message.SpeechEnd, audio };
              } else {
                return { msg: messages_1.Message.VADMisfire };
              }
            }
            return {};
          };
          this.process = async (frame) => {
            if (!this.active) {
              return {};
            }
            const probs = await this.modelProcessFunc(frame);
            this.audioBuffer.push({
              frame,
              isSpeech: probs.isSpeech >= this.options.positiveSpeechThreshold
            });
            if (probs.isSpeech >= this.options.positiveSpeechThreshold && this.redemptionCounter) {
              this.redemptionCounter = 0;
            }
            if (probs.isSpeech >= this.options.positiveSpeechThreshold && !this.speaking) {
              this.speaking = true;
              return { probs, msg: messages_1.Message.SpeechStart };
            }
            if (probs.isSpeech < this.options.negativeSpeechThreshold && this.speaking && ++this.redemptionCounter >= this.options.redemptionFrames) {
              this.redemptionCounter = 0;
              this.speaking = false;
              const audioBuffer = this.audioBuffer;
              this.audioBuffer = [];
              const speechFrameCount = audioBuffer.reduce((acc, item) => {
                return acc + +item.isSpeech;
              }, 0);
              if (speechFrameCount >= this.options.minSpeechFrames) {
                const audio = concatArrays(audioBuffer.map((item) => item.frame));
                return { probs, msg: messages_1.Message.SpeechEnd, audio };
              } else {
                return { probs, msg: messages_1.Message.VADMisfire };
              }
            }
            if (!this.speaking) {
              while (this.audioBuffer.length > this.options.preSpeechPadFrames) {
                this.audioBuffer.shift();
              }
            }
            return { probs };
          };
          this.audioBuffer = [];
          this.reset();
        }
      };
      exports2.FrameProcessor = FrameProcessor;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/models.js
  var require_models = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/models.js"(exports2) {
      "use strict";
      var _a3;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Silero = void 0;
      var logging_1 = require_logging();
      var Silero = class {
        constructor(ort, modelFetcher) {
          this.ort = ort;
          this.modelFetcher = modelFetcher;
          this.init = async () => {
            logging_1.log.debug("initializing vad");
            const modelArrayBuffer = await this.modelFetcher();
            this._session = await this.ort.InferenceSession.create(modelArrayBuffer);
            this._sr = new this.ort.Tensor("int64", [16000n]);
            this.reset_state();
            logging_1.log.debug("vad is initialized");
          };
          this.reset_state = () => {
            const zeroes = Array(2 * 64).fill(0);
            this._h = new this.ort.Tensor("float32", zeroes, [2, 1, 64]);
            this._c = new this.ort.Tensor("float32", zeroes, [2, 1, 64]);
          };
          this.process = async (audioFrame) => {
            const t4 = new this.ort.Tensor("float32", audioFrame, [1, audioFrame.length]);
            const inputs = {
              input: t4,
              h: this._h,
              c: this._c,
              sr: this._sr
            };
            const out = await this._session.run(inputs);
            this._h = out.hn;
            this._c = out.cn;
            const [isSpeech] = out.output.data;
            const notSpeech = 1 - isSpeech;
            return { notSpeech, isSpeech };
          };
        }
      };
      exports2.Silero = Silero;
      _a3 = Silero;
      Silero.new = async (ort, modelFetcher) => {
        const model = new _a3(ort, modelFetcher);
        await model.init();
        return model;
      };
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/resampler.js
  var require_resampler = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/resampler.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Resampler = void 0;
      var logging_1 = require_logging();
      var Resampler = class {
        constructor(options) {
          this.options = options;
          this.process = (audioFrame) => {
            const outputFrames = [];
            for (const sample of audioFrame) {
              this.inputBuffer.push(sample);
            }
            while (this.inputBuffer.length * this.options.targetSampleRate / this.options.nativeSampleRate > this.options.targetFrameSize) {
              const outputFrame = new Float32Array(this.options.targetFrameSize);
              let outputIndex = 0;
              let inputIndex = 0;
              while (outputIndex < this.options.targetFrameSize) {
                let sum = 0;
                let num = 0;
                while (inputIndex < Math.min(this.inputBuffer.length, (outputIndex + 1) * this.options.nativeSampleRate / this.options.targetSampleRate)) {
                  sum += this.inputBuffer[inputIndex];
                  num++;
                  inputIndex++;
                }
                outputFrame[outputIndex] = sum / num;
                outputIndex++;
              }
              this.inputBuffer = this.inputBuffer.slice(inputIndex);
              outputFrames.push(outputFrame);
            }
            return outputFrames;
          };
          if (options.nativeSampleRate < 16e3) {
            logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate");
          }
          this.inputBuffer = [];
        }
      };
      exports2.Resampler = Resampler;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js
  var require_non_real_time_vad = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PlatformAgnosticNonRealTimeVAD = exports2.defaultNonRealTimeVADOptions = void 0;
      var frame_processor_1 = require_frame_processor();
      var messages_1 = require_messages();
      var models_1 = require_models();
      var resampler_1 = require_resampler();
      exports2.defaultNonRealTimeVADOptions = {
        ...frame_processor_1.defaultFrameProcessorOptions
      };
      var PlatformAgnosticNonRealTimeVAD = class {
        static async _new(modelFetcher, ort, options = {}) {
          const vad = new this(modelFetcher, ort, {
            ...exports2.defaultNonRealTimeVADOptions,
            ...options
          });
          await vad.init();
          return vad;
        }
        constructor(modelFetcher, ort, options) {
          this.modelFetcher = modelFetcher;
          this.ort = ort;
          this.options = options;
          this.init = async () => {
            const model = await models_1.Silero.new(this.ort, this.modelFetcher);
            this.frameProcessor = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
              frameSamples: this.options.frameSamples,
              positiveSpeechThreshold: this.options.positiveSpeechThreshold,
              negativeSpeechThreshold: this.options.negativeSpeechThreshold,
              redemptionFrames: this.options.redemptionFrames,
              preSpeechPadFrames: this.options.preSpeechPadFrames,
              minSpeechFrames: this.options.minSpeechFrames,
              submitUserSpeechOnPause: this.options.submitUserSpeechOnPause
            });
            this.frameProcessor.resume();
          };
          this.run = async function* (inputAudio, sampleRate) {
            const resamplerOptions = {
              nativeSampleRate: sampleRate,
              targetSampleRate: 16e3,
              targetFrameSize: this.options.frameSamples
            };
            const resampler = new resampler_1.Resampler(resamplerOptions);
            const frames = resampler.process(inputAudio);
            let start, end;
            for (const i5 of [...Array(frames.length)].keys()) {
              const f3 = frames[i5];
              const { msg: msg2, audio: audio2 } = await this.frameProcessor.process(f3);
              switch (msg2) {
                case messages_1.Message.SpeechStart:
                  start = i5 * this.options.frameSamples / 16;
                  break;
                case messages_1.Message.SpeechEnd:
                  end = (i5 + 1) * this.options.frameSamples / 16;
                  yield { audio: audio2, start, end };
                  break;
                default:
                  break;
              }
            }
            const { msg, audio } = this.frameProcessor.endSegment();
            if (msg == messages_1.Message.SpeechEnd) {
              yield {
                audio,
                // @ts-ignore
                start,
                end: frames.length * this.options.frameSamples / 16
              };
            }
          };
          (0, frame_processor_1.validateOptions)(options);
        }
      };
      exports2.PlatformAgnosticNonRealTimeVAD = PlatformAgnosticNonRealTimeVAD;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/_common/index.js
  var require_common = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/_common/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o4, m4, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        var desc = Object.getOwnPropertyDescriptor(m4, k4);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k4];
          } };
        }
        Object.defineProperty(o4, k22, desc);
      } : function(o4, m4, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        o4[k22] = m4[k4];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o4, v5) {
        Object.defineProperty(o4, "default", { enumerable: true, value: v5 });
      } : function(o4, v5) {
        o4["default"] = v5;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k4 in mod2)
            if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
              __createBinding(result, mod2, k4);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __exportStar = exports2 && exports2.__exportStar || function(m4, exports3) {
        for (var p4 in m4)
          if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p4))
            __createBinding(exports3, m4, p4);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.utils = void 0;
      var _utils = __importStar(require_utils());
      exports2.utils = {
        minFramesForTargetMS: _utils.minFramesForTargetMS,
        arrayBufferToBase64: _utils.arrayBufferToBase64,
        encodeWAV: _utils.encodeWAV
      };
      __exportStar(require_non_real_time_vad(), exports2);
      __exportStar(require_frame_processor(), exports2);
      __exportStar(require_messages(), exports2);
      __exportStar(require_logging(), exports2);
      __exportStar(require_models(), exports2);
      __exportStar(require_resampler(), exports2);
    }
  });

  // node_modules/@ricky0123/vad-web/dist/utils.js
  var require_utils2 = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/utils.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.audioFileToArray = void 0;
      async function audioFileToArray(audioFileData) {
        const ctx = new OfflineAudioContext(1, 1, 44100);
        const reader = new FileReader();
        let audioBuffer = null;
        await new Promise((res) => {
          reader.addEventListener("loadend", (ev) => {
            const audioData = reader.result;
            ctx.decodeAudioData(audioData, (buffer) => {
              audioBuffer = buffer;
              ctx.startRendering().then((renderedBuffer) => {
                console.log("Rendering completed successfully");
                res();
              }).catch((err) => {
                console.error(`Rendering failed: ${err}`);
              });
            }, (e4) => {
              console.log(`Error with decoding audio data: ${e4}`);
            });
          });
          reader.readAsArrayBuffer(audioFileData);
        });
        if (audioBuffer === null) {
          throw Error("some shit");
        }
        let _audioBuffer = audioBuffer;
        let out = new Float32Array(_audioBuffer.length);
        for (let i5 = 0; i5 < _audioBuffer.length; i5++) {
          for (let j4 = 0; j4 < _audioBuffer.numberOfChannels; j4++) {
            out[i5] += _audioBuffer.getChannelData(j4)[i5];
          }
        }
        return { audio: out, sampleRate: _audioBuffer.sampleRate };
      }
      exports2.audioFileToArray = audioFileToArray;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js
  var require_default_model_fetcher = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultModelFetcher = void 0;
      var defaultModelFetcher = (path) => {
        return fetch(path).then((model) => model.arrayBuffer());
      };
      exports2.defaultModelFetcher = defaultModelFetcher;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/asset-path.js
  var require_asset_path = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/asset-path.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.assetPath = void 0;
      var isWeb = typeof window !== "undefined" && typeof window.document !== "undefined";
      var currentScript = isWeb ? window.document.currentScript : null;
      var basePath = "";
      if (currentScript) {
        basePath = currentScript.src.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
      }
      var assetPath = (file) => {
        return basePath + file;
      };
      exports2.assetPath = assetPath;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/real-time-vad.js
  var require_real_time_vad = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/real-time-vad.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o4, m4, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        var desc = Object.getOwnPropertyDescriptor(m4, k4);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k4];
          } };
        }
        Object.defineProperty(o4, k22, desc);
      } : function(o4, m4, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        o4[k22] = m4[k4];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o4, v5) {
        Object.defineProperty(o4, "default", { enumerable: true, value: v5 });
      } : function(o4, v5) {
        o4["default"] = v5;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k4 in mod2)
            if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
              __createBinding(result, mod2, k4);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AudioNodeVAD = exports2.MicVAD = exports2.defaultRealTimeVADOptions = void 0;
      var ort = __importStar(require_ort_min());
      var _common_1 = require_common();
      var asset_path_1 = require_asset_path();
      var default_model_fetcher_1 = require_default_model_fetcher();
      exports2.defaultRealTimeVADOptions = {
        ..._common_1.defaultFrameProcessorOptions,
        onFrameProcessed: (probabilities) => {
        },
        onVADMisfire: () => {
          _common_1.log.debug("VAD misfire");
        },
        onSpeechStart: () => {
          _common_1.log.debug("Detected speech start");
        },
        onSpeechEnd: () => {
          _common_1.log.debug("Detected speech end");
        },
        workletURL: (0, asset_path_1.assetPath)("vad.worklet.bundle.min.js"),
        modelURL: (0, asset_path_1.assetPath)("silero_vad.onnx"),
        modelFetcher: default_model_fetcher_1.defaultModelFetcher,
        stream: void 0
      };
      var MicVAD = class _MicVAD {
        static async new(options = {}) {
          const fullOptions = {
            ...exports2.defaultRealTimeVADOptions,
            ...options
          };
          (0, _common_1.validateOptions)(fullOptions);
          let stream;
          if (fullOptions.stream === void 0)
            stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                ...fullOptions.additionalAudioConstraints,
                channelCount: 1,
                echoCancellation: true,
                autoGainControl: true,
                noiseSuppression: true
              }
            });
          else
            stream = fullOptions.stream;
          const audioContext = new AudioContext();
          const sourceNode = new MediaStreamAudioSourceNode(audioContext, {
            mediaStream: stream
          });
          const audioNodeVAD = await AudioNodeVAD.new(audioContext, fullOptions);
          audioNodeVAD.receive(sourceNode);
          return new _MicVAD(fullOptions, audioContext, stream, audioNodeVAD, sourceNode);
        }
        constructor(options, audioContext, stream, audioNodeVAD, sourceNode, listening = false) {
          this.options = options;
          this.audioContext = audioContext;
          this.stream = stream;
          this.audioNodeVAD = audioNodeVAD;
          this.sourceNode = sourceNode;
          this.listening = listening;
          this.pause = () => {
            this.audioNodeVAD.pause();
            this.listening = false;
          };
          this.start = () => {
            this.audioNodeVAD.start();
            this.listening = true;
          };
          this.destroy = () => {
            if (this.listening) {
              this.pause();
            }
            if (this.options.stream === void 0) {
              this.stream.getTracks().forEach((track) => track.stop());
            }
            this.sourceNode.disconnect();
            this.audioNodeVAD.destroy();
            this.audioContext.close();
          };
        }
      };
      exports2.MicVAD = MicVAD;
      var AudioNodeVAD = class _AudioNodeVAD {
        static async new(ctx, options = {}) {
          const fullOptions = {
            ...exports2.defaultRealTimeVADOptions,
            ...options
          };
          (0, _common_1.validateOptions)(fullOptions);
          await ctx.audioWorklet.addModule(fullOptions.workletURL);
          const vadNode = new AudioWorkletNode(ctx, "vad-helper-worklet", {
            processorOptions: {
              frameSamples: fullOptions.frameSamples
            }
          });
          const model = await _common_1.Silero.new(ort, () => fullOptions.modelFetcher(fullOptions.modelURL));
          const frameProcessor = new _common_1.FrameProcessor(model.process, model.reset_state, {
            frameSamples: fullOptions.frameSamples,
            positiveSpeechThreshold: fullOptions.positiveSpeechThreshold,
            negativeSpeechThreshold: fullOptions.negativeSpeechThreshold,
            redemptionFrames: fullOptions.redemptionFrames,
            preSpeechPadFrames: fullOptions.preSpeechPadFrames,
            minSpeechFrames: fullOptions.minSpeechFrames,
            submitUserSpeechOnPause: fullOptions.submitUserSpeechOnPause
          });
          const audioNodeVAD = new _AudioNodeVAD(ctx, fullOptions, frameProcessor, vadNode);
          vadNode.port.onmessage = async (ev) => {
            switch (ev.data?.message) {
              case _common_1.Message.AudioFrame:
                const buffer = ev.data.data;
                const frame = new Float32Array(buffer);
                await audioNodeVAD.processFrame(frame);
                break;
              default:
                break;
            }
          };
          return audioNodeVAD;
        }
        constructor(ctx, options, frameProcessor, entryNode) {
          this.ctx = ctx;
          this.options = options;
          this.frameProcessor = frameProcessor;
          this.entryNode = entryNode;
          this.pause = () => {
            const ev = this.frameProcessor.pause();
            this.handleFrameProcessorEvent(ev);
          };
          this.start = () => {
            this.frameProcessor.resume();
          };
          this.receive = (node) => {
            node.connect(this.entryNode);
          };
          this.processFrame = async (frame) => {
            const ev = await this.frameProcessor.process(frame);
            this.handleFrameProcessorEvent(ev);
          };
          this.handleFrameProcessorEvent = (ev) => {
            if (ev.probs !== void 0) {
              this.options.onFrameProcessed(ev.probs);
            }
            switch (ev.msg) {
              case _common_1.Message.SpeechStart:
                this.options.onSpeechStart();
                break;
              case _common_1.Message.VADMisfire:
                this.options.onVADMisfire();
                break;
              case _common_1.Message.SpeechEnd:
                this.options.onSpeechEnd(ev.audio);
                break;
              default:
                break;
            }
          };
          this.destroy = () => {
            this.entryNode.port.postMessage({
              message: _common_1.Message.SpeechStop
            });
            this.entryNode.disconnect();
          };
        }
      };
      exports2.AudioNodeVAD = AudioNodeVAD;
    }
  });

  // node_modules/@ricky0123/vad-web/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@ricky0123/vad-web/dist/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o4, m4, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        var desc = Object.getOwnPropertyDescriptor(m4, k4);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k4];
          } };
        }
        Object.defineProperty(o4, k22, desc);
      } : function(o4, m4, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        o4[k22] = m4[k4];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o4, v5) {
        Object.defineProperty(o4, "default", { enumerable: true, value: v5 });
      } : function(o4, v5) {
        o4["default"] = v5;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k4 in mod2)
            if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
              __createBinding(result, mod2, k4);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultRealTimeVADOptions = exports2.AudioNodeVAD = exports2.MicVAD = exports2.NonRealTimeVAD = exports2.Message = exports2.FrameProcessor = exports2.utils = exports2.defaultNonRealTimeVADOptions = void 0;
      var ort = __importStar(require_ort_min());
      var _common_1 = require_common();
      Object.defineProperty(exports2, "FrameProcessor", { enumerable: true, get: function() {
        return _common_1.FrameProcessor;
      } });
      Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
        return _common_1.Message;
      } });
      var utils_1 = require_utils2();
      var default_model_fetcher_1 = require_default_model_fetcher();
      var asset_path_1 = require_asset_path();
      exports2.defaultNonRealTimeVADOptions = {
        modelURL: (0, asset_path_1.assetPath)("silero_vad.onnx"),
        modelFetcher: default_model_fetcher_1.defaultModelFetcher
      };
      var NonRealTimeVAD = class extends _common_1.PlatformAgnosticNonRealTimeVAD {
        static async new(options = {}) {
          const { modelURL, modelFetcher } = {
            ...exports2.defaultNonRealTimeVADOptions,
            ...options
          };
          return await this._new(() => modelFetcher(modelURL), ort, options);
        }
      };
      exports2.NonRealTimeVAD = NonRealTimeVAD;
      exports2.utils = { audioFileToArray: utils_1.audioFileToArray, ..._common_1.utils };
      var real_time_vad_1 = require_real_time_vad();
      Object.defineProperty(exports2, "MicVAD", { enumerable: true, get: function() {
        return real_time_vad_1.MicVAD;
      } });
      Object.defineProperty(exports2, "AudioNodeVAD", { enumerable: true, get: function() {
        return real_time_vad_1.AudioNodeVAD;
      } });
      Object.defineProperty(exports2, "defaultRealTimeVADOptions", { enumerable: true, get: function() {
        return real_time_vad_1.defaultRealTimeVADOptions;
      } });
    }
  });

  // node_modules/@sermas/toolkit/detection/audio.detection.js
  var import_eventemitter25, VAD_SAMPLE_RATE, SPEECH_CLASSIFIER_THRESHOLD, AUDIO_CLASSIFICATION_SAMPLE_SEC, AUDIO_CLASSIFICATION_THRESHOLD, AUDIO_CLASSIFICATION_SKIP_CLASSES, AudioDetection;
  var init_audio_detection = __esm({
    "node_modules/@sermas/toolkit/detection/audio.detection.js"() {
      import_eventemitter25 = __toESM(require_eventemitter2(), 1);
      init_utils3();
      init_events();
      init_toolkit();
      init_logger();
      init_audio_classifier();
      init_classes();
      VAD_SAMPLE_RATE = 16e3;
      SPEECH_CLASSIFIER_THRESHOLD = 0.5;
      AUDIO_CLASSIFICATION_SAMPLE_SEC = 1;
      AUDIO_CLASSIFICATION_THRESHOLD = 0.3;
      AUDIO_CLASSIFICATION_SKIP_CLASSES = ["Static", "Silence", "White noise"];
      AudioDetection = class _AudioDetection extends import_eventemitter25.default {
        constructor(toolkit) {
          super();
          this.toolkit = toolkit;
          this.logger = new Logger(_AudioDetection.name);
        }
        async stop() {
          if (this.mediaRecorder) {
            this.mediaRecorder.stop();
            this.mediaRecorder.ondataavailable = () => {
            };
            this.mediaRecorder = void 0;
          }
          if (this.vad) {
            this.vad.pause();
          }
          if (this.stream) {
            this.pause();
          }
          if (this.classifier) {
            this.classifier.close();
          }
          this.emit("stopped");
          this.removeAllListeners();
          this.logger.log("Audio detection stopped");
        }
        getSampleRate() {
          return this.vad?.options.frameSamples;
        }
        /**
         * Pause the microphone audio stream
         */
        pause() {
          const tracks = this.stream?.getTracks() || [];
          tracks.forEach((t4) => t4.enabled = false);
        }
        /**
         * Restore the microphone audio stream
         */
        restore() {
          const tracks = this.stream?.getTracks() || [];
          tracks.forEach((t4) => t4.enabled = true);
        }
        async start(stream) {
          if (!this.hasMediaSupport()) {
            return false;
          }
          await this.startClassifier();
          const ok = await this.startVAD(stream);
          return ok;
        }
        async startVAD(stream) {
          this.logger.debug(`Loading VAD`);
          const vadModuleLoader = await Promise.resolve().then(() => __toESM(require_dist(), 1));
          const vadModule = vadModuleLoader.default || vadModuleLoader;
          try {
            const onSpeech = async (op3, audio) => {
              emitter.emit("detection.audio", op3);
              if (!audio)
                return;
              const isSpeech = await this.classify(audio);
              if (!isSpeech) {
                this.logger.debug(`Audio does not classify as speech`);
                return;
              }
              this.logger.debug(`Speech detected`);
              const wav = vadModule.utils.encodeWAV(audio);
              const ev = { op: op3, audio, wav };
              this.emit("speech", ev);
              this.speechDetected(ev);
            };
            this.vad = await vadModule.MicVAD.new({
              positiveSpeechThreshold: 0.7,
              minSpeechFrames: 3,
              preSpeechPadFrames: 5,
              stream,
              workletURL: "/vad.worklet.bundle.min.js",
              onSpeechEnd: (audio) => {
                onSpeech("stopped", audio);
              },
              onSpeechStart: () => {
                onSpeech("started");
              }
            });
            this.stream = stream ? stream : this.vad.options.stream;
            const tracks = this.stream?.getTracks() || [];
            tracks.forEach((t4) => t4.enabled = true);
            this.vad.start();
            this.emit("started");
            this.logger.debug(`VAD started (sampleRate=${this.getSampleRate()})`);
          } catch (e4) {
            this.logger.error(`Failed to start VAD ${e4.stack}`);
            this.emit("error", e4);
            return false;
          }
          return true;
        }
        async startMediaRecorder(stream) {
          if (this.mediaRecorder) {
            this.mediaRecorder.stop();
            this.mediaRecorder.ondataavailable = () => {
            };
          }
          const sample = AUDIO_CLASSIFICATION_SAMPLE_SEC * 1e3;
          this.mediaRecorder = new MediaRecorder(stream, {});
          this.mediaRecorder.ondataavailable = (e4) => {
            (async () => {
              try {
                const arrayBuffer = await e4.data.arrayBuffer();
                const arr = this.convertBlock(arrayBuffer);
                this.classify(arr);
              } catch {
              }
            })();
          };
          this.mediaRecorder.start(sample);
        }
        convertBlock(buffer) {
          const incomingData = new Uint8Array(buffer);
          const l4 = incomingData.length;
          const outputData = new Float32Array(incomingData.length);
          for (let i5 = 0; i5 < l4; i5++) {
            outputData[i5] = (incomingData[i5] - 128) / 128;
          }
          return outputData;
        }
        async classify(audio, sampleRate) {
          if (!audio || !audio.length)
            return;
          let matchSpeech = false;
          const results = this.classifier?.classify(audio, sampleRate || VAD_SAMPLE_RATE) || [];
          const classMatches = [];
          const classifications = [];
          const classesMaps = {};
          results.forEach((r4) => {
            r4.classifications.forEach((cs3) => {
              cs3.categories.forEach((c5) => {
                const humanClasses = classes_default.human;
                if (AUDIO_CLASSIFICATION_SKIP_CLASSES.includes(c5.categoryName))
                  return;
                if (humanClasses[c5.index.toString()] && c5.score > SPEECH_CLASSIFIER_THRESHOLD) {
                  matchSpeech = true;
                }
                if (!humanClasses[c5.index.toString()] && c5.score > AUDIO_CLASSIFICATION_THRESHOLD) {
                  classesMaps[c5.categoryName] = classesMaps[c5.categoryName] || 0;
                  if (classesMaps[c5.categoryName] < c5.score) {
                    classesMaps[c5.categoryName] = c5.score;
                    const payload = {
                      value: c5.categoryName,
                      probability: c5.score
                    };
                    classifications.push(payload);
                  }
                }
                classMatches.push(`"${c5.categoryName}" score=${c5.score} id=${c5.index}`);
              });
            });
          });
          if (classMatches.length)
            this.logger.debug(`Matches: ${classMatches.join("; ")}`);
          if (classifications.length) {
            this.logger.debug(`classification event ${JSON.stringify(classifications)}`);
            this.emit("classification", classifications);
            this.sendAudioClassification(classifications);
          }
          return matchSpeech;
        }
        async startClassifier(sampleRate) {
          if (this.classifier) {
            this.classifier.close();
          }
          this.classifier = await createAudioClassifier();
          if (sampleRate)
            this.classifier.setDefaultSampleRate(sampleRate);
        }
        hasMediaSupport() {
          const _navigator = navigator;
          if (!_navigator.getUserMedia) {
            _navigator.getUserMedia = _navigator.getUserMedia || _navigator.webkitGetUserMedia || _navigator.mozGetUserMedia || _navigator.msGetUserMedia;
          }
          return _navigator.getUserMedia ? true : false;
        }
        async createMicrophoneStream(constraints) {
          this.logger.log("start mic");
          if (this.stream) {
            this.logger.debug("mic is already started");
            return this.stream;
          }
          if (!this.hasMediaSupport()) {
            this.logger.error("mic not supported");
            this.emit("error", new Error("Microphone not supported"));
            return void 0;
          }
          try {
            this.stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                ...constraints || {},
                sampleRate: { exact: VAD_SAMPLE_RATE },
                channelCount: 1,
                echoCancellation: true,
                autoGainControl: true,
                noiseSuppression: true
              }
            });
          } catch (e4) {
            this.logger.error(`Failed to get mic stream: ${e4.stack}`);
            this.stream = void 0;
            this.emit("error", e4);
          }
          return this.stream;
        }
        sendAudioClassification(detections) {
          if (!this.toolkit)
            return;
          const payload = {
            appId: this.toolkit.getAppId(),
            source: "avatar",
            sessionId: this.toolkit.getSessionId(),
            ts: (/* @__PURE__ */ new Date()).toString(),
            detections
          };
          this.toolkit.getBroker().publish(AUDIO_CLASSIFICATION_TOPIC, payload);
        }
        speechDetected(ev) {
          if (!this.toolkit)
            return;
          if (ev.wav) {
            this.sendSpeechAudio("wav", ev.wav);
          } else if (ev.audio) {
            const sampleRate = this.getSampleRate() || 16e3;
            this.sendSpeechAudio("raw", ev.audio, sampleRate);
          }
        }
        async sendSpeechAudio(type, audio, sampleRate) {
          if (!this.toolkit)
            return;
          if (this.toolkit.getSettings().get().interactionStart == "speak" && !this.toolkit.getSessionId()) {
            this.toolkit.triggerInteractionStart("microphone");
            return;
          }
          this.pause();
          this.logger.log(`Sending speech chunk type=${type}`);
          const ev = {
            appId: this.toolkit.getAppId(),
            gender: await this.toolkit.getAvatarGender(),
            avatar: (await this.toolkit.getAvatarConfig())?.id,
            actor: "user",
            language: this.toolkit.getAppLanguage(),
            chunkId: getChunkId(),
            text: "",
            sessionId: this.toolkit.getSessionId(),
            userId: this.toolkit.getUserId()
          };
          const formData = new FormData();
          const blob = new Blob([audio], {
            type: type === "raw" ? "application/octet-stream" : "audio/wav"
          });
          formData.append("file", blob, "audio.wav");
          for (const key in ev) {
            formData.append(key, ev[key]);
          }
          try {
            await this.toolkit.getApi().sendAudio(formData, {
              sampleRate
            });
            this.logger.debug(`Audio clip sent`);
          } catch (err) {
            this.logger.error(`Failed to send clip: ${err.stack}`);
          } finally {
            this.restore();
          }
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/detection/index.js
  var init_detection = __esm({
    "node_modules/@sermas/toolkit/detection/index.js"() {
      init_detection_dto2();
      init_video_detection();
      init_video_dto();
      init_human();
      init_holistic();
      init_face_landmarker();
      init_qrcode();
      init_audio_detection_dto();
      init_audio_detection();
    }
  });

  // node_modules/mqtt/dist/mqtt.esm.js
  function bs3(t4) {
    throw new Error("Node.js process " + t4 + " is not supported by JSPM core outside of Node.js");
  }
  function Jg() {
    !xr4 || !Yt4 || (xr4 = false, Yt4.length ? bt3 = Yt4.concat(bt3) : Di3 = -1, bt3.length && Bl2());
  }
  function Bl2() {
    if (!xr4) {
      var t4 = setTimeout(Jg, 0);
      xr4 = true;
      for (var e4 = bt3.length; e4; ) {
        for (Yt4 = bt3, bt3 = []; ++Di3 < e4; )
          Yt4 && Yt4[Di3].run();
        Di3 = -1, e4 = bt3.length;
      }
      Yt4 = null, xr4 = false, clearTimeout(t4);
    }
  }
  function Pl2(t4) {
    var e4 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r4 = 1; r4 < arguments.length; r4++)
        e4[r4 - 1] = arguments[r4];
    bt3.push(new Ol2(t4, e4)), bt3.length === 1 && !xr4 && setTimeout(Bl2, 0);
  }
  function Ol2(t4, e4) {
    this.fun = t4, this.array = e4;
  }
  function ve3() {
  }
  function Gl2(t4) {
    bs3("_linkedBinding");
  }
  function Xl2(t4) {
    bs3("dlopen");
  }
  function Zl2() {
    return [];
  }
  function eu2() {
    return [];
  }
  function uu(t4, e4) {
    if (!t4)
      throw new Error(e4 || "assertion error");
  }
  function du() {
    return false;
  }
  function Pu2() {
    return Lt3.now() / 1e3;
  }
  function ji3(t4) {
    var e4 = Math.floor((Date.now() - Lt3.now()) * 1e-3), r4 = Lt3.now() * 1e-3, i5 = Math.floor(r4) + e4, n4 = Math.floor(r4 % 1 * 1e9);
    return t4 && (i5 = i5 - t4[0], n4 = n4 - t4[1], n4 < 0 && (i5--, n4 += ys3)), [i5, n4];
  }
  function wt4() {
    return $u;
  }
  function Wu2(t4) {
    return [];
  }
  function Xg() {
    if (Vu2)
      return ui2;
    Vu2 = true, ui2.byteLength = a4, ui2.toByteArray = c5, ui2.fromByteArray = g4;
    for (var t4 = [], e4 = [], r4 = typeof Uint8Array < "u" ? Uint8Array : Array, i5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n4 = 0, o4 = i5.length; n4 < o4; ++n4)
      t4[n4] = i5[n4], e4[i5.charCodeAt(n4)] = n4;
    e4["-".charCodeAt(0)] = 62, e4["_".charCodeAt(0)] = 63;
    function s4(y3) {
      var w3 = y3.length;
      if (w3 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var E4 = y3.indexOf("=");
      E4 === -1 && (E4 = w3);
      var S3 = E4 === w3 ? 0 : 4 - E4 % 4;
      return [E4, S3];
    }
    function a4(y3) {
      var w3 = s4(y3), E4 = w3[0], S3 = w3[1];
      return (E4 + S3) * 3 / 4 - S3;
    }
    function u4(y3, w3, E4) {
      return (w3 + E4) * 3 / 4 - E4;
    }
    function c5(y3) {
      var w3, E4 = s4(y3), S3 = E4[0], I3 = E4[1], C3 = new r4(u4(y3, S3, I3)), R5 = 0, U5 = I3 > 0 ? S3 - 4 : S3, N4;
      for (N4 = 0; N4 < U5; N4 += 4)
        w3 = e4[y3.charCodeAt(N4)] << 18 | e4[y3.charCodeAt(N4 + 1)] << 12 | e4[y3.charCodeAt(N4 + 2)] << 6 | e4[y3.charCodeAt(N4 + 3)], C3[R5++] = w3 >> 16 & 255, C3[R5++] = w3 >> 8 & 255, C3[R5++] = w3 & 255;
      return I3 === 2 && (w3 = e4[y3.charCodeAt(N4)] << 2 | e4[y3.charCodeAt(N4 + 1)] >> 4, C3[R5++] = w3 & 255), I3 === 1 && (w3 = e4[y3.charCodeAt(N4)] << 10 | e4[y3.charCodeAt(N4 + 1)] << 4 | e4[y3.charCodeAt(N4 + 2)] >> 2, C3[R5++] = w3 >> 8 & 255, C3[R5++] = w3 & 255), C3;
    }
    function h4(y3) {
      return t4[y3 >> 18 & 63] + t4[y3 >> 12 & 63] + t4[y3 >> 6 & 63] + t4[y3 & 63];
    }
    function d4(y3, w3, E4) {
      for (var S3, I3 = [], C3 = w3; C3 < E4; C3 += 3)
        S3 = (y3[C3] << 16 & 16711680) + (y3[C3 + 1] << 8 & 65280) + (y3[C3 + 2] & 255), I3.push(h4(S3));
      return I3.join("");
    }
    function g4(y3) {
      for (var w3, E4 = y3.length, S3 = E4 % 3, I3 = [], C3 = 16383, R5 = 0, U5 = E4 - S3; R5 < U5; R5 += C3)
        I3.push(d4(y3, R5, R5 + C3 > U5 ? U5 : R5 + C3));
      return S3 === 1 ? (w3 = y3[E4 - 1], I3.push(t4[w3 >> 2] + t4[w3 << 4 & 63] + "==")) : S3 === 2 && (w3 = (y3[E4 - 2] << 8) + y3[E4 - 1], I3.push(t4[w3 >> 10] + t4[w3 >> 4 & 63] + t4[w3 << 2 & 63] + "=")), I3.join("");
    }
    return ui2;
  }
  function Zg() {
    if (zu2)
      return Wi3;
    zu2 = true;
    return Wi3.read = function(t4, e4, r4, i5, n4) {
      var o4, s4, a4 = n4 * 8 - i5 - 1, u4 = (1 << a4) - 1, c5 = u4 >> 1, h4 = -7, d4 = r4 ? n4 - 1 : 0, g4 = r4 ? -1 : 1, y3 = t4[e4 + d4];
      for (d4 += g4, o4 = y3 & (1 << -h4) - 1, y3 >>= -h4, h4 += a4; h4 > 0; o4 = o4 * 256 + t4[e4 + d4], d4 += g4, h4 -= 8)
        ;
      for (s4 = o4 & (1 << -h4) - 1, o4 >>= -h4, h4 += i5; h4 > 0; s4 = s4 * 256 + t4[e4 + d4], d4 += g4, h4 -= 8)
        ;
      if (o4 === 0)
        o4 = 1 - c5;
      else {
        if (o4 === u4)
          return s4 ? NaN : (y3 ? -1 : 1) * (1 / 0);
        s4 = s4 + Math.pow(2, i5), o4 = o4 - c5;
      }
      return (y3 ? -1 : 1) * s4 * Math.pow(2, o4 - i5);
    }, Wi3.write = function(t4, e4, r4, i5, n4, o4) {
      var s4, a4, u4, c5 = o4 * 8 - n4 - 1, h4 = (1 << c5) - 1, d4 = h4 >> 1, g4 = n4 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y3 = i5 ? 0 : o4 - 1, w3 = i5 ? 1 : -1, E4 = e4 < 0 || e4 === 0 && 1 / e4 < 0 ? 1 : 0;
      for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (a4 = isNaN(e4) ? 1 : 0, s4 = h4) : (s4 = Math.floor(Math.log(e4) / Math.LN2), e4 * (u4 = Math.pow(2, -s4)) < 1 && (s4--, u4 *= 2), s4 + d4 >= 1 ? e4 += g4 / u4 : e4 += g4 * Math.pow(2, 1 - d4), e4 * u4 >= 2 && (s4++, u4 /= 2), s4 + d4 >= h4 ? (a4 = 0, s4 = h4) : s4 + d4 >= 1 ? (a4 = (e4 * u4 - 1) * Math.pow(2, n4), s4 = s4 + d4) : (a4 = e4 * Math.pow(2, d4 - 1) * Math.pow(2, n4), s4 = 0)); n4 >= 8; t4[r4 + y3] = a4 & 255, y3 += w3, a4 /= 256, n4 -= 8)
        ;
      for (s4 = s4 << n4 | a4, c5 += n4; c5 > 0; t4[r4 + y3] = s4 & 255, y3 += w3, s4 /= 256, c5 -= 8)
        ;
      t4[r4 + y3 - w3] |= E4 * 128;
    }, Wi3;
  }
  function ey() {
    if (Ku2)
      return Jt3;
    Ku2 = true;
    let t4 = Xg(), e4 = Zg(), r4 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Jt3.Buffer = s4, Jt3.SlowBuffer = I3, Jt3.INSPECT_MAX_BYTES = 50;
    let i5 = 2147483647;
    Jt3.kMaxLength = i5, s4.TYPED_ARRAY_SUPPORT = n4(), !s4.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function n4() {
      try {
        let p4 = new Uint8Array(1), l4 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(l4, Uint8Array.prototype), Object.setPrototypeOf(p4, l4), p4.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(s4.prototype, "parent", { enumerable: true, get: function() {
      if (s4.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(s4.prototype, "offset", { enumerable: true, get: function() {
      if (s4.isBuffer(this))
        return this.byteOffset;
    } });
    function o4(p4) {
      if (p4 > i5)
        throw new RangeError('The value "' + p4 + '" is invalid for option "size"');
      let l4 = new Uint8Array(p4);
      return Object.setPrototypeOf(l4, s4.prototype), l4;
    }
    function s4(p4, l4, f3) {
      if (typeof p4 == "number") {
        if (typeof l4 == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return h4(p4);
      }
      return a4(p4, l4, f3);
    }
    s4.poolSize = 8192;
    function a4(p4, l4, f3) {
      if (typeof p4 == "string")
        return d4(p4, l4);
      if (ArrayBuffer.isView(p4))
        return y3(p4);
      if (p4 == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p4);
      if (Ye3(p4, ArrayBuffer) || p4 && Ye3(p4.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ye3(p4, SharedArrayBuffer) || p4 && Ye3(p4.buffer, SharedArrayBuffer)))
        return w3(p4, l4, f3);
      if (typeof p4 == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let b3 = p4.valueOf && p4.valueOf();
      if (b3 != null && b3 !== p4)
        return s4.from(b3, l4, f3);
      let A3 = E4(p4);
      if (A3)
        return A3;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof p4[Symbol.toPrimitive] == "function")
        return s4.from(p4[Symbol.toPrimitive]("string"), l4, f3);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p4);
    }
    s4.from = function(p4, l4, f3) {
      return a4(p4, l4, f3);
    }, Object.setPrototypeOf(s4.prototype, Uint8Array.prototype), Object.setPrototypeOf(s4, Uint8Array);
    function u4(p4) {
      if (typeof p4 != "number")
        throw new TypeError('"size" argument must be of type number');
      if (p4 < 0)
        throw new RangeError('The value "' + p4 + '" is invalid for option "size"');
    }
    function c5(p4, l4, f3) {
      return u4(p4), p4 <= 0 ? o4(p4) : l4 !== void 0 ? typeof f3 == "string" ? o4(p4).fill(l4, f3) : o4(p4).fill(l4) : o4(p4);
    }
    s4.alloc = function(p4, l4, f3) {
      return c5(p4, l4, f3);
    };
    function h4(p4) {
      return u4(p4), o4(p4 < 0 ? 0 : S3(p4) | 0);
    }
    s4.allocUnsafe = function(p4) {
      return h4(p4);
    }, s4.allocUnsafeSlow = function(p4) {
      return h4(p4);
    };
    function d4(p4, l4) {
      if ((typeof l4 != "string" || l4 === "") && (l4 = "utf8"), !s4.isEncoding(l4))
        throw new TypeError("Unknown encoding: " + l4);
      let f3 = C3(p4, l4) | 0, b3 = o4(f3), A3 = b3.write(p4, l4);
      return A3 !== f3 && (b3 = b3.slice(0, A3)), b3;
    }
    function g4(p4) {
      let l4 = p4.length < 0 ? 0 : S3(p4.length) | 0, f3 = o4(l4);
      for (let b3 = 0; b3 < l4; b3 += 1)
        f3[b3] = p4[b3] & 255;
      return f3;
    }
    function y3(p4) {
      if (Ye3(p4, Uint8Array)) {
        let l4 = new Uint8Array(p4);
        return w3(l4.buffer, l4.byteOffset, l4.byteLength);
      }
      return g4(p4);
    }
    function w3(p4, l4, f3) {
      if (l4 < 0 || p4.byteLength < l4)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (p4.byteLength < l4 + (f3 || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let b3;
      return l4 === void 0 && f3 === void 0 ? b3 = new Uint8Array(p4) : f3 === void 0 ? b3 = new Uint8Array(p4, l4) : b3 = new Uint8Array(p4, l4, f3), Object.setPrototypeOf(b3, s4.prototype), b3;
    }
    function E4(p4) {
      if (s4.isBuffer(p4)) {
        let l4 = S3(p4.length) | 0, f3 = o4(l4);
        return f3.length === 0 || p4.copy(f3, 0, 0, l4), f3;
      }
      if (p4.length !== void 0)
        return typeof p4.length != "number" || ds3(p4.length) ? o4(0) : g4(p4);
      if (p4.type === "Buffer" && Array.isArray(p4.data))
        return g4(p4.data);
    }
    function S3(p4) {
      if (p4 >= i5)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i5.toString(16) + " bytes");
      return p4 | 0;
    }
    function I3(p4) {
      return +p4 != p4 && (p4 = 0), s4.alloc(+p4);
    }
    s4.isBuffer = function(l4) {
      return l4 != null && l4._isBuffer === true && l4 !== s4.prototype;
    }, s4.compare = function(l4, f3) {
      if (Ye3(l4, Uint8Array) && (l4 = s4.from(l4, l4.offset, l4.byteLength)), Ye3(f3, Uint8Array) && (f3 = s4.from(f3, f3.offset, f3.byteLength)), !s4.isBuffer(l4) || !s4.isBuffer(f3))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (l4 === f3)
        return 0;
      let b3 = l4.length, A3 = f3.length;
      for (let T3 = 0, O5 = Math.min(b3, A3); T3 < O5; ++T3)
        if (l4[T3] !== f3[T3]) {
          b3 = l4[T3], A3 = f3[T3];
          break;
        }
      return b3 < A3 ? -1 : A3 < b3 ? 1 : 0;
    }, s4.isEncoding = function(l4) {
      switch (String(l4).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, s4.concat = function(l4, f3) {
      if (!Array.isArray(l4))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (l4.length === 0)
        return s4.alloc(0);
      let b3;
      if (f3 === void 0)
        for (f3 = 0, b3 = 0; b3 < l4.length; ++b3)
          f3 += l4[b3].length;
      let A3 = s4.allocUnsafe(f3), T3 = 0;
      for (b3 = 0; b3 < l4.length; ++b3) {
        let O5 = l4[b3];
        if (Ye3(O5, Uint8Array))
          T3 + O5.length > A3.length ? (s4.isBuffer(O5) || (O5 = s4.from(O5)), O5.copy(A3, T3)) : Uint8Array.prototype.set.call(A3, O5, T3);
        else if (s4.isBuffer(O5))
          O5.copy(A3, T3);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        T3 += O5.length;
      }
      return A3;
    };
    function C3(p4, l4) {
      if (s4.isBuffer(p4))
        return p4.length;
      if (ArrayBuffer.isView(p4) || Ye3(p4, ArrayBuffer))
        return p4.byteLength;
      if (typeof p4 != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof p4);
      let f3 = p4.length, b3 = arguments.length > 2 && arguments[2] === true;
      if (!b3 && f3 === 0)
        return 0;
      let A3 = false;
      for (; ; )
        switch (l4) {
          case "ascii":
          case "latin1":
          case "binary":
            return f3;
          case "utf8":
          case "utf-8":
            return hs3(p4).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return f3 * 2;
          case "hex":
            return f3 >>> 1;
          case "base64":
            return Cl2(p4).length;
          default:
            if (A3)
              return b3 ? -1 : hs3(p4).length;
            l4 = ("" + l4).toLowerCase(), A3 = true;
        }
    }
    s4.byteLength = C3;
    function R5(p4, l4, f3) {
      let b3 = false;
      if ((l4 === void 0 || l4 < 0) && (l4 = 0), l4 > this.length || ((f3 === void 0 || f3 > this.length) && (f3 = this.length), f3 <= 0) || (f3 >>>= 0, l4 >>>= 0, f3 <= l4))
        return "";
      for (p4 || (p4 = "utf8"); ; )
        switch (p4) {
          case "hex":
            return qg(this, l4, f3);
          case "utf8":
          case "utf-8":
            return Cr3(this, l4, f3);
          case "ascii":
            return fs3(this, l4, f3);
          case "latin1":
          case "binary":
            return Ng(this, l4, f3);
          case "base64":
            return pe3(this, l4, f3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Dg(this, l4, f3);
          default:
            if (b3)
              throw new TypeError("Unknown encoding: " + p4);
            p4 = (p4 + "").toLowerCase(), b3 = true;
        }
    }
    s4.prototype._isBuffer = true;
    function U5(p4, l4, f3) {
      let b3 = p4[l4];
      p4[l4] = p4[f3], p4[f3] = b3;
    }
    s4.prototype.swap16 = function() {
      let l4 = this.length;
      if (l4 % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let f3 = 0; f3 < l4; f3 += 2)
        U5(this, f3, f3 + 1);
      return this;
    }, s4.prototype.swap32 = function() {
      let l4 = this.length;
      if (l4 % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let f3 = 0; f3 < l4; f3 += 4)
        U5(this, f3, f3 + 3), U5(this, f3 + 1, f3 + 2);
      return this;
    }, s4.prototype.swap64 = function() {
      let l4 = this.length;
      if (l4 % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let f3 = 0; f3 < l4; f3 += 8)
        U5(this, f3, f3 + 7), U5(this, f3 + 1, f3 + 6), U5(this, f3 + 2, f3 + 5), U5(this, f3 + 3, f3 + 4);
      return this;
    }, s4.prototype.toString = function() {
      let l4 = this.length;
      return l4 === 0 ? "" : arguments.length === 0 ? Cr3(this, 0, l4) : R5.apply(this, arguments);
    }, s4.prototype.toLocaleString = s4.prototype.toString, s4.prototype.equals = function(l4) {
      if (!s4.isBuffer(l4))
        throw new TypeError("Argument must be a Buffer");
      return this === l4 ? true : s4.compare(this, l4) === 0;
    }, s4.prototype.inspect = function() {
      let l4 = "", f3 = Jt3.INSPECT_MAX_BYTES;
      return l4 = this.toString("hex", 0, f3).replace(/(.{2})/g, "$1 ").trim(), this.length > f3 && (l4 += " ... "), "<Buffer " + l4 + ">";
    }, r4 && (s4.prototype[r4] = s4.prototype.inspect), s4.prototype.compare = function(l4, f3, b3, A3, T3) {
      if (Ye3(l4, Uint8Array) && (l4 = s4.from(l4, l4.offset, l4.byteLength)), !s4.isBuffer(l4))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l4);
      if (f3 === void 0 && (f3 = 0), b3 === void 0 && (b3 = l4 ? l4.length : 0), A3 === void 0 && (A3 = 0), T3 === void 0 && (T3 = this.length), f3 < 0 || b3 > l4.length || A3 < 0 || T3 > this.length)
        throw new RangeError("out of range index");
      if (A3 >= T3 && f3 >= b3)
        return 0;
      if (A3 >= T3)
        return -1;
      if (f3 >= b3)
        return 1;
      if (f3 >>>= 0, b3 >>>= 0, A3 >>>= 0, T3 >>>= 0, this === l4)
        return 0;
      let O5 = T3 - A3, $5 = b3 - f3, se3 = Math.min(O5, $5), te3 = this.slice(A3, T3), oe4 = l4.slice(f3, b3);
      for (let J3 = 0; J3 < se3; ++J3)
        if (te3[J3] !== oe4[J3]) {
          O5 = te3[J3], $5 = oe4[J3];
          break;
        }
      return O5 < $5 ? -1 : $5 < O5 ? 1 : 0;
    };
    function N4(p4, l4, f3, b3, A3) {
      if (p4.length === 0)
        return -1;
      if (typeof f3 == "string" ? (b3 = f3, f3 = 0) : f3 > 2147483647 ? f3 = 2147483647 : f3 < -2147483648 && (f3 = -2147483648), f3 = +f3, ds3(f3) && (f3 = A3 ? 0 : p4.length - 1), f3 < 0 && (f3 = p4.length + f3), f3 >= p4.length) {
        if (A3)
          return -1;
        f3 = p4.length - 1;
      } else if (f3 < 0)
        if (A3)
          f3 = 0;
        else
          return -1;
      if (typeof l4 == "string" && (l4 = s4.from(l4, b3)), s4.isBuffer(l4))
        return l4.length === 0 ? -1 : W4(p4, l4, f3, b3, A3);
      if (typeof l4 == "number")
        return l4 = l4 & 255, typeof Uint8Array.prototype.indexOf == "function" ? A3 ? Uint8Array.prototype.indexOf.call(p4, l4, f3) : Uint8Array.prototype.lastIndexOf.call(p4, l4, f3) : W4(p4, [l4], f3, b3, A3);
      throw new TypeError("val must be string, number or Buffer");
    }
    function W4(p4, l4, f3, b3, A3) {
      let T3 = 1, O5 = p4.length, $5 = l4.length;
      if (b3 !== void 0 && (b3 = String(b3).toLowerCase(), b3 === "ucs2" || b3 === "ucs-2" || b3 === "utf16le" || b3 === "utf-16le")) {
        if (p4.length < 2 || l4.length < 2)
          return -1;
        T3 = 2, O5 /= 2, $5 /= 2, f3 /= 2;
      }
      function se3(oe4, J3) {
        return T3 === 1 ? oe4[J3] : oe4.readUInt16BE(J3 * T3);
      }
      let te3;
      if (A3) {
        let oe4 = -1;
        for (te3 = f3; te3 < O5; te3++)
          if (se3(p4, te3) === se3(l4, oe4 === -1 ? 0 : te3 - oe4)) {
            if (oe4 === -1 && (oe4 = te3), te3 - oe4 + 1 === $5)
              return oe4 * T3;
          } else
            oe4 !== -1 && (te3 -= te3 - oe4), oe4 = -1;
      } else
        for (f3 + $5 > O5 && (f3 = O5 - $5), te3 = f3; te3 >= 0; te3--) {
          let oe4 = true;
          for (let J3 = 0; J3 < $5; J3++)
            if (se3(p4, te3 + J3) !== se3(l4, J3)) {
              oe4 = false;
              break;
            }
          if (oe4)
            return te3;
        }
      return -1;
    }
    s4.prototype.includes = function(l4, f3, b3) {
      return this.indexOf(l4, f3, b3) !== -1;
    }, s4.prototype.indexOf = function(l4, f3, b3) {
      return N4(this, l4, f3, b3, true);
    }, s4.prototype.lastIndexOf = function(l4, f3, b3) {
      return N4(this, l4, f3, b3, false);
    };
    function K5(p4, l4, f3, b3) {
      f3 = Number(f3) || 0;
      let A3 = p4.length - f3;
      b3 ? (b3 = Number(b3), b3 > A3 && (b3 = A3)) : b3 = A3;
      let T3 = l4.length;
      b3 > T3 / 2 && (b3 = T3 / 2);
      let O5;
      for (O5 = 0; O5 < b3; ++O5) {
        let $5 = parseInt(l4.substr(O5 * 2, 2), 16);
        if (ds3($5))
          return O5;
        p4[f3 + O5] = $5;
      }
      return O5;
    }
    function z4(p4, l4, f3, b3) {
      return qi3(hs3(l4, p4.length - f3), p4, f3, b3);
    }
    function Q3(p4, l4, f3, b3) {
      return qi3($g(l4), p4, f3, b3);
    }
    function de3(p4, l4, f3, b3) {
      return qi3(Cl2(l4), p4, f3, b3);
    }
    function Gt3(p4, l4, f3, b3) {
      return qi3(Hg(l4, p4.length - f3), p4, f3, b3);
    }
    s4.prototype.write = function(l4, f3, b3, A3) {
      if (f3 === void 0)
        A3 = "utf8", b3 = this.length, f3 = 0;
      else if (b3 === void 0 && typeof f3 == "string")
        A3 = f3, b3 = this.length, f3 = 0;
      else if (isFinite(f3))
        f3 = f3 >>> 0, isFinite(b3) ? (b3 = b3 >>> 0, A3 === void 0 && (A3 = "utf8")) : (A3 = b3, b3 = void 0);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let T3 = this.length - f3;
      if ((b3 === void 0 || b3 > T3) && (b3 = T3), l4.length > 0 && (b3 < 0 || f3 < 0) || f3 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      A3 || (A3 = "utf8");
      let O5 = false;
      for (; ; )
        switch (A3) {
          case "hex":
            return K5(this, l4, f3, b3);
          case "utf8":
          case "utf-8":
            return z4(this, l4, f3, b3);
          case "ascii":
          case "latin1":
          case "binary":
            return Q3(this, l4, f3, b3);
          case "base64":
            return de3(this, l4, f3, b3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Gt3(this, l4, f3, b3);
          default:
            if (O5)
              throw new TypeError("Unknown encoding: " + A3);
            A3 = ("" + A3).toLowerCase(), O5 = true;
        }
    }, s4.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function pe3(p4, l4, f3) {
      return l4 === 0 && f3 === p4.length ? t4.fromByteArray(p4) : t4.fromByteArray(p4.slice(l4, f3));
    }
    function Cr3(p4, l4, f3) {
      f3 = Math.min(p4.length, f3);
      let b3 = [], A3 = l4;
      for (; A3 < f3; ) {
        let T3 = p4[A3], O5 = null, $5 = T3 > 239 ? 4 : T3 > 223 ? 3 : T3 > 191 ? 2 : 1;
        if (A3 + $5 <= f3) {
          let se3, te3, oe4, J3;
          switch ($5) {
            case 1:
              T3 < 128 && (O5 = T3);
              break;
            case 2:
              se3 = p4[A3 + 1], (se3 & 192) === 128 && (J3 = (T3 & 31) << 6 | se3 & 63, J3 > 127 && (O5 = J3));
              break;
            case 3:
              se3 = p4[A3 + 1], te3 = p4[A3 + 2], (se3 & 192) === 128 && (te3 & 192) === 128 && (J3 = (T3 & 15) << 12 | (se3 & 63) << 6 | te3 & 63, J3 > 2047 && (J3 < 55296 || J3 > 57343) && (O5 = J3));
              break;
            case 4:
              se3 = p4[A3 + 1], te3 = p4[A3 + 2], oe4 = p4[A3 + 3], (se3 & 192) === 128 && (te3 & 192) === 128 && (oe4 & 192) === 128 && (J3 = (T3 & 15) << 18 | (se3 & 63) << 12 | (te3 & 63) << 6 | oe4 & 63, J3 > 65535 && J3 < 1114112 && (O5 = J3));
          }
        }
        O5 === null ? (O5 = 65533, $5 = 1) : O5 > 65535 && (O5 -= 65536, b3.push(O5 >>> 10 & 1023 | 55296), O5 = 56320 | O5 & 1023), b3.push(O5), A3 += $5;
      }
      return Pr3(b3);
    }
    let Br4 = 4096;
    function Pr3(p4) {
      let l4 = p4.length;
      if (l4 <= Br4)
        return String.fromCharCode.apply(String, p4);
      let f3 = "", b3 = 0;
      for (; b3 < l4; )
        f3 += String.fromCharCode.apply(String, p4.slice(b3, b3 += Br4));
      return f3;
    }
    function fs3(p4, l4, f3) {
      let b3 = "";
      f3 = Math.min(p4.length, f3);
      for (let A3 = l4; A3 < f3; ++A3)
        b3 += String.fromCharCode(p4[A3] & 127);
      return b3;
    }
    function Ng(p4, l4, f3) {
      let b3 = "";
      f3 = Math.min(p4.length, f3);
      for (let A3 = l4; A3 < f3; ++A3)
        b3 += String.fromCharCode(p4[A3]);
      return b3;
    }
    function qg(p4, l4, f3) {
      let b3 = p4.length;
      (!l4 || l4 < 0) && (l4 = 0), (!f3 || f3 < 0 || f3 > b3) && (f3 = b3);
      let A3 = "";
      for (let T3 = l4; T3 < f3; ++T3)
        A3 += Vg[p4[T3]];
      return A3;
    }
    function Dg(p4, l4, f3) {
      let b3 = p4.slice(l4, f3), A3 = "";
      for (let T3 = 0; T3 < b3.length - 1; T3 += 2)
        A3 += String.fromCharCode(b3[T3] + b3[T3 + 1] * 256);
      return A3;
    }
    s4.prototype.slice = function(l4, f3) {
      let b3 = this.length;
      l4 = ~~l4, f3 = f3 === void 0 ? b3 : ~~f3, l4 < 0 ? (l4 += b3, l4 < 0 && (l4 = 0)) : l4 > b3 && (l4 = b3), f3 < 0 ? (f3 += b3, f3 < 0 && (f3 = 0)) : f3 > b3 && (f3 = b3), f3 < l4 && (f3 = l4);
      let A3 = this.subarray(l4, f3);
      return Object.setPrototypeOf(A3, s4.prototype), A3;
    };
    function ge4(p4, l4, f3) {
      if (p4 % 1 !== 0 || p4 < 0)
        throw new RangeError("offset is not uint");
      if (p4 + l4 > f3)
        throw new RangeError("Trying to access beyond buffer length");
    }
    s4.prototype.readUintLE = s4.prototype.readUIntLE = function(l4, f3, b3) {
      l4 = l4 >>> 0, f3 = f3 >>> 0, b3 || ge4(l4, f3, this.length);
      let A3 = this[l4], T3 = 1, O5 = 0;
      for (; ++O5 < f3 && (T3 *= 256); )
        A3 += this[l4 + O5] * T3;
      return A3;
    }, s4.prototype.readUintBE = s4.prototype.readUIntBE = function(l4, f3, b3) {
      l4 = l4 >>> 0, f3 = f3 >>> 0, b3 || ge4(l4, f3, this.length);
      let A3 = this[l4 + --f3], T3 = 1;
      for (; f3 > 0 && (T3 *= 256); )
        A3 += this[l4 + --f3] * T3;
      return A3;
    }, s4.prototype.readUint8 = s4.prototype.readUInt8 = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 1, this.length), this[l4];
    }, s4.prototype.readUint16LE = s4.prototype.readUInt16LE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 2, this.length), this[l4] | this[l4 + 1] << 8;
    }, s4.prototype.readUint16BE = s4.prototype.readUInt16BE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 2, this.length), this[l4] << 8 | this[l4 + 1];
    }, s4.prototype.readUint32LE = s4.prototype.readUInt32LE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 4, this.length), (this[l4] | this[l4 + 1] << 8 | this[l4 + 2] << 16) + this[l4 + 3] * 16777216;
    }, s4.prototype.readUint32BE = s4.prototype.readUInt32BE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 4, this.length), this[l4] * 16777216 + (this[l4 + 1] << 16 | this[l4 + 2] << 8 | this[l4 + 3]);
    }, s4.prototype.readBigUInt64LE = Mt3(function(l4) {
      l4 = l4 >>> 0, kr4(l4, "offset");
      let f3 = this[l4], b3 = this[l4 + 7];
      (f3 === void 0 || b3 === void 0) && li2(l4, this.length - 8);
      let A3 = f3 + this[++l4] * 2 ** 8 + this[++l4] * 2 ** 16 + this[++l4] * 2 ** 24, T3 = this[++l4] + this[++l4] * 2 ** 8 + this[++l4] * 2 ** 16 + b3 * 2 ** 24;
      return BigInt(A3) + (BigInt(T3) << BigInt(32));
    }), s4.prototype.readBigUInt64BE = Mt3(function(l4) {
      l4 = l4 >>> 0, kr4(l4, "offset");
      let f3 = this[l4], b3 = this[l4 + 7];
      (f3 === void 0 || b3 === void 0) && li2(l4, this.length - 8);
      let A3 = f3 * 2 ** 24 + this[++l4] * 2 ** 16 + this[++l4] * 2 ** 8 + this[++l4], T3 = this[++l4] * 2 ** 24 + this[++l4] * 2 ** 16 + this[++l4] * 2 ** 8 + b3;
      return (BigInt(A3) << BigInt(32)) + BigInt(T3);
    }), s4.prototype.readIntLE = function(l4, f3, b3) {
      l4 = l4 >>> 0, f3 = f3 >>> 0, b3 || ge4(l4, f3, this.length);
      let A3 = this[l4], T3 = 1, O5 = 0;
      for (; ++O5 < f3 && (T3 *= 256); )
        A3 += this[l4 + O5] * T3;
      return T3 *= 128, A3 >= T3 && (A3 -= Math.pow(2, 8 * f3)), A3;
    }, s4.prototype.readIntBE = function(l4, f3, b3) {
      l4 = l4 >>> 0, f3 = f3 >>> 0, b3 || ge4(l4, f3, this.length);
      let A3 = f3, T3 = 1, O5 = this[l4 + --A3];
      for (; A3 > 0 && (T3 *= 256); )
        O5 += this[l4 + --A3] * T3;
      return T3 *= 128, O5 >= T3 && (O5 -= Math.pow(2, 8 * f3)), O5;
    }, s4.prototype.readInt8 = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 1, this.length), this[l4] & 128 ? (255 - this[l4] + 1) * -1 : this[l4];
    }, s4.prototype.readInt16LE = function(l4, f3) {
      l4 = l4 >>> 0, f3 || ge4(l4, 2, this.length);
      let b3 = this[l4] | this[l4 + 1] << 8;
      return b3 & 32768 ? b3 | 4294901760 : b3;
    }, s4.prototype.readInt16BE = function(l4, f3) {
      l4 = l4 >>> 0, f3 || ge4(l4, 2, this.length);
      let b3 = this[l4 + 1] | this[l4] << 8;
      return b3 & 32768 ? b3 | 4294901760 : b3;
    }, s4.prototype.readInt32LE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 4, this.length), this[l4] | this[l4 + 1] << 8 | this[l4 + 2] << 16 | this[l4 + 3] << 24;
    }, s4.prototype.readInt32BE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 4, this.length), this[l4] << 24 | this[l4 + 1] << 16 | this[l4 + 2] << 8 | this[l4 + 3];
    }, s4.prototype.readBigInt64LE = Mt3(function(l4) {
      l4 = l4 >>> 0, kr4(l4, "offset");
      let f3 = this[l4], b3 = this[l4 + 7];
      (f3 === void 0 || b3 === void 0) && li2(l4, this.length - 8);
      let A3 = this[l4 + 4] + this[l4 + 5] * 2 ** 8 + this[l4 + 6] * 2 ** 16 + (b3 << 24);
      return (BigInt(A3) << BigInt(32)) + BigInt(f3 + this[++l4] * 2 ** 8 + this[++l4] * 2 ** 16 + this[++l4] * 2 ** 24);
    }), s4.prototype.readBigInt64BE = Mt3(function(l4) {
      l4 = l4 >>> 0, kr4(l4, "offset");
      let f3 = this[l4], b3 = this[l4 + 7];
      (f3 === void 0 || b3 === void 0) && li2(l4, this.length - 8);
      let A3 = (f3 << 24) + this[++l4] * 2 ** 16 + this[++l4] * 2 ** 8 + this[++l4];
      return (BigInt(A3) << BigInt(32)) + BigInt(this[++l4] * 2 ** 24 + this[++l4] * 2 ** 16 + this[++l4] * 2 ** 8 + b3);
    }), s4.prototype.readFloatLE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 4, this.length), e4.read(this, l4, true, 23, 4);
    }, s4.prototype.readFloatBE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 4, this.length), e4.read(this, l4, false, 23, 4);
    }, s4.prototype.readDoubleLE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 8, this.length), e4.read(this, l4, true, 52, 8);
    }, s4.prototype.readDoubleBE = function(l4, f3) {
      return l4 = l4 >>> 0, f3 || ge4(l4, 8, this.length), e4.read(this, l4, false, 52, 8);
    };
    function Ce5(p4, l4, f3, b3, A3, T3) {
      if (!s4.isBuffer(p4))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (l4 > A3 || l4 < T3)
        throw new RangeError('"value" argument is out of bounds');
      if (f3 + b3 > p4.length)
        throw new RangeError("Index out of range");
    }
    s4.prototype.writeUintLE = s4.prototype.writeUIntLE = function(l4, f3, b3, A3) {
      if (l4 = +l4, f3 = f3 >>> 0, b3 = b3 >>> 0, !A3) {
        let $5 = Math.pow(2, 8 * b3) - 1;
        Ce5(this, l4, f3, b3, $5, 0);
      }
      let T3 = 1, O5 = 0;
      for (this[f3] = l4 & 255; ++O5 < b3 && (T3 *= 256); )
        this[f3 + O5] = l4 / T3 & 255;
      return f3 + b3;
    }, s4.prototype.writeUintBE = s4.prototype.writeUIntBE = function(l4, f3, b3, A3) {
      if (l4 = +l4, f3 = f3 >>> 0, b3 = b3 >>> 0, !A3) {
        let $5 = Math.pow(2, 8 * b3) - 1;
        Ce5(this, l4, f3, b3, $5, 0);
      }
      let T3 = b3 - 1, O5 = 1;
      for (this[f3 + T3] = l4 & 255; --T3 >= 0 && (O5 *= 256); )
        this[f3 + T3] = l4 / O5 & 255;
      return f3 + b3;
    }, s4.prototype.writeUint8 = s4.prototype.writeUInt8 = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 1, 255, 0), this[f3] = l4 & 255, f3 + 1;
    }, s4.prototype.writeUint16LE = s4.prototype.writeUInt16LE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 2, 65535, 0), this[f3] = l4 & 255, this[f3 + 1] = l4 >>> 8, f3 + 2;
    }, s4.prototype.writeUint16BE = s4.prototype.writeUInt16BE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 2, 65535, 0), this[f3] = l4 >>> 8, this[f3 + 1] = l4 & 255, f3 + 2;
    }, s4.prototype.writeUint32LE = s4.prototype.writeUInt32LE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 4, 4294967295, 0), this[f3 + 3] = l4 >>> 24, this[f3 + 2] = l4 >>> 16, this[f3 + 1] = l4 >>> 8, this[f3] = l4 & 255, f3 + 4;
    }, s4.prototype.writeUint32BE = s4.prototype.writeUInt32BE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 4, 4294967295, 0), this[f3] = l4 >>> 24, this[f3 + 1] = l4 >>> 16, this[f3 + 2] = l4 >>> 8, this[f3 + 3] = l4 & 255, f3 + 4;
    };
    function vl2(p4, l4, f3, b3, A3) {
      Rl2(l4, b3, A3, p4, f3, 7);
      let T3 = Number(l4 & BigInt(4294967295));
      p4[f3++] = T3, T3 = T3 >> 8, p4[f3++] = T3, T3 = T3 >> 8, p4[f3++] = T3, T3 = T3 >> 8, p4[f3++] = T3;
      let O5 = Number(l4 >> BigInt(32) & BigInt(4294967295));
      return p4[f3++] = O5, O5 = O5 >> 8, p4[f3++] = O5, O5 = O5 >> 8, p4[f3++] = O5, O5 = O5 >> 8, p4[f3++] = O5, f3;
    }
    function El2(p4, l4, f3, b3, A3) {
      Rl2(l4, b3, A3, p4, f3, 7);
      let T3 = Number(l4 & BigInt(4294967295));
      p4[f3 + 7] = T3, T3 = T3 >> 8, p4[f3 + 6] = T3, T3 = T3 >> 8, p4[f3 + 5] = T3, T3 = T3 >> 8, p4[f3 + 4] = T3;
      let O5 = Number(l4 >> BigInt(32) & BigInt(4294967295));
      return p4[f3 + 3] = O5, O5 = O5 >> 8, p4[f3 + 2] = O5, O5 = O5 >> 8, p4[f3 + 1] = O5, O5 = O5 >> 8, p4[f3] = O5, f3 + 8;
    }
    s4.prototype.writeBigUInt64LE = Mt3(function(l4, f3 = 0) {
      return vl2(this, l4, f3, BigInt(0), BigInt("0xffffffffffffffff"));
    }), s4.prototype.writeBigUInt64BE = Mt3(function(l4, f3 = 0) {
      return El2(this, l4, f3, BigInt(0), BigInt("0xffffffffffffffff"));
    }), s4.prototype.writeIntLE = function(l4, f3, b3, A3) {
      if (l4 = +l4, f3 = f3 >>> 0, !A3) {
        let se3 = Math.pow(2, 8 * b3 - 1);
        Ce5(this, l4, f3, b3, se3 - 1, -se3);
      }
      let T3 = 0, O5 = 1, $5 = 0;
      for (this[f3] = l4 & 255; ++T3 < b3 && (O5 *= 256); )
        l4 < 0 && $5 === 0 && this[f3 + T3 - 1] !== 0 && ($5 = 1), this[f3 + T3] = (l4 / O5 >> 0) - $5 & 255;
      return f3 + b3;
    }, s4.prototype.writeIntBE = function(l4, f3, b3, A3) {
      if (l4 = +l4, f3 = f3 >>> 0, !A3) {
        let se3 = Math.pow(2, 8 * b3 - 1);
        Ce5(this, l4, f3, b3, se3 - 1, -se3);
      }
      let T3 = b3 - 1, O5 = 1, $5 = 0;
      for (this[f3 + T3] = l4 & 255; --T3 >= 0 && (O5 *= 256); )
        l4 < 0 && $5 === 0 && this[f3 + T3 + 1] !== 0 && ($5 = 1), this[f3 + T3] = (l4 / O5 >> 0) - $5 & 255;
      return f3 + b3;
    }, s4.prototype.writeInt8 = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 1, 127, -128), l4 < 0 && (l4 = 255 + l4 + 1), this[f3] = l4 & 255, f3 + 1;
    }, s4.prototype.writeInt16LE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 2, 32767, -32768), this[f3] = l4 & 255, this[f3 + 1] = l4 >>> 8, f3 + 2;
    }, s4.prototype.writeInt16BE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 2, 32767, -32768), this[f3] = l4 >>> 8, this[f3 + 1] = l4 & 255, f3 + 2;
    }, s4.prototype.writeInt32LE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 4, 2147483647, -2147483648), this[f3] = l4 & 255, this[f3 + 1] = l4 >>> 8, this[f3 + 2] = l4 >>> 16, this[f3 + 3] = l4 >>> 24, f3 + 4;
    }, s4.prototype.writeInt32BE = function(l4, f3, b3) {
      return l4 = +l4, f3 = f3 >>> 0, b3 || Ce5(this, l4, f3, 4, 2147483647, -2147483648), l4 < 0 && (l4 = 4294967295 + l4 + 1), this[f3] = l4 >>> 24, this[f3 + 1] = l4 >>> 16, this[f3 + 2] = l4 >>> 8, this[f3 + 3] = l4 & 255, f3 + 4;
    }, s4.prototype.writeBigInt64LE = Mt3(function(l4, f3 = 0) {
      return vl2(this, l4, f3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), s4.prototype.writeBigInt64BE = Mt3(function(l4, f3 = 0) {
      return El2(this, l4, f3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Sl2(p4, l4, f3, b3, A3, T3) {
      if (f3 + b3 > p4.length)
        throw new RangeError("Index out of range");
      if (f3 < 0)
        throw new RangeError("Index out of range");
    }
    function Al2(p4, l4, f3, b3, A3) {
      return l4 = +l4, f3 = f3 >>> 0, A3 || Sl2(p4, l4, f3, 4), e4.write(p4, l4, f3, b3, 23, 4), f3 + 4;
    }
    s4.prototype.writeFloatLE = function(l4, f3, b3) {
      return Al2(this, l4, f3, true, b3);
    }, s4.prototype.writeFloatBE = function(l4, f3, b3) {
      return Al2(this, l4, f3, false, b3);
    };
    function Il2(p4, l4, f3, b3, A3) {
      return l4 = +l4, f3 = f3 >>> 0, A3 || Sl2(p4, l4, f3, 8), e4.write(p4, l4, f3, b3, 52, 8), f3 + 8;
    }
    s4.prototype.writeDoubleLE = function(l4, f3, b3) {
      return Il2(this, l4, f3, true, b3);
    }, s4.prototype.writeDoubleBE = function(l4, f3, b3) {
      return Il2(this, l4, f3, false, b3);
    }, s4.prototype.copy = function(l4, f3, b3, A3) {
      if (!s4.isBuffer(l4))
        throw new TypeError("argument should be a Buffer");
      if (b3 || (b3 = 0), !A3 && A3 !== 0 && (A3 = this.length), f3 >= l4.length && (f3 = l4.length), f3 || (f3 = 0), A3 > 0 && A3 < b3 && (A3 = b3), A3 === b3 || l4.length === 0 || this.length === 0)
        return 0;
      if (f3 < 0)
        throw new RangeError("targetStart out of bounds");
      if (b3 < 0 || b3 >= this.length)
        throw new RangeError("Index out of range");
      if (A3 < 0)
        throw new RangeError("sourceEnd out of bounds");
      A3 > this.length && (A3 = this.length), l4.length - f3 < A3 - b3 && (A3 = l4.length - f3 + b3);
      let T3 = A3 - b3;
      return this === l4 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(f3, b3, A3) : Uint8Array.prototype.set.call(l4, this.subarray(b3, A3), f3), T3;
    }, s4.prototype.fill = function(l4, f3, b3, A3) {
      if (typeof l4 == "string") {
        if (typeof f3 == "string" ? (A3 = f3, f3 = 0, b3 = this.length) : typeof b3 == "string" && (A3 = b3, b3 = this.length), A3 !== void 0 && typeof A3 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof A3 == "string" && !s4.isEncoding(A3))
          throw new TypeError("Unknown encoding: " + A3);
        if (l4.length === 1) {
          let O5 = l4.charCodeAt(0);
          (A3 === "utf8" && O5 < 128 || A3 === "latin1") && (l4 = O5);
        }
      } else
        typeof l4 == "number" ? l4 = l4 & 255 : typeof l4 == "boolean" && (l4 = Number(l4));
      if (f3 < 0 || this.length < f3 || this.length < b3)
        throw new RangeError("Out of range index");
      if (b3 <= f3)
        return this;
      f3 = f3 >>> 0, b3 = b3 === void 0 ? this.length : b3 >>> 0, l4 || (l4 = 0);
      let T3;
      if (typeof l4 == "number")
        for (T3 = f3; T3 < b3; ++T3)
          this[T3] = l4;
      else {
        let O5 = s4.isBuffer(l4) ? l4 : s4.from(l4, A3), $5 = O5.length;
        if ($5 === 0)
          throw new TypeError('The value "' + l4 + '" is invalid for argument "value"');
        for (T3 = 0; T3 < b3 - f3; ++T3)
          this[T3 + f3] = O5[T3 % $5];
      }
      return this;
    };
    let Or3 = {};
    function cs3(p4, l4, f3) {
      Or3[p4] = class extends f3 {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: l4.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${p4}]`, this.stack, delete this.name;
        }
        get code() {
          return p4;
        }
        set code(A3) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: A3, writable: true });
        }
        toString() {
          return `${this.name} [${p4}]: ${this.message}`;
        }
      };
    }
    cs3("ERR_BUFFER_OUT_OF_BOUNDS", function(p4) {
      return p4 ? `${p4} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), cs3("ERR_INVALID_ARG_TYPE", function(p4, l4) {
      return `The "${p4}" argument must be of type number. Received type ${typeof l4}`;
    }, TypeError), cs3("ERR_OUT_OF_RANGE", function(p4, l4, f3) {
      let b3 = `The value of "${p4}" is out of range.`, A3 = f3;
      return Number.isInteger(f3) && Math.abs(f3) > 2 ** 32 ? A3 = Tl2(String(f3)) : typeof f3 == "bigint" && (A3 = String(f3), (f3 > BigInt(2) ** BigInt(32) || f3 < -(BigInt(2) ** BigInt(32))) && (A3 = Tl2(A3)), A3 += "n"), b3 += ` It must be ${l4}. Received ${A3}`, b3;
    }, RangeError);
    function Tl2(p4) {
      let l4 = "", f3 = p4.length, b3 = p4[0] === "-" ? 1 : 0;
      for (; f3 >= b3 + 4; f3 -= 3)
        l4 = `_${p4.slice(f3 - 3, f3)}${l4}`;
      return `${p4.slice(0, f3)}${l4}`;
    }
    function jg(p4, l4, f3) {
      kr4(l4, "offset"), (p4[l4] === void 0 || p4[l4 + f3] === void 0) && li2(l4, p4.length - (f3 + 1));
    }
    function Rl2(p4, l4, f3, b3, A3, T3) {
      if (p4 > f3 || p4 < l4) {
        let O5 = typeof l4 == "bigint" ? "n" : "", $5;
        throw T3 > 3 ? l4 === 0 || l4 === BigInt(0) ? $5 = `>= 0${O5} and < 2${O5} ** ${(T3 + 1) * 8}${O5}` : $5 = `>= -(2${O5} ** ${(T3 + 1) * 8 - 1}${O5}) and < 2 ** ${(T3 + 1) * 8 - 1}${O5}` : $5 = `>= ${l4}${O5} and <= ${f3}${O5}`, new Or3.ERR_OUT_OF_RANGE("value", $5, p4);
      }
      jg(b3, A3, T3);
    }
    function kr4(p4, l4) {
      if (typeof p4 != "number")
        throw new Or3.ERR_INVALID_ARG_TYPE(l4, "number", p4);
    }
    function li2(p4, l4, f3) {
      throw Math.floor(p4) !== p4 ? (kr4(p4, f3), new Or3.ERR_OUT_OF_RANGE(f3 || "offset", "an integer", p4)) : l4 < 0 ? new Or3.ERR_BUFFER_OUT_OF_BOUNDS() : new Or3.ERR_OUT_OF_RANGE(f3 || "offset", `>= ${f3 ? 1 : 0} and <= ${l4}`, p4);
    }
    let Fg = /[^+/0-9A-Za-z-_]/g;
    function Wg(p4) {
      if (p4 = p4.split("=")[0], p4 = p4.trim().replace(Fg, ""), p4.length < 2)
        return "";
      for (; p4.length % 4 !== 0; )
        p4 = p4 + "=";
      return p4;
    }
    function hs3(p4, l4) {
      l4 = l4 || 1 / 0;
      let f3, b3 = p4.length, A3 = null, T3 = [];
      for (let O5 = 0; O5 < b3; ++O5) {
        if (f3 = p4.charCodeAt(O5), f3 > 55295 && f3 < 57344) {
          if (!A3) {
            if (f3 > 56319) {
              (l4 -= 3) > -1 && T3.push(239, 191, 189);
              continue;
            } else if (O5 + 1 === b3) {
              (l4 -= 3) > -1 && T3.push(239, 191, 189);
              continue;
            }
            A3 = f3;
            continue;
          }
          if (f3 < 56320) {
            (l4 -= 3) > -1 && T3.push(239, 191, 189), A3 = f3;
            continue;
          }
          f3 = (A3 - 55296 << 10 | f3 - 56320) + 65536;
        } else
          A3 && (l4 -= 3) > -1 && T3.push(239, 191, 189);
        if (A3 = null, f3 < 128) {
          if ((l4 -= 1) < 0)
            break;
          T3.push(f3);
        } else if (f3 < 2048) {
          if ((l4 -= 2) < 0)
            break;
          T3.push(f3 >> 6 | 192, f3 & 63 | 128);
        } else if (f3 < 65536) {
          if ((l4 -= 3) < 0)
            break;
          T3.push(f3 >> 12 | 224, f3 >> 6 & 63 | 128, f3 & 63 | 128);
        } else if (f3 < 1114112) {
          if ((l4 -= 4) < 0)
            break;
          T3.push(f3 >> 18 | 240, f3 >> 12 & 63 | 128, f3 >> 6 & 63 | 128, f3 & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return T3;
    }
    function $g(p4) {
      let l4 = [];
      for (let f3 = 0; f3 < p4.length; ++f3)
        l4.push(p4.charCodeAt(f3) & 255);
      return l4;
    }
    function Hg(p4, l4) {
      let f3, b3, A3, T3 = [];
      for (let O5 = 0; O5 < p4.length && !((l4 -= 2) < 0); ++O5)
        f3 = p4.charCodeAt(O5), b3 = f3 >> 8, A3 = f3 % 256, T3.push(A3), T3.push(b3);
      return T3;
    }
    function Cl2(p4) {
      return t4.toByteArray(Wg(p4));
    }
    function qi3(p4, l4, f3, b3) {
      let A3;
      for (A3 = 0; A3 < b3 && !(A3 + f3 >= l4.length || A3 >= p4.length); ++A3)
        l4[A3 + f3] = p4[A3];
      return A3;
    }
    function Ye3(p4, l4) {
      return p4 instanceof l4 || p4 != null && p4.constructor != null && p4.constructor.name != null && p4.constructor.name === l4.name;
    }
    function ds3(p4) {
      return p4 !== p4;
    }
    let Vg = function() {
      let p4 = "0123456789abcdef", l4 = new Array(256);
      for (let f3 = 0; f3 < 16; ++f3) {
        let b3 = f3 * 16;
        for (let A3 = 0; A3 < 16; ++A3)
          l4[b3 + A3] = p4[f3] + p4[A3];
      }
      return l4;
    }();
    function Mt3(p4) {
      return typeof BigInt > "u" ? zg : p4;
    }
    function zg() {
      throw new Error("BigInt not supported");
    }
    return Jt3;
  }
  function Y3() {
    Y3.init.call(this);
  }
  function Xi3(t4) {
    if (typeof t4 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t4);
  }
  function nc2(t4) {
    return t4._maxListeners === void 0 ? Y3.defaultMaxListeners : t4._maxListeners;
  }
  function Xf2(t4, e4, r4, i5) {
    var n4, o4, s4, a4;
    if (Xi3(r4), (o4 = t4._events) === void 0 ? (o4 = t4._events = /* @__PURE__ */ Object.create(null), t4._eventsCount = 0) : (o4.newListener !== void 0 && (t4.emit("newListener", e4, r4.listener ? r4.listener : r4), o4 = t4._events), s4 = o4[e4]), s4 === void 0)
      s4 = o4[e4] = r4, ++t4._eventsCount;
    else if (typeof s4 == "function" ? s4 = o4[e4] = i5 ? [r4, s4] : [s4, r4] : i5 ? s4.unshift(r4) : s4.push(r4), (n4 = nc2(t4)) > 0 && s4.length > n4 && !s4.warned) {
      s4.warned = true;
      var u4 = new Error("Possible EventEmitter memory leak detected. " + s4.length + " " + String(e4) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u4.name = "MaxListenersExceededWarning", u4.emitter = t4, u4.type = e4, u4.count = s4.length, a4 = u4, console && console.warn && console.warn(a4);
    }
    return t4;
  }
  function Gb2() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Zf2(t4, e4, r4) {
    var i5 = { fired: false, wrapFn: void 0, target: t4, type: e4, listener: r4 }, n4 = Gb2.bind(i5);
    return n4.listener = r4, i5.wrapFn = n4, n4;
  }
  function ec2(t4, e4, r4) {
    var i5 = t4._events;
    if (i5 === void 0)
      return [];
    var n4 = i5[e4];
    return n4 === void 0 ? [] : typeof n4 == "function" ? r4 ? [n4.listener || n4] : [n4] : r4 ? function(o4) {
      for (var s4 = new Array(o4.length), a4 = 0; a4 < s4.length; ++a4)
        s4[a4] = o4[a4].listener || o4[a4];
      return s4;
    }(n4) : sc2(n4, n4.length);
  }
  function tc2(t4) {
    var e4 = this._events;
    if (e4 !== void 0) {
      var r4 = e4[t4];
      if (typeof r4 == "function")
        return 1;
      if (r4 !== void 0)
        return r4.length;
    }
    return 0;
  }
  function sc2(t4, e4) {
    for (var r4 = new Array(e4), i5 = 0; i5 < e4; ++i5)
      r4[i5] = t4[i5];
    return r4;
  }
  function wc2(t4) {
    var e4 = t4.length;
    if (e4 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r4 = t4.indexOf("=");
    return r4 === -1 && (r4 = e4), [r4, r4 === e4 ? 0 : 4 - r4 % 4];
  }
  function gw(t4, e4, r4) {
    for (var i5, n4, o4 = [], s4 = e4; s4 < r4; s4 += 3)
      i5 = (t4[s4] << 16 & 16711680) + (t4[s4 + 1] << 8 & 65280) + (255 & t4[s4 + 2]), o4.push($e3[(n4 = i5) >> 18 & 63] + $e3[n4 >> 12 & 63] + $e3[n4 >> 6 & 63] + $e3[63 & n4]);
    return o4.join("");
  }
  function Et3(t4) {
    if (t4 > 2147483647)
      throw new RangeError('The value "' + t4 + '" is invalid for option "size"');
    var e4 = new Uint8Array(t4);
    return Object.setPrototypeOf(e4, k3.prototype), e4;
  }
  function k3(t4, e4, r4) {
    if (typeof t4 == "number") {
      if (typeof e4 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return Vs2(t4);
    }
    return Cc2(t4, e4, r4);
  }
  function Cc2(t4, e4, r4) {
    if (typeof t4 == "string")
      return function(o4, s4) {
        if (typeof s4 == "string" && s4 !== "" || (s4 = "utf8"), !k3.isEncoding(s4))
          throw new TypeError("Unknown encoding: " + s4);
        var a4 = 0 | Pc2(o4, s4), u4 = Et3(a4), c5 = u4.write(o4, s4);
        return c5 !== a4 && (u4 = u4.slice(0, c5)), u4;
      }(t4, e4);
    if (ArrayBuffer.isView(t4))
      return Ws3(t4);
    if (t4 == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t4);
    if (St3(t4, ArrayBuffer) || t4 && St3(t4.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (St3(t4, SharedArrayBuffer) || t4 && St3(t4.buffer, SharedArrayBuffer)))
      return mc2(t4, e4, r4);
    if (typeof t4 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var i5 = t4.valueOf && t4.valueOf();
    if (i5 != null && i5 !== t4)
      return k3.from(i5, e4, r4);
    var n4 = function(o4) {
      if (k3.isBuffer(o4)) {
        var s4 = 0 | Gs3(o4.length), a4 = Et3(s4);
        return a4.length === 0 || o4.copy(a4, 0, 0, s4), a4;
      }
      if (o4.length !== void 0)
        return typeof o4.length != "number" || Qs3(o4.length) ? Et3(0) : Ws3(o4);
      if (o4.type === "Buffer" && Array.isArray(o4.data))
        return Ws3(o4.data);
    }(t4);
    if (n4)
      return n4;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t4[Symbol.toPrimitive] == "function")
      return k3.from(t4[Symbol.toPrimitive]("string"), e4, r4);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t4);
  }
  function Bc2(t4) {
    if (typeof t4 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (t4 < 0)
      throw new RangeError('The value "' + t4 + '" is invalid for option "size"');
  }
  function Vs2(t4) {
    return Bc2(t4), Et3(t4 < 0 ? 0 : 0 | Gs3(t4));
  }
  function Ws3(t4) {
    for (var e4 = t4.length < 0 ? 0 : 0 | Gs3(t4.length), r4 = Et3(e4), i5 = 0; i5 < e4; i5 += 1)
      r4[i5] = 255 & t4[i5];
    return r4;
  }
  function mc2(t4, e4, r4) {
    if (e4 < 0 || t4.byteLength < e4)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (t4.byteLength < e4 + (r4 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var i5;
    return i5 = e4 === void 0 && r4 === void 0 ? new Uint8Array(t4) : r4 === void 0 ? new Uint8Array(t4, e4) : new Uint8Array(t4, e4, r4), Object.setPrototypeOf(i5, k3.prototype), i5;
  }
  function Gs3(t4) {
    if (t4 >= 2147483647)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
    return 0 | t4;
  }
  function Pc2(t4, e4) {
    if (k3.isBuffer(t4))
      return t4.length;
    if (ArrayBuffer.isView(t4) || St3(t4, ArrayBuffer))
      return t4.byteLength;
    if (typeof t4 != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t4);
    var r4 = t4.length, i5 = arguments.length > 2 && arguments[2] === true;
    if (!i5 && r4 === 0)
      return 0;
    for (var n4 = false; ; )
      switch (e4) {
        case "ascii":
        case "latin1":
        case "binary":
          return r4;
        case "utf8":
        case "utf-8":
          return zs2(t4).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * r4;
        case "hex":
          return r4 >>> 1;
        case "base64":
          return Mc2(t4).length;
        default:
          if (n4)
            return i5 ? -1 : zs2(t4).length;
          e4 = ("" + e4).toLowerCase(), n4 = true;
      }
  }
  function bw(t4, e4, r4) {
    var i5 = false;
    if ((e4 === void 0 || e4 < 0) && (e4 = 0), e4 > this.length || ((r4 === void 0 || r4 > this.length) && (r4 = this.length), r4 <= 0) || (r4 >>>= 0) <= (e4 >>>= 0))
      return "";
    for (t4 || (t4 = "utf8"); ; )
      switch (t4) {
        case "hex":
          return Tw(this, e4, r4);
        case "utf8":
        case "utf-8":
          return kc2(this, e4, r4);
        case "ascii":
          return Aw(this, e4, r4);
        case "latin1":
        case "binary":
          return Iw(this, e4, r4);
        case "base64":
          return Sw(this, e4, r4);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Rw(this, e4, r4);
        default:
          if (i5)
            throw new TypeError("Unknown encoding: " + t4);
          t4 = (t4 + "").toLowerCase(), i5 = true;
      }
  }
  function sr4(t4, e4, r4) {
    var i5 = t4[e4];
    t4[e4] = t4[r4], t4[r4] = i5;
  }
  function vc2(t4, e4, r4, i5, n4) {
    if (t4.length === 0)
      return -1;
    if (typeof r4 == "string" ? (i5 = r4, r4 = 0) : r4 > 2147483647 ? r4 = 2147483647 : r4 < -2147483648 && (r4 = -2147483648), Qs3(r4 = +r4) && (r4 = n4 ? 0 : t4.length - 1), r4 < 0 && (r4 = t4.length + r4), r4 >= t4.length) {
      if (n4)
        return -1;
      r4 = t4.length - 1;
    } else if (r4 < 0) {
      if (!n4)
        return -1;
      r4 = 0;
    }
    if (typeof e4 == "string" && (e4 = k3.from(e4, i5)), k3.isBuffer(e4))
      return e4.length === 0 ? -1 : Ec2(t4, e4, r4, i5, n4);
    if (typeof e4 == "number")
      return e4 &= 255, typeof Uint8Array.prototype.indexOf == "function" ? n4 ? Uint8Array.prototype.indexOf.call(t4, e4, r4) : Uint8Array.prototype.lastIndexOf.call(t4, e4, r4) : Ec2(t4, [e4], r4, i5, n4);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ec2(t4, e4, r4, i5, n4) {
    var o4, s4 = 1, a4 = t4.length, u4 = e4.length;
    if (i5 !== void 0 && ((i5 = String(i5).toLowerCase()) === "ucs2" || i5 === "ucs-2" || i5 === "utf16le" || i5 === "utf-16le")) {
      if (t4.length < 2 || e4.length < 2)
        return -1;
      s4 = 2, a4 /= 2, u4 /= 2, r4 /= 2;
    }
    function c5(y3, w3) {
      return s4 === 1 ? y3[w3] : y3.readUInt16BE(w3 * s4);
    }
    if (n4) {
      var h4 = -1;
      for (o4 = r4; o4 < a4; o4++)
        if (c5(t4, o4) === c5(e4, h4 === -1 ? 0 : o4 - h4)) {
          if (h4 === -1 && (h4 = o4), o4 - h4 + 1 === u4)
            return h4 * s4;
        } else
          h4 !== -1 && (o4 -= o4 - h4), h4 = -1;
    } else
      for (r4 + u4 > a4 && (r4 = a4 - u4), o4 = r4; o4 >= 0; o4--) {
        for (var d4 = true, g4 = 0; g4 < u4; g4++)
          if (c5(t4, o4 + g4) !== c5(e4, g4)) {
            d4 = false;
            break;
          }
        if (d4)
          return o4;
      }
    return -1;
  }
  function ww(t4, e4, r4, i5) {
    r4 = Number(r4) || 0;
    var n4 = t4.length - r4;
    i5 ? (i5 = Number(i5)) > n4 && (i5 = n4) : i5 = n4;
    var o4 = e4.length;
    i5 > o4 / 2 && (i5 = o4 / 2);
    for (var s4 = 0; s4 < i5; ++s4) {
      var a4 = parseInt(e4.substr(2 * s4, 2), 16);
      if (Qs3(a4))
        return s4;
      t4[r4 + s4] = a4;
    }
    return s4;
  }
  function _w(t4, e4, r4, i5) {
    return un4(zs2(e4, t4.length - r4), t4, r4, i5);
  }
  function Oc2(t4, e4, r4, i5) {
    return un4(function(n4) {
      for (var o4 = [], s4 = 0; s4 < n4.length; ++s4)
        o4.push(255 & n4.charCodeAt(s4));
      return o4;
    }(e4), t4, r4, i5);
  }
  function mw(t4, e4, r4, i5) {
    return Oc2(t4, e4, r4, i5);
  }
  function vw(t4, e4, r4, i5) {
    return un4(Mc2(e4), t4, r4, i5);
  }
  function Ew(t4, e4, r4, i5) {
    return un4(function(n4, o4) {
      for (var s4, a4, u4, c5 = [], h4 = 0; h4 < n4.length && !((o4 -= 2) < 0); ++h4)
        s4 = n4.charCodeAt(h4), a4 = s4 >> 8, u4 = s4 % 256, c5.push(u4), c5.push(a4);
      return c5;
    }(e4, t4.length - r4), t4, r4, i5);
  }
  function Sw(t4, e4, r4) {
    return e4 === 0 && r4 === t4.length ? Hs2.fromByteArray(t4) : Hs2.fromByteArray(t4.slice(e4, r4));
  }
  function kc2(t4, e4, r4) {
    r4 = Math.min(t4.length, r4);
    for (var i5 = [], n4 = e4; n4 < r4; ) {
      var o4, s4, a4, u4, c5 = t4[n4], h4 = null, d4 = c5 > 239 ? 4 : c5 > 223 ? 3 : c5 > 191 ? 2 : 1;
      if (n4 + d4 <= r4)
        switch (d4) {
          case 1:
            c5 < 128 && (h4 = c5);
            break;
          case 2:
            (192 & (o4 = t4[n4 + 1])) == 128 && (u4 = (31 & c5) << 6 | 63 & o4) > 127 && (h4 = u4);
            break;
          case 3:
            o4 = t4[n4 + 1], s4 = t4[n4 + 2], (192 & o4) == 128 && (192 & s4) == 128 && (u4 = (15 & c5) << 12 | (63 & o4) << 6 | 63 & s4) > 2047 && (u4 < 55296 || u4 > 57343) && (h4 = u4);
            break;
          case 4:
            o4 = t4[n4 + 1], s4 = t4[n4 + 2], a4 = t4[n4 + 3], (192 & o4) == 128 && (192 & s4) == 128 && (192 & a4) == 128 && (u4 = (15 & c5) << 18 | (63 & o4) << 12 | (63 & s4) << 6 | 63 & a4) > 65535 && u4 < 1114112 && (h4 = u4);
        }
      h4 === null ? (h4 = 65533, d4 = 1) : h4 > 65535 && (h4 -= 65536, i5.push(h4 >>> 10 & 1023 | 55296), h4 = 56320 | 1023 & h4), i5.push(h4), n4 += d4;
    }
    return function(g4) {
      var y3 = g4.length;
      if (y3 <= 4096)
        return String.fromCharCode.apply(String, g4);
      for (var w3 = "", E4 = 0; E4 < y3; )
        w3 += String.fromCharCode.apply(String, g4.slice(E4, E4 += 4096));
      return w3;
    }(i5);
  }
  function Aw(t4, e4, r4) {
    var i5 = "";
    r4 = Math.min(t4.length, r4);
    for (var n4 = e4; n4 < r4; ++n4)
      i5 += String.fromCharCode(127 & t4[n4]);
    return i5;
  }
  function Iw(t4, e4, r4) {
    var i5 = "";
    r4 = Math.min(t4.length, r4);
    for (var n4 = e4; n4 < r4; ++n4)
      i5 += String.fromCharCode(t4[n4]);
    return i5;
  }
  function Tw(t4, e4, r4) {
    var i5 = t4.length;
    (!e4 || e4 < 0) && (e4 = 0), (!r4 || r4 < 0 || r4 > i5) && (r4 = i5);
    for (var n4 = "", o4 = e4; o4 < r4; ++o4)
      n4 += Bw[t4[o4]];
    return n4;
  }
  function Rw(t4, e4, r4) {
    for (var i5 = t4.slice(e4, r4), n4 = "", o4 = 0; o4 < i5.length; o4 += 2)
      n4 += String.fromCharCode(i5[o4] + 256 * i5[o4 + 1]);
    return n4;
  }
  function be4(t4, e4, r4) {
    if (t4 % 1 != 0 || t4 < 0)
      throw new RangeError("offset is not uint");
    if (t4 + e4 > r4)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function Pe3(t4, e4, r4, i5, n4, o4) {
    if (!k3.isBuffer(t4))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e4 > n4 || e4 < o4)
      throw new RangeError('"value" argument is out of bounds');
    if (r4 + i5 > t4.length)
      throw new RangeError("Index out of range");
  }
  function xc2(t4, e4, r4, i5, n4, o4) {
    if (r4 + i5 > t4.length)
      throw new RangeError("Index out of range");
    if (r4 < 0)
      throw new RangeError("Index out of range");
  }
  function Sc2(t4, e4, r4, i5, n4) {
    return e4 = +e4, r4 >>>= 0, n4 || xc2(t4, 0, r4, 4), Nr4.write(t4, e4, r4, i5, 23, 4), r4 + 4;
  }
  function Ac2(t4, e4, r4, i5, n4) {
    return e4 = +e4, r4 >>>= 0, n4 || xc2(t4, 0, r4, 8), Nr4.write(t4, e4, r4, i5, 52, 8), r4 + 8;
  }
  function zs2(t4, e4) {
    var r4;
    e4 = e4 || 1 / 0;
    for (var i5 = t4.length, n4 = null, o4 = [], s4 = 0; s4 < i5; ++s4) {
      if ((r4 = t4.charCodeAt(s4)) > 55295 && r4 < 57344) {
        if (!n4) {
          if (r4 > 56319) {
            (e4 -= 3) > -1 && o4.push(239, 191, 189);
            continue;
          }
          if (s4 + 1 === i5) {
            (e4 -= 3) > -1 && o4.push(239, 191, 189);
            continue;
          }
          n4 = r4;
          continue;
        }
        if (r4 < 56320) {
          (e4 -= 3) > -1 && o4.push(239, 191, 189), n4 = r4;
          continue;
        }
        r4 = 65536 + (n4 - 55296 << 10 | r4 - 56320);
      } else
        n4 && (e4 -= 3) > -1 && o4.push(239, 191, 189);
      if (n4 = null, r4 < 128) {
        if ((e4 -= 1) < 0)
          break;
        o4.push(r4);
      } else if (r4 < 2048) {
        if ((e4 -= 2) < 0)
          break;
        o4.push(r4 >> 6 | 192, 63 & r4 | 128);
      } else if (r4 < 65536) {
        if ((e4 -= 3) < 0)
          break;
        o4.push(r4 >> 12 | 224, r4 >> 6 & 63 | 128, 63 & r4 | 128);
      } else {
        if (!(r4 < 1114112))
          throw new Error("Invalid code point");
        if ((e4 -= 4) < 0)
          break;
        o4.push(r4 >> 18 | 240, r4 >> 12 & 63 | 128, r4 >> 6 & 63 | 128, 63 & r4 | 128);
      }
    }
    return o4;
  }
  function Mc2(t4) {
    return Hs2.toByteArray(function(e4) {
      if ((e4 = (e4 = e4.split("=")[0]).trim().replace(Cw, "")).length < 2)
        return "";
      for (; e4.length % 4 != 0; )
        e4 += "=";
      return e4;
    }(t4));
  }
  function un4(t4, e4, r4, i5) {
    for (var n4 = 0; n4 < i5 && !(n4 + r4 >= e4.length || n4 >= t4.length); ++n4)
      e4[n4 + r4] = t4[n4];
    return n4;
  }
  function St3(t4, e4) {
    return t4 instanceof e4 || t4 != null && t4.constructor != null && t4.constructor.name != null && t4.constructor.name === e4.name;
  }
  function Qs3(t4) {
    return t4 != t4;
  }
  function Ic2(t4, e4) {
    for (var r4 in t4)
      e4[r4] = t4[r4];
  }
  function or3(t4, e4, r4) {
    return it4(t4, e4, r4);
  }
  function hi2(t4) {
    var e4;
    switch (this.encoding = function(r4) {
      var i5 = function(n4) {
        if (!n4)
          return "utf8";
        for (var o4; ; )
          switch (n4) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return n4;
            default:
              if (o4)
                return;
              n4 = ("" + n4).toLowerCase(), o4 = true;
          }
      }(r4);
      if (typeof i5 != "string" && (Ks2.isEncoding === Tc2 || !Tc2(r4)))
        throw new Error("Unknown encoding: " + r4);
      return i5 || r4;
    }(t4), this.encoding) {
      case "utf16le":
        this.text = kw, this.end = xw, e4 = 4;
        break;
      case "utf8":
        this.fillLast = Ow, e4 = 4;
        break;
      case "base64":
        this.text = Mw, this.end = Lw, e4 = 3;
        break;
      default:
        return this.write = Uw, this.end = Nw, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Ks2.allocUnsafe(e4);
  }
  function $s3(t4) {
    return t4 <= 127 ? 0 : t4 >> 5 == 6 ? 2 : t4 >> 4 == 14 ? 3 : t4 >> 3 == 30 ? 4 : t4 >> 6 == 2 ? -1 : -2;
  }
  function Ow(t4) {
    var e4 = this.lastTotal - this.lastNeed, r4 = function(i5, n4, o4) {
      if ((192 & n4[0]) != 128)
        return i5.lastNeed = 0, "\uFFFD";
      if (i5.lastNeed > 1 && n4.length > 1) {
        if ((192 & n4[1]) != 128)
          return i5.lastNeed = 1, "\uFFFD";
        if (i5.lastNeed > 2 && n4.length > 2 && (192 & n4[2]) != 128)
          return i5.lastNeed = 2, "\uFFFD";
      }
    }(this, t4);
    return r4 !== void 0 ? r4 : this.lastNeed <= t4.length ? (t4.copy(this.lastChar, e4, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t4.copy(this.lastChar, e4, 0, t4.length), this.lastNeed -= t4.length, void 0);
  }
  function kw(t4, e4) {
    if ((t4.length - e4) % 2 == 0) {
      var r4 = t4.toString("utf16le", e4);
      if (r4) {
        var i5 = r4.charCodeAt(r4.length - 1);
        if (i5 >= 55296 && i5 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t4[t4.length - 2], this.lastChar[1] = t4[t4.length - 1], r4.slice(0, -1);
      }
      return r4;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t4[t4.length - 1], t4.toString("utf16le", e4, t4.length - 1);
  }
  function xw(t4) {
    var e4 = t4 && t4.length ? this.write(t4) : "";
    if (this.lastNeed) {
      var r4 = this.lastTotal - this.lastNeed;
      return e4 + this.lastChar.toString("utf16le", 0, r4);
    }
    return e4;
  }
  function Mw(t4, e4) {
    var r4 = (t4.length - e4) % 3;
    return r4 === 0 ? t4.toString("base64", e4) : (this.lastNeed = 3 - r4, this.lastTotal = 3, r4 === 1 ? this.lastChar[0] = t4[t4.length - 1] : (this.lastChar[0] = t4[t4.length - 2], this.lastChar[1] = t4[t4.length - 1]), t4.toString("base64", e4, t4.length - r4));
  }
  function Lw(t4) {
    var e4 = t4 && t4.length ? this.write(t4) : "";
    return this.lastNeed ? e4 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e4;
  }
  function Uw(t4) {
    return t4.toString(this.encoding);
  }
  function Nw(t4) {
    return t4 && t4.length ? this.write(t4) : "";
  }
  function Ir3(t4) {
    throw new RangeError(sE[t4]);
  }
  function Vp2(t4, e4) {
    let r4 = t4.split("@"), i5 = "";
    r4.length > 1 && (i5 = r4[0] + "@", t4 = r4[1]);
    let n4 = function(o4, s4) {
      let a4 = [], u4 = o4.length;
      for (; u4--; )
        a4[u4] = s4(o4[u4]);
      return a4;
    }((t4 = t4.replace(nE, ".")).split("."), e4).join(".");
    return i5 + n4;
  }
  function Qp2(t4) {
    let e4 = [], r4 = 0, i5 = t4.length;
    for (; r4 < i5; ) {
      let n4 = t4.charCodeAt(r4++);
      if (n4 >= 55296 && n4 <= 56319 && r4 < i5) {
        let o4 = t4.charCodeAt(r4++);
        (64512 & o4) == 56320 ? e4.push(((1023 & n4) << 10) + (1023 & o4) + 65536) : (e4.push(n4), r4--);
      } else
        e4.push(n4);
    }
    return e4;
  }
  function oE(t4, e4) {
    return Object.prototype.hasOwnProperty.call(t4, e4);
  }
  function za2() {
    throw new Error("setTimeout has not been defined");
  }
  function Ka3() {
    throw new Error("clearTimeout has not been defined");
  }
  function tg2(t4) {
    if (Pt3 === setTimeout)
      return setTimeout(t4, 0);
    if ((Pt3 === za2 || !Pt3) && setTimeout)
      return Pt3 = setTimeout, setTimeout(t4, 0);
    try {
      return Pt3(t4, 0);
    } catch {
      try {
        return Pt3.call(null, t4, 0);
      } catch {
        return Pt3.call(this || ii2, t4, 0);
      }
    }
  }
  function uE() {
    ri2 && Tr4 && (ri2 = false, Tr4.length ? kt4 = Tr4.concat(kt4) : os3 = -1, kt4.length && rg());
  }
  function rg() {
    if (!ri2) {
      var t4 = tg2(uE);
      ri2 = true;
      for (var e4 = kt4.length; e4; ) {
        for (Tr4 = kt4, kt4 = []; ++os3 < e4; )
          Tr4 && Tr4[os3].run();
        os3 = -1, e4 = kt4.length;
      }
      Tr4 = null, ri2 = false, function(r4) {
        if (Ot4 === clearTimeout)
          return clearTimeout(r4);
        if ((Ot4 === Ka3 || !Ot4) && clearTimeout)
          return Ot4 = clearTimeout, clearTimeout(r4);
        try {
          Ot4(r4);
        } catch {
          try {
            return Ot4.call(null, r4);
          } catch {
            return Ot4.call(this || ii2, r4);
          }
        }
      }(t4);
    }
  }
  function Zp2(t4, e4) {
    (this || ii2).fun = t4, (this || ii2).array = e4;
  }
  function Bt4() {
  }
  function fE() {
    if (ng2)
      return Ga2;
    ng2 = true;
    var t4 = Ga2 = {}, e4, r4;
    function i5() {
      throw new Error("setTimeout has not been defined");
    }
    function n4() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? e4 = setTimeout : e4 = i5;
      } catch {
        e4 = i5;
      }
      try {
        typeof clearTimeout == "function" ? r4 = clearTimeout : r4 = n4;
      } catch {
        r4 = n4;
      }
    })();
    function o4(E4) {
      if (e4 === setTimeout)
        return setTimeout(E4, 0);
      if ((e4 === i5 || !e4) && setTimeout)
        return e4 = setTimeout, setTimeout(E4, 0);
      try {
        return e4(E4, 0);
      } catch {
        try {
          return e4.call(null, E4, 0);
        } catch {
          return e4.call(this || ni2, E4, 0);
        }
      }
    }
    function s4(E4) {
      if (r4 === clearTimeout)
        return clearTimeout(E4);
      if ((r4 === n4 || !r4) && clearTimeout)
        return r4 = clearTimeout, clearTimeout(E4);
      try {
        return r4(E4);
      } catch {
        try {
          return r4.call(null, E4);
        } catch {
          return r4.call(this || ni2, E4);
        }
      }
    }
    var a4 = [], u4 = false, c5, h4 = -1;
    function d4() {
      !u4 || !c5 || (u4 = false, c5.length ? a4 = c5.concat(a4) : h4 = -1, a4.length && g4());
    }
    function g4() {
      if (!u4) {
        var E4 = o4(d4);
        u4 = true;
        for (var S3 = a4.length; S3; ) {
          for (c5 = a4, a4 = []; ++h4 < S3; )
            c5 && c5[h4].run();
          h4 = -1, S3 = a4.length;
        }
        c5 = null, u4 = false, s4(E4);
      }
    }
    t4.nextTick = function(E4) {
      var S3 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var I3 = 1; I3 < arguments.length; I3++)
          S3[I3 - 1] = arguments[I3];
      a4.push(new y3(E4, S3)), a4.length === 1 && !u4 && o4(g4);
    };
    function y3(E4, S3) {
      (this || ni2).fun = E4, (this || ni2).array = S3;
    }
    y3.prototype.run = function() {
      (this || ni2).fun.apply(null, (this || ni2).array);
    }, t4.title = "browser", t4.browser = true, t4.env = {}, t4.argv = [], t4.version = "", t4.versions = {};
    function w3() {
    }
    return t4.on = w3, t4.addListener = w3, t4.once = w3, t4.off = w3, t4.removeListener = w3, t4.removeAllListeners = w3, t4.emit = w3, t4.prependListener = w3, t4.prependOnceListener = w3, t4.listeners = function(E4) {
      return [];
    }, t4.binding = function(E4) {
      throw new Error("process.binding is not supported");
    }, t4.cwd = function() {
      return "/";
    }, t4.chdir = function(E4) {
      throw new Error("process.chdir is not supported");
    }, t4.umask = function() {
      return 0;
    }, Ga2;
  }
  function cE() {
    if (sg2)
      return Ya3;
    sg2 = true;
    var t4 = re4;
    function e4(o4) {
      if (typeof o4 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(o4));
    }
    function r4(o4, s4) {
      for (var a4 = "", u4 = 0, c5 = -1, h4 = 0, d4, g4 = 0; g4 <= o4.length; ++g4) {
        if (g4 < o4.length)
          d4 = o4.charCodeAt(g4);
        else {
          if (d4 === 47)
            break;
          d4 = 47;
        }
        if (d4 === 47) {
          if (!(c5 === g4 - 1 || h4 === 1))
            if (c5 !== g4 - 1 && h4 === 2) {
              if (a4.length < 2 || u4 !== 2 || a4.charCodeAt(a4.length - 1) !== 46 || a4.charCodeAt(a4.length - 2) !== 46) {
                if (a4.length > 2) {
                  var y3 = a4.lastIndexOf("/");
                  if (y3 !== a4.length - 1) {
                    y3 === -1 ? (a4 = "", u4 = 0) : (a4 = a4.slice(0, y3), u4 = a4.length - 1 - a4.lastIndexOf("/")), c5 = g4, h4 = 0;
                    continue;
                  }
                } else if (a4.length === 2 || a4.length === 1) {
                  a4 = "", u4 = 0, c5 = g4, h4 = 0;
                  continue;
                }
              }
              s4 && (a4.length > 0 ? a4 += "/.." : a4 = "..", u4 = 2);
            } else
              a4.length > 0 ? a4 += "/" + o4.slice(c5 + 1, g4) : a4 = o4.slice(c5 + 1, g4), u4 = g4 - c5 - 1;
          c5 = g4, h4 = 0;
        } else
          d4 === 46 && h4 !== -1 ? ++h4 : h4 = -1;
      }
      return a4;
    }
    function i5(o4, s4) {
      var a4 = s4.dir || s4.root, u4 = s4.base || (s4.name || "") + (s4.ext || "");
      return a4 ? a4 === s4.root ? a4 + u4 : a4 + o4 + u4 : u4;
    }
    var n4 = { resolve: function() {
      for (var s4 = "", a4 = false, u4, c5 = arguments.length - 1; c5 >= -1 && !a4; c5--) {
        var h4;
        c5 >= 0 ? h4 = arguments[c5] : (u4 === void 0 && (u4 = t4.cwd()), h4 = u4), e4(h4), h4.length !== 0 && (s4 = h4 + "/" + s4, a4 = h4.charCodeAt(0) === 47);
      }
      return s4 = r4(s4, !a4), a4 ? s4.length > 0 ? "/" + s4 : "/" : s4.length > 0 ? s4 : ".";
    }, normalize: function(s4) {
      if (e4(s4), s4.length === 0)
        return ".";
      var a4 = s4.charCodeAt(0) === 47, u4 = s4.charCodeAt(s4.length - 1) === 47;
      return s4 = r4(s4, !a4), s4.length === 0 && !a4 && (s4 = "."), s4.length > 0 && u4 && (s4 += "/"), a4 ? "/" + s4 : s4;
    }, isAbsolute: function(s4) {
      return e4(s4), s4.length > 0 && s4.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var s4, a4 = 0; a4 < arguments.length; ++a4) {
        var u4 = arguments[a4];
        e4(u4), u4.length > 0 && (s4 === void 0 ? s4 = u4 : s4 += "/" + u4);
      }
      return s4 === void 0 ? "." : n4.normalize(s4);
    }, relative: function(s4, a4) {
      if (e4(s4), e4(a4), s4 === a4 || (s4 = n4.resolve(s4), a4 = n4.resolve(a4), s4 === a4))
        return "";
      for (var u4 = 1; u4 < s4.length && s4.charCodeAt(u4) === 47; ++u4)
        ;
      for (var c5 = s4.length, h4 = c5 - u4, d4 = 1; d4 < a4.length && a4.charCodeAt(d4) === 47; ++d4)
        ;
      for (var g4 = a4.length, y3 = g4 - d4, w3 = h4 < y3 ? h4 : y3, E4 = -1, S3 = 0; S3 <= w3; ++S3) {
        if (S3 === w3) {
          if (y3 > w3) {
            if (a4.charCodeAt(d4 + S3) === 47)
              return a4.slice(d4 + S3 + 1);
            if (S3 === 0)
              return a4.slice(d4 + S3);
          } else
            h4 > w3 && (s4.charCodeAt(u4 + S3) === 47 ? E4 = S3 : S3 === 0 && (E4 = 0));
          break;
        }
        var I3 = s4.charCodeAt(u4 + S3), C3 = a4.charCodeAt(d4 + S3);
        if (I3 !== C3)
          break;
        I3 === 47 && (E4 = S3);
      }
      var R5 = "";
      for (S3 = u4 + E4 + 1; S3 <= c5; ++S3)
        (S3 === c5 || s4.charCodeAt(S3) === 47) && (R5.length === 0 ? R5 += ".." : R5 += "/..");
      return R5.length > 0 ? R5 + a4.slice(d4 + E4) : (d4 += E4, a4.charCodeAt(d4) === 47 && ++d4, a4.slice(d4));
    }, _makeLong: function(s4) {
      return s4;
    }, dirname: function(s4) {
      if (e4(s4), s4.length === 0)
        return ".";
      for (var a4 = s4.charCodeAt(0), u4 = a4 === 47, c5 = -1, h4 = true, d4 = s4.length - 1; d4 >= 1; --d4)
        if (a4 = s4.charCodeAt(d4), a4 === 47) {
          if (!h4) {
            c5 = d4;
            break;
          }
        } else
          h4 = false;
      return c5 === -1 ? u4 ? "/" : "." : u4 && c5 === 1 ? "//" : s4.slice(0, c5);
    }, basename: function(s4, a4) {
      if (a4 !== void 0 && typeof a4 != "string")
        throw new TypeError('"ext" argument must be a string');
      e4(s4);
      var u4 = 0, c5 = -1, h4 = true, d4;
      if (a4 !== void 0 && a4.length > 0 && a4.length <= s4.length) {
        if (a4.length === s4.length && a4 === s4)
          return "";
        var g4 = a4.length - 1, y3 = -1;
        for (d4 = s4.length - 1; d4 >= 0; --d4) {
          var w3 = s4.charCodeAt(d4);
          if (w3 === 47) {
            if (!h4) {
              u4 = d4 + 1;
              break;
            }
          } else
            y3 === -1 && (h4 = false, y3 = d4 + 1), g4 >= 0 && (w3 === a4.charCodeAt(g4) ? --g4 === -1 && (c5 = d4) : (g4 = -1, c5 = y3));
        }
        return u4 === c5 ? c5 = y3 : c5 === -1 && (c5 = s4.length), s4.slice(u4, c5);
      } else {
        for (d4 = s4.length - 1; d4 >= 0; --d4)
          if (s4.charCodeAt(d4) === 47) {
            if (!h4) {
              u4 = d4 + 1;
              break;
            }
          } else
            c5 === -1 && (h4 = false, c5 = d4 + 1);
        return c5 === -1 ? "" : s4.slice(u4, c5);
      }
    }, extname: function(s4) {
      e4(s4);
      for (var a4 = -1, u4 = 0, c5 = -1, h4 = true, d4 = 0, g4 = s4.length - 1; g4 >= 0; --g4) {
        var y3 = s4.charCodeAt(g4);
        if (y3 === 47) {
          if (!h4) {
            u4 = g4 + 1;
            break;
          }
          continue;
        }
        c5 === -1 && (h4 = false, c5 = g4 + 1), y3 === 46 ? a4 === -1 ? a4 = g4 : d4 !== 1 && (d4 = 1) : a4 !== -1 && (d4 = -1);
      }
      return a4 === -1 || c5 === -1 || d4 === 0 || d4 === 1 && a4 === c5 - 1 && a4 === u4 + 1 ? "" : s4.slice(a4, c5);
    }, format: function(s4) {
      if (s4 === null || typeof s4 != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof s4);
      return i5("/", s4);
    }, parse: function(s4) {
      e4(s4);
      var a4 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (s4.length === 0)
        return a4;
      var u4 = s4.charCodeAt(0), c5 = u4 === 47, h4;
      c5 ? (a4.root = "/", h4 = 1) : h4 = 0;
      for (var d4 = -1, g4 = 0, y3 = -1, w3 = true, E4 = s4.length - 1, S3 = 0; E4 >= h4; --E4) {
        if (u4 = s4.charCodeAt(E4), u4 === 47) {
          if (!w3) {
            g4 = E4 + 1;
            break;
          }
          continue;
        }
        y3 === -1 && (w3 = false, y3 = E4 + 1), u4 === 46 ? d4 === -1 ? d4 = E4 : S3 !== 1 && (S3 = 1) : d4 !== -1 && (S3 = -1);
      }
      return d4 === -1 || y3 === -1 || S3 === 0 || S3 === 1 && d4 === y3 - 1 && d4 === g4 + 1 ? y3 !== -1 && (g4 === 0 && c5 ? a4.base = a4.name = s4.slice(1, y3) : a4.base = a4.name = s4.slice(g4, y3)) : (g4 === 0 && c5 ? (a4.name = s4.slice(1, d4), a4.base = s4.slice(1, y3)) : (a4.name = s4.slice(g4, d4), a4.base = s4.slice(g4, y3)), a4.ext = s4.slice(d4, y3)), g4 > 0 ? a4.dir = s4.slice(0, g4 - 1) : c5 && (a4.dir = "/"), a4;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    return n4.posix = n4, Ya3 = n4, Ya3;
  }
  function Fe4() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  function xi3(t4, e4, r4) {
    if (t4 && gt3.isObject(t4) && t4 instanceof Fe4)
      return t4;
    var i5 = new Fe4();
    return i5.parse(t4, e4, r4), i5;
  }
  function _E() {
    if (fg2)
      return el2;
    fg2 = true;
    var t4 = ne3;
    function e4(o4) {
      if (typeof o4 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(o4));
    }
    function r4(o4, s4) {
      for (var a4 = "", u4 = 0, c5 = -1, h4 = 0, d4, g4 = 0; g4 <= o4.length; ++g4) {
        if (g4 < o4.length)
          d4 = o4.charCodeAt(g4);
        else {
          if (d4 === 47)
            break;
          d4 = 47;
        }
        if (d4 === 47) {
          if (!(c5 === g4 - 1 || h4 === 1))
            if (c5 !== g4 - 1 && h4 === 2) {
              if (a4.length < 2 || u4 !== 2 || a4.charCodeAt(a4.length - 1) !== 46 || a4.charCodeAt(a4.length - 2) !== 46) {
                if (a4.length > 2) {
                  var y3 = a4.lastIndexOf("/");
                  if (y3 !== a4.length - 1) {
                    y3 === -1 ? (a4 = "", u4 = 0) : (a4 = a4.slice(0, y3), u4 = a4.length - 1 - a4.lastIndexOf("/")), c5 = g4, h4 = 0;
                    continue;
                  }
                } else if (a4.length === 2 || a4.length === 1) {
                  a4 = "", u4 = 0, c5 = g4, h4 = 0;
                  continue;
                }
              }
              s4 && (a4.length > 0 ? a4 += "/.." : a4 = "..", u4 = 2);
            } else
              a4.length > 0 ? a4 += "/" + o4.slice(c5 + 1, g4) : a4 = o4.slice(c5 + 1, g4), u4 = g4 - c5 - 1;
          c5 = g4, h4 = 0;
        } else
          d4 === 46 && h4 !== -1 ? ++h4 : h4 = -1;
      }
      return a4;
    }
    function i5(o4, s4) {
      var a4 = s4.dir || s4.root, u4 = s4.base || (s4.name || "") + (s4.ext || "");
      return a4 ? a4 === s4.root ? a4 + u4 : a4 + o4 + u4 : u4;
    }
    var n4 = { resolve: function() {
      for (var s4 = "", a4 = false, u4, c5 = arguments.length - 1; c5 >= -1 && !a4; c5--) {
        var h4;
        c5 >= 0 ? h4 = arguments[c5] : (u4 === void 0 && (u4 = t4.cwd()), h4 = u4), e4(h4), h4.length !== 0 && (s4 = h4 + "/" + s4, a4 = h4.charCodeAt(0) === 47);
      }
      return s4 = r4(s4, !a4), a4 ? s4.length > 0 ? "/" + s4 : "/" : s4.length > 0 ? s4 : ".";
    }, normalize: function(s4) {
      if (e4(s4), s4.length === 0)
        return ".";
      var a4 = s4.charCodeAt(0) === 47, u4 = s4.charCodeAt(s4.length - 1) === 47;
      return s4 = r4(s4, !a4), s4.length === 0 && !a4 && (s4 = "."), s4.length > 0 && u4 && (s4 += "/"), a4 ? "/" + s4 : s4;
    }, isAbsolute: function(s4) {
      return e4(s4), s4.length > 0 && s4.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var s4, a4 = 0; a4 < arguments.length; ++a4) {
        var u4 = arguments[a4];
        e4(u4), u4.length > 0 && (s4 === void 0 ? s4 = u4 : s4 += "/" + u4);
      }
      return s4 === void 0 ? "." : n4.normalize(s4);
    }, relative: function(s4, a4) {
      if (e4(s4), e4(a4), s4 === a4 || (s4 = n4.resolve(s4), a4 = n4.resolve(a4), s4 === a4))
        return "";
      for (var u4 = 1; u4 < s4.length && s4.charCodeAt(u4) === 47; ++u4)
        ;
      for (var c5 = s4.length, h4 = c5 - u4, d4 = 1; d4 < a4.length && a4.charCodeAt(d4) === 47; ++d4)
        ;
      for (var g4 = a4.length, y3 = g4 - d4, w3 = h4 < y3 ? h4 : y3, E4 = -1, S3 = 0; S3 <= w3; ++S3) {
        if (S3 === w3) {
          if (y3 > w3) {
            if (a4.charCodeAt(d4 + S3) === 47)
              return a4.slice(d4 + S3 + 1);
            if (S3 === 0)
              return a4.slice(d4 + S3);
          } else
            h4 > w3 && (s4.charCodeAt(u4 + S3) === 47 ? E4 = S3 : S3 === 0 && (E4 = 0));
          break;
        }
        var I3 = s4.charCodeAt(u4 + S3), C3 = a4.charCodeAt(d4 + S3);
        if (I3 !== C3)
          break;
        I3 === 47 && (E4 = S3);
      }
      var R5 = "";
      for (S3 = u4 + E4 + 1; S3 <= c5; ++S3)
        (S3 === c5 || s4.charCodeAt(S3) === 47) && (R5.length === 0 ? R5 += ".." : R5 += "/..");
      return R5.length > 0 ? R5 + a4.slice(d4 + E4) : (d4 += E4, a4.charCodeAt(d4) === 47 && ++d4, a4.slice(d4));
    }, _makeLong: function(s4) {
      return s4;
    }, dirname: function(s4) {
      if (e4(s4), s4.length === 0)
        return ".";
      for (var a4 = s4.charCodeAt(0), u4 = a4 === 47, c5 = -1, h4 = true, d4 = s4.length - 1; d4 >= 1; --d4)
        if (a4 = s4.charCodeAt(d4), a4 === 47) {
          if (!h4) {
            c5 = d4;
            break;
          }
        } else
          h4 = false;
      return c5 === -1 ? u4 ? "/" : "." : u4 && c5 === 1 ? "//" : s4.slice(0, c5);
    }, basename: function(s4, a4) {
      if (a4 !== void 0 && typeof a4 != "string")
        throw new TypeError('"ext" argument must be a string');
      e4(s4);
      var u4 = 0, c5 = -1, h4 = true, d4;
      if (a4 !== void 0 && a4.length > 0 && a4.length <= s4.length) {
        if (a4.length === s4.length && a4 === s4)
          return "";
        var g4 = a4.length - 1, y3 = -1;
        for (d4 = s4.length - 1; d4 >= 0; --d4) {
          var w3 = s4.charCodeAt(d4);
          if (w3 === 47) {
            if (!h4) {
              u4 = d4 + 1;
              break;
            }
          } else
            y3 === -1 && (h4 = false, y3 = d4 + 1), g4 >= 0 && (w3 === a4.charCodeAt(g4) ? --g4 === -1 && (c5 = d4) : (g4 = -1, c5 = y3));
        }
        return u4 === c5 ? c5 = y3 : c5 === -1 && (c5 = s4.length), s4.slice(u4, c5);
      } else {
        for (d4 = s4.length - 1; d4 >= 0; --d4)
          if (s4.charCodeAt(d4) === 47) {
            if (!h4) {
              u4 = d4 + 1;
              break;
            }
          } else
            c5 === -1 && (h4 = false, c5 = d4 + 1);
        return c5 === -1 ? "" : s4.slice(u4, c5);
      }
    }, extname: function(s4) {
      e4(s4);
      for (var a4 = -1, u4 = 0, c5 = -1, h4 = true, d4 = 0, g4 = s4.length - 1; g4 >= 0; --g4) {
        var y3 = s4.charCodeAt(g4);
        if (y3 === 47) {
          if (!h4) {
            u4 = g4 + 1;
            break;
          }
          continue;
        }
        c5 === -1 && (h4 = false, c5 = g4 + 1), y3 === 46 ? a4 === -1 ? a4 = g4 : d4 !== 1 && (d4 = 1) : a4 !== -1 && (d4 = -1);
      }
      return a4 === -1 || c5 === -1 || d4 === 0 || d4 === 1 && a4 === c5 - 1 && a4 === u4 + 1 ? "" : s4.slice(a4, c5);
    }, format: function(s4) {
      if (s4 === null || typeof s4 != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof s4);
      return i5("/", s4);
    }, parse: function(s4) {
      e4(s4);
      var a4 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (s4.length === 0)
        return a4;
      var u4 = s4.charCodeAt(0), c5 = u4 === 47, h4;
      c5 ? (a4.root = "/", h4 = 1) : h4 = 0;
      for (var d4 = -1, g4 = 0, y3 = -1, w3 = true, E4 = s4.length - 1, S3 = 0; E4 >= h4; --E4) {
        if (u4 = s4.charCodeAt(E4), u4 === 47) {
          if (!w3) {
            g4 = E4 + 1;
            break;
          }
          continue;
        }
        y3 === -1 && (w3 = false, y3 = E4 + 1), u4 === 46 ? d4 === -1 ? d4 = E4 : S3 !== 1 && (S3 = 1) : d4 !== -1 && (S3 = -1);
      }
      return d4 === -1 || y3 === -1 || S3 === 0 || S3 === 1 && d4 === y3 - 1 && d4 === g4 + 1 ? y3 !== -1 && (g4 === 0 && c5 ? a4.base = a4.name = s4.slice(1, y3) : a4.base = a4.name = s4.slice(g4, y3)) : (g4 === 0 && c5 ? (a4.name = s4.slice(1, d4), a4.base = s4.slice(1, y3)) : (a4.name = s4.slice(g4, d4), a4.base = s4.slice(g4, y3)), a4.ext = s4.slice(d4, y3)), g4 > 0 ? a4.dir = s4.slice(0, g4 - 1) : c5 && (a4.dir = "/"), a4;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    return n4.posix = n4, el2 = n4, el2;
  }
  function OE(t4) {
    if (typeof t4 == "string")
      t4 = new URL(t4);
    else if (!(t4 instanceof URL))
      throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
    if (t4.protocol !== "file:")
      throw new Deno.errors.InvalidData("invalid url scheme");
    return rl2 ? kE(t4) : xE(t4);
  }
  function kE(t4) {
    let e4 = t4.hostname, r4 = t4.pathname;
    for (let i5 = 0; i5 < r4.length; i5++)
      if (r4[i5] === "%") {
        let n4 = r4.codePointAt(i5 + 2) || 32;
        if (r4[i5 + 1] === "2" && n4 === 102 || r4[i5 + 1] === "5" && n4 === 99)
          throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
      }
    if (r4 = r4.replace(IE, "\\"), r4 = decodeURIComponent(r4), e4 !== "")
      return `\\\\${e4}${r4}`;
    {
      let i5 = r4.codePointAt(1) | 32, n4 = r4[2];
      if (i5 < SE || i5 > AE || n4 !== ":")
        throw new Deno.errors.InvalidData("file url path must be absolute");
      return r4.slice(1);
    }
  }
  function xE(t4) {
    if (t4.hostname !== "")
      throw new Deno.errors.InvalidData("invalid file url hostname");
    let e4 = t4.pathname;
    for (let r4 = 0; r4 < e4.length; r4++)
      if (e4[r4] === "%") {
        let i5 = e4.codePointAt(r4 + 2) || 32;
        if (e4[r4 + 1] === "2" && i5 === 102)
          throw new Deno.errors.InvalidData("must not include encoded / characters");
      }
    return decodeURIComponent(e4);
  }
  function ME(t4) {
    let e4 = cg2.resolve(t4), r4 = t4.charCodeAt(t4.length - 1);
    (r4 === EE || rl2 && r4 === vE) && e4[e4.length - 1] !== cg2.sep && (e4 += "/");
    let i5 = new URL("file://");
    return e4.includes("%") && (e4 = e4.replace(TE, "%25")), !rl2 && e4.includes("\\") && (e4 = e4.replace(RE, "%5C")), e4.includes(`
`) && (e4 = e4.replace(CE, "%0A")), e4.includes("\r") && (e4 = e4.replace(BE, "%0D")), e4.includes("	") && (e4 = e4.replace(PE, "%09")), i5.pathname = e4, i5;
  }
  function hg2(t4) {
    if (typeof t4 == "string")
      t4 = new URL(t4);
    else if (!(t4 instanceof URL))
      throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
    if (t4.protocol !== "file:")
      throw new Deno.errors.InvalidData("invalid url scheme");
    return il2 ? XE(t4) : ZE(t4);
  }
  function XE(t4) {
    let e4 = t4.hostname, r4 = t4.pathname;
    for (let i5 = 0; i5 < r4.length; i5++)
      if (r4[i5] === "%") {
        let n4 = r4.codePointAt(i5 + 2) || 32;
        if (r4[i5 + 1] === "2" && n4 === 102 || r4[i5 + 1] === "5" && n4 === 99)
          throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
      }
    if (r4 = r4.replace(zE, "\\"), r4 = decodeURIComponent(r4), e4 !== "")
      return `\\\\${e4}${r4}`;
    {
      let i5 = r4.codePointAt(1) | 32, n4 = r4[2];
      if (i5 < HE || i5 > VE || n4 !== ":")
        throw new Deno.errors.InvalidData("file url path must be absolute");
      return r4.slice(1);
    }
  }
  function ZE(t4) {
    if (t4.hostname !== "")
      throw new Deno.errors.InvalidData("invalid file url hostname");
    let e4 = t4.pathname;
    for (let r4 = 0; r4 < e4.length; r4++)
      if (e4[r4] === "%") {
        let i5 = e4.codePointAt(r4 + 2) || 32;
        if (e4[r4 + 1] === "2" && i5 === 102)
          throw new Deno.errors.InvalidData("must not include encoded / characters");
      }
    return decodeURIComponent(e4);
  }
  function dg2(t4) {
    let e4 = Ja3.resolve(t4), r4 = t4.charCodeAt(t4.length - 1);
    (r4 === $E || il2 && r4 === WE) && e4[e4.length - 1] !== Ja3.sep && (e4 += "/");
    let i5 = new URL("file://");
    return e4.includes("%") && (e4 = e4.replace(KE, "%25")), !il2 && e4.includes("\\") && (e4 = e4.replace(GE, "%5C")), e4.includes(`
`) && (e4 = e4.replace(QE, "%0A")), e4.includes("\r") && (e4 = e4.replace(YE, "%0D")), e4.includes("	") && (e4 = e4.replace(JE, "%09")), i5.pathname = e4, i5;
  }
  function Me3() {
    throw new Error("Node.js net module is not supported by JSPM core outside of Node.js");
  }
  var ps3, Kg, Gg, Qg, we4, M3, Qt3, Yg, X3, B4, _3, P3, bt3, xr4, Yt4, Di3, kl2, xl2, Ml2, Ll2, Ul2, Nl2, ql2, Dl2, jl2, Fl2, Wl2, $l2, Hl2, Vl2, zl2, Kl2, Ql2, Yl2, Jl2, tu, ru2, Fi3, iu, nu, su, ou2, au2, lu, fu, cu, hu, pu, gu, yu, bu, wu, _u, mu2, vu, Eu, Su2, Au, Iu, Tu, Ru2, Cu2, Bu, Lt3, gs3, ys3, Ou2, ku2, xu, Mu2, Lu, Uu2, Nu2, qu2, Du2, ju2, Fu, $u, Hu2, m3, _e5, ui2, Vu2, Wi3, zu2, Jt3, Ku2, Ut3, x3, ty, ry, ye5, v3, Gu2, ce5, Je4, Hi3, Se4, fi3, Nt4, tt4, vt3, tr4, rc2, ic2, Ur4, Qf2, Yf2, Jf2, Be4, Ds3, rr3, Qb2, Yb2, Jb2, Xb2, Zb2, ew, ir3, tn4, ci2, dc2, sn3, Rc2, $e3, ke4, yc2, on3, nr3, bc2, yw, At3, Hs2, Nr4, _c2, Cw, Bw, an3, ln4, it4, Pw, ar3, Ks2, Tc2, Ys2, Lc2, qw, Uc2, Js2, di3, fo4, Sh3, nt4, wo4, mo4, mn4, Po4, Qh3, Mo2, Lo4, jt4, od2, ud2, fd3, hd2, Wo2, gd2, bd2, ot3, md2, Ad2, Id, Ko3, Ud, Nd2, Jo3, Dd2, Fd2, $d2, ea3, Vd, zd, Jr3, Ai3, Gd, Zd2, lt3, ep2, tp2, rp2, qn3, ut4, ga2, ip2, np2, sp2, op2, va2, Sa2, fp2, hp2, Ra2, Oa2, gp2, bp2, wp2, mp2, Ma2, Ep2, Sp2, Ap2, Ip2, Tp2, Pi3, Pp2, kp2, Mp2, qp2, ja3, ss3, Hp2, rE, iE, nE, sE, dt4, Va2, zp2, Yp2, Kp2, Gp2, zt3, Jp2, aE, ki3, lE, pt4, Xp2, eg2, Pt3, Ot4, ii2, fe4, Tr4, kt4, ri2, os3, ne3, ig2, Ga2, ng2, ni2, re4, Qa3, Ya3, sg2, Ja3, og2, pg2, Z4, hE, gt3, dE, pE, gE, yE, tl2, ag2, lg2, ug, bE, wE, Xa3, si2, Za3, el2, fg2, cg2, mE, vE, EE, SE, AE, rl2, IE, TE, RE, CE, BE, PE, LE, UE, NE, qE, DE, jE, FE, WE, $E, HE, VE, il2, zE, KE, GE, QE, YE, JE, gg2, nl, eS, sl2, ol2, bg2, sS, wg2, ll2, as3, hl2, gl2, Ag, _l2, Og2, ml2, JS, mqtt_esm_default;
  var init_mqtt_esm = __esm({
    "node_modules/mqtt/dist/mqtt.esm.js"() {
      ps3 = Object.defineProperty;
      Kg = Object.getOwnPropertyDescriptor;
      Gg = Object.getOwnPropertyNames;
      Qg = Object.prototype.hasOwnProperty;
      we4 = (t4, e4) => () => (t4 && (e4 = t4(t4 = 0)), e4);
      M3 = (t4, e4) => () => (e4 || t4((e4 = { exports: {} }).exports, e4), e4.exports);
      Qt3 = (t4, e4) => {
        for (var r4 in e4)
          ps3(t4, r4, { get: e4[r4], enumerable: true });
      };
      Yg = (t4, e4, r4, i5) => {
        if (e4 && typeof e4 == "object" || typeof e4 == "function")
          for (let n4 of Gg(e4))
            !Qg.call(t4, n4) && n4 !== r4 && ps3(t4, n4, { get: () => e4[n4], enumerable: !(i5 = Kg(e4, n4)) || i5.enumerable });
        return t4;
      };
      X3 = (t4) => Yg(ps3({}, "__esModule", { value: true }), t4);
      _3 = we4(() => {
        B4 = { deviceMemory: 8, hardwareConcurrency: 8, language: "en-US" };
      });
      P3 = {};
      Qt3(P3, { _debugEnd: () => yu, _debugProcess: () => gu, _events: () => ku2, _eventsCount: () => xu, _exiting: () => Yl2, _fatalExceptions: () => cu, _getActiveHandles: () => eu2, _getActiveRequests: () => Zl2, _kill: () => ru2, _linkedBinding: () => Gl2, _maxListeners: () => Ou2, _preload_modules: () => Cu2, _rawDebug: () => zl2, _startProfilerIdleNotifier: () => bu, _stopProfilerIdleNotifier: () => wu, _tickCallback: () => pu, abort: () => Eu, addListener: () => Mu2, allowedNodeEnvironmentFlags: () => lu, arch: () => xl2, argv: () => Ul2, argv0: () => Ru2, assert: () => uu, binding: () => Fl2, chdir: () => Hl2, config: () => Jl2, cpuUsage: () => Fi3, cwd: () => $l2, debugPort: () => Tu, default: () => $u, dlopen: () => Xl2, domain: () => Ql2, emit: () => Du2, emitWarning: () => jl2, env: () => Ll2, execArgv: () => Nl2, execPath: () => Iu, exit: () => ou2, features: () => fu, hasUncaughtExceptionCaptureCallback: () => du, hrtime: () => ji3, kill: () => su, listeners: () => Wu2, memoryUsage: () => nu, moduleLoadList: () => Kl2, nextTick: () => Pl2, off: () => Uu2, on: () => wt4, once: () => Lu, openStdin: () => au2, pid: () => Su2, platform: () => Ml2, ppid: () => Au, prependListener: () => ju2, prependOnceListener: () => Fu, reallyExit: () => tu, release: () => Vl2, removeAllListeners: () => qu2, removeListener: () => Nu2, resourceUsage: () => iu, setSourceMapsEnabled: () => Bu, setUncaughtExceptionCaptureCallback: () => hu, stderr: () => mu2, stdin: () => vu, stdout: () => _u, title: () => kl2, umask: () => Wl2, uptime: () => Pu2, version: () => ql2, versions: () => Dl2 });
      Hu2 = we4(() => {
        v3();
        m3();
        _3();
        bt3 = [], xr4 = false, Di3 = -1;
        Ol2.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        kl2 = "browser", xl2 = "x64", Ml2 = "browser", Ll2 = { PATH: "/usr/bin", LANG: B4.language + ".UTF-8", PWD: "/", HOME: "/home", TMP: "/tmp" }, Ul2 = ["/usr/bin/node"], Nl2 = [], ql2 = "v16.8.0", Dl2 = {}, jl2 = function(t4, e4) {
          console.warn((e4 ? e4 + ": " : "") + t4);
        }, Fl2 = function(t4) {
          bs3("binding");
        }, Wl2 = function(t4) {
          return 0;
        }, $l2 = function() {
          return "/";
        }, Hl2 = function(t4) {
        }, Vl2 = { name: "node", sourceUrl: "", headersUrl: "", libUrl: "" };
        zl2 = ve3, Kl2 = [];
        Ql2 = {}, Yl2 = false, Jl2 = {};
        tu = ve3, ru2 = ve3, Fi3 = function() {
          return {};
        }, iu = Fi3, nu = Fi3, su = ve3, ou2 = ve3, au2 = ve3, lu = {};
        fu = { inspector: false, debug: false, uv: false, ipv6: false, tls_alpn: false, tls_sni: false, tls_ocsp: false, tls: false, cached_builtins: true }, cu = ve3, hu = ve3;
        pu = ve3, gu = ve3, yu = ve3, bu = ve3, wu = ve3, _u = void 0, mu2 = void 0, vu = void 0, Eu = ve3, Su2 = 2, Au = 1, Iu = "/bin/usr/node", Tu = 9229, Ru2 = "node", Cu2 = [], Bu = ve3, Lt3 = { now: typeof performance < "u" ? performance.now.bind(performance) : void 0, timing: typeof performance < "u" ? performance.timing : void 0 };
        Lt3.now === void 0 && (gs3 = Date.now(), Lt3.timing && Lt3.timing.navigationStart && (gs3 = Lt3.timing.navigationStart), Lt3.now = () => Date.now() - gs3);
        ys3 = 1e9;
        ji3.bigint = function(t4) {
          var e4 = ji3(t4);
          return typeof BigInt > "u" ? e4[0] * ys3 + e4[1] : BigInt(e4[0] * ys3) + BigInt(e4[1]);
        };
        Ou2 = 10, ku2 = {}, xu = 0;
        Mu2 = wt4, Lu = wt4, Uu2 = wt4, Nu2 = wt4, qu2 = wt4, Du2 = ve3, ju2 = wt4, Fu = wt4;
        $u = { version: ql2, versions: Dl2, arch: xl2, platform: Ml2, release: Vl2, _rawDebug: zl2, moduleLoadList: Kl2, binding: Fl2, _linkedBinding: Gl2, _events: ku2, _eventsCount: xu, _maxListeners: Ou2, on: wt4, addListener: Mu2, once: Lu, off: Uu2, removeListener: Nu2, removeAllListeners: qu2, emit: Du2, prependListener: ju2, prependOnceListener: Fu, listeners: Wu2, domain: Ql2, _exiting: Yl2, config: Jl2, dlopen: Xl2, uptime: Pu2, _getActiveRequests: Zl2, _getActiveHandles: eu2, reallyExit: tu, _kill: ru2, cpuUsage: Fi3, resourceUsage: iu, memoryUsage: nu, kill: su, exit: ou2, openStdin: au2, allowedNodeEnvironmentFlags: lu, assert: uu, features: fu, _fatalExceptions: cu, setUncaughtExceptionCaptureCallback: hu, hasUncaughtExceptionCaptureCallback: du, emitWarning: jl2, nextTick: Pl2, _tickCallback: pu, _debugProcess: gu, _debugEnd: yu, _startProfilerIdleNotifier: bu, _stopProfilerIdleNotifier: wu, stdout: _u, stdin: vu, stderr: mu2, abort: Eu, umask: Wl2, chdir: Hl2, cwd: $l2, env: Ll2, title: kl2, argv: Ul2, execArgv: Nl2, pid: Su2, ppid: Au, execPath: Iu, debugPort: Tu, hrtime: ji3, argv0: Ru2, _preload_modules: Cu2, setSourceMapsEnabled: Bu };
      });
      m3 = we4(() => {
        Hu2();
      });
      _e5 = {};
      Qt3(_e5, { Buffer: () => x3, INSPECT_MAX_BYTES: () => ty, default: () => Ut3, kMaxLength: () => ry });
      ye5 = we4(() => {
        v3();
        m3();
        _3();
        ui2 = {}, Vu2 = false;
        Wi3 = {}, zu2 = false;
        Jt3 = {}, Ku2 = false;
        Ut3 = ey();
        Ut3.Buffer;
        Ut3.SlowBuffer;
        Ut3.INSPECT_MAX_BYTES;
        Ut3.kMaxLength;
        x3 = Ut3.Buffer, ty = Ut3.INSPECT_MAX_BYTES, ry = Ut3.kMaxLength;
      });
      v3 = we4(() => {
        ye5();
      });
      Gu2 = M3((_s3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(_s3, "__esModule", { value: true });
        var ws3 = class {
          constructor(e4) {
            this.aliasToTopic = {}, this.max = e4;
          }
          put(e4, r4) {
            return r4 === 0 || r4 > this.max ? false : (this.aliasToTopic[r4] = e4, this.length = Object.keys(this.aliasToTopic).length, true);
          }
          getTopicByAlias(e4) {
            return this.aliasToTopic[e4];
          }
          clear() {
            this.aliasToTopic = {};
          }
        };
        _s3.default = ws3;
      });
      ce5 = M3((kA, Qu2) => {
        "use strict";
        v3();
        m3();
        _3();
        Qu2.exports = { ArrayIsArray(t4) {
          return Array.isArray(t4);
        }, ArrayPrototypeIncludes(t4, e4) {
          return t4.includes(e4);
        }, ArrayPrototypeIndexOf(t4, e4) {
          return t4.indexOf(e4);
        }, ArrayPrototypeJoin(t4, e4) {
          return t4.join(e4);
        }, ArrayPrototypeMap(t4, e4) {
          return t4.map(e4);
        }, ArrayPrototypePop(t4, e4) {
          return t4.pop(e4);
        }, ArrayPrototypePush(t4, e4) {
          return t4.push(e4);
        }, ArrayPrototypeSlice(t4, e4, r4) {
          return t4.slice(e4, r4);
        }, Error, FunctionPrototypeCall(t4, e4, ...r4) {
          return t4.call(e4, ...r4);
        }, FunctionPrototypeSymbolHasInstance(t4, e4) {
          return Function.prototype[Symbol.hasInstance].call(t4, e4);
        }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t4, e4) {
          return Object.defineProperties(t4, e4);
        }, ObjectDefineProperty(t4, e4, r4) {
          return Object.defineProperty(t4, e4, r4);
        }, ObjectGetOwnPropertyDescriptor(t4, e4) {
          return Object.getOwnPropertyDescriptor(t4, e4);
        }, ObjectKeys(t4) {
          return Object.keys(t4);
        }, ObjectSetPrototypeOf(t4, e4) {
          return Object.setPrototypeOf(t4, e4);
        }, Promise, PromisePrototypeCatch(t4, e4) {
          return t4.catch(e4);
        }, PromisePrototypeThen(t4, e4, r4) {
          return t4.then(e4, r4);
        }, PromiseReject(t4) {
          return Promise.reject(t4);
        }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t4, e4) {
          return t4.test(e4);
        }, SafeSet: Set, String, StringPrototypeSlice(t4, e4, r4) {
          return t4.slice(e4, r4);
        }, StringPrototypeToLowerCase(t4) {
          return t4.toLowerCase();
        }, StringPrototypeToUpperCase(t4) {
          return t4.toUpperCase();
        }, StringPrototypeTrim(t4) {
          return t4.trim();
        }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t4, e4, r4) {
          return t4.set(e4, r4);
        }, Uint8Array };
      });
      Je4 = M3((WA, vs3) => {
        "use strict";
        v3();
        m3();
        _3();
        var iy = (ye5(), X3(_e5)), ny = Object.getPrototypeOf(async function() {
        }).constructor, Yu2 = globalThis.Blob || iy.Blob, sy = typeof Yu2 < "u" ? function(e4) {
          return e4 instanceof Yu2;
        } : function(e4) {
          return false;
        }, ms3 = class extends Error {
          constructor(e4) {
            if (!Array.isArray(e4))
              throw new TypeError(`Expected input to be an Array, got ${typeof e4}`);
            let r4 = "";
            for (let i5 = 0; i5 < e4.length; i5++)
              r4 += `    ${e4[i5].stack}
`;
            super(r4), this.name = "AggregateError", this.errors = e4;
          }
        };
        vs3.exports = { AggregateError: ms3, kEmptyObject: Object.freeze({}), once(t4) {
          let e4 = false;
          return function(...r4) {
            e4 || (e4 = true, t4.apply(this, r4));
          };
        }, createDeferredPromise: function() {
          let t4, e4;
          return { promise: new Promise((i5, n4) => {
            t4 = i5, e4 = n4;
          }), resolve: t4, reject: e4 };
        }, promisify(t4) {
          return new Promise((e4, r4) => {
            t4((i5, ...n4) => i5 ? r4(i5) : e4(...n4));
          });
        }, debuglog() {
          return function() {
          };
        }, format(t4, ...e4) {
          return t4.replace(/%([sdifj])/g, function(...[r4, i5]) {
            let n4 = e4.shift();
            return i5 === "f" ? n4.toFixed(6) : i5 === "j" ? JSON.stringify(n4) : i5 === "s" && typeof n4 == "object" ? `${n4.constructor !== Object ? n4.constructor.name : ""} {}`.trim() : n4.toString();
          });
        }, inspect(t4) {
          switch (typeof t4) {
            case "string":
              if (t4.includes("'"))
                if (t4.includes('"')) {
                  if (!t4.includes("`") && !t4.includes("${"))
                    return `\`${t4}\``;
                } else
                  return `"${t4}"`;
              return `'${t4}'`;
            case "number":
              return isNaN(t4) ? "NaN" : Object.is(t4, -0) ? String(t4) : t4;
            case "bigint":
              return `${String(t4)}n`;
            case "boolean":
            case "undefined":
              return String(t4);
            case "object":
              return "{}";
          }
        }, types: { isAsyncFunction(t4) {
          return t4 instanceof ny;
        }, isArrayBufferView(t4) {
          return ArrayBuffer.isView(t4);
        } }, isBlob: sy };
        vs3.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
      });
      Hi3 = M3((XA, $i3) => {
        "use strict";
        v3();
        m3();
        _3();
        var { AbortController: Ju2, AbortSignal: oy } = typeof self < "u" ? self : typeof window < "u" ? window : void 0;
        $i3.exports = Ju2;
        $i3.exports.AbortSignal = oy;
        $i3.exports.default = Ju2;
      });
      Se4 = M3((lI, ef2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { format: ay, inspect: Vi3, AggregateError: ly } = Je4(), uy = globalThis.AggregateError || ly, fy = Symbol("kIsNodeError"), cy = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], hy = /^([A-Z][a-z0-9]*)+$/, dy = "__node_internal_", zi3 = {};
        function Xt4(t4, e4) {
          if (!t4)
            throw new zi3.ERR_INTERNAL_ASSERTION(e4);
        }
        function Xu2(t4) {
          let e4 = "", r4 = t4.length, i5 = t4[0] === "-" ? 1 : 0;
          for (; r4 >= i5 + 4; r4 -= 3)
            e4 = `_${t4.slice(r4 - 3, r4)}${e4}`;
          return `${t4.slice(0, r4)}${e4}`;
        }
        function py(t4, e4, r4) {
          if (typeof e4 == "function")
            return Xt4(e4.length <= r4.length, `Code: ${t4}; The provided arguments length (${r4.length}) does not match the required ones (${e4.length}).`), e4(...r4);
          let i5 = (e4.match(/%[dfijoOs]/g) || []).length;
          return Xt4(i5 === r4.length, `Code: ${t4}; The provided arguments length (${r4.length}) does not match the required ones (${i5}).`), r4.length === 0 ? e4 : ay(e4, ...r4);
        }
        function me4(t4, e4, r4) {
          r4 || (r4 = Error);
          class i5 extends r4 {
            constructor(...o4) {
              super(py(t4, e4, o4));
            }
            toString() {
              return `${this.name} [${t4}]: ${this.message}`;
            }
          }
          Object.defineProperties(i5.prototype, { name: { value: r4.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
            return `${this.name} [${t4}]: ${this.message}`;
          }, writable: true, enumerable: false, configurable: true } }), i5.prototype.code = t4, i5.prototype[fy] = true, zi3[t4] = i5;
        }
        function Zu2(t4) {
          let e4 = dy + t4.name;
          return Object.defineProperty(t4, "name", { value: e4 }), t4;
        }
        function gy(t4, e4) {
          if (t4 && e4 && t4 !== e4) {
            if (Array.isArray(e4.errors))
              return e4.errors.push(t4), e4;
            let r4 = new uy([e4, t4], e4.message);
            return r4.code = e4.code, r4;
          }
          return t4 || e4;
        }
        var Es3 = class extends Error {
          constructor(e4 = "The operation was aborted", r4 = void 0) {
            if (r4 !== void 0 && typeof r4 != "object")
              throw new zi3.ERR_INVALID_ARG_TYPE("options", "Object", r4);
            super(e4, r4), this.code = "ABORT_ERR", this.name = "AbortError";
          }
        };
        me4("ERR_ASSERTION", "%s", Error);
        me4("ERR_INVALID_ARG_TYPE", (t4, e4, r4) => {
          Xt4(typeof t4 == "string", "'name' must be a string"), Array.isArray(e4) || (e4 = [e4]);
          let i5 = "The ";
          t4.endsWith(" argument") ? i5 += `${t4} ` : i5 += `"${t4}" ${t4.includes(".") ? "property" : "argument"} `, i5 += "must be ";
          let n4 = [], o4 = [], s4 = [];
          for (let u4 of e4)
            Xt4(typeof u4 == "string", "All expected entries have to be of type string"), cy.includes(u4) ? n4.push(u4.toLowerCase()) : hy.test(u4) ? o4.push(u4) : (Xt4(u4 !== "object", 'The value "object" should be written as "Object"'), s4.push(u4));
          if (o4.length > 0) {
            let u4 = n4.indexOf("object");
            u4 !== -1 && (n4.splice(n4, u4, 1), o4.push("Object"));
          }
          if (n4.length > 0) {
            switch (n4.length) {
              case 1:
                i5 += `of type ${n4[0]}`;
                break;
              case 2:
                i5 += `one of type ${n4[0]} or ${n4[1]}`;
                break;
              default: {
                let u4 = n4.pop();
                i5 += `one of type ${n4.join(", ")}, or ${u4}`;
              }
            }
            (o4.length > 0 || s4.length > 0) && (i5 += " or ");
          }
          if (o4.length > 0) {
            switch (o4.length) {
              case 1:
                i5 += `an instance of ${o4[0]}`;
                break;
              case 2:
                i5 += `an instance of ${o4[0]} or ${o4[1]}`;
                break;
              default: {
                let u4 = o4.pop();
                i5 += `an instance of ${o4.join(", ")}, or ${u4}`;
              }
            }
            s4.length > 0 && (i5 += " or ");
          }
          switch (s4.length) {
            case 0:
              break;
            case 1:
              s4[0].toLowerCase() !== s4[0] && (i5 += "an "), i5 += `${s4[0]}`;
              break;
            case 2:
              i5 += `one of ${s4[0]} or ${s4[1]}`;
              break;
            default: {
              let u4 = s4.pop();
              i5 += `one of ${s4.join(", ")}, or ${u4}`;
            }
          }
          if (r4 == null)
            i5 += `. Received ${r4}`;
          else if (typeof r4 == "function" && r4.name)
            i5 += `. Received function ${r4.name}`;
          else if (typeof r4 == "object") {
            var a4;
            if ((a4 = r4.constructor) !== null && a4 !== void 0 && a4.name)
              i5 += `. Received an instance of ${r4.constructor.name}`;
            else {
              let u4 = Vi3(r4, { depth: -1 });
              i5 += `. Received ${u4}`;
            }
          } else {
            let u4 = Vi3(r4, { colors: false });
            u4.length > 25 && (u4 = `${u4.slice(0, 25)}...`), i5 += `. Received type ${typeof r4} (${u4})`;
          }
          return i5;
        }, TypeError);
        me4("ERR_INVALID_ARG_VALUE", (t4, e4, r4 = "is invalid") => {
          let i5 = Vi3(e4);
          return i5.length > 128 && (i5 = i5.slice(0, 128) + "..."), `The ${t4.includes(".") ? "property" : "argument"} '${t4}' ${r4}. Received ${i5}`;
        }, TypeError);
        me4("ERR_INVALID_RETURN_VALUE", (t4, e4, r4) => {
          var i5;
          let n4 = r4 != null && (i5 = r4.constructor) !== null && i5 !== void 0 && i5.name ? `instance of ${r4.constructor.name}` : `type ${typeof r4}`;
          return `Expected ${t4} to be returned from the "${e4}" function but got ${n4}.`;
        }, TypeError);
        me4("ERR_MISSING_ARGS", (...t4) => {
          Xt4(t4.length > 0, "At least one arg needs to be specified");
          let e4, r4 = t4.length;
          switch (t4 = (Array.isArray(t4) ? t4 : [t4]).map((i5) => `"${i5}"`).join(" or "), r4) {
            case 1:
              e4 += `The ${t4[0]} argument`;
              break;
            case 2:
              e4 += `The ${t4[0]} and ${t4[1]} arguments`;
              break;
            default:
              {
                let i5 = t4.pop();
                e4 += `The ${t4.join(", ")}, and ${i5} arguments`;
              }
              break;
          }
          return `${e4} must be specified`;
        }, TypeError);
        me4("ERR_OUT_OF_RANGE", (t4, e4, r4) => {
          Xt4(e4, 'Missing "range" argument');
          let i5;
          return Number.isInteger(r4) && Math.abs(r4) > 2 ** 32 ? i5 = Xu2(String(r4)) : typeof r4 == "bigint" ? (i5 = String(r4), (r4 > 2n ** 32n || r4 < -(2n ** 32n)) && (i5 = Xu2(i5)), i5 += "n") : i5 = Vi3(r4), `The value of "${t4}" is out of range. It must be ${e4}. Received ${i5}`;
        }, RangeError);
        me4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
        me4("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
        me4("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
        me4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
        me4("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
        me4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        me4("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
        me4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
        me4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
        me4("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
        me4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
        ef2.exports = { AbortError: Es3, aggregateTwoErrors: Zu2(gy), hideStackFrames: Zu2, codes: zi3 };
      });
      fi3 = M3((wI, ff2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { ArrayIsArray: As3, ArrayPrototypeIncludes: sf2, ArrayPrototypeJoin: of2, ArrayPrototypeMap: yy, NumberIsInteger: Is3, NumberIsNaN: by, NumberMAX_SAFE_INTEGER: wy, NumberMIN_SAFE_INTEGER: _y2, NumberParseInt: my, ObjectPrototypeHasOwnProperty: vy, RegExpPrototypeExec: af2, String: Ey, StringPrototypeToUpperCase: Sy, StringPrototypeTrim: Ay } = ce5(), { hideStackFrames: Ue3, codes: { ERR_SOCKET_BAD_PORT: Iy, ERR_INVALID_ARG_TYPE: Ae3, ERR_INVALID_ARG_VALUE: Mr4, ERR_OUT_OF_RANGE: Zt4, ERR_UNKNOWN_SIGNAL: tf2 } } = Se4(), { normalizeEncoding: Ty } = Je4(), { isAsyncFunction: Ry, isArrayBufferView: Cy } = Je4().types, rf2 = {};
        function By(t4) {
          return t4 === (t4 | 0);
        }
        function Py(t4) {
          return t4 === t4 >>> 0;
        }
        var Oy = /^[0-7]+$/, ky = "must be a 32-bit unsigned integer or an octal string";
        function xy(t4, e4, r4) {
          if (typeof t4 > "u" && (t4 = r4), typeof t4 == "string") {
            if (af2(Oy, t4) === null)
              throw new Mr4(e4, t4, ky);
            t4 = my(t4, 8);
          }
          return lf2(t4, e4), t4;
        }
        var My = Ue3((t4, e4, r4 = _y2, i5 = wy) => {
          if (typeof t4 != "number")
            throw new Ae3(e4, "number", t4);
          if (!Is3(t4))
            throw new Zt4(e4, "an integer", t4);
          if (t4 < r4 || t4 > i5)
            throw new Zt4(e4, `>= ${r4} && <= ${i5}`, t4);
        }), Ly = Ue3((t4, e4, r4 = -2147483648, i5 = 2147483647) => {
          if (typeof t4 != "number")
            throw new Ae3(e4, "number", t4);
          if (!Is3(t4))
            throw new Zt4(e4, "an integer", t4);
          if (t4 < r4 || t4 > i5)
            throw new Zt4(e4, `>= ${r4} && <= ${i5}`, t4);
        }), lf2 = Ue3((t4, e4, r4 = false) => {
          if (typeof t4 != "number")
            throw new Ae3(e4, "number", t4);
          if (!Is3(t4))
            throw new Zt4(e4, "an integer", t4);
          let i5 = r4 ? 1 : 0, n4 = 4294967295;
          if (t4 < i5 || t4 > n4)
            throw new Zt4(e4, `>= ${i5} && <= ${n4}`, t4);
        });
        function Ts3(t4, e4) {
          if (typeof t4 != "string")
            throw new Ae3(e4, "string", t4);
        }
        function Uy(t4, e4, r4 = void 0, i5) {
          if (typeof t4 != "number")
            throw new Ae3(e4, "number", t4);
          if (r4 != null && t4 < r4 || i5 != null && t4 > i5 || (r4 != null || i5 != null) && by(t4))
            throw new Zt4(e4, `${r4 != null ? `>= ${r4}` : ""}${r4 != null && i5 != null ? " && " : ""}${i5 != null ? `<= ${i5}` : ""}`, t4);
        }
        var Ny = Ue3((t4, e4, r4) => {
          if (!sf2(r4, t4)) {
            let n4 = "must be one of: " + of2(yy(r4, (o4) => typeof o4 == "string" ? `'${o4}'` : Ey(o4)), ", ");
            throw new Mr4(e4, t4, n4);
          }
        });
        function uf2(t4, e4) {
          if (typeof t4 != "boolean")
            throw new Ae3(e4, "boolean", t4);
        }
        function Ss3(t4, e4, r4) {
          return t4 == null || !vy(t4, e4) ? r4 : t4[e4];
        }
        var qy = Ue3((t4, e4, r4 = null) => {
          let i5 = Ss3(r4, "allowArray", false), n4 = Ss3(r4, "allowFunction", false);
          if (!Ss3(r4, "nullable", false) && t4 === null || !i5 && As3(t4) || typeof t4 != "object" && (!n4 || typeof t4 != "function"))
            throw new Ae3(e4, "Object", t4);
        }), Dy = Ue3((t4, e4) => {
          if (t4 != null && typeof t4 != "object" && typeof t4 != "function")
            throw new Ae3(e4, "a dictionary", t4);
        }), Rs3 = Ue3((t4, e4, r4 = 0) => {
          if (!As3(t4))
            throw new Ae3(e4, "Array", t4);
          if (t4.length < r4) {
            let i5 = `must be longer than ${r4}`;
            throw new Mr4(e4, t4, i5);
          }
        });
        function jy(t4, e4) {
          Rs3(t4, e4);
          for (let r4 = 0; r4 < t4.length; r4++)
            Ts3(t4[r4], `${e4}[${r4}]`);
        }
        function Fy(t4, e4) {
          Rs3(t4, e4);
          for (let r4 = 0; r4 < t4.length; r4++)
            uf2(t4[r4], `${e4}[${r4}]`);
        }
        function Wy(t4, e4 = "signal") {
          if (Ts3(t4, e4), rf2[t4] === void 0)
            throw rf2[Sy(t4)] !== void 0 ? new tf2(t4 + " (signals must use all capital letters)") : new tf2(t4);
        }
        var $y = Ue3((t4, e4 = "buffer") => {
          if (!Cy(t4))
            throw new Ae3(e4, ["Buffer", "TypedArray", "DataView"], t4);
        });
        function Hy(t4, e4) {
          let r4 = Ty(e4), i5 = t4.length;
          if (r4 === "hex" && i5 % 2 !== 0)
            throw new Mr4("encoding", e4, `is invalid for data of length ${i5}`);
        }
        function Vy(t4, e4 = "Port", r4 = true) {
          if (typeof t4 != "number" && typeof t4 != "string" || typeof t4 == "string" && Ay(t4).length === 0 || +t4 !== +t4 >>> 0 || t4 > 65535 || t4 === 0 && !r4)
            throw new Iy(e4, t4, r4);
          return t4 | 0;
        }
        var zy = Ue3((t4, e4) => {
          if (t4 !== void 0 && (t4 === null || typeof t4 != "object" || !("aborted" in t4)))
            throw new Ae3(e4, "AbortSignal", t4);
        }), Ky = Ue3((t4, e4) => {
          if (typeof t4 != "function")
            throw new Ae3(e4, "Function", t4);
        }), Gy = Ue3((t4, e4) => {
          if (typeof t4 != "function" || Ry(t4))
            throw new Ae3(e4, "Function", t4);
        }), Qy = Ue3((t4, e4) => {
          if (t4 !== void 0)
            throw new Ae3(e4, "undefined", t4);
        });
        function Yy(t4, e4, r4) {
          if (!sf2(r4, t4))
            throw new Ae3(e4, `('${of2(r4, "|")}')`, t4);
        }
        var Jy = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
        function nf2(t4, e4) {
          if (typeof t4 > "u" || !af2(Jy, t4))
            throw new Mr4(e4, t4, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
        }
        function Xy(t4) {
          if (typeof t4 == "string")
            return nf2(t4, "hints"), t4;
          if (As3(t4)) {
            let e4 = t4.length, r4 = "";
            if (e4 === 0)
              return r4;
            for (let i5 = 0; i5 < e4; i5++) {
              let n4 = t4[i5];
              nf2(n4, "hints"), r4 += n4, i5 !== e4 - 1 && (r4 += ", ");
            }
            return r4;
          }
          throw new Mr4("hints", t4, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
        }
        ff2.exports = { isInt32: By, isUint32: Py, parseFileMode: xy, validateArray: Rs3, validateStringArray: jy, validateBooleanArray: Fy, validateBoolean: uf2, validateBuffer: $y, validateDictionary: Dy, validateEncoding: Hy, validateFunction: Ky, validateInt32: Ly, validateInteger: My, validateNumber: Uy, validateObject: qy, validateOneOf: Ny, validatePlainFunction: Gy, validatePort: Vy, validateSignalName: Wy, validateString: Ts3, validateUint32: lf2, validateUndefined: Qy, validateUnion: Yy, validateAbortSignal: zy, validateLinkHeaderValue: Xy };
      });
      Nt4 = M3((CI, pf2) => {
        v3();
        m3();
        _3();
        var ae4 = pf2.exports = {}, Xe5, Ze3;
        function Cs3() {
          throw new Error("setTimeout has not been defined");
        }
        function Bs3() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? Xe5 = setTimeout : Xe5 = Cs3;
          } catch {
            Xe5 = Cs3;
          }
          try {
            typeof clearTimeout == "function" ? Ze3 = clearTimeout : Ze3 = Bs3;
          } catch {
            Ze3 = Bs3;
          }
        })();
        function cf2(t4) {
          if (Xe5 === setTimeout)
            return setTimeout(t4, 0);
          if ((Xe5 === Cs3 || !Xe5) && setTimeout)
            return Xe5 = setTimeout, setTimeout(t4, 0);
          try {
            return Xe5(t4, 0);
          } catch {
            try {
              return Xe5.call(null, t4, 0);
            } catch {
              return Xe5.call(this, t4, 0);
            }
          }
        }
        function Zy(t4) {
          if (Ze3 === clearTimeout)
            return clearTimeout(t4);
          if ((Ze3 === Bs3 || !Ze3) && clearTimeout)
            return Ze3 = clearTimeout, clearTimeout(t4);
          try {
            return Ze3(t4);
          } catch {
            try {
              return Ze3.call(null, t4);
            } catch {
              return Ze3.call(this, t4);
            }
          }
        }
        var _t3 = [], Lr4 = false, er4, Ki3 = -1;
        function eb2() {
          !Lr4 || !er4 || (Lr4 = false, er4.length ? _t3 = er4.concat(_t3) : Ki3 = -1, _t3.length && hf2());
        }
        function hf2() {
          if (!Lr4) {
            var t4 = cf2(eb2);
            Lr4 = true;
            for (var e4 = _t3.length; e4; ) {
              for (er4 = _t3, _t3 = []; ++Ki3 < e4; )
                er4 && er4[Ki3].run();
              Ki3 = -1, e4 = _t3.length;
            }
            er4 = null, Lr4 = false, Zy(t4);
          }
        }
        ae4.nextTick = function(t4) {
          var e4 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r4 = 1; r4 < arguments.length; r4++)
              e4[r4 - 1] = arguments[r4];
          _t3.push(new df2(t4, e4)), _t3.length === 1 && !Lr4 && cf2(hf2);
        };
        function df2(t4, e4) {
          this.fun = t4, this.array = e4;
        }
        df2.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        ae4.title = "browser";
        ae4.browser = true;
        ae4.env = {};
        ae4.argv = [];
        ae4.version = "";
        ae4.versions = {};
        function mt3() {
        }
        ae4.on = mt3;
        ae4.addListener = mt3;
        ae4.once = mt3;
        ae4.off = mt3;
        ae4.removeListener = mt3;
        ae4.removeAllListeners = mt3;
        ae4.emit = mt3;
        ae4.prependListener = mt3;
        ae4.prependOnceListener = mt3;
        ae4.listeners = function(t4) {
          return [];
        };
        ae4.binding = function(t4) {
          throw new Error("process.binding is not supported");
        };
        ae4.cwd = function() {
          return "/";
        };
        ae4.chdir = function(t4) {
          throw new Error("process.chdir is not supported");
        };
        ae4.umask = function() {
          return 0;
        };
      });
      tt4 = M3((qI, Pf2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { Symbol: Gi3, SymbolAsyncIterator: gf2, SymbolIterator: yf2, SymbolFor: bf2 } = ce5(), wf2 = Gi3("kDestroyed"), _f3 = Gi3("kIsErrored"), Ps3 = Gi3("kIsReadable"), mf2 = Gi3("kIsDisturbed"), tb2 = bf2("nodejs.webstream.isClosedPromise"), rb2 = bf2("nodejs.webstream.controllerErrorFunction");
        function Qi3(t4, e4 = false) {
          var r4;
          return !!(t4 && typeof t4.pipe == "function" && typeof t4.on == "function" && (!e4 || typeof t4.pause == "function" && typeof t4.resume == "function") && (!t4._writableState || ((r4 = t4._readableState) === null || r4 === void 0 ? void 0 : r4.readable) !== false) && (!t4._writableState || t4._readableState));
        }
        function Yi3(t4) {
          var e4;
          return !!(t4 && typeof t4.write == "function" && typeof t4.on == "function" && (!t4._readableState || ((e4 = t4._writableState) === null || e4 === void 0 ? void 0 : e4.writable) !== false));
        }
        function ib2(t4) {
          return !!(t4 && typeof t4.pipe == "function" && t4._readableState && typeof t4.on == "function" && typeof t4.write == "function");
        }
        function et4(t4) {
          return t4 && (t4._readableState || t4._writableState || typeof t4.write == "function" && typeof t4.on == "function" || typeof t4.pipe == "function" && typeof t4.on == "function");
        }
        function vf2(t4) {
          return !!(t4 && !et4(t4) && typeof t4.pipeThrough == "function" && typeof t4.getReader == "function" && typeof t4.cancel == "function");
        }
        function Ef2(t4) {
          return !!(t4 && !et4(t4) && typeof t4.getWriter == "function" && typeof t4.abort == "function");
        }
        function Sf2(t4) {
          return !!(t4 && !et4(t4) && typeof t4.readable == "object" && typeof t4.writable == "object");
        }
        function nb2(t4) {
          return vf2(t4) || Ef2(t4) || Sf2(t4);
        }
        function sb2(t4, e4) {
          return t4 == null ? false : e4 === true ? typeof t4[gf2] == "function" : e4 === false ? typeof t4[yf2] == "function" : typeof t4[gf2] == "function" || typeof t4[yf2] == "function";
        }
        function Ji3(t4) {
          if (!et4(t4))
            return null;
          let e4 = t4._writableState, r4 = t4._readableState, i5 = e4 || r4;
          return !!(t4.destroyed || t4[wf2] || i5 != null && i5.destroyed);
        }
        function Af2(t4) {
          if (!Yi3(t4))
            return null;
          if (t4.writableEnded === true)
            return true;
          let e4 = t4._writableState;
          return e4 != null && e4.errored ? false : typeof e4?.ended != "boolean" ? null : e4.ended;
        }
        function ob2(t4, e4) {
          if (!Yi3(t4))
            return null;
          if (t4.writableFinished === true)
            return true;
          let r4 = t4._writableState;
          return r4 != null && r4.errored ? false : typeof r4?.finished != "boolean" ? null : !!(r4.finished || e4 === false && r4.ended === true && r4.length === 0);
        }
        function ab2(t4) {
          if (!Qi3(t4))
            return null;
          if (t4.readableEnded === true)
            return true;
          let e4 = t4._readableState;
          return !e4 || e4.errored ? false : typeof e4?.ended != "boolean" ? null : e4.ended;
        }
        function If2(t4, e4) {
          if (!Qi3(t4))
            return null;
          let r4 = t4._readableState;
          return r4 != null && r4.errored ? false : typeof r4?.endEmitted != "boolean" ? null : !!(r4.endEmitted || e4 === false && r4.ended === true && r4.length === 0);
        }
        function Tf2(t4) {
          return t4 && t4[Ps3] != null ? t4[Ps3] : typeof t4?.readable != "boolean" ? null : Ji3(t4) ? false : Qi3(t4) && t4.readable && !If2(t4);
        }
        function Rf2(t4) {
          return typeof t4?.writable != "boolean" ? null : Ji3(t4) ? false : Yi3(t4) && t4.writable && !Af2(t4);
        }
        function lb2(t4, e4) {
          return et4(t4) ? Ji3(t4) ? true : !(e4?.readable !== false && Tf2(t4) || e4?.writable !== false && Rf2(t4)) : null;
        }
        function ub2(t4) {
          var e4, r4;
          return et4(t4) ? t4.writableErrored ? t4.writableErrored : (e4 = (r4 = t4._writableState) === null || r4 === void 0 ? void 0 : r4.errored) !== null && e4 !== void 0 ? e4 : null : null;
        }
        function fb2(t4) {
          var e4, r4;
          return et4(t4) ? t4.readableErrored ? t4.readableErrored : (e4 = (r4 = t4._readableState) === null || r4 === void 0 ? void 0 : r4.errored) !== null && e4 !== void 0 ? e4 : null : null;
        }
        function cb2(t4) {
          if (!et4(t4))
            return null;
          if (typeof t4.closed == "boolean")
            return t4.closed;
          let e4 = t4._writableState, r4 = t4._readableState;
          return typeof e4?.closed == "boolean" || typeof r4?.closed == "boolean" ? e4?.closed || r4?.closed : typeof t4._closed == "boolean" && Cf2(t4) ? t4._closed : null;
        }
        function Cf2(t4) {
          return typeof t4._closed == "boolean" && typeof t4._defaultKeepAlive == "boolean" && typeof t4._removedConnection == "boolean" && typeof t4._removedContLen == "boolean";
        }
        function Bf2(t4) {
          return typeof t4._sent100 == "boolean" && Cf2(t4);
        }
        function hb2(t4) {
          var e4;
          return typeof t4._consuming == "boolean" && typeof t4._dumped == "boolean" && ((e4 = t4.req) === null || e4 === void 0 ? void 0 : e4.upgradeOrConnect) === void 0;
        }
        function db2(t4) {
          if (!et4(t4))
            return null;
          let e4 = t4._writableState, r4 = t4._readableState, i5 = e4 || r4;
          return !i5 && Bf2(t4) || !!(i5 && i5.autoDestroy && i5.emitClose && i5.closed === false);
        }
        function pb2(t4) {
          var e4;
          return !!(t4 && ((e4 = t4[mf2]) !== null && e4 !== void 0 ? e4 : t4.readableDidRead || t4.readableAborted));
        }
        function gb2(t4) {
          var e4, r4, i5, n4, o4, s4, a4, u4, c5, h4;
          return !!(t4 && ((e4 = (r4 = (i5 = (n4 = (o4 = (s4 = t4[_f3]) !== null && s4 !== void 0 ? s4 : t4.readableErrored) !== null && o4 !== void 0 ? o4 : t4.writableErrored) !== null && n4 !== void 0 ? n4 : (a4 = t4._readableState) === null || a4 === void 0 ? void 0 : a4.errorEmitted) !== null && i5 !== void 0 ? i5 : (u4 = t4._writableState) === null || u4 === void 0 ? void 0 : u4.errorEmitted) !== null && r4 !== void 0 ? r4 : (c5 = t4._readableState) === null || c5 === void 0 ? void 0 : c5.errored) !== null && e4 !== void 0 ? e4 : !((h4 = t4._writableState) === null || h4 === void 0) && h4.errored));
        }
        Pf2.exports = { kDestroyed: wf2, isDisturbed: pb2, kIsDisturbed: mf2, isErrored: gb2, kIsErrored: _f3, isReadable: Tf2, kIsReadable: Ps3, kIsClosedPromise: tb2, kControllerErrorFunction: rb2, isClosed: cb2, isDestroyed: Ji3, isDuplexNodeStream: ib2, isFinished: lb2, isIterable: sb2, isReadableNodeStream: Qi3, isReadableStream: vf2, isReadableEnded: ab2, isReadableFinished: If2, isReadableErrored: fb2, isNodeStream: et4, isWebStream: nb2, isWritable: Rf2, isWritableNodeStream: Yi3, isWritableStream: Ef2, isWritableEnded: Af2, isWritableFinished: ob2, isWritableErrored: ub2, isServerRequest: hb2, isServerResponse: Bf2, willEmitClose: db2, isTransformStream: Sf2 };
      });
      vt3 = M3((GI, Ls3) => {
        v3();
        m3();
        _3();
        var qt3 = Nt4(), { AbortError: Df2, codes: yb2 } = Se4(), { ERR_INVALID_ARG_TYPE: bb2, ERR_STREAM_PREMATURE_CLOSE: Of2 } = yb2, { kEmptyObject: ks3, once: xs3 } = Je4(), { validateAbortSignal: wb2, validateFunction: _b3, validateObject: mb2, validateBoolean: vb2 } = fi3(), { Promise: Eb2, PromisePrototypeThen: Sb2 } = ce5(), { isClosed: Ab2, isReadable: kf2, isReadableNodeStream: Os3, isReadableStream: Ib2, isReadableFinished: xf2, isReadableErrored: Mf2, isWritable: Lf2, isWritableNodeStream: Uf2, isWritableStream: Tb2, isWritableFinished: Nf2, isWritableErrored: qf2, isNodeStream: Rb2, willEmitClose: Cb2, kIsClosedPromise: Bb2 } = tt4();
        function Pb2(t4) {
          return t4.setHeader && typeof t4.abort == "function";
        }
        var Ms2 = () => {
        };
        function jf2(t4, e4, r4) {
          var i5, n4;
          if (arguments.length === 2 ? (r4 = e4, e4 = ks3) : e4 == null ? e4 = ks3 : mb2(e4, "options"), _b3(r4, "callback"), wb2(e4.signal, "options.signal"), r4 = xs3(r4), Ib2(t4) || Tb2(t4))
            return Ob2(t4, e4, r4);
          if (!Rb2(t4))
            throw new bb2("stream", ["ReadableStream", "WritableStream", "Stream"], t4);
          let o4 = (i5 = e4.readable) !== null && i5 !== void 0 ? i5 : Os3(t4), s4 = (n4 = e4.writable) !== null && n4 !== void 0 ? n4 : Uf2(t4), a4 = t4._writableState, u4 = t4._readableState, c5 = () => {
            t4.writable || g4();
          }, h4 = Cb2(t4) && Os3(t4) === o4 && Uf2(t4) === s4, d4 = Nf2(t4, false), g4 = () => {
            d4 = true, t4.destroyed && (h4 = false), !(h4 && (!t4.readable || o4)) && (!o4 || y3) && r4.call(t4);
          }, y3 = xf2(t4, false), w3 = () => {
            y3 = true, t4.destroyed && (h4 = false), !(h4 && (!t4.writable || s4)) && (!s4 || d4) && r4.call(t4);
          }, E4 = (N4) => {
            r4.call(t4, N4);
          }, S3 = Ab2(t4), I3 = () => {
            S3 = true;
            let N4 = qf2(t4) || Mf2(t4);
            if (N4 && typeof N4 != "boolean")
              return r4.call(t4, N4);
            if (o4 && !y3 && Os3(t4, true) && !xf2(t4, false))
              return r4.call(t4, new Of2());
            if (s4 && !d4 && !Nf2(t4, false))
              return r4.call(t4, new Of2());
            r4.call(t4);
          }, C3 = () => {
            S3 = true;
            let N4 = qf2(t4) || Mf2(t4);
            if (N4 && typeof N4 != "boolean")
              return r4.call(t4, N4);
            r4.call(t4);
          }, R5 = () => {
            t4.req.on("finish", g4);
          };
          Pb2(t4) ? (t4.on("complete", g4), h4 || t4.on("abort", I3), t4.req ? R5() : t4.on("request", R5)) : s4 && !a4 && (t4.on("end", c5), t4.on("close", c5)), !h4 && typeof t4.aborted == "boolean" && t4.on("aborted", I3), t4.on("end", w3), t4.on("finish", g4), e4.error !== false && t4.on("error", E4), t4.on("close", I3), S3 ? qt3.nextTick(I3) : a4 != null && a4.errorEmitted || u4 != null && u4.errorEmitted ? h4 || qt3.nextTick(C3) : (!o4 && (!h4 || kf2(t4)) && (d4 || Lf2(t4) === false) || !s4 && (!h4 || Lf2(t4)) && (y3 || kf2(t4) === false) || u4 && t4.req && t4.aborted) && qt3.nextTick(C3);
          let U5 = () => {
            r4 = Ms2, t4.removeListener("aborted", I3), t4.removeListener("complete", g4), t4.removeListener("abort", I3), t4.removeListener("request", R5), t4.req && t4.req.removeListener("finish", g4), t4.removeListener("end", c5), t4.removeListener("close", c5), t4.removeListener("finish", g4), t4.removeListener("end", w3), t4.removeListener("error", E4), t4.removeListener("close", I3);
          };
          if (e4.signal && !S3) {
            let N4 = () => {
              let W4 = r4;
              U5(), W4.call(t4, new Df2(void 0, { cause: e4.signal.reason }));
            };
            if (e4.signal.aborted)
              qt3.nextTick(N4);
            else {
              let W4 = r4;
              r4 = xs3((...K5) => {
                e4.signal.removeEventListener("abort", N4), W4.apply(t4, K5);
              }), e4.signal.addEventListener("abort", N4);
            }
          }
          return U5;
        }
        function Ob2(t4, e4, r4) {
          let i5 = false, n4 = Ms2;
          if (e4.signal)
            if (n4 = () => {
              i5 = true, r4.call(t4, new Df2(void 0, { cause: e4.signal.reason }));
            }, e4.signal.aborted)
              qt3.nextTick(n4);
            else {
              let s4 = r4;
              r4 = xs3((...a4) => {
                e4.signal.removeEventListener("abort", n4), s4.apply(t4, a4);
              }), e4.signal.addEventListener("abort", n4);
            }
          let o4 = (...s4) => {
            i5 || qt3.nextTick(() => r4.apply(t4, s4));
          };
          return Sb2(t4[Bb2].promise, o4, o4), Ms2;
        }
        function kb2(t4, e4) {
          var r4;
          let i5 = false;
          return e4 === null && (e4 = ks3), (r4 = e4) !== null && r4 !== void 0 && r4.cleanup && (vb2(e4.cleanup, "cleanup"), i5 = e4.cleanup), new Eb2((n4, o4) => {
            let s4 = jf2(t4, e4, (a4) => {
              i5 && s4(), a4 ? o4(a4) : n4();
            });
          });
        }
        Ls3.exports = jf2;
        Ls3.exports.finished = kb2;
      });
      tr4 = M3((nT, Gf2) => {
        "use strict";
        v3();
        m3();
        _3();
        var rt3 = Nt4(), { aggregateTwoErrors: xb2, codes: { ERR_MULTIPLE_CALLBACK: Mb2 }, AbortError: Lb2 } = Se4(), { Symbol: $f2 } = ce5(), { kDestroyed: Ub2, isDestroyed: Nb2, isFinished: qb2, isServerRequest: Db2 } = tt4(), Hf2 = $f2("kDestroy"), Us2 = $f2("kConstruct");
        function Vf2(t4, e4, r4) {
          t4 && (t4.stack, e4 && !e4.errored && (e4.errored = t4), r4 && !r4.errored && (r4.errored = t4));
        }
        function jb2(t4, e4) {
          let r4 = this._readableState, i5 = this._writableState, n4 = i5 || r4;
          return i5 != null && i5.destroyed || r4 != null && r4.destroyed ? (typeof e4 == "function" && e4(), this) : (Vf2(t4, i5, r4), i5 && (i5.destroyed = true), r4 && (r4.destroyed = true), n4.constructed ? Ff2(this, t4, e4) : this.once(Hf2, function(o4) {
            Ff2(this, xb2(o4, t4), e4);
          }), this);
        }
        function Ff2(t4, e4, r4) {
          let i5 = false;
          function n4(o4) {
            if (i5)
              return;
            i5 = true;
            let s4 = t4._readableState, a4 = t4._writableState;
            Vf2(o4, a4, s4), a4 && (a4.closed = true), s4 && (s4.closed = true), typeof r4 == "function" && r4(o4), o4 ? rt3.nextTick(Fb2, t4, o4) : rt3.nextTick(zf2, t4);
          }
          try {
            t4._destroy(e4 || null, n4);
          } catch (o4) {
            n4(o4);
          }
        }
        function Fb2(t4, e4) {
          Ns3(t4, e4), zf2(t4);
        }
        function zf2(t4) {
          let e4 = t4._readableState, r4 = t4._writableState;
          r4 && (r4.closeEmitted = true), e4 && (e4.closeEmitted = true), (r4 != null && r4.emitClose || e4 != null && e4.emitClose) && t4.emit("close");
        }
        function Ns3(t4, e4) {
          let r4 = t4._readableState, i5 = t4._writableState;
          i5 != null && i5.errorEmitted || r4 != null && r4.errorEmitted || (i5 && (i5.errorEmitted = true), r4 && (r4.errorEmitted = true), t4.emit("error", e4));
        }
        function Wb2() {
          let t4 = this._readableState, e4 = this._writableState;
          t4 && (t4.constructed = true, t4.closed = false, t4.closeEmitted = false, t4.destroyed = false, t4.errored = null, t4.errorEmitted = false, t4.reading = false, t4.ended = t4.readable === false, t4.endEmitted = t4.readable === false), e4 && (e4.constructed = true, e4.destroyed = false, e4.closed = false, e4.closeEmitted = false, e4.errored = null, e4.errorEmitted = false, e4.finalCalled = false, e4.prefinished = false, e4.ended = e4.writable === false, e4.ending = e4.writable === false, e4.finished = e4.writable === false);
        }
        function qs3(t4, e4, r4) {
          let i5 = t4._readableState, n4 = t4._writableState;
          if (n4 != null && n4.destroyed || i5 != null && i5.destroyed)
            return this;
          i5 != null && i5.autoDestroy || n4 != null && n4.autoDestroy ? t4.destroy(e4) : e4 && (e4.stack, n4 && !n4.errored && (n4.errored = e4), i5 && !i5.errored && (i5.errored = e4), r4 ? rt3.nextTick(Ns3, t4, e4) : Ns3(t4, e4));
        }
        function $b2(t4, e4) {
          if (typeof t4._construct != "function")
            return;
          let r4 = t4._readableState, i5 = t4._writableState;
          r4 && (r4.constructed = false), i5 && (i5.constructed = false), t4.once(Us2, e4), !(t4.listenerCount(Us2) > 1) && rt3.nextTick(Hb2, t4);
        }
        function Hb2(t4) {
          let e4 = false;
          function r4(i5) {
            if (e4) {
              qs3(t4, i5 ?? new Mb2());
              return;
            }
            e4 = true;
            let n4 = t4._readableState, o4 = t4._writableState, s4 = o4 || n4;
            n4 && (n4.constructed = true), o4 && (o4.constructed = true), s4.destroyed ? t4.emit(Hf2, i5) : i5 ? qs3(t4, i5, true) : rt3.nextTick(Vb2, t4);
          }
          try {
            t4._construct((i5) => {
              rt3.nextTick(r4, i5);
            });
          } catch (i5) {
            rt3.nextTick(r4, i5);
          }
        }
        function Vb2(t4) {
          t4.emit(Us2);
        }
        function Wf2(t4) {
          return t4?.setHeader && typeof t4.abort == "function";
        }
        function Kf2(t4) {
          t4.emit("close");
        }
        function zb2(t4, e4) {
          t4.emit("error", e4), rt3.nextTick(Kf2, t4);
        }
        function Kb2(t4, e4) {
          !t4 || Nb2(t4) || (!e4 && !qb2(t4) && (e4 = new Lb2()), Db2(t4) ? (t4.socket = null, t4.destroy(e4)) : Wf2(t4) ? t4.abort() : Wf2(t4.req) ? t4.req.abort() : typeof t4.destroy == "function" ? t4.destroy(e4) : typeof t4.close == "function" ? t4.close() : e4 ? rt3.nextTick(zb2, t4, e4) : rt3.nextTick(Kf2, t4), t4.destroyed || (t4[Ub2] = true));
        }
        Gf2.exports = { construct: $b2, destroyer: Kb2, destroy: jb2, undestroy: Wb2, errorOrDestroy: qs3 };
      });
      Ds3 = we4(() => {
        v3();
        m3();
        _3();
        Ur4 = typeof Reflect == "object" ? Reflect : null, Qf2 = Ur4 && typeof Ur4.apply == "function" ? Ur4.apply : function(t4, e4, r4) {
          return Function.prototype.apply.call(t4, e4, r4);
        };
        ic2 = Ur4 && typeof Ur4.ownKeys == "function" ? Ur4.ownKeys : Object.getOwnPropertySymbols ? function(t4) {
          return Object.getOwnPropertyNames(t4).concat(Object.getOwnPropertySymbols(t4));
        } : function(t4) {
          return Object.getOwnPropertyNames(t4);
        };
        Yf2 = Number.isNaN || function(t4) {
          return t4 != t4;
        };
        rc2 = Y3, Y3.EventEmitter = Y3, Y3.prototype._events = void 0, Y3.prototype._eventsCount = 0, Y3.prototype._maxListeners = void 0;
        Jf2 = 10;
        Object.defineProperty(Y3, "defaultMaxListeners", { enumerable: true, get: function() {
          return Jf2;
        }, set: function(t4) {
          if (typeof t4 != "number" || t4 < 0 || Yf2(t4))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t4 + ".");
          Jf2 = t4;
        } }), Y3.init = function() {
          this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, Y3.prototype.setMaxListeners = function(t4) {
          if (typeof t4 != "number" || t4 < 0 || Yf2(t4))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t4 + ".");
          return this._maxListeners = t4, this;
        }, Y3.prototype.getMaxListeners = function() {
          return nc2(this);
        }, Y3.prototype.emit = function(t4) {
          for (var e4 = [], r4 = 1; r4 < arguments.length; r4++)
            e4.push(arguments[r4]);
          var i5 = t4 === "error", n4 = this._events;
          if (n4 !== void 0)
            i5 = i5 && n4.error === void 0;
          else if (!i5)
            return false;
          if (i5) {
            var o4;
            if (e4.length > 0 && (o4 = e4[0]), o4 instanceof Error)
              throw o4;
            var s4 = new Error("Unhandled error." + (o4 ? " (" + o4.message + ")" : ""));
            throw s4.context = o4, s4;
          }
          var a4 = n4[t4];
          if (a4 === void 0)
            return false;
          if (typeof a4 == "function")
            Qf2(a4, this, e4);
          else {
            var u4 = a4.length, c5 = sc2(a4, u4);
            for (r4 = 0; r4 < u4; ++r4)
              Qf2(c5[r4], this, e4);
          }
          return true;
        }, Y3.prototype.addListener = function(t4, e4) {
          return Xf2(this, t4, e4, false);
        }, Y3.prototype.on = Y3.prototype.addListener, Y3.prototype.prependListener = function(t4, e4) {
          return Xf2(this, t4, e4, true);
        }, Y3.prototype.once = function(t4, e4) {
          return Xi3(e4), this.on(t4, Zf2(this, t4, e4)), this;
        }, Y3.prototype.prependOnceListener = function(t4, e4) {
          return Xi3(e4), this.prependListener(t4, Zf2(this, t4, e4)), this;
        }, Y3.prototype.removeListener = function(t4, e4) {
          var r4, i5, n4, o4, s4;
          if (Xi3(e4), (i5 = this._events) === void 0)
            return this;
          if ((r4 = i5[t4]) === void 0)
            return this;
          if (r4 === e4 || r4.listener === e4)
            --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i5[t4], i5.removeListener && this.emit("removeListener", t4, r4.listener || e4));
          else if (typeof r4 != "function") {
            for (n4 = -1, o4 = r4.length - 1; o4 >= 0; o4--)
              if (r4[o4] === e4 || r4[o4].listener === e4) {
                s4 = r4[o4].listener, n4 = o4;
                break;
              }
            if (n4 < 0)
              return this;
            n4 === 0 ? r4.shift() : function(a4, u4) {
              for (; u4 + 1 < a4.length; u4++)
                a4[u4] = a4[u4 + 1];
              a4.pop();
            }(r4, n4), r4.length === 1 && (i5[t4] = r4[0]), i5.removeListener !== void 0 && this.emit("removeListener", t4, s4 || e4);
          }
          return this;
        }, Y3.prototype.off = Y3.prototype.removeListener, Y3.prototype.removeAllListeners = function(t4) {
          var e4, r4, i5;
          if ((r4 = this._events) === void 0)
            return this;
          if (r4.removeListener === void 0)
            return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r4[t4] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r4[t4]), this;
          if (arguments.length === 0) {
            var n4, o4 = Object.keys(r4);
            for (i5 = 0; i5 < o4.length; ++i5)
              (n4 = o4[i5]) !== "removeListener" && this.removeAllListeners(n4);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (typeof (e4 = r4[t4]) == "function")
            this.removeListener(t4, e4);
          else if (e4 !== void 0)
            for (i5 = e4.length - 1; i5 >= 0; i5--)
              this.removeListener(t4, e4[i5]);
          return this;
        }, Y3.prototype.listeners = function(t4) {
          return ec2(this, t4, true);
        }, Y3.prototype.rawListeners = function(t4) {
          return ec2(this, t4, false);
        }, Y3.listenerCount = function(t4, e4) {
          return typeof t4.listenerCount == "function" ? t4.listenerCount(e4) : tc2.call(t4, e4);
        }, Y3.prototype.listenerCount = tc2, Y3.prototype.eventNames = function() {
          return this._eventsCount > 0 ? ic2(this._events) : [];
        };
        Be4 = rc2;
        Be4.EventEmitter;
        Be4.defaultMaxListeners;
        Be4.init;
        Be4.listenerCount;
        Be4.EventEmitter;
        Be4.defaultMaxListeners;
        Be4.init;
        Be4.listenerCount;
      });
      rr3 = {};
      Qt3(rr3, { EventEmitter: () => Qb2, default: () => Be4, defaultMaxListeners: () => Yb2, init: () => Jb2, listenerCount: () => Xb2, on: () => Zb2, once: () => ew });
      ir3 = we4(() => {
        v3();
        m3();
        _3();
        Ds3();
        Ds3();
        Be4.once = function(t4, e4) {
          return new Promise((r4, i5) => {
            function n4(...s4) {
              o4 !== void 0 && t4.removeListener("error", o4), r4(s4);
            }
            let o4;
            e4 !== "error" && (o4 = (s4) => {
              t4.removeListener(name, n4), i5(s4);
            }, t4.once("error", o4)), t4.once(e4, n4);
          });
        };
        Be4.on = function(t4, e4) {
          let r4 = [], i5 = [], n4 = null, o4 = false, s4 = { async next() {
            let c5 = r4.shift();
            if (c5)
              return createIterResult(c5, false);
            if (n4) {
              let h4 = Promise.reject(n4);
              return n4 = null, h4;
            }
            return o4 ? createIterResult(void 0, true) : new Promise((h4, d4) => i5.push({ resolve: h4, reject: d4 }));
          }, async return() {
            t4.removeListener(e4, a4), t4.removeListener("error", u4), o4 = true;
            for (let c5 of i5)
              c5.resolve(createIterResult(void 0, true));
            return createIterResult(void 0, true);
          }, throw(c5) {
            n4 = c5, t4.removeListener(e4, a4), t4.removeListener("error", u4);
          }, [Symbol.asyncIterator]() {
            return this;
          } };
          return t4.on(e4, a4), t4.on("error", u4), s4;
          function a4(...c5) {
            let h4 = i5.shift();
            h4 ? h4.resolve(createIterResult(c5, false)) : r4.push(c5);
          }
          function u4(c5) {
            o4 = true;
            let h4 = i5.shift();
            h4 ? h4.reject(c5) : n4 = c5, s4.return();
          }
        };
        ({ EventEmitter: Qb2, defaultMaxListeners: Yb2, init: Jb2, listenerCount: Xb2, on: Zb2, once: ew } = Be4);
      });
      tn4 = M3((LT, ac2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { ArrayIsArray: tw, ObjectSetPrototypeOf: oc2 } = ce5(), { EventEmitter: Zi3 } = (ir3(), X3(rr3));
        function en3(t4) {
          Zi3.call(this, t4);
        }
        oc2(en3.prototype, Zi3.prototype);
        oc2(en3, Zi3);
        en3.prototype.pipe = function(t4, e4) {
          let r4 = this;
          function i5(h4) {
            t4.writable && t4.write(h4) === false && r4.pause && r4.pause();
          }
          r4.on("data", i5);
          function n4() {
            r4.readable && r4.resume && r4.resume();
          }
          t4.on("drain", n4), !t4._isStdio && (!e4 || e4.end !== false) && (r4.on("end", s4), r4.on("close", a4));
          let o4 = false;
          function s4() {
            o4 || (o4 = true, t4.end());
          }
          function a4() {
            o4 || (o4 = true, typeof t4.destroy == "function" && t4.destroy());
          }
          function u4(h4) {
            c5(), Zi3.listenerCount(this, "error") === 0 && this.emit("error", h4);
          }
          js2(r4, "error", u4), js2(t4, "error", u4);
          function c5() {
            r4.removeListener("data", i5), t4.removeListener("drain", n4), r4.removeListener("end", s4), r4.removeListener("close", a4), r4.removeListener("error", u4), t4.removeListener("error", u4), r4.removeListener("end", c5), r4.removeListener("close", c5), t4.removeListener("close", c5);
          }
          return r4.on("end", c5), r4.on("close", c5), t4.on("close", c5), t4.emit("pipe", r4), t4;
        };
        function js2(t4, e4, r4) {
          if (typeof t4.prependListener == "function")
            return t4.prependListener(e4, r4);
          !t4._events || !t4._events[e4] ? t4.on(e4, r4) : tw(t4._events[e4]) ? t4._events[e4].unshift(r4) : t4._events[e4] = [r4, t4._events[e4]];
        }
        ac2.exports = { Stream: en3, prependListener: js2 };
      });
      ci2 = M3((VT, rn4) => {
        "use strict";
        v3();
        m3();
        _3();
        var { AbortError: lc2, codes: rw } = Se4(), { isNodeStream: uc2, isWebStream: iw, kControllerErrorFunction: nw } = tt4(), sw = vt3(), { ERR_INVALID_ARG_TYPE: fc2 } = rw, ow = (t4, e4) => {
          if (typeof t4 != "object" || !("aborted" in t4))
            throw new fc2(e4, "AbortSignal", t4);
        };
        rn4.exports.addAbortSignal = function(e4, r4) {
          if (ow(e4, "signal"), !uc2(r4) && !iw(r4))
            throw new fc2("stream", ["ReadableStream", "WritableStream", "Stream"], r4);
          return rn4.exports.addAbortSignalNoValidate(e4, r4);
        };
        rn4.exports.addAbortSignalNoValidate = function(t4, e4) {
          if (typeof t4 != "object" || !("aborted" in t4))
            return e4;
          let r4 = uc2(e4) ? () => {
            e4.destroy(new lc2(void 0, { cause: t4.reason }));
          } : () => {
            e4[nw](new lc2(void 0, { cause: t4.reason }));
          };
          return t4.aborted ? r4() : (t4.addEventListener("abort", r4), sw(e4, () => t4.removeEventListener("abort", r4))), e4;
        };
      });
      dc2 = M3((r22, hc2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { StringPrototypeSlice: cc2, SymbolIterator: aw, TypedArrayPrototypeSet: nn4, Uint8Array: lw } = ce5(), { Buffer: Fs3 } = (ye5(), X3(_e5)), { inspect: uw } = Je4();
        hc2.exports = class {
          constructor() {
            this.head = null, this.tail = null, this.length = 0;
          }
          push(e4) {
            let r4 = { data: e4, next: null };
            this.length > 0 ? this.tail.next = r4 : this.head = r4, this.tail = r4, ++this.length;
          }
          unshift(e4) {
            let r4 = { data: e4, next: this.head };
            this.length === 0 && (this.tail = r4), this.head = r4, ++this.length;
          }
          shift() {
            if (this.length === 0)
              return;
            let e4 = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e4;
          }
          clear() {
            this.head = this.tail = null, this.length = 0;
          }
          join(e4) {
            if (this.length === 0)
              return "";
            let r4 = this.head, i5 = "" + r4.data;
            for (; (r4 = r4.next) !== null; )
              i5 += e4 + r4.data;
            return i5;
          }
          concat(e4) {
            if (this.length === 0)
              return Fs3.alloc(0);
            let r4 = Fs3.allocUnsafe(e4 >>> 0), i5 = this.head, n4 = 0;
            for (; i5; )
              nn4(r4, i5.data, n4), n4 += i5.data.length, i5 = i5.next;
            return r4;
          }
          consume(e4, r4) {
            let i5 = this.head.data;
            if (e4 < i5.length) {
              let n4 = i5.slice(0, e4);
              return this.head.data = i5.slice(e4), n4;
            }
            return e4 === i5.length ? this.shift() : r4 ? this._getString(e4) : this._getBuffer(e4);
          }
          first() {
            return this.head.data;
          }
          *[aw]() {
            for (let e4 = this.head; e4; e4 = e4.next)
              yield e4.data;
          }
          _getString(e4) {
            let r4 = "", i5 = this.head, n4 = 0;
            do {
              let o4 = i5.data;
              if (e4 > o4.length)
                r4 += o4, e4 -= o4.length;
              else {
                e4 === o4.length ? (r4 += o4, ++n4, i5.next ? this.head = i5.next : this.head = this.tail = null) : (r4 += cc2(o4, 0, e4), this.head = i5, i5.data = cc2(o4, e4));
                break;
              }
              ++n4;
            } while ((i5 = i5.next) !== null);
            return this.length -= n4, r4;
          }
          _getBuffer(e4) {
            let r4 = Fs3.allocUnsafe(e4), i5 = e4, n4 = this.head, o4 = 0;
            do {
              let s4 = n4.data;
              if (e4 > s4.length)
                nn4(r4, s4, i5 - e4), e4 -= s4.length;
              else {
                e4 === s4.length ? (nn4(r4, s4, i5 - e4), ++o4, n4.next ? this.head = n4.next : this.head = this.tail = null) : (nn4(r4, new lw(s4.buffer, s4.byteOffset, e4), i5 - e4), this.head = n4, n4.data = s4.slice(e4));
                break;
              }
              ++o4;
            } while ((n4 = n4.next) !== null);
            return this.length -= o4, r4;
          }
          [Symbol.for("nodejs.util.inspect.custom")](e4, r4) {
            return uw(this, { ...r4, depth: 0, customInspect: false });
          }
        };
      });
      sn3 = M3((h22, gc2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { MathFloor: fw, NumberIsInteger: cw } = ce5(), { ERR_INVALID_ARG_VALUE: hw } = Se4().codes;
        function dw(t4, e4, r4) {
          return t4.highWaterMark != null ? t4.highWaterMark : e4 ? t4[r4] : null;
        }
        function pc2(t4) {
          return t4 ? 16 : 16 * 1024;
        }
        function pw(t4, e4, r4, i5) {
          let n4 = dw(e4, i5, r4);
          if (n4 != null) {
            if (!cw(n4) || n4 < 0) {
              let o4 = i5 ? `options.${r4}` : "options.highWaterMark";
              throw new hw(o4, n4);
            }
            return fw(n4);
          }
          return pc2(t4.objectMode);
        }
        gc2.exports = { getHighWaterMark: pw, getDefaultHighWaterMark: pc2 };
      });
      Ys2 = we4(() => {
        v3();
        m3();
        _3();
        for (Rc2 = { byteLength: function(t4) {
          var e4 = wc2(t4), r4 = e4[0], i5 = e4[1];
          return 3 * (r4 + i5) / 4 - i5;
        }, toByteArray: function(t4) {
          var e4, r4, i5 = wc2(t4), n4 = i5[0], o4 = i5[1], s4 = new yc2(function(c5, h4, d4) {
            return 3 * (h4 + d4) / 4 - d4;
          }(0, n4, o4)), a4 = 0, u4 = o4 > 0 ? n4 - 4 : n4;
          for (r4 = 0; r4 < u4; r4 += 4)
            e4 = ke4[t4.charCodeAt(r4)] << 18 | ke4[t4.charCodeAt(r4 + 1)] << 12 | ke4[t4.charCodeAt(r4 + 2)] << 6 | ke4[t4.charCodeAt(r4 + 3)], s4[a4++] = e4 >> 16 & 255, s4[a4++] = e4 >> 8 & 255, s4[a4++] = 255 & e4;
          return o4 === 2 && (e4 = ke4[t4.charCodeAt(r4)] << 2 | ke4[t4.charCodeAt(r4 + 1)] >> 4, s4[a4++] = 255 & e4), o4 === 1 && (e4 = ke4[t4.charCodeAt(r4)] << 10 | ke4[t4.charCodeAt(r4 + 1)] << 4 | ke4[t4.charCodeAt(r4 + 2)] >> 2, s4[a4++] = e4 >> 8 & 255, s4[a4++] = 255 & e4), s4;
        }, fromByteArray: function(t4) {
          for (var e4, r4 = t4.length, i5 = r4 % 3, n4 = [], o4 = 0, s4 = r4 - i5; o4 < s4; o4 += 16383)
            n4.push(gw(t4, o4, o4 + 16383 > s4 ? s4 : o4 + 16383));
          return i5 === 1 ? (e4 = t4[r4 - 1], n4.push($e3[e4 >> 2] + $e3[e4 << 4 & 63] + "==")) : i5 === 2 && (e4 = (t4[r4 - 2] << 8) + t4[r4 - 1], n4.push($e3[e4 >> 10] + $e3[e4 >> 4 & 63] + $e3[e4 << 2 & 63] + "=")), n4.join("");
        } }, $e3 = [], ke4 = [], yc2 = typeof Uint8Array < "u" ? Uint8Array : Array, on3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", nr3 = 0, bc2 = on3.length; nr3 < bc2; ++nr3)
          $e3[nr3] = on3[nr3], ke4[on3.charCodeAt(nr3)] = nr3;
        ke4["-".charCodeAt(0)] = 62, ke4["_".charCodeAt(0)] = 63;
        yw = { read: function(t4, e4, r4, i5, n4) {
          var o4, s4, a4 = 8 * n4 - i5 - 1, u4 = (1 << a4) - 1, c5 = u4 >> 1, h4 = -7, d4 = r4 ? n4 - 1 : 0, g4 = r4 ? -1 : 1, y3 = t4[e4 + d4];
          for (d4 += g4, o4 = y3 & (1 << -h4) - 1, y3 >>= -h4, h4 += a4; h4 > 0; o4 = 256 * o4 + t4[e4 + d4], d4 += g4, h4 -= 8)
            ;
          for (s4 = o4 & (1 << -h4) - 1, o4 >>= -h4, h4 += i5; h4 > 0; s4 = 256 * s4 + t4[e4 + d4], d4 += g4, h4 -= 8)
            ;
          if (o4 === 0)
            o4 = 1 - c5;
          else {
            if (o4 === u4)
              return s4 ? NaN : 1 / 0 * (y3 ? -1 : 1);
            s4 += Math.pow(2, i5), o4 -= c5;
          }
          return (y3 ? -1 : 1) * s4 * Math.pow(2, o4 - i5);
        }, write: function(t4, e4, r4, i5, n4, o4) {
          var s4, a4, u4, c5 = 8 * o4 - n4 - 1, h4 = (1 << c5) - 1, d4 = h4 >> 1, g4 = n4 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y3 = i5 ? 0 : o4 - 1, w3 = i5 ? 1 : -1, E4 = e4 < 0 || e4 === 0 && 1 / e4 < 0 ? 1 : 0;
          for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (a4 = isNaN(e4) ? 1 : 0, s4 = h4) : (s4 = Math.floor(Math.log(e4) / Math.LN2), e4 * (u4 = Math.pow(2, -s4)) < 1 && (s4--, u4 *= 2), (e4 += s4 + d4 >= 1 ? g4 / u4 : g4 * Math.pow(2, 1 - d4)) * u4 >= 2 && (s4++, u4 /= 2), s4 + d4 >= h4 ? (a4 = 0, s4 = h4) : s4 + d4 >= 1 ? (a4 = (e4 * u4 - 1) * Math.pow(2, n4), s4 += d4) : (a4 = e4 * Math.pow(2, d4 - 1) * Math.pow(2, n4), s4 = 0)); n4 >= 8; t4[r4 + y3] = 255 & a4, y3 += w3, a4 /= 256, n4 -= 8)
            ;
          for (s4 = s4 << n4 | a4, c5 += n4; c5 > 0; t4[r4 + y3] = 255 & s4, y3 += w3, s4 /= 256, c5 -= 8)
            ;
          t4[r4 + y3 - w3] |= 128 * E4;
        } }, At3 = {}, Hs2 = Rc2, Nr4 = yw, _c2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        At3.Buffer = k3, At3.SlowBuffer = function(t4) {
          return +t4 != t4 && (t4 = 0), k3.alloc(+t4);
        }, At3.INSPECT_MAX_BYTES = 50;
        At3.kMaxLength = 2147483647, k3.TYPED_ARRAY_SUPPORT = function() {
          try {
            var t4 = new Uint8Array(1), e4 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(e4, Uint8Array.prototype), Object.setPrototypeOf(t4, e4), t4.foo() === 42;
          } catch {
            return false;
          }
        }(), k3.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(k3.prototype, "parent", { enumerable: true, get: function() {
          if (k3.isBuffer(this))
            return this.buffer;
        } }), Object.defineProperty(k3.prototype, "offset", { enumerable: true, get: function() {
          if (k3.isBuffer(this))
            return this.byteOffset;
        } }), k3.poolSize = 8192, k3.from = function(t4, e4, r4) {
          return Cc2(t4, e4, r4);
        }, Object.setPrototypeOf(k3.prototype, Uint8Array.prototype), Object.setPrototypeOf(k3, Uint8Array), k3.alloc = function(t4, e4, r4) {
          return function(i5, n4, o4) {
            return Bc2(i5), i5 <= 0 ? Et3(i5) : n4 !== void 0 ? typeof o4 == "string" ? Et3(i5).fill(n4, o4) : Et3(i5).fill(n4) : Et3(i5);
          }(t4, e4, r4);
        }, k3.allocUnsafe = function(t4) {
          return Vs2(t4);
        }, k3.allocUnsafeSlow = function(t4) {
          return Vs2(t4);
        }, k3.isBuffer = function(t4) {
          return t4 != null && t4._isBuffer === true && t4 !== k3.prototype;
        }, k3.compare = function(t4, e4) {
          if (St3(t4, Uint8Array) && (t4 = k3.from(t4, t4.offset, t4.byteLength)), St3(e4, Uint8Array) && (e4 = k3.from(e4, e4.offset, e4.byteLength)), !k3.isBuffer(t4) || !k3.isBuffer(e4))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (t4 === e4)
            return 0;
          for (var r4 = t4.length, i5 = e4.length, n4 = 0, o4 = Math.min(r4, i5); n4 < o4; ++n4)
            if (t4[n4] !== e4[n4]) {
              r4 = t4[n4], i5 = e4[n4];
              break;
            }
          return r4 < i5 ? -1 : i5 < r4 ? 1 : 0;
        }, k3.isEncoding = function(t4) {
          switch (String(t4).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, k3.concat = function(t4, e4) {
          if (!Array.isArray(t4))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (t4.length === 0)
            return k3.alloc(0);
          var r4;
          if (e4 === void 0)
            for (e4 = 0, r4 = 0; r4 < t4.length; ++r4)
              e4 += t4[r4].length;
          var i5 = k3.allocUnsafe(e4), n4 = 0;
          for (r4 = 0; r4 < t4.length; ++r4) {
            var o4 = t4[r4];
            if (St3(o4, Uint8Array) && (o4 = k3.from(o4)), !k3.isBuffer(o4))
              throw new TypeError('"list" argument must be an Array of Buffers');
            o4.copy(i5, n4), n4 += o4.length;
          }
          return i5;
        }, k3.byteLength = Pc2, k3.prototype._isBuffer = true, k3.prototype.swap16 = function() {
          var t4 = this.length;
          if (t4 % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var e4 = 0; e4 < t4; e4 += 2)
            sr4(this, e4, e4 + 1);
          return this;
        }, k3.prototype.swap32 = function() {
          var t4 = this.length;
          if (t4 % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var e4 = 0; e4 < t4; e4 += 4)
            sr4(this, e4, e4 + 3), sr4(this, e4 + 1, e4 + 2);
          return this;
        }, k3.prototype.swap64 = function() {
          var t4 = this.length;
          if (t4 % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var e4 = 0; e4 < t4; e4 += 8)
            sr4(this, e4, e4 + 7), sr4(this, e4 + 1, e4 + 6), sr4(this, e4 + 2, e4 + 5), sr4(this, e4 + 3, e4 + 4);
          return this;
        }, k3.prototype.toString = function() {
          var t4 = this.length;
          return t4 === 0 ? "" : arguments.length === 0 ? kc2(this, 0, t4) : bw.apply(this, arguments);
        }, k3.prototype.toLocaleString = k3.prototype.toString, k3.prototype.equals = function(t4) {
          if (!k3.isBuffer(t4))
            throw new TypeError("Argument must be a Buffer");
          return this === t4 || k3.compare(this, t4) === 0;
        }, k3.prototype.inspect = function() {
          var t4 = "", e4 = At3.INSPECT_MAX_BYTES;
          return t4 = this.toString("hex", 0, e4).replace(/(.{2})/g, "$1 ").trim(), this.length > e4 && (t4 += " ... "), "<Buffer " + t4 + ">";
        }, _c2 && (k3.prototype[_c2] = k3.prototype.inspect), k3.prototype.compare = function(t4, e4, r4, i5, n4) {
          if (St3(t4, Uint8Array) && (t4 = k3.from(t4, t4.offset, t4.byteLength)), !k3.isBuffer(t4))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t4);
          if (e4 === void 0 && (e4 = 0), r4 === void 0 && (r4 = t4 ? t4.length : 0), i5 === void 0 && (i5 = 0), n4 === void 0 && (n4 = this.length), e4 < 0 || r4 > t4.length || i5 < 0 || n4 > this.length)
            throw new RangeError("out of range index");
          if (i5 >= n4 && e4 >= r4)
            return 0;
          if (i5 >= n4)
            return -1;
          if (e4 >= r4)
            return 1;
          if (this === t4)
            return 0;
          for (var o4 = (n4 >>>= 0) - (i5 >>>= 0), s4 = (r4 >>>= 0) - (e4 >>>= 0), a4 = Math.min(o4, s4), u4 = this.slice(i5, n4), c5 = t4.slice(e4, r4), h4 = 0; h4 < a4; ++h4)
            if (u4[h4] !== c5[h4]) {
              o4 = u4[h4], s4 = c5[h4];
              break;
            }
          return o4 < s4 ? -1 : s4 < o4 ? 1 : 0;
        }, k3.prototype.includes = function(t4, e4, r4) {
          return this.indexOf(t4, e4, r4) !== -1;
        }, k3.prototype.indexOf = function(t4, e4, r4) {
          return vc2(this, t4, e4, r4, true);
        }, k3.prototype.lastIndexOf = function(t4, e4, r4) {
          return vc2(this, t4, e4, r4, false);
        }, k3.prototype.write = function(t4, e4, r4, i5) {
          if (e4 === void 0)
            i5 = "utf8", r4 = this.length, e4 = 0;
          else if (r4 === void 0 && typeof e4 == "string")
            i5 = e4, r4 = this.length, e4 = 0;
          else {
            if (!isFinite(e4))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e4 >>>= 0, isFinite(r4) ? (r4 >>>= 0, i5 === void 0 && (i5 = "utf8")) : (i5 = r4, r4 = void 0);
          }
          var n4 = this.length - e4;
          if ((r4 === void 0 || r4 > n4) && (r4 = n4), t4.length > 0 && (r4 < 0 || e4 < 0) || e4 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          i5 || (i5 = "utf8");
          for (var o4 = false; ; )
            switch (i5) {
              case "hex":
                return ww(this, t4, e4, r4);
              case "utf8":
              case "utf-8":
                return _w(this, t4, e4, r4);
              case "ascii":
                return Oc2(this, t4, e4, r4);
              case "latin1":
              case "binary":
                return mw(this, t4, e4, r4);
              case "base64":
                return vw(this, t4, e4, r4);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return Ew(this, t4, e4, r4);
              default:
                if (o4)
                  throw new TypeError("Unknown encoding: " + i5);
                i5 = ("" + i5).toLowerCase(), o4 = true;
            }
        }, k3.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        k3.prototype.slice = function(t4, e4) {
          var r4 = this.length;
          (t4 = ~~t4) < 0 ? (t4 += r4) < 0 && (t4 = 0) : t4 > r4 && (t4 = r4), (e4 = e4 === void 0 ? r4 : ~~e4) < 0 ? (e4 += r4) < 0 && (e4 = 0) : e4 > r4 && (e4 = r4), e4 < t4 && (e4 = t4);
          var i5 = this.subarray(t4, e4);
          return Object.setPrototypeOf(i5, k3.prototype), i5;
        }, k3.prototype.readUIntLE = function(t4, e4, r4) {
          t4 >>>= 0, e4 >>>= 0, r4 || be4(t4, e4, this.length);
          for (var i5 = this[t4], n4 = 1, o4 = 0; ++o4 < e4 && (n4 *= 256); )
            i5 += this[t4 + o4] * n4;
          return i5;
        }, k3.prototype.readUIntBE = function(t4, e4, r4) {
          t4 >>>= 0, e4 >>>= 0, r4 || be4(t4, e4, this.length);
          for (var i5 = this[t4 + --e4], n4 = 1; e4 > 0 && (n4 *= 256); )
            i5 += this[t4 + --e4] * n4;
          return i5;
        }, k3.prototype.readUInt8 = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 1, this.length), this[t4];
        }, k3.prototype.readUInt16LE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 2, this.length), this[t4] | this[t4 + 1] << 8;
        }, k3.prototype.readUInt16BE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 2, this.length), this[t4] << 8 | this[t4 + 1];
        }, k3.prototype.readUInt32LE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 4, this.length), (this[t4] | this[t4 + 1] << 8 | this[t4 + 2] << 16) + 16777216 * this[t4 + 3];
        }, k3.prototype.readUInt32BE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 4, this.length), 16777216 * this[t4] + (this[t4 + 1] << 16 | this[t4 + 2] << 8 | this[t4 + 3]);
        }, k3.prototype.readIntLE = function(t4, e4, r4) {
          t4 >>>= 0, e4 >>>= 0, r4 || be4(t4, e4, this.length);
          for (var i5 = this[t4], n4 = 1, o4 = 0; ++o4 < e4 && (n4 *= 256); )
            i5 += this[t4 + o4] * n4;
          return i5 >= (n4 *= 128) && (i5 -= Math.pow(2, 8 * e4)), i5;
        }, k3.prototype.readIntBE = function(t4, e4, r4) {
          t4 >>>= 0, e4 >>>= 0, r4 || be4(t4, e4, this.length);
          for (var i5 = e4, n4 = 1, o4 = this[t4 + --i5]; i5 > 0 && (n4 *= 256); )
            o4 += this[t4 + --i5] * n4;
          return o4 >= (n4 *= 128) && (o4 -= Math.pow(2, 8 * e4)), o4;
        }, k3.prototype.readInt8 = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 1, this.length), 128 & this[t4] ? -1 * (255 - this[t4] + 1) : this[t4];
        }, k3.prototype.readInt16LE = function(t4, e4) {
          t4 >>>= 0, e4 || be4(t4, 2, this.length);
          var r4 = this[t4] | this[t4 + 1] << 8;
          return 32768 & r4 ? 4294901760 | r4 : r4;
        }, k3.prototype.readInt16BE = function(t4, e4) {
          t4 >>>= 0, e4 || be4(t4, 2, this.length);
          var r4 = this[t4 + 1] | this[t4] << 8;
          return 32768 & r4 ? 4294901760 | r4 : r4;
        }, k3.prototype.readInt32LE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 4, this.length), this[t4] | this[t4 + 1] << 8 | this[t4 + 2] << 16 | this[t4 + 3] << 24;
        }, k3.prototype.readInt32BE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 4, this.length), this[t4] << 24 | this[t4 + 1] << 16 | this[t4 + 2] << 8 | this[t4 + 3];
        }, k3.prototype.readFloatLE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 4, this.length), Nr4.read(this, t4, true, 23, 4);
        }, k3.prototype.readFloatBE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 4, this.length), Nr4.read(this, t4, false, 23, 4);
        }, k3.prototype.readDoubleLE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 8, this.length), Nr4.read(this, t4, true, 52, 8);
        }, k3.prototype.readDoubleBE = function(t4, e4) {
          return t4 >>>= 0, e4 || be4(t4, 8, this.length), Nr4.read(this, t4, false, 52, 8);
        }, k3.prototype.writeUIntLE = function(t4, e4, r4, i5) {
          t4 = +t4, e4 >>>= 0, r4 >>>= 0, i5 || Pe3(this, t4, e4, r4, Math.pow(2, 8 * r4) - 1, 0);
          var n4 = 1, o4 = 0;
          for (this[e4] = 255 & t4; ++o4 < r4 && (n4 *= 256); )
            this[e4 + o4] = t4 / n4 & 255;
          return e4 + r4;
        }, k3.prototype.writeUIntBE = function(t4, e4, r4, i5) {
          t4 = +t4, e4 >>>= 0, r4 >>>= 0, i5 || Pe3(this, t4, e4, r4, Math.pow(2, 8 * r4) - 1, 0);
          var n4 = r4 - 1, o4 = 1;
          for (this[e4 + n4] = 255 & t4; --n4 >= 0 && (o4 *= 256); )
            this[e4 + n4] = t4 / o4 & 255;
          return e4 + r4;
        }, k3.prototype.writeUInt8 = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 1, 255, 0), this[e4] = 255 & t4, e4 + 1;
        }, k3.prototype.writeUInt16LE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 2, 65535, 0), this[e4] = 255 & t4, this[e4 + 1] = t4 >>> 8, e4 + 2;
        }, k3.prototype.writeUInt16BE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 2, 65535, 0), this[e4] = t4 >>> 8, this[e4 + 1] = 255 & t4, e4 + 2;
        }, k3.prototype.writeUInt32LE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 4, 4294967295, 0), this[e4 + 3] = t4 >>> 24, this[e4 + 2] = t4 >>> 16, this[e4 + 1] = t4 >>> 8, this[e4] = 255 & t4, e4 + 4;
        }, k3.prototype.writeUInt32BE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 4, 4294967295, 0), this[e4] = t4 >>> 24, this[e4 + 1] = t4 >>> 16, this[e4 + 2] = t4 >>> 8, this[e4 + 3] = 255 & t4, e4 + 4;
        }, k3.prototype.writeIntLE = function(t4, e4, r4, i5) {
          if (t4 = +t4, e4 >>>= 0, !i5) {
            var n4 = Math.pow(2, 8 * r4 - 1);
            Pe3(this, t4, e4, r4, n4 - 1, -n4);
          }
          var o4 = 0, s4 = 1, a4 = 0;
          for (this[e4] = 255 & t4; ++o4 < r4 && (s4 *= 256); )
            t4 < 0 && a4 === 0 && this[e4 + o4 - 1] !== 0 && (a4 = 1), this[e4 + o4] = (t4 / s4 >> 0) - a4 & 255;
          return e4 + r4;
        }, k3.prototype.writeIntBE = function(t4, e4, r4, i5) {
          if (t4 = +t4, e4 >>>= 0, !i5) {
            var n4 = Math.pow(2, 8 * r4 - 1);
            Pe3(this, t4, e4, r4, n4 - 1, -n4);
          }
          var o4 = r4 - 1, s4 = 1, a4 = 0;
          for (this[e4 + o4] = 255 & t4; --o4 >= 0 && (s4 *= 256); )
            t4 < 0 && a4 === 0 && this[e4 + o4 + 1] !== 0 && (a4 = 1), this[e4 + o4] = (t4 / s4 >> 0) - a4 & 255;
          return e4 + r4;
        }, k3.prototype.writeInt8 = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 1, 127, -128), t4 < 0 && (t4 = 255 + t4 + 1), this[e4] = 255 & t4, e4 + 1;
        }, k3.prototype.writeInt16LE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 2, 32767, -32768), this[e4] = 255 & t4, this[e4 + 1] = t4 >>> 8, e4 + 2;
        }, k3.prototype.writeInt16BE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 2, 32767, -32768), this[e4] = t4 >>> 8, this[e4 + 1] = 255 & t4, e4 + 2;
        }, k3.prototype.writeInt32LE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 4, 2147483647, -2147483648), this[e4] = 255 & t4, this[e4 + 1] = t4 >>> 8, this[e4 + 2] = t4 >>> 16, this[e4 + 3] = t4 >>> 24, e4 + 4;
        }, k3.prototype.writeInt32BE = function(t4, e4, r4) {
          return t4 = +t4, e4 >>>= 0, r4 || Pe3(this, t4, e4, 4, 2147483647, -2147483648), t4 < 0 && (t4 = 4294967295 + t4 + 1), this[e4] = t4 >>> 24, this[e4 + 1] = t4 >>> 16, this[e4 + 2] = t4 >>> 8, this[e4 + 3] = 255 & t4, e4 + 4;
        }, k3.prototype.writeFloatLE = function(t4, e4, r4) {
          return Sc2(this, t4, e4, true, r4);
        }, k3.prototype.writeFloatBE = function(t4, e4, r4) {
          return Sc2(this, t4, e4, false, r4);
        }, k3.prototype.writeDoubleLE = function(t4, e4, r4) {
          return Ac2(this, t4, e4, true, r4);
        }, k3.prototype.writeDoubleBE = function(t4, e4, r4) {
          return Ac2(this, t4, e4, false, r4);
        }, k3.prototype.copy = function(t4, e4, r4, i5) {
          if (!k3.isBuffer(t4))
            throw new TypeError("argument should be a Buffer");
          if (r4 || (r4 = 0), i5 || i5 === 0 || (i5 = this.length), e4 >= t4.length && (e4 = t4.length), e4 || (e4 = 0), i5 > 0 && i5 < r4 && (i5 = r4), i5 === r4 || t4.length === 0 || this.length === 0)
            return 0;
          if (e4 < 0)
            throw new RangeError("targetStart out of bounds");
          if (r4 < 0 || r4 >= this.length)
            throw new RangeError("Index out of range");
          if (i5 < 0)
            throw new RangeError("sourceEnd out of bounds");
          i5 > this.length && (i5 = this.length), t4.length - e4 < i5 - r4 && (i5 = t4.length - e4 + r4);
          var n4 = i5 - r4;
          if (this === t4 && typeof Uint8Array.prototype.copyWithin == "function")
            this.copyWithin(e4, r4, i5);
          else if (this === t4 && r4 < e4 && e4 < i5)
            for (var o4 = n4 - 1; o4 >= 0; --o4)
              t4[o4 + e4] = this[o4 + r4];
          else
            Uint8Array.prototype.set.call(t4, this.subarray(r4, i5), e4);
          return n4;
        }, k3.prototype.fill = function(t4, e4, r4, i5) {
          if (typeof t4 == "string") {
            if (typeof e4 == "string" ? (i5 = e4, e4 = 0, r4 = this.length) : typeof r4 == "string" && (i5 = r4, r4 = this.length), i5 !== void 0 && typeof i5 != "string")
              throw new TypeError("encoding must be a string");
            if (typeof i5 == "string" && !k3.isEncoding(i5))
              throw new TypeError("Unknown encoding: " + i5);
            if (t4.length === 1) {
              var n4 = t4.charCodeAt(0);
              (i5 === "utf8" && n4 < 128 || i5 === "latin1") && (t4 = n4);
            }
          } else
            typeof t4 == "number" ? t4 &= 255 : typeof t4 == "boolean" && (t4 = Number(t4));
          if (e4 < 0 || this.length < e4 || this.length < r4)
            throw new RangeError("Out of range index");
          if (r4 <= e4)
            return this;
          var o4;
          if (e4 >>>= 0, r4 = r4 === void 0 ? this.length : r4 >>> 0, t4 || (t4 = 0), typeof t4 == "number")
            for (o4 = e4; o4 < r4; ++o4)
              this[o4] = t4;
          else {
            var s4 = k3.isBuffer(t4) ? t4 : k3.from(t4, i5), a4 = s4.length;
            if (a4 === 0)
              throw new TypeError('The value "' + t4 + '" is invalid for argument "value"');
            for (o4 = 0; o4 < r4 - e4; ++o4)
              this[o4 + e4] = s4[o4 % a4];
          }
          return this;
        };
        Cw = /[^+/0-9A-Za-z-_]/g;
        Bw = function() {
          for (var t4 = new Array(256), e4 = 0; e4 < 16; ++e4)
            for (var r4 = 16 * e4, i5 = 0; i5 < 16; ++i5)
              t4[r4 + i5] = "0123456789abcdef"[e4] + "0123456789abcdef"[i5];
          return t4;
        }();
        At3.Buffer;
        At3.INSPECT_MAX_BYTES;
        At3.kMaxLength;
        an3 = {}, ln4 = At3, it4 = ln4.Buffer;
        it4.from && it4.alloc && it4.allocUnsafe && it4.allocUnsafeSlow ? an3 = ln4 : (Ic2(ln4, an3), an3.Buffer = or3), or3.prototype = Object.create(it4.prototype), Ic2(it4, or3), or3.from = function(t4, e4, r4) {
          if (typeof t4 == "number")
            throw new TypeError("Argument must not be a number");
          return it4(t4, e4, r4);
        }, or3.alloc = function(t4, e4, r4) {
          if (typeof t4 != "number")
            throw new TypeError("Argument must be a number");
          var i5 = it4(t4);
          return e4 !== void 0 ? typeof r4 == "string" ? i5.fill(e4, r4) : i5.fill(e4) : i5.fill(0), i5;
        }, or3.allocUnsafe = function(t4) {
          if (typeof t4 != "number")
            throw new TypeError("Argument must be a number");
          return it4(t4);
        }, or3.allocUnsafeSlow = function(t4) {
          if (typeof t4 != "number")
            throw new TypeError("Argument must be a number");
          return ln4.SlowBuffer(t4);
        };
        Pw = an3, ar3 = {}, Ks2 = Pw.Buffer, Tc2 = Ks2.isEncoding || function(t4) {
          switch ((t4 = "" + t4) && t4.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        ar3.StringDecoder = hi2, hi2.prototype.write = function(t4) {
          if (t4.length === 0)
            return "";
          var e4, r4;
          if (this.lastNeed) {
            if ((e4 = this.fillLast(t4)) === void 0)
              return "";
            r4 = this.lastNeed, this.lastNeed = 0;
          } else
            r4 = 0;
          return r4 < t4.length ? e4 ? e4 + this.text(t4, r4) : this.text(t4, r4) : e4 || "";
        }, hi2.prototype.end = function(t4) {
          var e4 = t4 && t4.length ? this.write(t4) : "";
          return this.lastNeed ? e4 + "\uFFFD" : e4;
        }, hi2.prototype.text = function(t4, e4) {
          var r4 = function(n4, o4, s4) {
            var a4 = o4.length - 1;
            if (a4 < s4)
              return 0;
            var u4 = $s3(o4[a4]);
            return u4 >= 0 ? (u4 > 0 && (n4.lastNeed = u4 - 1), u4) : --a4 < s4 || u4 === -2 ? 0 : (u4 = $s3(o4[a4])) >= 0 ? (u4 > 0 && (n4.lastNeed = u4 - 2), u4) : --a4 < s4 || u4 === -2 ? 0 : (u4 = $s3(o4[a4])) >= 0 ? (u4 > 0 && (u4 === 2 ? u4 = 0 : n4.lastNeed = u4 - 3), u4) : 0;
          }(this, t4, e4);
          if (!this.lastNeed)
            return t4.toString("utf8", e4);
          this.lastTotal = r4;
          var i5 = t4.length - (r4 - this.lastNeed);
          return t4.copy(this.lastChar, 0, i5), t4.toString("utf8", e4, i5);
        }, hi2.prototype.fillLast = function(t4) {
          if (this.lastNeed <= t4.length)
            return t4.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          t4.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t4.length), this.lastNeed -= t4.length;
        };
        ar3.StringDecoder;
        ar3.StringDecoder;
      });
      Lc2 = {};
      Qt3(Lc2, { StringDecoder: () => qw, default: () => ar3 });
      Uc2 = we4(() => {
        v3();
        m3();
        _3();
        Ys2();
        Ys2();
        qw = ar3.StringDecoder;
      });
      Js2 = M3(($22, jc2) => {
        "use strict";
        v3();
        m3();
        _3();
        var Nc2 = Nt4(), { PromisePrototypeThen: Dw, SymbolAsyncIterator: qc2, SymbolIterator: Dc2 } = ce5(), { Buffer: jw } = (ye5(), X3(_e5)), { ERR_INVALID_ARG_TYPE: Fw, ERR_STREAM_NULL_VALUES: Ww } = Se4().codes;
        function $w(t4, e4, r4) {
          let i5;
          if (typeof e4 == "string" || e4 instanceof jw)
            return new t4({ objectMode: true, ...r4, read() {
              this.push(e4), this.push(null);
            } });
          let n4;
          if (e4 && e4[qc2])
            n4 = true, i5 = e4[qc2]();
          else if (e4 && e4[Dc2])
            n4 = false, i5 = e4[Dc2]();
          else
            throw new Fw("iterable", ["Iterable"], e4);
          let o4 = new t4({ objectMode: true, highWaterMark: 1, ...r4 }), s4 = false;
          o4._read = function() {
            s4 || (s4 = true, u4());
          }, o4._destroy = function(c5, h4) {
            Dw(a4(c5), () => Nc2.nextTick(h4, c5), (d4) => Nc2.nextTick(h4, d4 || c5));
          };
          async function a4(c5) {
            let h4 = c5 != null, d4 = typeof i5.throw == "function";
            if (h4 && d4) {
              let { value: g4, done: y3 } = await i5.throw(c5);
              if (await g4, y3)
                return;
            }
            if (typeof i5.return == "function") {
              let { value: g4 } = await i5.return();
              await g4;
            }
          }
          async function u4() {
            for (; ; ) {
              try {
                let { value: c5, done: h4 } = n4 ? await i5.next() : i5.next();
                if (h4)
                  o4.push(null);
                else {
                  let d4 = c5 && typeof c5.then == "function" ? await c5 : c5;
                  if (d4 === null)
                    throw s4 = false, new Ww();
                  if (o4.push(d4))
                    continue;
                  s4 = false;
                }
              } catch (c5) {
                o4.destroy(c5);
              }
              break;
            }
          }
          return o4;
        }
        jc2.exports = $w;
      });
      di3 = M3((Z22, Zc2) => {
        v3();
        m3();
        _3();
        var He3 = Nt4(), { ArrayPrototypeIndexOf: Hw, NumberIsInteger: Vw, NumberIsNaN: zw, NumberParseInt: Kw, ObjectDefineProperties: $c2, ObjectKeys: Gw, ObjectSetPrototypeOf: Hc2, Promise: Qw, SafeSet: Yw, SymbolAsyncIterator: Jw, Symbol: Xw } = ce5();
        Zc2.exports = F4;
        F4.ReadableState = io4;
        var { EventEmitter: Zw } = (ir3(), X3(rr3)), { Stream: Dt3, prependListener: e_ } = tn4(), { Buffer: Xs2 } = (ye5(), X3(_e5)), { addAbortSignal: t_ } = ci2(), r_ = vt3(), H4 = Je4().debuglog("stream", (t4) => {
          H4 = t4;
        }), i_ = dc2(), Dr4 = tr4(), { getHighWaterMark: n_, getDefaultHighWaterMark: s_ } = sn3(), { aggregateTwoErrors: Fc2, codes: { ERR_INVALID_ARG_TYPE: o_, ERR_METHOD_NOT_IMPLEMENTED: a_, ERR_OUT_OF_RANGE: l_, ERR_STREAM_PUSH_AFTER_EOF: u_, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: f_ } } = Se4(), { validateObject: c_ } = fi3(), lr4 = Xw("kPaused"), { StringDecoder: Vc2 } = (Uc2(), X3(Lc2)), h_ = Js2();
        Hc2(F4.prototype, Dt3.prototype);
        Hc2(F4, Dt3);
        var Zs2 = () => {
        }, { errorOrDestroy: qr4 } = Dr4;
        function io4(t4, e4, r4) {
          typeof r4 != "boolean" && (r4 = e4 instanceof nt4()), this.objectMode = !!(t4 && t4.objectMode), r4 && (this.objectMode = this.objectMode || !!(t4 && t4.readableObjectMode)), this.highWaterMark = t4 ? n_(this, t4, "readableHighWaterMark", r4) : s_(false), this.buffer = new i_(), this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[lr4] = null, this.errorEmitted = false, this.emitClose = !t4 || t4.emitClose !== false, this.autoDestroy = !t4 || t4.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t4 && t4.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t4 && t4.encoding && (this.decoder = new Vc2(t4.encoding), this.encoding = t4.encoding);
        }
        function F4(t4) {
          if (!(this instanceof F4))
            return new F4(t4);
          let e4 = this instanceof nt4();
          this._readableState = new io4(t4, this, e4), t4 && (typeof t4.read == "function" && (this._read = t4.read), typeof t4.destroy == "function" && (this._destroy = t4.destroy), typeof t4.construct == "function" && (this._construct = t4.construct), t4.signal && !e4 && t_(t4.signal, this)), Dt3.call(this, t4), Dr4.construct(this, () => {
            this._readableState.needReadable && fn4(this, this._readableState);
          });
        }
        F4.prototype.destroy = Dr4.destroy;
        F4.prototype._undestroy = Dr4.undestroy;
        F4.prototype._destroy = function(t4, e4) {
          e4(t4);
        };
        F4.prototype[Zw.captureRejectionSymbol] = function(t4) {
          this.destroy(t4);
        };
        F4.prototype.push = function(t4, e4) {
          return zc2(this, t4, e4, false);
        };
        F4.prototype.unshift = function(t4, e4) {
          return zc2(this, t4, e4, true);
        };
        function zc2(t4, e4, r4, i5) {
          H4("readableAddChunk", e4);
          let n4 = t4._readableState, o4;
          if (n4.objectMode || (typeof e4 == "string" ? (r4 = r4 || n4.defaultEncoding, n4.encoding !== r4 && (i5 && n4.encoding ? e4 = Xs2.from(e4, r4).toString(n4.encoding) : (e4 = Xs2.from(e4, r4), r4 = ""))) : e4 instanceof Xs2 ? r4 = "" : Dt3._isUint8Array(e4) ? (e4 = Dt3._uint8ArrayToBuffer(e4), r4 = "") : e4 != null && (o4 = new o_("chunk", ["string", "Buffer", "Uint8Array"], e4))), o4)
            qr4(t4, o4);
          else if (e4 === null)
            n4.reading = false, g_(t4, n4);
          else if (n4.objectMode || e4 && e4.length > 0)
            if (i5)
              if (n4.endEmitted)
                qr4(t4, new f_());
              else {
                if (n4.destroyed || n4.errored)
                  return false;
                eo4(t4, n4, e4, true);
              }
            else if (n4.ended)
              qr4(t4, new u_());
            else {
              if (n4.destroyed || n4.errored)
                return false;
              n4.reading = false, n4.decoder && !r4 ? (e4 = n4.decoder.write(e4), n4.objectMode || e4.length !== 0 ? eo4(t4, n4, e4, false) : fn4(t4, n4)) : eo4(t4, n4, e4, false);
            }
          else
            i5 || (n4.reading = false, fn4(t4, n4));
          return !n4.ended && (n4.length < n4.highWaterMark || n4.length === 0);
        }
        function eo4(t4, e4, r4, i5) {
          e4.flowing && e4.length === 0 && !e4.sync && t4.listenerCount("data") > 0 ? (e4.multiAwaitDrain ? e4.awaitDrainWriters.clear() : e4.awaitDrainWriters = null, e4.dataEmitted = true, t4.emit("data", r4)) : (e4.length += e4.objectMode ? 1 : r4.length, i5 ? e4.buffer.unshift(r4) : e4.buffer.push(r4), e4.needReadable && cn4(t4)), fn4(t4, e4);
        }
        F4.prototype.isPaused = function() {
          let t4 = this._readableState;
          return t4[lr4] === true || t4.flowing === false;
        };
        F4.prototype.setEncoding = function(t4) {
          let e4 = new Vc2(t4);
          this._readableState.decoder = e4, this._readableState.encoding = this._readableState.decoder.encoding;
          let r4 = this._readableState.buffer, i5 = "";
          for (let n4 of r4)
            i5 += e4.write(n4);
          return r4.clear(), i5 !== "" && r4.push(i5), this._readableState.length = i5.length, this;
        };
        var d_ = 1073741824;
        function p_(t4) {
          if (t4 > d_)
            throw new l_("size", "<= 1GiB", t4);
          return t4--, t4 |= t4 >>> 1, t4 |= t4 >>> 2, t4 |= t4 >>> 4, t4 |= t4 >>> 8, t4 |= t4 >>> 16, t4++, t4;
        }
        function Wc2(t4, e4) {
          return t4 <= 0 || e4.length === 0 && e4.ended ? 0 : e4.objectMode ? 1 : zw(t4) ? e4.flowing && e4.length ? e4.buffer.first().length : e4.length : t4 <= e4.length ? t4 : e4.ended ? e4.length : 0;
        }
        F4.prototype.read = function(t4) {
          H4("read", t4), t4 === void 0 ? t4 = NaN : Vw(t4) || (t4 = Kw(t4, 10));
          let e4 = this._readableState, r4 = t4;
          if (t4 > e4.highWaterMark && (e4.highWaterMark = p_(t4)), t4 !== 0 && (e4.emittedReadable = false), t4 === 0 && e4.needReadable && ((e4.highWaterMark !== 0 ? e4.length >= e4.highWaterMark : e4.length > 0) || e4.ended))
            return H4("read: emitReadable", e4.length, e4.ended), e4.length === 0 && e4.ended ? to4(this) : cn4(this), null;
          if (t4 = Wc2(t4, e4), t4 === 0 && e4.ended)
            return e4.length === 0 && to4(this), null;
          let i5 = e4.needReadable;
          if (H4("need readable", i5), (e4.length === 0 || e4.length - t4 < e4.highWaterMark) && (i5 = true, H4("length less than watermark", i5)), e4.ended || e4.reading || e4.destroyed || e4.errored || !e4.constructed)
            i5 = false, H4("reading, ended or constructing", i5);
          else if (i5) {
            H4("do read"), e4.reading = true, e4.sync = true, e4.length === 0 && (e4.needReadable = true);
            try {
              this._read(e4.highWaterMark);
            } catch (o4) {
              qr4(this, o4);
            }
            e4.sync = false, e4.reading || (t4 = Wc2(r4, e4));
          }
          let n4;
          return t4 > 0 ? n4 = Jc2(t4, e4) : n4 = null, n4 === null ? (e4.needReadable = e4.length <= e4.highWaterMark, t4 = 0) : (e4.length -= t4, e4.multiAwaitDrain ? e4.awaitDrainWriters.clear() : e4.awaitDrainWriters = null), e4.length === 0 && (e4.ended || (e4.needReadable = true), r4 !== t4 && e4.ended && to4(this)), n4 !== null && !e4.errorEmitted && !e4.closeEmitted && (e4.dataEmitted = true, this.emit("data", n4)), n4;
        };
        function g_(t4, e4) {
          if (H4("onEofChunk"), !e4.ended) {
            if (e4.decoder) {
              let r4 = e4.decoder.end();
              r4 && r4.length && (e4.buffer.push(r4), e4.length += e4.objectMode ? 1 : r4.length);
            }
            e4.ended = true, e4.sync ? cn4(t4) : (e4.needReadable = false, e4.emittedReadable = true, Kc2(t4));
          }
        }
        function cn4(t4) {
          let e4 = t4._readableState;
          H4("emitReadable", e4.needReadable, e4.emittedReadable), e4.needReadable = false, e4.emittedReadable || (H4("emitReadable", e4.flowing), e4.emittedReadable = true, He3.nextTick(Kc2, t4));
        }
        function Kc2(t4) {
          let e4 = t4._readableState;
          H4("emitReadable_", e4.destroyed, e4.length, e4.ended), !e4.destroyed && !e4.errored && (e4.length || e4.ended) && (t4.emit("readable"), e4.emittedReadable = false), e4.needReadable = !e4.flowing && !e4.ended && e4.length <= e4.highWaterMark, Qc2(t4);
        }
        function fn4(t4, e4) {
          !e4.readingMore && e4.constructed && (e4.readingMore = true, He3.nextTick(y_, t4, e4));
        }
        function y_(t4, e4) {
          for (; !e4.reading && !e4.ended && (e4.length < e4.highWaterMark || e4.flowing && e4.length === 0); ) {
            let r4 = e4.length;
            if (H4("maybeReadMore read 0"), t4.read(0), r4 === e4.length)
              break;
          }
          e4.readingMore = false;
        }
        F4.prototype._read = function(t4) {
          throw new a_("_read()");
        };
        F4.prototype.pipe = function(t4, e4) {
          let r4 = this, i5 = this._readableState;
          i5.pipes.length === 1 && (i5.multiAwaitDrain || (i5.multiAwaitDrain = true, i5.awaitDrainWriters = new Yw(i5.awaitDrainWriters ? [i5.awaitDrainWriters] : []))), i5.pipes.push(t4), H4("pipe count=%d opts=%j", i5.pipes.length, e4);
          let o4 = (!e4 || e4.end !== false) && t4 !== He3.stdout && t4 !== He3.stderr ? a4 : S3;
          i5.endEmitted ? He3.nextTick(o4) : r4.once("end", o4), t4.on("unpipe", s4);
          function s4(I3, C3) {
            H4("onunpipe"), I3 === r4 && C3 && C3.hasUnpiped === false && (C3.hasUnpiped = true, h4());
          }
          function a4() {
            H4("onend"), t4.end();
          }
          let u4, c5 = false;
          function h4() {
            H4("cleanup"), t4.removeListener("close", w3), t4.removeListener("finish", E4), u4 && t4.removeListener("drain", u4), t4.removeListener("error", y3), t4.removeListener("unpipe", s4), r4.removeListener("end", a4), r4.removeListener("end", S3), r4.removeListener("data", g4), c5 = true, u4 && i5.awaitDrainWriters && (!t4._writableState || t4._writableState.needDrain) && u4();
          }
          function d4() {
            c5 || (i5.pipes.length === 1 && i5.pipes[0] === t4 ? (H4("false write response, pause", 0), i5.awaitDrainWriters = t4, i5.multiAwaitDrain = false) : i5.pipes.length > 1 && i5.pipes.includes(t4) && (H4("false write response, pause", i5.awaitDrainWriters.size), i5.awaitDrainWriters.add(t4)), r4.pause()), u4 || (u4 = b_(r4, t4), t4.on("drain", u4));
          }
          r4.on("data", g4);
          function g4(I3) {
            H4("ondata");
            let C3 = t4.write(I3);
            H4("dest.write", C3), C3 === false && d4();
          }
          function y3(I3) {
            if (H4("onerror", I3), S3(), t4.removeListener("error", y3), t4.listenerCount("error") === 0) {
              let C3 = t4._writableState || t4._readableState;
              C3 && !C3.errorEmitted ? qr4(t4, I3) : t4.emit("error", I3);
            }
          }
          e_(t4, "error", y3);
          function w3() {
            t4.removeListener("finish", E4), S3();
          }
          t4.once("close", w3);
          function E4() {
            H4("onfinish"), t4.removeListener("close", w3), S3();
          }
          t4.once("finish", E4);
          function S3() {
            H4("unpipe"), r4.unpipe(t4);
          }
          return t4.emit("pipe", r4), t4.writableNeedDrain === true ? i5.flowing && d4() : i5.flowing || (H4("pipe resume"), r4.resume()), t4;
        };
        function b_(t4, e4) {
          return function() {
            let i5 = t4._readableState;
            i5.awaitDrainWriters === e4 ? (H4("pipeOnDrain", 1), i5.awaitDrainWriters = null) : i5.multiAwaitDrain && (H4("pipeOnDrain", i5.awaitDrainWriters.size), i5.awaitDrainWriters.delete(e4)), (!i5.awaitDrainWriters || i5.awaitDrainWriters.size === 0) && t4.listenerCount("data") && t4.resume();
          };
        }
        F4.prototype.unpipe = function(t4) {
          let e4 = this._readableState, r4 = { hasUnpiped: false };
          if (e4.pipes.length === 0)
            return this;
          if (!t4) {
            let n4 = e4.pipes;
            e4.pipes = [], this.pause();
            for (let o4 = 0; o4 < n4.length; o4++)
              n4[o4].emit("unpipe", this, { hasUnpiped: false });
            return this;
          }
          let i5 = Hw(e4.pipes, t4);
          return i5 === -1 ? this : (e4.pipes.splice(i5, 1), e4.pipes.length === 0 && this.pause(), t4.emit("unpipe", this, r4), this);
        };
        F4.prototype.on = function(t4, e4) {
          let r4 = Dt3.prototype.on.call(this, t4, e4), i5 = this._readableState;
          return t4 === "data" ? (i5.readableListening = this.listenerCount("readable") > 0, i5.flowing !== false && this.resume()) : t4 === "readable" && !i5.endEmitted && !i5.readableListening && (i5.readableListening = i5.needReadable = true, i5.flowing = false, i5.emittedReadable = false, H4("on readable", i5.length, i5.reading), i5.length ? cn4(this) : i5.reading || He3.nextTick(w_, this)), r4;
        };
        F4.prototype.addListener = F4.prototype.on;
        F4.prototype.removeListener = function(t4, e4) {
          let r4 = Dt3.prototype.removeListener.call(this, t4, e4);
          return t4 === "readable" && He3.nextTick(Gc2, this), r4;
        };
        F4.prototype.off = F4.prototype.removeListener;
        F4.prototype.removeAllListeners = function(t4) {
          let e4 = Dt3.prototype.removeAllListeners.apply(this, arguments);
          return (t4 === "readable" || t4 === void 0) && He3.nextTick(Gc2, this), e4;
        };
        function Gc2(t4) {
          let e4 = t4._readableState;
          e4.readableListening = t4.listenerCount("readable") > 0, e4.resumeScheduled && e4[lr4] === false ? e4.flowing = true : t4.listenerCount("data") > 0 ? t4.resume() : e4.readableListening || (e4.flowing = null);
        }
        function w_(t4) {
          H4("readable nexttick read 0"), t4.read(0);
        }
        F4.prototype.resume = function() {
          let t4 = this._readableState;
          return t4.flowing || (H4("resume"), t4.flowing = !t4.readableListening, __(this, t4)), t4[lr4] = false, this;
        };
        function __(t4, e4) {
          e4.resumeScheduled || (e4.resumeScheduled = true, He3.nextTick(m_, t4, e4));
        }
        function m_(t4, e4) {
          H4("resume", e4.reading), e4.reading || t4.read(0), e4.resumeScheduled = false, t4.emit("resume"), Qc2(t4), e4.flowing && !e4.reading && t4.read(0);
        }
        F4.prototype.pause = function() {
          return H4("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (H4("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[lr4] = true, this;
        };
        function Qc2(t4) {
          let e4 = t4._readableState;
          for (H4("flow", e4.flowing); e4.flowing && t4.read() !== null; )
            ;
        }
        F4.prototype.wrap = function(t4) {
          let e4 = false;
          t4.on("data", (i5) => {
            !this.push(i5) && t4.pause && (e4 = true, t4.pause());
          }), t4.on("end", () => {
            this.push(null);
          }), t4.on("error", (i5) => {
            qr4(this, i5);
          }), t4.on("close", () => {
            this.destroy();
          }), t4.on("destroy", () => {
            this.destroy();
          }), this._read = () => {
            e4 && t4.resume && (e4 = false, t4.resume());
          };
          let r4 = Gw(t4);
          for (let i5 = 1; i5 < r4.length; i5++) {
            let n4 = r4[i5];
            this[n4] === void 0 && typeof t4[n4] == "function" && (this[n4] = t4[n4].bind(t4));
          }
          return this;
        };
        F4.prototype[Jw] = function() {
          return Yc2(this);
        };
        F4.prototype.iterator = function(t4) {
          return t4 !== void 0 && c_(t4, "options"), Yc2(this, t4);
        };
        function Yc2(t4, e4) {
          typeof t4.read != "function" && (t4 = F4.wrap(t4, { objectMode: true }));
          let r4 = v_(t4, e4);
          return r4.stream = t4, r4;
        }
        async function* v_(t4, e4) {
          let r4 = Zs2;
          function i5(s4) {
            this === t4 ? (r4(), r4 = Zs2) : r4 = s4;
          }
          t4.on("readable", i5);
          let n4, o4 = r_(t4, { writable: false }, (s4) => {
            n4 = s4 ? Fc2(n4, s4) : null, r4(), r4 = Zs2;
          });
          try {
            for (; ; ) {
              let s4 = t4.destroyed ? null : t4.read();
              if (s4 !== null)
                yield s4;
              else {
                if (n4)
                  throw n4;
                if (n4 === null)
                  return;
                await new Qw(i5);
              }
            }
          } catch (s4) {
            throw n4 = Fc2(n4, s4), n4;
          } finally {
            (n4 || e4?.destroyOnReturn !== false) && (n4 === void 0 || t4._readableState.autoDestroy) ? Dr4.destroyer(t4, null) : (t4.off("readable", i5), o4());
          }
        }
        $c2(F4.prototype, { readable: { __proto__: null, get() {
          let t4 = this._readableState;
          return !!t4 && t4.readable !== false && !t4.destroyed && !t4.errorEmitted && !t4.endEmitted;
        }, set(t4) {
          this._readableState && (this._readableState.readable = !!t4);
        } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.dataEmitted;
        } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
          return this._readableState && this._readableState.buffer;
        } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.flowing;
        }, set: function(t4) {
          this._readableState && (this._readableState.flowing = t4);
        } }, readableLength: { __proto__: null, enumerable: false, get() {
          return this._readableState.length;
        } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.objectMode : false;
        } }, readableEncoding: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.encoding : null;
        } }, errored: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.errored : null;
        } }, closed: { __proto__: null, get() {
          return this._readableState ? this._readableState.closed : false;
        } }, destroyed: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.destroyed : false;
        }, set(t4) {
          this._readableState && (this._readableState.destroyed = t4);
        } }, readableEnded: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.endEmitted : false;
        } } });
        $c2(io4.prototype, { pipesCount: { __proto__: null, get() {
          return this.pipes.length;
        } }, paused: { __proto__: null, get() {
          return this[lr4] !== false;
        }, set(t4) {
          this[lr4] = !!t4;
        } } });
        F4._fromList = Jc2;
        function Jc2(t4, e4) {
          if (e4.length === 0)
            return null;
          let r4;
          return e4.objectMode ? r4 = e4.buffer.shift() : !t4 || t4 >= e4.length ? (e4.decoder ? r4 = e4.buffer.join("") : e4.buffer.length === 1 ? r4 = e4.buffer.first() : r4 = e4.buffer.concat(e4.length), e4.buffer.clear()) : r4 = e4.buffer.consume(t4, e4.decoder), r4;
        }
        function to4(t4) {
          let e4 = t4._readableState;
          H4("endReadable", e4.endEmitted), e4.endEmitted || (e4.ended = true, He3.nextTick(E_, e4, t4));
        }
        function E_(t4, e4) {
          if (H4("endReadableNT", t4.endEmitted, t4.length), !t4.errored && !t4.closeEmitted && !t4.endEmitted && t4.length === 0) {
            if (t4.endEmitted = true, e4.emit("end"), e4.writable && e4.allowHalfOpen === false)
              He3.nextTick(S_, e4);
            else if (t4.autoDestroy) {
              let r4 = e4._writableState;
              (!r4 || r4.autoDestroy && (r4.finished || r4.writable === false)) && e4.destroy();
            }
          }
        }
        function S_(t4) {
          t4.writable && !t4.writableEnded && !t4.destroyed && t4.end();
        }
        F4.from = function(t4, e4) {
          return h_(F4, t4, e4);
        };
        var ro4;
        function Xc2() {
          return ro4 === void 0 && (ro4 = {}), ro4;
        }
        F4.fromWeb = function(t4, e4) {
          return Xc2().newStreamReadableFromReadableStream(t4, e4);
        };
        F4.toWeb = function(t4, e4) {
          return Xc2().newReadableStreamFromStreamReadable(t4, e4);
        };
        F4.wrap = function(t4, e4) {
          var r4, i5;
          return new F4({ objectMode: (r4 = (i5 = t4.readableObjectMode) !== null && i5 !== void 0 ? i5 : t4.objectMode) !== null && r4 !== void 0 ? r4 : true, ...e4, destroy(n4, o4) {
            Dr4.destroyer(t4, n4), o4(n4);
          } }).wrap(t4);
        };
      });
      fo4 = M3((uR, ch3) => {
        v3();
        m3();
        _3();
        var ur4 = Nt4(), { ArrayPrototypeSlice: rh3, Error: A_, FunctionPrototypeSymbolHasInstance: ih3, ObjectDefineProperty: nh3, ObjectDefineProperties: I_, ObjectSetPrototypeOf: sh3, StringPrototypeToLowerCase: T_, Symbol: R_, SymbolHasInstance: C_ } = ce5();
        ch3.exports = ie3;
        ie3.WritableState = yi3;
        var { EventEmitter: B_ } = (ir3(), X3(rr3)), pi2 = tn4().Stream, { Buffer: hn4 } = (ye5(), X3(_e5)), gn4 = tr4(), { addAbortSignal: P_ } = ci2(), { getHighWaterMark: O_, getDefaultHighWaterMark: k_ } = sn3(), { ERR_INVALID_ARG_TYPE: x_, ERR_METHOD_NOT_IMPLEMENTED: M_, ERR_MULTIPLE_CALLBACK: oh3, ERR_STREAM_CANNOT_PIPE: L_, ERR_STREAM_DESTROYED: gi3, ERR_STREAM_ALREADY_FINISHED: U_, ERR_STREAM_NULL_VALUES: N_, ERR_STREAM_WRITE_AFTER_END: q_, ERR_UNKNOWN_ENCODING: ah3 } = Se4().codes, { errorOrDestroy: jr3 } = gn4;
        sh3(ie3.prototype, pi2.prototype);
        sh3(ie3, pi2);
        function oo4() {
        }
        var Fr4 = R_("kOnFinished");
        function yi3(t4, e4, r4) {
          typeof r4 != "boolean" && (r4 = e4 instanceof nt4()), this.objectMode = !!(t4 && t4.objectMode), r4 && (this.objectMode = this.objectMode || !!(t4 && t4.writableObjectMode)), this.highWaterMark = t4 ? O_(this, t4, "writableHighWaterMark", r4) : k_(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          let i5 = !!(t4 && t4.decodeStrings === false);
          this.decodeStrings = !i5, this.defaultEncoding = t4 && t4.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = j_.bind(void 0, e4), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, pn4(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t4 || t4.emitClose !== false, this.autoDestroy = !t4 || t4.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[Fr4] = [];
        }
        function pn4(t4) {
          t4.buffered = [], t4.bufferedIndex = 0, t4.allBuffers = true, t4.allNoop = true;
        }
        yi3.prototype.getBuffer = function() {
          return rh3(this.buffered, this.bufferedIndex);
        };
        nh3(yi3.prototype, "bufferedRequestCount", { __proto__: null, get() {
          return this.buffered.length - this.bufferedIndex;
        } });
        function ie3(t4) {
          let e4 = this instanceof nt4();
          if (!e4 && !ih3(ie3, this))
            return new ie3(t4);
          this._writableState = new yi3(t4, this, e4), t4 && (typeof t4.write == "function" && (this._write = t4.write), typeof t4.writev == "function" && (this._writev = t4.writev), typeof t4.destroy == "function" && (this._destroy = t4.destroy), typeof t4.final == "function" && (this._final = t4.final), typeof t4.construct == "function" && (this._construct = t4.construct), t4.signal && P_(t4.signal, this)), pi2.call(this, t4), gn4.construct(this, () => {
            let r4 = this._writableState;
            r4.writing || lo4(this, r4), uo4(this, r4);
          });
        }
        nh3(ie3, C_, { __proto__: null, value: function(t4) {
          return ih3(this, t4) ? true : this !== ie3 ? false : t4 && t4._writableState instanceof yi3;
        } });
        ie3.prototype.pipe = function() {
          jr3(this, new L_());
        };
        function lh3(t4, e4, r4, i5) {
          let n4 = t4._writableState;
          if (typeof r4 == "function")
            i5 = r4, r4 = n4.defaultEncoding;
          else {
            if (!r4)
              r4 = n4.defaultEncoding;
            else if (r4 !== "buffer" && !hn4.isEncoding(r4))
              throw new ah3(r4);
            typeof i5 != "function" && (i5 = oo4);
          }
          if (e4 === null)
            throw new N_();
          if (!n4.objectMode)
            if (typeof e4 == "string")
              n4.decodeStrings !== false && (e4 = hn4.from(e4, r4), r4 = "buffer");
            else if (e4 instanceof hn4)
              r4 = "buffer";
            else if (pi2._isUint8Array(e4))
              e4 = pi2._uint8ArrayToBuffer(e4), r4 = "buffer";
            else
              throw new x_("chunk", ["string", "Buffer", "Uint8Array"], e4);
          let o4;
          return n4.ending ? o4 = new q_() : n4.destroyed && (o4 = new gi3("write")), o4 ? (ur4.nextTick(i5, o4), jr3(t4, o4, true), o4) : (n4.pendingcb++, D_(t4, n4, e4, r4, i5));
        }
        ie3.prototype.write = function(t4, e4, r4) {
          return lh3(this, t4, e4, r4) === true;
        };
        ie3.prototype.cork = function() {
          this._writableState.corked++;
        };
        ie3.prototype.uncork = function() {
          let t4 = this._writableState;
          t4.corked && (t4.corked--, t4.writing || lo4(this, t4));
        };
        ie3.prototype.setDefaultEncoding = function(e4) {
          if (typeof e4 == "string" && (e4 = T_(e4)), !hn4.isEncoding(e4))
            throw new ah3(e4);
          return this._writableState.defaultEncoding = e4, this;
        };
        function D_(t4, e4, r4, i5, n4) {
          let o4 = e4.objectMode ? 1 : r4.length;
          e4.length += o4;
          let s4 = e4.length < e4.highWaterMark;
          return s4 || (e4.needDrain = true), e4.writing || e4.corked || e4.errored || !e4.constructed ? (e4.buffered.push({ chunk: r4, encoding: i5, callback: n4 }), e4.allBuffers && i5 !== "buffer" && (e4.allBuffers = false), e4.allNoop && n4 !== oo4 && (e4.allNoop = false)) : (e4.writelen = o4, e4.writecb = n4, e4.writing = true, e4.sync = true, t4._write(r4, i5, e4.onwrite), e4.sync = false), s4 && !e4.errored && !e4.destroyed;
        }
        function eh3(t4, e4, r4, i5, n4, o4, s4) {
          e4.writelen = i5, e4.writecb = s4, e4.writing = true, e4.sync = true, e4.destroyed ? e4.onwrite(new gi3("write")) : r4 ? t4._writev(n4, e4.onwrite) : t4._write(n4, o4, e4.onwrite), e4.sync = false;
        }
        function th3(t4, e4, r4, i5) {
          --e4.pendingcb, i5(r4), ao4(e4), jr3(t4, r4);
        }
        function j_(t4, e4) {
          let r4 = t4._writableState, i5 = r4.sync, n4 = r4.writecb;
          if (typeof n4 != "function") {
            jr3(t4, new oh3());
            return;
          }
          r4.writing = false, r4.writecb = null, r4.length -= r4.writelen, r4.writelen = 0, e4 ? (e4.stack, r4.errored || (r4.errored = e4), t4._readableState && !t4._readableState.errored && (t4._readableState.errored = e4), i5 ? ur4.nextTick(th3, t4, r4, e4, n4) : th3(t4, r4, e4, n4)) : (r4.buffered.length > r4.bufferedIndex && lo4(t4, r4), i5 ? r4.afterWriteTickInfo !== null && r4.afterWriteTickInfo.cb === n4 ? r4.afterWriteTickInfo.count++ : (r4.afterWriteTickInfo = { count: 1, cb: n4, stream: t4, state: r4 }, ur4.nextTick(F_, r4.afterWriteTickInfo)) : uh2(t4, r4, 1, n4));
        }
        function F_({ stream: t4, state: e4, count: r4, cb: i5 }) {
          return e4.afterWriteTickInfo = null, uh2(t4, e4, r4, i5);
        }
        function uh2(t4, e4, r4, i5) {
          for (!e4.ending && !t4.destroyed && e4.length === 0 && e4.needDrain && (e4.needDrain = false, t4.emit("drain")); r4-- > 0; )
            e4.pendingcb--, i5();
          e4.destroyed && ao4(e4), uo4(t4, e4);
        }
        function ao4(t4) {
          if (t4.writing)
            return;
          for (let n4 = t4.bufferedIndex; n4 < t4.buffered.length; ++n4) {
            var e4;
            let { chunk: o4, callback: s4 } = t4.buffered[n4], a4 = t4.objectMode ? 1 : o4.length;
            t4.length -= a4, s4((e4 = t4.errored) !== null && e4 !== void 0 ? e4 : new gi3("write"));
          }
          let r4 = t4[Fr4].splice(0);
          for (let n4 = 0; n4 < r4.length; n4++) {
            var i5;
            r4[n4]((i5 = t4.errored) !== null && i5 !== void 0 ? i5 : new gi3("end"));
          }
          pn4(t4);
        }
        function lo4(t4, e4) {
          if (e4.corked || e4.bufferProcessing || e4.destroyed || !e4.constructed)
            return;
          let { buffered: r4, bufferedIndex: i5, objectMode: n4 } = e4, o4 = r4.length - i5;
          if (!o4)
            return;
          let s4 = i5;
          if (e4.bufferProcessing = true, o4 > 1 && t4._writev) {
            e4.pendingcb -= o4 - 1;
            let a4 = e4.allNoop ? oo4 : (c5) => {
              for (let h4 = s4; h4 < r4.length; ++h4)
                r4[h4].callback(c5);
            }, u4 = e4.allNoop && s4 === 0 ? r4 : rh3(r4, s4);
            u4.allBuffers = e4.allBuffers, eh3(t4, e4, true, e4.length, u4, "", a4), pn4(e4);
          } else {
            do {
              let { chunk: a4, encoding: u4, callback: c5 } = r4[s4];
              r4[s4++] = null;
              let h4 = n4 ? 1 : a4.length;
              eh3(t4, e4, false, h4, a4, u4, c5);
            } while (s4 < r4.length && !e4.writing);
            s4 === r4.length ? pn4(e4) : s4 > 256 ? (r4.splice(0, s4), e4.bufferedIndex = 0) : e4.bufferedIndex = s4;
          }
          e4.bufferProcessing = false;
        }
        ie3.prototype._write = function(t4, e4, r4) {
          if (this._writev)
            this._writev([{ chunk: t4, encoding: e4 }], r4);
          else
            throw new M_("_write()");
        };
        ie3.prototype._writev = null;
        ie3.prototype.end = function(t4, e4, r4) {
          let i5 = this._writableState;
          typeof t4 == "function" ? (r4 = t4, t4 = null, e4 = null) : typeof e4 == "function" && (r4 = e4, e4 = null);
          let n4;
          if (t4 != null) {
            let o4 = lh3(this, t4, e4);
            o4 instanceof A_ && (n4 = o4);
          }
          return i5.corked && (i5.corked = 1, this.uncork()), n4 || (!i5.errored && !i5.ending ? (i5.ending = true, uo4(this, i5, true), i5.ended = true) : i5.finished ? n4 = new U_("end") : i5.destroyed && (n4 = new gi3("end"))), typeof r4 == "function" && (n4 || i5.finished ? ur4.nextTick(r4, n4) : i5[Fr4].push(r4)), this;
        };
        function dn4(t4) {
          return t4.ending && !t4.destroyed && t4.constructed && t4.length === 0 && !t4.errored && t4.buffered.length === 0 && !t4.finished && !t4.writing && !t4.errorEmitted && !t4.closeEmitted;
        }
        function W_(t4, e4) {
          let r4 = false;
          function i5(n4) {
            if (r4) {
              jr3(t4, n4 ?? oh3());
              return;
            }
            if (r4 = true, e4.pendingcb--, n4) {
              let o4 = e4[Fr4].splice(0);
              for (let s4 = 0; s4 < o4.length; s4++)
                o4[s4](n4);
              jr3(t4, n4, e4.sync);
            } else
              dn4(e4) && (e4.prefinished = true, t4.emit("prefinish"), e4.pendingcb++, ur4.nextTick(so4, t4, e4));
          }
          e4.sync = true, e4.pendingcb++;
          try {
            t4._final(i5);
          } catch (n4) {
            i5(n4);
          }
          e4.sync = false;
        }
        function $_(t4, e4) {
          !e4.prefinished && !e4.finalCalled && (typeof t4._final == "function" && !e4.destroyed ? (e4.finalCalled = true, W_(t4, e4)) : (e4.prefinished = true, t4.emit("prefinish")));
        }
        function uo4(t4, e4, r4) {
          dn4(e4) && ($_(t4, e4), e4.pendingcb === 0 && (r4 ? (e4.pendingcb++, ur4.nextTick((i5, n4) => {
            dn4(n4) ? so4(i5, n4) : n4.pendingcb--;
          }, t4, e4)) : dn4(e4) && (e4.pendingcb++, so4(t4, e4))));
        }
        function so4(t4, e4) {
          e4.pendingcb--, e4.finished = true;
          let r4 = e4[Fr4].splice(0);
          for (let i5 = 0; i5 < r4.length; i5++)
            r4[i5]();
          if (t4.emit("finish"), e4.autoDestroy) {
            let i5 = t4._readableState;
            (!i5 || i5.autoDestroy && (i5.endEmitted || i5.readable === false)) && t4.destroy();
          }
        }
        I_(ie3.prototype, { closed: { __proto__: null, get() {
          return this._writableState ? this._writableState.closed : false;
        } }, destroyed: { __proto__: null, get() {
          return this._writableState ? this._writableState.destroyed : false;
        }, set(t4) {
          this._writableState && (this._writableState.destroyed = t4);
        } }, writable: { __proto__: null, get() {
          let t4 = this._writableState;
          return !!t4 && t4.writable !== false && !t4.destroyed && !t4.errored && !t4.ending && !t4.ended;
        }, set(t4) {
          this._writableState && (this._writableState.writable = !!t4);
        } }, writableFinished: { __proto__: null, get() {
          return this._writableState ? this._writableState.finished : false;
        } }, writableObjectMode: { __proto__: null, get() {
          return this._writableState ? this._writableState.objectMode : false;
        } }, writableBuffer: { __proto__: null, get() {
          return this._writableState && this._writableState.getBuffer();
        } }, writableEnded: { __proto__: null, get() {
          return this._writableState ? this._writableState.ending : false;
        } }, writableNeedDrain: { __proto__: null, get() {
          let t4 = this._writableState;
          return t4 ? !t4.destroyed && !t4.ending && t4.needDrain : false;
        } }, writableHighWaterMark: { __proto__: null, get() {
          return this._writableState && this._writableState.highWaterMark;
        } }, writableCorked: { __proto__: null, get() {
          return this._writableState ? this._writableState.corked : 0;
        } }, writableLength: { __proto__: null, get() {
          return this._writableState && this._writableState.length;
        } }, errored: { __proto__: null, enumerable: false, get() {
          return this._writableState ? this._writableState.errored : null;
        } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        } } });
        var H_ = gn4.destroy;
        ie3.prototype.destroy = function(t4, e4) {
          let r4 = this._writableState;
          return !r4.destroyed && (r4.bufferedIndex < r4.buffered.length || r4[Fr4].length) && ur4.nextTick(ao4, r4), H_.call(this, t4, e4), this;
        };
        ie3.prototype._undestroy = gn4.undestroy;
        ie3.prototype._destroy = function(t4, e4) {
          e4(t4);
        };
        ie3.prototype[B_.captureRejectionSymbol] = function(t4) {
          this.destroy(t4);
        };
        var no4;
        function fh3() {
          return no4 === void 0 && (no4 = {}), no4;
        }
        ie3.fromWeb = function(t4, e4) {
          return fh3().newStreamWritableFromWritableStream(t4, e4);
        };
        ie3.toWeb = function(t4) {
          return fh3().newWritableStreamFromStreamWritable(t4);
        };
      });
      Sh3 = M3((_R, Eh3) => {
        v3();
        m3();
        _3();
        var co4 = Nt4(), V_ = (ye5(), X3(_e5)), { isReadable: z_, isWritable: K_, isIterable: hh3, isNodeStream: G_, isReadableNodeStream: dh3, isWritableNodeStream: ph2, isDuplexNodeStream: Q_ } = tt4(), gh3 = vt3(), { AbortError: vh3, codes: { ERR_INVALID_ARG_TYPE: Y_, ERR_INVALID_RETURN_VALUE: yh3 } } = Se4(), { destroyer: Wr4 } = tr4(), J_ = nt4(), X_ = di3(), { createDeferredPromise: bh3 } = Je4(), wh3 = Js2(), _h3 = globalThis.Blob || V_.Blob, Z_ = typeof _h3 < "u" ? function(e4) {
          return e4 instanceof _h3;
        } : function(e4) {
          return false;
        }, e0 = globalThis.AbortController || Hi3().AbortController, { FunctionPrototypeCall: mh3 } = ce5(), fr4 = class extends J_ {
          constructor(e4) {
            super(e4), e4?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e4?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
          }
        };
        Eh3.exports = function t4(e4, r4) {
          if (Q_(e4))
            return e4;
          if (dh3(e4))
            return yn4({ readable: e4 });
          if (ph2(e4))
            return yn4({ writable: e4 });
          if (G_(e4))
            return yn4({ writable: false, readable: false });
          if (typeof e4 == "function") {
            let { value: n4, write: o4, final: s4, destroy: a4 } = t0(e4);
            if (hh3(n4))
              return wh3(fr4, n4, { objectMode: true, write: o4, final: s4, destroy: a4 });
            let u4 = n4?.then;
            if (typeof u4 == "function") {
              let c5, h4 = mh3(u4, n4, (d4) => {
                if (d4 != null)
                  throw new yh3("nully", "body", d4);
              }, (d4) => {
                Wr4(c5, d4);
              });
              return c5 = new fr4({ objectMode: true, readable: false, write: o4, final(d4) {
                s4(async () => {
                  try {
                    await h4, co4.nextTick(d4, null);
                  } catch (g4) {
                    co4.nextTick(d4, g4);
                  }
                });
              }, destroy: a4 });
            }
            throw new yh3("Iterable, AsyncIterable or AsyncFunction", r4, n4);
          }
          if (Z_(e4))
            return t4(e4.arrayBuffer());
          if (hh3(e4))
            return wh3(fr4, e4, { objectMode: true, writable: false });
          if (typeof e4?.writable == "object" || typeof e4?.readable == "object") {
            let n4 = e4 != null && e4.readable ? dh3(e4?.readable) ? e4?.readable : t4(e4.readable) : void 0, o4 = e4 != null && e4.writable ? ph2(e4?.writable) ? e4?.writable : t4(e4.writable) : void 0;
            return yn4({ readable: n4, writable: o4 });
          }
          let i5 = e4?.then;
          if (typeof i5 == "function") {
            let n4;
            return mh3(i5, e4, (o4) => {
              o4 != null && n4.push(o4), n4.push(null);
            }, (o4) => {
              Wr4(n4, o4);
            }), n4 = new fr4({ objectMode: true, writable: false, read() {
            } });
          }
          throw new Y_(r4, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e4);
        };
        function t0(t4) {
          let { promise: e4, resolve: r4 } = bh3(), i5 = new e0(), n4 = i5.signal;
          return { value: t4(async function* () {
            for (; ; ) {
              let s4 = e4;
              e4 = null;
              let { chunk: a4, done: u4, cb: c5 } = await s4;
              if (co4.nextTick(c5), u4)
                return;
              if (n4.aborted)
                throw new vh3(void 0, { cause: n4.reason });
              ({ promise: e4, resolve: r4 } = bh3()), yield a4;
            }
          }(), { signal: n4 }), write(s4, a4, u4) {
            let c5 = r4;
            r4 = null, c5({ chunk: s4, done: false, cb: u4 });
          }, final(s4) {
            let a4 = r4;
            r4 = null, a4({ done: true, cb: s4 });
          }, destroy(s4, a4) {
            i5.abort(), a4(s4);
          } };
        }
        function yn4(t4) {
          let e4 = t4.readable && typeof t4.readable.read != "function" ? X_.wrap(t4.readable) : t4.readable, r4 = t4.writable, i5 = !!z_(e4), n4 = !!K_(r4), o4, s4, a4, u4, c5;
          function h4(d4) {
            let g4 = u4;
            u4 = null, g4 ? g4(d4) : d4 && c5.destroy(d4);
          }
          return c5 = new fr4({ readableObjectMode: !!(e4 != null && e4.readableObjectMode), writableObjectMode: !!(r4 != null && r4.writableObjectMode), readable: i5, writable: n4 }), n4 && (gh3(r4, (d4) => {
            n4 = false, d4 && Wr4(e4, d4), h4(d4);
          }), c5._write = function(d4, g4, y3) {
            r4.write(d4, g4) ? y3() : o4 = y3;
          }, c5._final = function(d4) {
            r4.end(), s4 = d4;
          }, r4.on("drain", function() {
            if (o4) {
              let d4 = o4;
              o4 = null, d4();
            }
          }), r4.on("finish", function() {
            if (s4) {
              let d4 = s4;
              s4 = null, d4();
            }
          })), i5 && (gh3(e4, (d4) => {
            i5 = false, d4 && Wr4(e4, d4), h4(d4);
          }), e4.on("readable", function() {
            if (a4) {
              let d4 = a4;
              a4 = null, d4();
            }
          }), e4.on("end", function() {
            c5.push(null);
          }), c5._read = function() {
            for (; ; ) {
              let d4 = e4.read();
              if (d4 === null) {
                a4 = c5._read;
                return;
              }
              if (!c5.push(d4))
                return;
            }
          }), c5._destroy = function(d4, g4) {
            !d4 && u4 !== null && (d4 = new vh3()), a4 = null, o4 = null, s4 = null, u4 === null ? g4(d4) : (u4 = g4, Wr4(r4, d4), Wr4(e4, d4));
          }, c5;
        }
      });
      nt4 = M3((BR, Th3) => {
        "use strict";
        v3();
        m3();
        _3();
        var { ObjectDefineProperties: r0, ObjectGetOwnPropertyDescriptor: It3, ObjectKeys: i0, ObjectSetPrototypeOf: Ah2 } = ce5();
        Th3.exports = Ve4;
        var go4 = di3(), Ne3 = fo4();
        Ah2(Ve4.prototype, go4.prototype);
        Ah2(Ve4, go4);
        {
          let t4 = i0(Ne3.prototype);
          for (let e4 = 0; e4 < t4.length; e4++) {
            let r4 = t4[e4];
            Ve4.prototype[r4] || (Ve4.prototype[r4] = Ne3.prototype[r4]);
          }
        }
        function Ve4(t4) {
          if (!(this instanceof Ve4))
            return new Ve4(t4);
          go4.call(this, t4), Ne3.call(this, t4), t4 ? (this.allowHalfOpen = t4.allowHalfOpen !== false, t4.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t4.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
        }
        r0(Ve4.prototype, { writable: { __proto__: null, ...It3(Ne3.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...It3(Ne3.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...It3(Ne3.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...It3(Ne3.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...It3(Ne3.prototype, "writableLength") }, writableFinished: { __proto__: null, ...It3(Ne3.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...It3(Ne3.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...It3(Ne3.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...It3(Ne3.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
          return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
        }, set(t4) {
          this._readableState && this._writableState && (this._readableState.destroyed = t4, this._writableState.destroyed = t4);
        } } });
        var ho4;
        function Ih3() {
          return ho4 === void 0 && (ho4 = {}), ho4;
        }
        Ve4.fromWeb = function(t4, e4) {
          return Ih3().newStreamDuplexFromReadableWritablePair(t4, e4);
        };
        Ve4.toWeb = function(t4) {
          return Ih3().newReadableWritablePairFromDuplex(t4);
        };
        var po4;
        Ve4.from = function(t4) {
          return po4 || (po4 = Sh3()), po4(t4, "body");
        };
      });
      wo4 = M3((DR, Ch3) => {
        "use strict";
        v3();
        m3();
        _3();
        var { ObjectSetPrototypeOf: Rh3, Symbol: n0 } = ce5();
        Ch3.exports = Tt4;
        var { ERR_METHOD_NOT_IMPLEMENTED: s0 } = Se4().codes, bo4 = nt4(), { getHighWaterMark: o0 } = sn3();
        Rh3(Tt4.prototype, bo4.prototype);
        Rh3(Tt4, bo4);
        var bi3 = n0("kCallback");
        function Tt4(t4) {
          if (!(this instanceof Tt4))
            return new Tt4(t4);
          let e4 = t4 ? o0(this, t4, "readableHighWaterMark", true) : null;
          e4 === 0 && (t4 = { ...t4, highWaterMark: null, readableHighWaterMark: e4, writableHighWaterMark: t4.writableHighWaterMark || 0 }), bo4.call(this, t4), this._readableState.sync = false, this[bi3] = null, t4 && (typeof t4.transform == "function" && (this._transform = t4.transform), typeof t4.flush == "function" && (this._flush = t4.flush)), this.on("prefinish", a0);
        }
        function yo4(t4) {
          typeof this._flush == "function" && !this.destroyed ? this._flush((e4, r4) => {
            if (e4) {
              t4 ? t4(e4) : this.destroy(e4);
              return;
            }
            r4 != null && this.push(r4), this.push(null), t4 && t4();
          }) : (this.push(null), t4 && t4());
        }
        function a0() {
          this._final !== yo4 && yo4.call(this);
        }
        Tt4.prototype._final = yo4;
        Tt4.prototype._transform = function(t4, e4, r4) {
          throw new s0("_transform()");
        };
        Tt4.prototype._write = function(t4, e4, r4) {
          let i5 = this._readableState, n4 = this._writableState, o4 = i5.length;
          this._transform(t4, e4, (s4, a4) => {
            if (s4) {
              r4(s4);
              return;
            }
            a4 != null && this.push(a4), n4.ended || o4 === i5.length || i5.length < i5.highWaterMark ? r4() : this[bi3] = r4;
          });
        };
        Tt4.prototype._read = function() {
          if (this[bi3]) {
            let t4 = this[bi3];
            this[bi3] = null, t4();
          }
        };
      });
      mo4 = M3((QR, Ph3) => {
        "use strict";
        v3();
        m3();
        _3();
        var { ObjectSetPrototypeOf: Bh3 } = ce5();
        Ph3.exports = $r4;
        var _o4 = wo4();
        Bh3($r4.prototype, _o4.prototype);
        Bh3($r4, _o4);
        function $r4(t4) {
          if (!(this instanceof $r4))
            return new $r4(t4);
          _o4.call(this, t4);
        }
        $r4.prototype._transform = function(t4, e4, r4) {
          r4(null, t4);
        };
      });
      mn4 = M3((sC, Lh3) => {
        v3();
        m3();
        _3();
        var wi3 = Nt4(), { ArrayIsArray: l0, Promise: u0, SymbolAsyncIterator: f0 } = ce5(), _n3 = vt3(), { once: c0 } = Je4(), h0 = tr4(), Oh3 = nt4(), { aggregateTwoErrors: d0, codes: { ERR_INVALID_ARG_TYPE: Co3, ERR_INVALID_RETURN_VALUE: vo4, ERR_MISSING_ARGS: p0, ERR_STREAM_DESTROYED: g0, ERR_STREAM_PREMATURE_CLOSE: y0 }, AbortError: b0 } = Se4(), { validateFunction: w0, validateAbortSignal: _0 } = fi3(), { isIterable: cr4, isReadable: Eo4, isReadableNodeStream: wn3, isNodeStream: kh3, isTransformStream: Hr4, isWebStream: m0, isReadableStream: So4, isReadableEnded: v0 } = tt4(), E0 = globalThis.AbortController || Hi3().AbortController, Ao4, Io4;
        function xh3(t4, e4, r4) {
          let i5 = false;
          t4.on("close", () => {
            i5 = true;
          });
          let n4 = _n3(t4, { readable: e4, writable: r4 }, (o4) => {
            i5 = !o4;
          });
          return { destroy: (o4) => {
            i5 || (i5 = true, h0.destroyer(t4, o4 || new g0("pipe")));
          }, cleanup: n4 };
        }
        function S0(t4) {
          return w0(t4[t4.length - 1], "streams[stream.length - 1]"), t4.pop();
        }
        function To4(t4) {
          if (cr4(t4))
            return t4;
          if (wn3(t4))
            return A0(t4);
          throw new Co3("val", ["Readable", "Iterable", "AsyncIterable"], t4);
        }
        async function* A0(t4) {
          Io4 || (Io4 = di3()), yield* Io4.prototype[f0].call(t4);
        }
        async function bn4(t4, e4, r4, { end: i5 }) {
          let n4, o4 = null, s4 = (c5) => {
            if (c5 && (n4 = c5), o4) {
              let h4 = o4;
              o4 = null, h4();
            }
          }, a4 = () => new u0((c5, h4) => {
            n4 ? h4(n4) : o4 = () => {
              n4 ? h4(n4) : c5();
            };
          });
          e4.on("drain", s4);
          let u4 = _n3(e4, { readable: false }, s4);
          try {
            e4.writableNeedDrain && await a4();
            for await (let c5 of t4)
              e4.write(c5) || await a4();
            i5 && e4.end(), await a4(), r4();
          } catch (c5) {
            r4(n4 !== c5 ? d0(n4, c5) : c5);
          } finally {
            u4(), e4.off("drain", s4);
          }
        }
        async function Ro2(t4, e4, r4, { end: i5 }) {
          Hr4(e4) && (e4 = e4.writable);
          let n4 = e4.getWriter();
          try {
            for await (let o4 of t4)
              await n4.ready, n4.write(o4).catch(() => {
              });
            await n4.ready, i5 && await n4.close(), r4();
          } catch (o4) {
            try {
              await n4.abort(o4), r4(o4);
            } catch (s4) {
              r4(s4);
            }
          }
        }
        function I0(...t4) {
          return Mh3(t4, c0(S0(t4)));
        }
        function Mh3(t4, e4, r4) {
          if (t4.length === 1 && l0(t4[0]) && (t4 = t4[0]), t4.length < 2)
            throw new p0("streams");
          let i5 = new E0(), n4 = i5.signal, o4 = r4?.signal, s4 = [];
          _0(o4, "options.signal");
          function a4() {
            y3(new b0());
          }
          o4?.addEventListener("abort", a4);
          let u4, c5, h4 = [], d4 = 0;
          function g4(C3) {
            y3(C3, --d4 === 0);
          }
          function y3(C3, R5) {
            if (C3 && (!u4 || u4.code === "ERR_STREAM_PREMATURE_CLOSE") && (u4 = C3), !(!u4 && !R5)) {
              for (; h4.length; )
                h4.shift()(u4);
              o4?.removeEventListener("abort", a4), i5.abort(), R5 && (u4 || s4.forEach((U5) => U5()), wi3.nextTick(e4, u4, c5));
            }
          }
          let w3;
          for (let C3 = 0; C3 < t4.length; C3++) {
            let R5 = t4[C3], U5 = C3 < t4.length - 1, N4 = C3 > 0, W4 = U5 || r4?.end !== false, K5 = C3 === t4.length - 1;
            if (kh3(R5)) {
              let z4 = function(Q3) {
                Q3 && Q3.name !== "AbortError" && Q3.code !== "ERR_STREAM_PREMATURE_CLOSE" && g4(Q3);
              };
              var I3 = z4;
              if (W4) {
                let { destroy: Q3, cleanup: de3 } = xh3(R5, U5, N4);
                h4.push(Q3), Eo4(R5) && K5 && s4.push(de3);
              }
              R5.on("error", z4), Eo4(R5) && K5 && s4.push(() => {
                R5.removeListener("error", z4);
              });
            }
            if (C3 === 0)
              if (typeof R5 == "function") {
                if (w3 = R5({ signal: n4 }), !cr4(w3))
                  throw new vo4("Iterable, AsyncIterable or Stream", "source", w3);
              } else
                cr4(R5) || wn3(R5) || Hr4(R5) ? w3 = R5 : w3 = Oh3.from(R5);
            else if (typeof R5 == "function") {
              if (Hr4(w3)) {
                var E4;
                w3 = To4((E4 = w3) === null || E4 === void 0 ? void 0 : E4.readable);
              } else
                w3 = To4(w3);
              if (w3 = R5(w3, { signal: n4 }), U5) {
                if (!cr4(w3, true))
                  throw new vo4("AsyncIterable", `transform[${C3 - 1}]`, w3);
              } else {
                var S3;
                Ao4 || (Ao4 = mo4());
                let z4 = new Ao4({ objectMode: true }), Q3 = (S3 = w3) === null || S3 === void 0 ? void 0 : S3.then;
                if (typeof Q3 == "function")
                  d4++, Q3.call(w3, (pe3) => {
                    c5 = pe3, pe3 != null && z4.write(pe3), W4 && z4.end(), wi3.nextTick(g4);
                  }, (pe3) => {
                    z4.destroy(pe3), wi3.nextTick(g4, pe3);
                  });
                else if (cr4(w3, true))
                  d4++, bn4(w3, z4, g4, { end: W4 });
                else if (So4(w3) || Hr4(w3)) {
                  let pe3 = w3.readable || w3;
                  d4++, bn4(pe3, z4, g4, { end: W4 });
                } else
                  throw new vo4("AsyncIterable or Promise", "destination", w3);
                w3 = z4;
                let { destroy: de3, cleanup: Gt3 } = xh3(w3, false, true);
                h4.push(de3), K5 && s4.push(Gt3);
              }
            } else if (kh3(R5)) {
              if (wn3(w3)) {
                d4 += 2;
                let z4 = T0(w3, R5, g4, { end: W4 });
                Eo4(R5) && K5 && s4.push(z4);
              } else if (Hr4(w3) || So4(w3)) {
                let z4 = w3.readable || w3;
                d4++, bn4(z4, R5, g4, { end: W4 });
              } else if (cr4(w3))
                d4++, bn4(w3, R5, g4, { end: W4 });
              else
                throw new Co3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], w3);
              w3 = R5;
            } else if (m0(R5)) {
              if (wn3(w3))
                d4++, Ro2(To4(w3), R5, g4, { end: W4 });
              else if (So4(w3) || cr4(w3))
                d4++, Ro2(w3, R5, g4, { end: W4 });
              else if (Hr4(w3))
                d4++, Ro2(w3.readable, R5, g4, { end: W4 });
              else
                throw new Co3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], w3);
              w3 = R5;
            } else
              w3 = Oh3.from(R5);
          }
          return (n4 != null && n4.aborted || o4 != null && o4.aborted) && wi3.nextTick(a4), w3;
        }
        function T0(t4, e4, r4, { end: i5 }) {
          let n4 = false;
          if (e4.on("close", () => {
            n4 || r4(new y0());
          }), t4.pipe(e4, { end: false }), i5) {
            let s4 = function() {
              n4 = true, e4.end();
            };
            var o4 = s4;
            v0(t4) ? wi3.nextTick(s4) : t4.once("end", s4);
          } else
            r4();
          return _n3(t4, { readable: true, writable: false }, (s4) => {
            let a4 = t4._readableState;
            s4 && s4.code === "ERR_STREAM_PREMATURE_CLOSE" && a4 && a4.ended && !a4.errored && !a4.errorEmitted ? t4.once("end", r4).once("error", r4) : r4(s4);
          }), _n3(e4, { readable: false, writable: true }, r4);
        }
        Lh3.exports = { pipelineImpl: Mh3, pipeline: I0 };
      });
      Po4 = M3((gC, Fh3) => {
        "use strict";
        v3();
        m3();
        _3();
        var { pipeline: R0 } = mn4(), vn3 = nt4(), { destroyer: C0 } = tr4(), { isNodeStream: En3, isReadable: Uh3, isWritable: Nh3, isWebStream: Bo3, isTransformStream: hr4, isWritableStream: qh3, isReadableStream: Dh3 } = tt4(), { AbortError: B0, codes: { ERR_INVALID_ARG_VALUE: jh3, ERR_MISSING_ARGS: P0 } } = Se4(), O0 = vt3();
        Fh3.exports = function(...e4) {
          if (e4.length === 0)
            throw new P0("streams");
          if (e4.length === 1)
            return vn3.from(e4[0]);
          let r4 = [...e4];
          if (typeof e4[0] == "function" && (e4[0] = vn3.from(e4[0])), typeof e4[e4.length - 1] == "function") {
            let y3 = e4.length - 1;
            e4[y3] = vn3.from(e4[y3]);
          }
          for (let y3 = 0; y3 < e4.length; ++y3)
            if (!(!En3(e4[y3]) && !Bo3(e4[y3]))) {
              if (y3 < e4.length - 1 && !(Uh3(e4[y3]) || Dh3(e4[y3]) || hr4(e4[y3])))
                throw new jh3(`streams[${y3}]`, r4[y3], "must be readable");
              if (y3 > 0 && !(Nh3(e4[y3]) || qh3(e4[y3]) || hr4(e4[y3])))
                throw new jh3(`streams[${y3}]`, r4[y3], "must be writable");
            }
          let i5, n4, o4, s4, a4;
          function u4(y3) {
            let w3 = s4;
            s4 = null, w3 ? w3(y3) : y3 ? a4.destroy(y3) : !g4 && !d4 && a4.destroy();
          }
          let c5 = e4[0], h4 = R0(e4, u4), d4 = !!(Nh3(c5) || qh3(c5) || hr4(c5)), g4 = !!(Uh3(h4) || Dh3(h4) || hr4(h4));
          if (a4 = new vn3({ writableObjectMode: !!(c5 != null && c5.writableObjectMode), readableObjectMode: !!(h4 != null && h4.writableObjectMode), writable: d4, readable: g4 }), d4) {
            if (En3(c5))
              a4._write = function(w3, E4, S3) {
                c5.write(w3, E4) ? S3() : i5 = S3;
              }, a4._final = function(w3) {
                c5.end(), n4 = w3;
              }, c5.on("drain", function() {
                if (i5) {
                  let w3 = i5;
                  i5 = null, w3();
                }
              });
            else if (Bo3(c5)) {
              let E4 = (hr4(c5) ? c5.writable : c5).getWriter();
              a4._write = async function(S3, I3, C3) {
                try {
                  await E4.ready, E4.write(S3).catch(() => {
                  }), C3();
                } catch (R5) {
                  C3(R5);
                }
              }, a4._final = async function(S3) {
                try {
                  await E4.ready, E4.close().catch(() => {
                  }), n4 = S3;
                } catch (I3) {
                  S3(I3);
                }
              };
            }
            let y3 = hr4(h4) ? h4.readable : h4;
            O0(y3, () => {
              if (n4) {
                let w3 = n4;
                n4 = null, w3();
              }
            });
          }
          if (g4) {
            if (En3(h4))
              h4.on("readable", function() {
                if (o4) {
                  let y3 = o4;
                  o4 = null, y3();
                }
              }), h4.on("end", function() {
                a4.push(null);
              }), a4._read = function() {
                for (; ; ) {
                  let y3 = h4.read();
                  if (y3 === null) {
                    o4 = a4._read;
                    return;
                  }
                  if (!a4.push(y3))
                    return;
                }
              };
            else if (Bo3(h4)) {
              let w3 = (hr4(h4) ? h4.readable : h4).getReader();
              a4._read = async function() {
                for (; ; )
                  try {
                    let { value: E4, done: S3 } = await w3.read();
                    if (!a4.push(E4))
                      return;
                    if (S3) {
                      a4.push(null);
                      return;
                    }
                  } catch {
                    return;
                  }
              };
            }
          }
          return a4._destroy = function(y3, w3) {
            !y3 && s4 !== null && (y3 = new B0()), o4 = null, i5 = null, n4 = null, s4 === null ? w3(y3) : (s4 = w3, En3(h4) && C0(h4, y3));
          }, a4;
        };
      });
      Qh3 = M3((IC, xo4) => {
        "use strict";
        v3();
        m3();
        _3();
        var Vh3 = globalThis.AbortController || Hi3().AbortController, { codes: { ERR_INVALID_ARG_VALUE: k0, ERR_INVALID_ARG_TYPE: _i3, ERR_MISSING_ARGS: x0, ERR_OUT_OF_RANGE: M0 }, AbortError: st4 } = Se4(), { validateAbortSignal: dr3, validateInteger: L0, validateObject: pr3 } = fi3(), U0 = ce5().Symbol("kWeak"), { finished: N0 } = vt3(), q0 = Po4(), { addAbortSignalNoValidate: D0 } = ci2(), { isWritable: j0, isNodeStream: F0 } = tt4(), { ArrayPrototypePush: W0, MathFloor: $0, Number: H0, NumberIsNaN: V0, Promise: Wh3, PromiseReject: $h3, PromisePrototypeThen: z0, Symbol: zh3 } = ce5(), Sn3 = zh3("kEmpty"), Hh3 = zh3("kEof");
        function K0(t4, e4) {
          if (e4 != null && pr3(e4, "options"), e4?.signal != null && dr3(e4.signal, "options.signal"), F0(t4) && !j0(t4))
            throw new k0("stream", t4, "must be writable");
          let r4 = q0(this, t4);
          return e4 != null && e4.signal && D0(e4.signal, r4), r4;
        }
        function An3(t4, e4) {
          if (typeof t4 != "function")
            throw new _i3("fn", ["Function", "AsyncFunction"], t4);
          e4 != null && pr3(e4, "options"), e4?.signal != null && dr3(e4.signal, "options.signal");
          let r4 = 1;
          return e4?.concurrency != null && (r4 = $0(e4.concurrency)), L0(r4, "concurrency", 1), async function* () {
            var n4, o4;
            let s4 = new Vh3(), a4 = this, u4 = [], c5 = s4.signal, h4 = { signal: c5 }, d4 = () => s4.abort();
            e4 != null && (n4 = e4.signal) !== null && n4 !== void 0 && n4.aborted && d4(), e4 == null || (o4 = e4.signal) === null || o4 === void 0 || o4.addEventListener("abort", d4);
            let g4, y3, w3 = false;
            function E4() {
              w3 = true;
            }
            async function S3() {
              try {
                for await (let R5 of a4) {
                  var I3;
                  if (w3)
                    return;
                  if (c5.aborted)
                    throw new st4();
                  try {
                    R5 = t4(R5, h4);
                  } catch (U5) {
                    R5 = $h3(U5);
                  }
                  R5 !== Sn3 && (typeof ((I3 = R5) === null || I3 === void 0 ? void 0 : I3.catch) == "function" && R5.catch(E4), u4.push(R5), g4 && (g4(), g4 = null), !w3 && u4.length && u4.length >= r4 && await new Wh3((U5) => {
                    y3 = U5;
                  }));
                }
                u4.push(Hh3);
              } catch (R5) {
                let U5 = $h3(R5);
                z0(U5, void 0, E4), u4.push(U5);
              } finally {
                var C3;
                w3 = true, g4 && (g4(), g4 = null), e4 == null || (C3 = e4.signal) === null || C3 === void 0 || C3.removeEventListener("abort", d4);
              }
            }
            S3();
            try {
              for (; ; ) {
                for (; u4.length > 0; ) {
                  let I3 = await u4[0];
                  if (I3 === Hh3)
                    return;
                  if (c5.aborted)
                    throw new st4();
                  I3 !== Sn3 && (yield I3), u4.shift(), y3 && (y3(), y3 = null);
                }
                await new Wh3((I3) => {
                  g4 = I3;
                });
              }
            } finally {
              s4.abort(), w3 = true, y3 && (y3(), y3 = null);
            }
          }.call(this);
        }
        function G0(t4 = void 0) {
          return t4 != null && pr3(t4, "options"), t4?.signal != null && dr3(t4.signal, "options.signal"), async function* () {
            let r4 = 0;
            for await (let n4 of this) {
              var i5;
              if (t4 != null && (i5 = t4.signal) !== null && i5 !== void 0 && i5.aborted)
                throw new st4({ cause: t4.signal.reason });
              yield [r4++, n4];
            }
          }.call(this);
        }
        async function Kh3(t4, e4 = void 0) {
          for await (let r4 of ko4.call(this, t4, e4))
            return true;
          return false;
        }
        async function Q0(t4, e4 = void 0) {
          if (typeof t4 != "function")
            throw new _i3("fn", ["Function", "AsyncFunction"], t4);
          return !await Kh3.call(this, async (...r4) => !await t4(...r4), e4);
        }
        async function Y0(t4, e4) {
          for await (let r4 of ko4.call(this, t4, e4))
            return r4;
        }
        async function J0(t4, e4) {
          if (typeof t4 != "function")
            throw new _i3("fn", ["Function", "AsyncFunction"], t4);
          async function r4(i5, n4) {
            return await t4(i5, n4), Sn3;
          }
          for await (let i5 of An3.call(this, r4, e4))
            ;
        }
        function ko4(t4, e4) {
          if (typeof t4 != "function")
            throw new _i3("fn", ["Function", "AsyncFunction"], t4);
          async function r4(i5, n4) {
            return await t4(i5, n4) ? i5 : Sn3;
          }
          return An3.call(this, r4, e4);
        }
        var Oo4 = class extends x0 {
          constructor() {
            super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
          }
        };
        async function X0(t4, e4, r4) {
          var i5;
          if (typeof t4 != "function")
            throw new _i3("reducer", ["Function", "AsyncFunction"], t4);
          r4 != null && pr3(r4, "options"), r4?.signal != null && dr3(r4.signal, "options.signal");
          let n4 = arguments.length > 1;
          if (r4 != null && (i5 = r4.signal) !== null && i5 !== void 0 && i5.aborted) {
            let c5 = new st4(void 0, { cause: r4.signal.reason });
            throw this.once("error", () => {
            }), await N0(this.destroy(c5)), c5;
          }
          let o4 = new Vh3(), s4 = o4.signal;
          if (r4 != null && r4.signal) {
            let c5 = { once: true, [U0]: this };
            r4.signal.addEventListener("abort", () => o4.abort(), c5);
          }
          let a4 = false;
          try {
            for await (let c5 of this) {
              var u4;
              if (a4 = true, r4 != null && (u4 = r4.signal) !== null && u4 !== void 0 && u4.aborted)
                throw new st4();
              n4 ? e4 = await t4(e4, c5, { signal: s4 }) : (e4 = c5, n4 = true);
            }
            if (!a4 && !n4)
              throw new Oo4();
          } finally {
            o4.abort();
          }
          return e4;
        }
        async function Z0(t4) {
          t4 != null && pr3(t4, "options"), t4?.signal != null && dr3(t4.signal, "options.signal");
          let e4 = [];
          for await (let i5 of this) {
            var r4;
            if (t4 != null && (r4 = t4.signal) !== null && r4 !== void 0 && r4.aborted)
              throw new st4(void 0, { cause: t4.signal.reason });
            W0(e4, i5);
          }
          return e4;
        }
        function em2(t4, e4) {
          let r4 = An3.call(this, t4, e4);
          return async function* () {
            for await (let n4 of r4)
              yield* n4;
          }.call(this);
        }
        function Gh3(t4) {
          if (t4 = H0(t4), V0(t4))
            return 0;
          if (t4 < 0)
            throw new M0("number", ">= 0", t4);
          return t4;
        }
        function tm2(t4, e4 = void 0) {
          return e4 != null && pr3(e4, "options"), e4?.signal != null && dr3(e4.signal, "options.signal"), t4 = Gh3(t4), async function* () {
            var i5;
            if (e4 != null && (i5 = e4.signal) !== null && i5 !== void 0 && i5.aborted)
              throw new st4();
            for await (let o4 of this) {
              var n4;
              if (e4 != null && (n4 = e4.signal) !== null && n4 !== void 0 && n4.aborted)
                throw new st4();
              t4-- <= 0 && (yield o4);
            }
          }.call(this);
        }
        function rm2(t4, e4 = void 0) {
          return e4 != null && pr3(e4, "options"), e4?.signal != null && dr3(e4.signal, "options.signal"), t4 = Gh3(t4), async function* () {
            var i5;
            if (e4 != null && (i5 = e4.signal) !== null && i5 !== void 0 && i5.aborted)
              throw new st4();
            for await (let o4 of this) {
              var n4;
              if (e4 != null && (n4 = e4.signal) !== null && n4 !== void 0 && n4.aborted)
                throw new st4();
              if (t4-- > 0)
                yield o4;
              else
                return;
            }
          }.call(this);
        }
        xo4.exports.streamReturningOperators = { asIndexedPairs: G0, drop: tm2, filter: ko4, flatMap: em2, map: An3, take: rm2, compose: K0 };
        xo4.exports.promiseReturningOperators = { every: Q0, forEach: J0, reduce: X0, toArray: Z0, some: Kh3, find: Y0 };
      });
      Mo2 = M3((LC, Yh3) => {
        "use strict";
        v3();
        m3();
        _3();
        var { ArrayPrototypePop: im2, Promise: nm2 } = ce5(), { isIterable: sm2, isNodeStream: om, isWebStream: am2 } = tt4(), { pipelineImpl: lm2 } = mn4(), { finished: um2 } = vt3();
        Lo4();
        function fm2(...t4) {
          return new nm2((e4, r4) => {
            let i5, n4, o4 = t4[t4.length - 1];
            if (o4 && typeof o4 == "object" && !om(o4) && !sm2(o4) && !am2(o4)) {
              let s4 = im2(t4);
              i5 = s4.signal, n4 = s4.end;
            }
            lm2(t4, (s4, a4) => {
              s4 ? r4(s4) : e4(a4);
            }, { signal: i5, end: n4 });
          });
        }
        Yh3.exports = { finished: um2, pipeline: fm2 };
      });
      Lo4 = M3((VC, sd2) => {
        v3();
        m3();
        _3();
        var { Buffer: cm2 } = (ye5(), X3(_e5)), { ObjectDefineProperty: Rt4, ObjectKeys: Zh3, ReflectApply: ed2 } = ce5(), { promisify: { custom: td3 } } = Je4(), { streamReturningOperators: Jh3, promiseReturningOperators: Xh3 } = Qh3(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: rd2 } } = Se4(), hm2 = Po4(), { pipeline: id2 } = mn4(), { destroyer: dm2 } = tr4(), nd2 = vt3(), Uo3 = Mo2(), No2 = tt4(), le4 = sd2.exports = tn4().Stream;
        le4.isDisturbed = No2.isDisturbed;
        le4.isErrored = No2.isErrored;
        le4.isReadable = No2.isReadable;
        le4.Readable = di3();
        for (let t4 of Zh3(Jh3)) {
          let r4 = function(...i5) {
            if (new.target)
              throw rd2();
            return le4.Readable.from(ed2(e4, this, i5));
          };
          qo3 = r4;
          let e4 = Jh3[t4];
          Rt4(r4, "name", { __proto__: null, value: e4.name }), Rt4(r4, "length", { __proto__: null, value: e4.length }), Rt4(le4.Readable.prototype, t4, { __proto__: null, value: r4, enumerable: false, configurable: true, writable: true });
        }
        var qo3;
        for (let t4 of Zh3(Xh3)) {
          let r4 = function(...n4) {
            if (new.target)
              throw rd2();
            return ed2(e4, this, n4);
          };
          qo3 = r4;
          let e4 = Xh3[t4];
          Rt4(r4, "name", { __proto__: null, value: e4.name }), Rt4(r4, "length", { __proto__: null, value: e4.length }), Rt4(le4.Readable.prototype, t4, { __proto__: null, value: r4, enumerable: false, configurable: true, writable: true });
        }
        var qo3;
        le4.Writable = fo4();
        le4.Duplex = nt4();
        le4.Transform = wo4();
        le4.PassThrough = mo4();
        le4.pipeline = id2;
        var { addAbortSignal: pm2 } = ci2();
        le4.addAbortSignal = pm2;
        le4.finished = nd2;
        le4.destroy = dm2;
        le4.compose = hm2;
        Rt4(le4, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
          return Uo3;
        } });
        Rt4(id2, td3, { __proto__: null, enumerable: true, get() {
          return Uo3.pipeline;
        } });
        Rt4(nd2, td3, { __proto__: null, enumerable: true, get() {
          return Uo3.finished;
        } });
        le4.Stream = le4;
        le4._isUint8Array = function(e4) {
          return e4 instanceof Uint8Array;
        };
        le4._uint8ArrayToBuffer = function(e4) {
          return cm2.from(e4.buffer, e4.byteOffset, e4.byteLength);
        };
      });
      jt4 = M3((tB, ue4) => {
        "use strict";
        v3();
        m3();
        _3();
        var he3 = Lo4(), gm2 = Mo2(), ym2 = he3.Readable.destroy;
        ue4.exports = he3.Readable;
        ue4.exports._uint8ArrayToBuffer = he3._uint8ArrayToBuffer;
        ue4.exports._isUint8Array = he3._isUint8Array;
        ue4.exports.isDisturbed = he3.isDisturbed;
        ue4.exports.isErrored = he3.isErrored;
        ue4.exports.isReadable = he3.isReadable;
        ue4.exports.Readable = he3.Readable;
        ue4.exports.Writable = he3.Writable;
        ue4.exports.Duplex = he3.Duplex;
        ue4.exports.Transform = he3.Transform;
        ue4.exports.PassThrough = he3.PassThrough;
        ue4.exports.addAbortSignal = he3.addAbortSignal;
        ue4.exports.finished = he3.finished;
        ue4.exports.destroy = he3.destroy;
        ue4.exports.destroy = ym2;
        ue4.exports.pipeline = he3.pipeline;
        ue4.exports.compose = he3.compose;
        Object.defineProperty(he3, "promises", { configurable: true, enumerable: true, get() {
          return gm2;
        } });
        ue4.exports.Stream = he3.Stream;
        ue4.exports.default = ue4.exports;
      });
      od2 = M3((cB, Do3) => {
        v3();
        m3();
        _3();
        typeof Object.create == "function" ? Do3.exports = function(e4, r4) {
          r4 && (e4.super_ = r4, e4.prototype = Object.create(r4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }));
        } : Do3.exports = function(e4, r4) {
          if (r4) {
            e4.super_ = r4;
            var i5 = function() {
            };
            i5.prototype = r4.prototype, e4.prototype = new i5(), e4.prototype.constructor = e4;
          }
        };
      });
      ud2 = M3((vB, ld2) => {
        "use strict";
        v3();
        m3();
        _3();
        var { Buffer: ze3 } = (ye5(), X3(_e5)), ad2 = Symbol.for("BufferList");
        function ee4(t4) {
          if (!(this instanceof ee4))
            return new ee4(t4);
          ee4._init.call(this, t4);
        }
        ee4._init = function(e4) {
          Object.defineProperty(this, ad2, { value: true }), this._bufs = [], this.length = 0, e4 && this.append(e4);
        };
        ee4.prototype._new = function(e4) {
          return new ee4(e4);
        };
        ee4.prototype._offset = function(e4) {
          if (e4 === 0)
            return [0, 0];
          let r4 = 0;
          for (let i5 = 0; i5 < this._bufs.length; i5++) {
            let n4 = r4 + this._bufs[i5].length;
            if (e4 < n4 || i5 === this._bufs.length - 1)
              return [i5, e4 - r4];
            r4 = n4;
          }
        };
        ee4.prototype._reverseOffset = function(t4) {
          let e4 = t4[0], r4 = t4[1];
          for (let i5 = 0; i5 < e4; i5++)
            r4 += this._bufs[i5].length;
          return r4;
        };
        ee4.prototype.get = function(e4) {
          if (e4 > this.length || e4 < 0)
            return;
          let r4 = this._offset(e4);
          return this._bufs[r4[0]][r4[1]];
        };
        ee4.prototype.slice = function(e4, r4) {
          return typeof e4 == "number" && e4 < 0 && (e4 += this.length), typeof r4 == "number" && r4 < 0 && (r4 += this.length), this.copy(null, 0, e4, r4);
        };
        ee4.prototype.copy = function(e4, r4, i5, n4) {
          if ((typeof i5 != "number" || i5 < 0) && (i5 = 0), (typeof n4 != "number" || n4 > this.length) && (n4 = this.length), i5 >= this.length || n4 <= 0)
            return e4 || ze3.alloc(0);
          let o4 = !!e4, s4 = this._offset(i5), a4 = n4 - i5, u4 = a4, c5 = o4 && r4 || 0, h4 = s4[1];
          if (i5 === 0 && n4 === this.length) {
            if (!o4)
              return this._bufs.length === 1 ? this._bufs[0] : ze3.concat(this._bufs, this.length);
            for (let d4 = 0; d4 < this._bufs.length; d4++)
              this._bufs[d4].copy(e4, c5), c5 += this._bufs[d4].length;
            return e4;
          }
          if (u4 <= this._bufs[s4[0]].length - h4)
            return o4 ? this._bufs[s4[0]].copy(e4, r4, h4, h4 + u4) : this._bufs[s4[0]].slice(h4, h4 + u4);
          o4 || (e4 = ze3.allocUnsafe(a4));
          for (let d4 = s4[0]; d4 < this._bufs.length; d4++) {
            let g4 = this._bufs[d4].length - h4;
            if (u4 > g4)
              this._bufs[d4].copy(e4, c5, h4), c5 += g4;
            else {
              this._bufs[d4].copy(e4, c5, h4, h4 + u4), c5 += g4;
              break;
            }
            u4 -= g4, h4 && (h4 = 0);
          }
          return e4.length > c5 ? e4.slice(0, c5) : e4;
        };
        ee4.prototype.shallowSlice = function(e4, r4) {
          if (e4 = e4 || 0, r4 = typeof r4 != "number" ? this.length : r4, e4 < 0 && (e4 += this.length), r4 < 0 && (r4 += this.length), e4 === r4)
            return this._new();
          let i5 = this._offset(e4), n4 = this._offset(r4), o4 = this._bufs.slice(i5[0], n4[0] + 1);
          return n4[1] === 0 ? o4.pop() : o4[o4.length - 1] = o4[o4.length - 1].slice(0, n4[1]), i5[1] !== 0 && (o4[0] = o4[0].slice(i5[1])), this._new(o4);
        };
        ee4.prototype.toString = function(e4, r4, i5) {
          return this.slice(r4, i5).toString(e4);
        };
        ee4.prototype.consume = function(e4) {
          if (e4 = Math.trunc(e4), Number.isNaN(e4) || e4 <= 0)
            return this;
          for (; this._bufs.length; )
            if (e4 >= this._bufs[0].length)
              e4 -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
            else {
              this._bufs[0] = this._bufs[0].slice(e4), this.length -= e4;
              break;
            }
          return this;
        };
        ee4.prototype.duplicate = function() {
          let e4 = this._new();
          for (let r4 = 0; r4 < this._bufs.length; r4++)
            e4.append(this._bufs[r4]);
          return e4;
        };
        ee4.prototype.append = function(e4) {
          if (e4 == null)
            return this;
          if (e4.buffer)
            this._appendBuffer(ze3.from(e4.buffer, e4.byteOffset, e4.byteLength));
          else if (Array.isArray(e4))
            for (let r4 = 0; r4 < e4.length; r4++)
              this.append(e4[r4]);
          else if (this._isBufferList(e4))
            for (let r4 = 0; r4 < e4._bufs.length; r4++)
              this.append(e4._bufs[r4]);
          else
            typeof e4 == "number" && (e4 = e4.toString()), this._appendBuffer(ze3.from(e4));
          return this;
        };
        ee4.prototype._appendBuffer = function(e4) {
          this._bufs.push(e4), this.length += e4.length;
        };
        ee4.prototype.indexOf = function(t4, e4, r4) {
          if (r4 === void 0 && typeof e4 == "string" && (r4 = e4, e4 = void 0), typeof t4 == "function" || Array.isArray(t4))
            throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
          if (typeof t4 == "number" ? t4 = ze3.from([t4]) : typeof t4 == "string" ? t4 = ze3.from(t4, r4) : this._isBufferList(t4) ? t4 = t4.slice() : Array.isArray(t4.buffer) ? t4 = ze3.from(t4.buffer, t4.byteOffset, t4.byteLength) : ze3.isBuffer(t4) || (t4 = ze3.from(t4)), e4 = Number(e4 || 0), isNaN(e4) && (e4 = 0), e4 < 0 && (e4 = this.length + e4), e4 < 0 && (e4 = 0), t4.length === 0)
            return e4 > this.length ? this.length : e4;
          let i5 = this._offset(e4), n4 = i5[0], o4 = i5[1];
          for (; n4 < this._bufs.length; n4++) {
            let s4 = this._bufs[n4];
            for (; o4 < s4.length; )
              if (s4.length - o4 >= t4.length) {
                let u4 = s4.indexOf(t4, o4);
                if (u4 !== -1)
                  return this._reverseOffset([n4, u4]);
                o4 = s4.length - t4.length + 1;
              } else {
                let u4 = this._reverseOffset([n4, o4]);
                if (this._match(u4, t4))
                  return u4;
                o4++;
              }
            o4 = 0;
          }
          return -1;
        };
        ee4.prototype._match = function(t4, e4) {
          if (this.length - t4 < e4.length)
            return false;
          for (let r4 = 0; r4 < e4.length; r4++)
            if (this.get(t4 + r4) !== e4[r4])
              return false;
          return true;
        };
        (function() {
          let t4 = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readBigInt64BE: 8, readBigInt64LE: 8, readBigUInt64BE: 8, readBigUInt64LE: 8, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null };
          for (let e4 in t4)
            (function(r4) {
              t4[r4] === null ? ee4.prototype[r4] = function(i5, n4) {
                return this.slice(i5, i5 + n4)[r4](0, n4);
              } : ee4.prototype[r4] = function(i5 = 0) {
                return this.slice(i5, i5 + t4[r4])[r4](0);
              };
            })(e4);
        })();
        ee4.prototype._isBufferList = function(e4) {
          return e4 instanceof ee4 || ee4.isBufferList(e4);
        };
        ee4.isBufferList = function(e4) {
          return e4 != null && e4[ad2];
        };
        ld2.exports = ee4;
      });
      fd3 = M3((OB, In3) => {
        "use strict";
        v3();
        m3();
        _3();
        var jo4 = jt4().Duplex, bm2 = od2(), mi3 = ud2();
        function Ee4(t4) {
          if (!(this instanceof Ee4))
            return new Ee4(t4);
          if (typeof t4 == "function") {
            this._callback = t4;
            let e4 = function(i5) {
              this._callback && (this._callback(i5), this._callback = null);
            }.bind(this);
            this.on("pipe", function(i5) {
              i5.on("error", e4);
            }), this.on("unpipe", function(i5) {
              i5.removeListener("error", e4);
            }), t4 = null;
          }
          mi3._init.call(this, t4), jo4.call(this);
        }
        bm2(Ee4, jo4);
        Object.assign(Ee4.prototype, mi3.prototype);
        Ee4.prototype._new = function(e4) {
          return new Ee4(e4);
        };
        Ee4.prototype._write = function(e4, r4, i5) {
          this._appendBuffer(e4), typeof i5 == "function" && i5();
        };
        Ee4.prototype._read = function(e4) {
          if (!this.length)
            return this.push(null);
          e4 = Math.min(e4, this.length), this.push(this.slice(0, e4)), this.consume(e4);
        };
        Ee4.prototype.end = function(e4) {
          jo4.prototype.end.call(this, e4), this._callback && (this._callback(null, this.slice()), this._callback = null);
        };
        Ee4.prototype._destroy = function(e4, r4) {
          this._bufs.length = 0, this.length = 0, r4(e4);
        };
        Ee4.prototype._isBufferList = function(e4) {
          return e4 instanceof Ee4 || e4 instanceof mi3 || Ee4.isBufferList(e4);
        };
        Ee4.isBufferList = mi3.isBufferList;
        In3.exports = Ee4;
        In3.exports.BufferListStream = Ee4;
        In3.exports.BufferList = mi3;
      });
      hd2 = M3((FB, cd2) => {
        v3();
        m3();
        _3();
        var Fo4 = class {
          constructor() {
            this.cmd = null, this.retain = false, this.qos = 0, this.dup = false, this.length = -1, this.topic = null, this.payload = null;
          }
        };
        cd2.exports = Fo4;
      });
      Wo2 = M3((JB, dd2) => {
        v3();
        m3();
        _3();
        var L3 = dd2.exports, { Buffer: Oe4 } = (ye5(), X3(_e5));
        L3.types = { 0: "reserved", 1: "connect", 2: "connack", 3: "publish", 4: "puback", 5: "pubrec", 6: "pubrel", 7: "pubcomp", 8: "subscribe", 9: "suback", 10: "unsubscribe", 11: "unsuback", 12: "pingreq", 13: "pingresp", 14: "disconnect", 15: "auth" };
        L3.requiredHeaderFlags = { 1: 0, 2: 0, 4: 0, 5: 0, 6: 2, 7: 0, 8: 2, 9: 0, 10: 2, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0 };
        L3.requiredHeaderFlagsErrors = {};
        for (let t4 in L3.requiredHeaderFlags) {
          let e4 = L3.requiredHeaderFlags[t4];
          L3.requiredHeaderFlagsErrors[t4] = "Invalid header flag bits, must be 0x" + e4.toString(16) + " for " + L3.types[t4] + " packet";
        }
        L3.codes = {};
        for (let t4 in L3.types) {
          let e4 = L3.types[t4];
          L3.codes[e4] = t4;
        }
        L3.CMD_SHIFT = 4;
        L3.CMD_MASK = 240;
        L3.DUP_MASK = 8;
        L3.QOS_MASK = 3;
        L3.QOS_SHIFT = 1;
        L3.RETAIN_MASK = 1;
        L3.VARBYTEINT_MASK = 127;
        L3.VARBYTEINT_FIN_MASK = 128;
        L3.VARBYTEINT_MAX = 268435455;
        L3.SESSIONPRESENT_MASK = 1;
        L3.SESSIONPRESENT_HEADER = Oe4.from([L3.SESSIONPRESENT_MASK]);
        L3.CONNACK_HEADER = Oe4.from([L3.codes.connack << L3.CMD_SHIFT]);
        L3.USERNAME_MASK = 128;
        L3.PASSWORD_MASK = 64;
        L3.WILL_RETAIN_MASK = 32;
        L3.WILL_QOS_MASK = 24;
        L3.WILL_QOS_SHIFT = 3;
        L3.WILL_FLAG_MASK = 4;
        L3.CLEAN_SESSION_MASK = 2;
        L3.CONNECT_HEADER = Oe4.from([L3.codes.connect << L3.CMD_SHIFT]);
        L3.properties = { sessionExpiryInterval: 17, willDelayInterval: 24, receiveMaximum: 33, maximumPacketSize: 39, topicAliasMaximum: 34, requestResponseInformation: 25, requestProblemInformation: 23, userProperties: 38, authenticationMethod: 21, authenticationData: 22, payloadFormatIndicator: 1, messageExpiryInterval: 2, contentType: 3, responseTopic: 8, correlationData: 9, maximumQoS: 36, retainAvailable: 37, assignedClientIdentifier: 18, reasonString: 31, wildcardSubscriptionAvailable: 40, subscriptionIdentifiersAvailable: 41, sharedSubscriptionAvailable: 42, serverKeepAlive: 19, responseInformation: 26, serverReference: 28, topicAlias: 35, subscriptionIdentifier: 11 };
        L3.propertiesCodes = {};
        for (let t4 in L3.properties) {
          let e4 = L3.properties[t4];
          L3.propertiesCodes[e4] = t4;
        }
        L3.propertiesTypes = { sessionExpiryInterval: "int32", willDelayInterval: "int32", receiveMaximum: "int16", maximumPacketSize: "int32", topicAliasMaximum: "int16", requestResponseInformation: "byte", requestProblemInformation: "byte", userProperties: "pair", authenticationMethod: "string", authenticationData: "binary", payloadFormatIndicator: "byte", messageExpiryInterval: "int32", contentType: "string", responseTopic: "string", correlationData: "binary", maximumQoS: "int8", retainAvailable: "byte", assignedClientIdentifier: "string", reasonString: "string", wildcardSubscriptionAvailable: "byte", subscriptionIdentifiersAvailable: "byte", sharedSubscriptionAvailable: "byte", serverKeepAlive: "int16", responseInformation: "string", serverReference: "string", topicAlias: "int16", subscriptionIdentifier: "var" };
        function Ft3(t4) {
          return [0, 1, 2].map((e4) => [0, 1].map((r4) => [0, 1].map((i5) => {
            let n4 = Oe4.alloc(1);
            return n4.writeUInt8(L3.codes[t4] << L3.CMD_SHIFT | (r4 ? L3.DUP_MASK : 0) | e4 << L3.QOS_SHIFT | i5, 0, true), n4;
          })));
        }
        L3.PUBLISH_HEADER = Ft3("publish");
        L3.SUBSCRIBE_HEADER = Ft3("subscribe");
        L3.SUBSCRIBE_OPTIONS_QOS_MASK = 3;
        L3.SUBSCRIBE_OPTIONS_NL_MASK = 1;
        L3.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;
        L3.SUBSCRIBE_OPTIONS_RAP_MASK = 1;
        L3.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;
        L3.SUBSCRIBE_OPTIONS_RH_MASK = 3;
        L3.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;
        L3.SUBSCRIBE_OPTIONS_RH = [0, 16, 32];
        L3.SUBSCRIBE_OPTIONS_NL = 4;
        L3.SUBSCRIBE_OPTIONS_RAP = 8;
        L3.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2];
        L3.UNSUBSCRIBE_HEADER = Ft3("unsubscribe");
        L3.ACKS = { unsuback: Ft3("unsuback"), puback: Ft3("puback"), pubcomp: Ft3("pubcomp"), pubrel: Ft3("pubrel"), pubrec: Ft3("pubrec") };
        L3.SUBACK_HEADER = Oe4.from([L3.codes.suback << L3.CMD_SHIFT]);
        L3.VERSION3 = Oe4.from([3]);
        L3.VERSION4 = Oe4.from([4]);
        L3.VERSION5 = Oe4.from([5]);
        L3.VERSION131 = Oe4.from([131]);
        L3.VERSION132 = Oe4.from([132]);
        L3.QOS = [0, 1, 2].map((t4) => Oe4.from([t4]));
        L3.EMPTY = { pingreq: Oe4.from([L3.codes.pingreq << 4, 0]), pingresp: Oe4.from([L3.codes.pingresp << 4, 0]), disconnect: Oe4.from([L3.codes.disconnect << 4, 0]) };
        L3.MQTT5_PUBACK_PUBREC_CODES = { 0: "Success", 16: "No matching subscribers", 128: "Unspecified error", 131: "Implementation specific error", 135: "Not authorized", 144: "Topic Name invalid", 145: "Packet identifier in use", 151: "Quota exceeded", 153: "Payload format invalid" };
        L3.MQTT5_PUBREL_PUBCOMP_CODES = { 0: "Success", 146: "Packet Identifier not found" };
        L3.MQTT5_SUBACK_CODES = { 0: "Granted QoS 0", 1: "Granted QoS 1", 2: "Granted QoS 2", 128: "Unspecified error", 131: "Implementation specific error", 135: "Not authorized", 143: "Topic Filter invalid", 145: "Packet Identifier in use", 151: "Quota exceeded", 158: "Shared Subscriptions not supported", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
        L3.MQTT5_UNSUBACK_CODES = { 0: "Success", 17: "No subscription existed", 128: "Unspecified error", 131: "Implementation specific error", 135: "Not authorized", 143: "Topic Filter invalid", 145: "Packet Identifier in use" };
        L3.MQTT5_DISCONNECT_CODES = { 0: "Normal disconnection", 4: "Disconnect with Will Message", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 135: "Not authorized", 137: "Server busy", 139: "Server shutting down", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
        L3.MQTT5_AUTH_CODES = { 0: "Success", 24: "Continue authentication", 25: "Re-authenticate" };
      });
      gd2 = M3((aP, pd2) => {
        v3();
        m3();
        _3();
        var Vr4 = 1e3, zr4 = Vr4 * 60, Kr3 = zr4 * 60, gr4 = Kr3 * 24, wm2 = gr4 * 7, _m2 = gr4 * 365.25;
        pd2.exports = function(t4, e4) {
          e4 = e4 || {};
          var r4 = typeof t4;
          if (r4 === "string" && t4.length > 0)
            return mm2(t4);
          if (r4 === "number" && isFinite(t4))
            return e4.long ? Em2(t4) : vm2(t4);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t4));
        };
        function mm2(t4) {
          if (t4 = String(t4), !(t4.length > 100)) {
            var e4 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t4);
            if (e4) {
              var r4 = parseFloat(e4[1]), i5 = (e4[2] || "ms").toLowerCase();
              switch (i5) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return r4 * _m2;
                case "weeks":
                case "week":
                case "w":
                  return r4 * wm2;
                case "days":
                case "day":
                case "d":
                  return r4 * gr4;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return r4 * Kr3;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return r4 * zr4;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return r4 * Vr4;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return r4;
                default:
                  return;
              }
            }
          }
        }
        function vm2(t4) {
          var e4 = Math.abs(t4);
          return e4 >= gr4 ? Math.round(t4 / gr4) + "d" : e4 >= Kr3 ? Math.round(t4 / Kr3) + "h" : e4 >= zr4 ? Math.round(t4 / zr4) + "m" : e4 >= Vr4 ? Math.round(t4 / Vr4) + "s" : t4 + "ms";
        }
        function Em2(t4) {
          var e4 = Math.abs(t4);
          return e4 >= gr4 ? Tn4(t4, e4, gr4, "day") : e4 >= Kr3 ? Tn4(t4, e4, Kr3, "hour") : e4 >= zr4 ? Tn4(t4, e4, zr4, "minute") : e4 >= Vr4 ? Tn4(t4, e4, Vr4, "second") : t4 + " ms";
        }
        function Tn4(t4, e4, r4, i5) {
          var n4 = e4 >= r4 * 1.5;
          return Math.round(t4 / r4) + " " + i5 + (n4 ? "s" : "");
        }
      });
      bd2 = M3((bP, yd2) => {
        v3();
        m3();
        _3();
        function Sm2(t4) {
          r4.debug = r4, r4.default = r4, r4.coerce = u4, r4.disable = o4, r4.enable = n4, r4.enabled = s4, r4.humanize = gd2(), r4.destroy = c5, Object.keys(t4).forEach((h4) => {
            r4[h4] = t4[h4];
          }), r4.names = [], r4.skips = [], r4.formatters = {};
          function e4(h4) {
            let d4 = 0;
            for (let g4 = 0; g4 < h4.length; g4++)
              d4 = (d4 << 5) - d4 + h4.charCodeAt(g4), d4 |= 0;
            return r4.colors[Math.abs(d4) % r4.colors.length];
          }
          r4.selectColor = e4;
          function r4(h4) {
            let d4, g4 = null, y3, w3;
            function E4(...S3) {
              if (!E4.enabled)
                return;
              let I3 = E4, C3 = Number(/* @__PURE__ */ new Date()), R5 = C3 - (d4 || C3);
              I3.diff = R5, I3.prev = d4, I3.curr = C3, d4 = C3, S3[0] = r4.coerce(S3[0]), typeof S3[0] != "string" && S3.unshift("%O");
              let U5 = 0;
              S3[0] = S3[0].replace(/%([a-zA-Z%])/g, (W4, K5) => {
                if (W4 === "%%")
                  return "%";
                U5++;
                let z4 = r4.formatters[K5];
                if (typeof z4 == "function") {
                  let Q3 = S3[U5];
                  W4 = z4.call(I3, Q3), S3.splice(U5, 1), U5--;
                }
                return W4;
              }), r4.formatArgs.call(I3, S3), (I3.log || r4.log).apply(I3, S3);
            }
            return E4.namespace = h4, E4.useColors = r4.useColors(), E4.color = r4.selectColor(h4), E4.extend = i5, E4.destroy = r4.destroy, Object.defineProperty(E4, "enabled", { enumerable: true, configurable: false, get: () => g4 !== null ? g4 : (y3 !== r4.namespaces && (y3 = r4.namespaces, w3 = r4.enabled(h4)), w3), set: (S3) => {
              g4 = S3;
            } }), typeof r4.init == "function" && r4.init(E4), E4;
          }
          function i5(h4, d4) {
            let g4 = r4(this.namespace + (typeof d4 > "u" ? ":" : d4) + h4);
            return g4.log = this.log, g4;
          }
          function n4(h4) {
            r4.save(h4), r4.namespaces = h4, r4.names = [], r4.skips = [];
            let d4, g4 = (typeof h4 == "string" ? h4 : "").split(/[\s,]+/), y3 = g4.length;
            for (d4 = 0; d4 < y3; d4++)
              g4[d4] && (h4 = g4[d4].replace(/\*/g, ".*?"), h4[0] === "-" ? r4.skips.push(new RegExp("^" + h4.slice(1) + "$")) : r4.names.push(new RegExp("^" + h4 + "$")));
          }
          function o4() {
            let h4 = [...r4.names.map(a4), ...r4.skips.map(a4).map((d4) => "-" + d4)].join(",");
            return r4.enable(""), h4;
          }
          function s4(h4) {
            if (h4[h4.length - 1] === "*")
              return true;
            let d4, g4;
            for (d4 = 0, g4 = r4.skips.length; d4 < g4; d4++)
              if (r4.skips[d4].test(h4))
                return false;
            for (d4 = 0, g4 = r4.names.length; d4 < g4; d4++)
              if (r4.names[d4].test(h4))
                return true;
            return false;
          }
          function a4(h4) {
            return h4.toString().substring(2, h4.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function u4(h4) {
            return h4 instanceof Error ? h4.stack || h4.message : h4;
          }
          function c5() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          return r4.enable(r4.load()), r4;
        }
        yd2.exports = Sm2;
      });
      ot3 = M3((xe5, Rn4) => {
        v3();
        m3();
        _3();
        xe5.formatArgs = Im2;
        xe5.save = Tm2;
        xe5.load = Rm2;
        xe5.useColors = Am2;
        xe5.storage = Cm2();
        xe5.destroy = /* @__PURE__ */ (() => {
          let t4 = false;
          return () => {
            t4 || (t4 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })();
        xe5.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function Am2() {
          return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof B4 < "u" && B4.userAgent && B4.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof B4 < "u" && B4.userAgent && B4.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof B4 < "u" && B4.userAgent && B4.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function Im2(t4) {
          if (t4[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t4[0] + (this.useColors ? "%c " : " ") + "+" + Rn4.exports.humanize(this.diff), !this.useColors)
            return;
          let e4 = "color: " + this.color;
          t4.splice(1, 0, e4, "color: inherit");
          let r4 = 0, i5 = 0;
          t4[0].replace(/%[a-zA-Z%]/g, (n4) => {
            n4 !== "%%" && (r4++, n4 === "%c" && (i5 = r4));
          }), t4.splice(i5, 0, e4);
        }
        xe5.log = console.debug || console.log || (() => {
        });
        function Tm2(t4) {
          try {
            t4 ? xe5.storage.setItem("debug", t4) : xe5.storage.removeItem("debug");
          } catch {
          }
        }
        function Rm2() {
          let t4;
          try {
            t4 = xe5.storage.getItem("debug");
          } catch {
          }
          return !t4 && typeof P3 < "u" && "env" in P3 && (t4 = P3.env.DEBUG), t4;
        }
        function Cm2() {
          try {
            return localStorage;
          } catch {
          }
        }
        Rn4.exports = bd2()(xe5);
        var { formatters: Bm2 } = Rn4.exports;
        Bm2.j = function(t4) {
          try {
            return JSON.stringify(t4);
          } catch (e4) {
            return "[UnexpectedJSONParseError]: " + e4.message;
          }
        };
      });
      md2 = M3((UP, _d) => {
        v3();
        m3();
        _3();
        var Pm2 = fd3(), { EventEmitter: Om2 } = (ir3(), X3(rr3)), wd = hd2(), V4 = Wo2(), D3 = ot3()("mqtt-packet:parser"), $o3 = class t4 extends Om2 {
          constructor() {
            super(), this.parser = this.constructor.parser;
          }
          static parser(e4) {
            return this instanceof t4 ? (this.settings = e4 || {}, this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState(), this) : new t4().parser(e4);
          }
          _resetState() {
            D3("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new wd(), this.error = null, this._list = Pm2(), this._stateCounter = 0;
          }
          parse(e4) {
            for (this.error && this._resetState(), this._list.append(e4), D3("parse: current state: %s", this._states[this._stateCounter]); (this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error; )
              this._stateCounter++, D3("parse: state complete. _stateCounter is now: %d", this._stateCounter), D3("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), this._stateCounter >= this._states.length && (this._stateCounter = 0);
            return D3("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), this._list.length;
          }
          _parseHeader() {
            let e4 = this._list.readUInt8(0), r4 = e4 >> V4.CMD_SHIFT;
            this.packet.cmd = V4.types[r4];
            let i5 = e4 & 15, n4 = V4.requiredHeaderFlags[r4];
            return n4 != null && i5 !== n4 ? this._emitError(new Error(V4.requiredHeaderFlagsErrors[r4])) : (this.packet.retain = (e4 & V4.RETAIN_MASK) !== 0, this.packet.qos = e4 >> V4.QOS_SHIFT & V4.QOS_MASK, this.packet.qos > 2 ? this._emitError(new Error("Packet must not have both QoS bits set to 1")) : (this.packet.dup = (e4 & V4.DUP_MASK) !== 0, D3("_parseHeader: packet: %o", this.packet), this._list.consume(1), true));
          }
          _parseLength() {
            let e4 = this._parseVarByteNum(true);
            return e4 && (this.packet.length = e4.value, this._list.consume(e4.bytes)), D3("_parseLength %d", e4.value), !!e4;
          }
          _parsePayload() {
            D3("_parsePayload: payload %O", this._list);
            let e4 = false;
            if (this.packet.length === 0 || this._list.length >= this.packet.length) {
              switch (this._pos = 0, this.packet.cmd) {
                case "connect":
                  this._parseConnect();
                  break;
                case "connack":
                  this._parseConnack();
                  break;
                case "publish":
                  this._parsePublish();
                  break;
                case "puback":
                case "pubrec":
                case "pubrel":
                case "pubcomp":
                  this._parseConfirmation();
                  break;
                case "subscribe":
                  this._parseSubscribe();
                  break;
                case "suback":
                  this._parseSuback();
                  break;
                case "unsubscribe":
                  this._parseUnsubscribe();
                  break;
                case "unsuback":
                  this._parseUnsuback();
                  break;
                case "pingreq":
                case "pingresp":
                  break;
                case "disconnect":
                  this._parseDisconnect();
                  break;
                case "auth":
                  this._parseAuth();
                  break;
                default:
                  this._emitError(new Error("Not supported"));
              }
              e4 = true;
            }
            return D3("_parsePayload complete result: %s", e4), e4;
          }
          _parseConnect() {
            D3("_parseConnect");
            let e4, r4, i5, n4, o4 = {}, s4 = this.packet, a4 = this._parseString();
            if (a4 === null)
              return this._emitError(new Error("Cannot parse protocolId"));
            if (a4 !== "MQTT" && a4 !== "MQIsdp")
              return this._emitError(new Error("Invalid protocolId"));
            if (s4.protocolId = a4, this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            if (s4.protocolVersion = this._list.readUInt8(this._pos), s4.protocolVersion >= 128 && (s4.bridgeMode = true, s4.protocolVersion = s4.protocolVersion - 128), s4.protocolVersion !== 3 && s4.protocolVersion !== 4 && s4.protocolVersion !== 5)
              return this._emitError(new Error("Invalid protocol version"));
            if (this._pos++, this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            if (this._list.readUInt8(this._pos) & 1)
              return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));
            o4.username = this._list.readUInt8(this._pos) & V4.USERNAME_MASK, o4.password = this._list.readUInt8(this._pos) & V4.PASSWORD_MASK, o4.will = this._list.readUInt8(this._pos) & V4.WILL_FLAG_MASK;
            let u4 = !!(this._list.readUInt8(this._pos) & V4.WILL_RETAIN_MASK), c5 = (this._list.readUInt8(this._pos) & V4.WILL_QOS_MASK) >> V4.WILL_QOS_SHIFT;
            if (o4.will)
              s4.will = {}, s4.will.retain = u4, s4.will.qos = c5;
            else {
              if (u4)
                return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));
              if (c5)
                return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"));
            }
            if (s4.clean = (this._list.readUInt8(this._pos) & V4.CLEAN_SESSION_MASK) !== 0, this._pos++, s4.keepalive = this._parseNum(), s4.keepalive === -1)
              return this._emitError(new Error("Packet too short"));
            if (s4.protocolVersion === 5) {
              let d4 = this._parseProperties();
              Object.getOwnPropertyNames(d4).length && (s4.properties = d4);
            }
            let h4 = this._parseString();
            if (h4 === null)
              return this._emitError(new Error("Packet too short"));
            if (s4.clientId = h4, D3("_parseConnect: packet.clientId: %s", s4.clientId), o4.will) {
              if (s4.protocolVersion === 5) {
                let d4 = this._parseProperties();
                Object.getOwnPropertyNames(d4).length && (s4.will.properties = d4);
              }
              if (e4 = this._parseString(), e4 === null)
                return this._emitError(new Error("Cannot parse will topic"));
              if (s4.will.topic = e4, D3("_parseConnect: packet.will.topic: %s", s4.will.topic), r4 = this._parseBuffer(), r4 === null)
                return this._emitError(new Error("Cannot parse will payload"));
              s4.will.payload = r4, D3("_parseConnect: packet.will.paylaod: %s", s4.will.payload);
            }
            if (o4.username) {
              if (n4 = this._parseString(), n4 === null)
                return this._emitError(new Error("Cannot parse username"));
              s4.username = n4, D3("_parseConnect: packet.username: %s", s4.username);
            }
            if (o4.password) {
              if (i5 = this._parseBuffer(), i5 === null)
                return this._emitError(new Error("Cannot parse password"));
              s4.password = i5;
            }
            return this.settings = s4, D3("_parseConnect: complete"), s4;
          }
          _parseConnack() {
            D3("_parseConnack");
            let e4 = this.packet;
            if (this._list.length < 1)
              return null;
            let r4 = this._list.readUInt8(this._pos++);
            if (r4 > 1)
              return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));
            if (e4.sessionPresent = !!(r4 & V4.SESSIONPRESENT_MASK), this.settings.protocolVersion === 5)
              this._list.length >= 2 ? e4.reasonCode = this._list.readUInt8(this._pos++) : e4.reasonCode = 0;
            else {
              if (this._list.length < 2)
                return null;
              e4.returnCode = this._list.readUInt8(this._pos++);
            }
            if (e4.returnCode === -1 || e4.reasonCode === -1)
              return this._emitError(new Error("Cannot parse return code"));
            if (this.settings.protocolVersion === 5) {
              let i5 = this._parseProperties();
              Object.getOwnPropertyNames(i5).length && (e4.properties = i5);
            }
            D3("_parseConnack: complete");
          }
          _parsePublish() {
            D3("_parsePublish");
            let e4 = this.packet;
            if (e4.topic = this._parseString(), e4.topic === null)
              return this._emitError(new Error("Cannot parse topic"));
            if (!(e4.qos > 0 && !this._parseMessageId())) {
              if (this.settings.protocolVersion === 5) {
                let r4 = this._parseProperties();
                Object.getOwnPropertyNames(r4).length && (e4.properties = r4);
              }
              e4.payload = this._list.slice(this._pos, e4.length), D3("_parsePublish: payload from buffer list: %o", e4.payload);
            }
          }
          _parseSubscribe() {
            D3("_parseSubscribe");
            let e4 = this.packet, r4, i5, n4, o4, s4, a4, u4;
            if (e4.subscriptions = [], !!this._parseMessageId()) {
              if (this.settings.protocolVersion === 5) {
                let c5 = this._parseProperties();
                Object.getOwnPropertyNames(c5).length && (e4.properties = c5);
              }
              if (e4.length <= 0)
                return this._emitError(new Error("Malformed subscribe, no payload specified"));
              for (; this._pos < e4.length; ) {
                if (r4 = this._parseString(), r4 === null)
                  return this._emitError(new Error("Cannot parse topic"));
                if (this._pos >= e4.length)
                  return this._emitError(new Error("Malformed Subscribe Payload"));
                if (i5 = this._parseByte(), this.settings.protocolVersion === 5) {
                  if (i5 & 192)
                    return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"));
                } else if (i5 & 252)
                  return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));
                if (n4 = i5 & V4.SUBSCRIBE_OPTIONS_QOS_MASK, n4 > 2)
                  return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));
                if (a4 = (i5 >> V4.SUBSCRIBE_OPTIONS_NL_SHIFT & V4.SUBSCRIBE_OPTIONS_NL_MASK) !== 0, s4 = (i5 >> V4.SUBSCRIBE_OPTIONS_RAP_SHIFT & V4.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0, o4 = i5 >> V4.SUBSCRIBE_OPTIONS_RH_SHIFT & V4.SUBSCRIBE_OPTIONS_RH_MASK, o4 > 2)
                  return this._emitError(new Error("Invalid retain handling, must be <= 2"));
                u4 = { topic: r4, qos: n4 }, this.settings.protocolVersion === 5 ? (u4.nl = a4, u4.rap = s4, u4.rh = o4) : this.settings.bridgeMode && (u4.rh = 0, u4.rap = true, u4.nl = true), D3("_parseSubscribe: push subscription `%s` to subscription", u4), e4.subscriptions.push(u4);
              }
            }
          }
          _parseSuback() {
            D3("_parseSuback");
            let e4 = this.packet;
            if (this.packet.granted = [], !!this._parseMessageId()) {
              if (this.settings.protocolVersion === 5) {
                let r4 = this._parseProperties();
                Object.getOwnPropertyNames(r4).length && (e4.properties = r4);
              }
              if (e4.length <= 0)
                return this._emitError(new Error("Malformed suback, no payload specified"));
              for (; this._pos < this.packet.length; ) {
                let r4 = this._list.readUInt8(this._pos++);
                if (this.settings.protocolVersion === 5) {
                  if (!V4.MQTT5_SUBACK_CODES[r4])
                    return this._emitError(new Error("Invalid suback code"));
                } else if (r4 > 2 && r4 !== 128)
                  return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));
                this.packet.granted.push(r4);
              }
            }
          }
          _parseUnsubscribe() {
            D3("_parseUnsubscribe");
            let e4 = this.packet;
            if (e4.unsubscriptions = [], !!this._parseMessageId()) {
              if (this.settings.protocolVersion === 5) {
                let r4 = this._parseProperties();
                Object.getOwnPropertyNames(r4).length && (e4.properties = r4);
              }
              if (e4.length <= 0)
                return this._emitError(new Error("Malformed unsubscribe, no payload specified"));
              for (; this._pos < e4.length; ) {
                let r4 = this._parseString();
                if (r4 === null)
                  return this._emitError(new Error("Cannot parse topic"));
                D3("_parseUnsubscribe: push topic `%s` to unsubscriptions", r4), e4.unsubscriptions.push(r4);
              }
            }
          }
          _parseUnsuback() {
            D3("_parseUnsuback");
            let e4 = this.packet;
            if (!this._parseMessageId())
              return this._emitError(new Error("Cannot parse messageId"));
            if ((this.settings.protocolVersion === 3 || this.settings.protocolVersion === 4) && e4.length !== 2)
              return this._emitError(new Error("Malformed unsuback, payload length must be 2"));
            if (e4.length <= 0)
              return this._emitError(new Error("Malformed unsuback, no payload specified"));
            if (this.settings.protocolVersion === 5) {
              let r4 = this._parseProperties();
              for (Object.getOwnPropertyNames(r4).length && (e4.properties = r4), e4.granted = []; this._pos < this.packet.length; ) {
                let i5 = this._list.readUInt8(this._pos++);
                if (!V4.MQTT5_UNSUBACK_CODES[i5])
                  return this._emitError(new Error("Invalid unsuback code"));
                this.packet.granted.push(i5);
              }
            }
          }
          _parseConfirmation() {
            D3("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
            let e4 = this.packet;
            if (this._parseMessageId(), this.settings.protocolVersion === 5) {
              if (e4.length > 2) {
                switch (e4.reasonCode = this._parseByte(), this.packet.cmd) {
                  case "puback":
                  case "pubrec":
                    if (!V4.MQTT5_PUBACK_PUBREC_CODES[e4.reasonCode])
                      return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                    break;
                  case "pubrel":
                  case "pubcomp":
                    if (!V4.MQTT5_PUBREL_PUBCOMP_CODES[e4.reasonCode])
                      return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                    break;
                }
                D3("_parseConfirmation: packet.reasonCode `%d`", e4.reasonCode);
              } else
                e4.reasonCode = 0;
              if (e4.length > 3) {
                let r4 = this._parseProperties();
                Object.getOwnPropertyNames(r4).length && (e4.properties = r4);
              }
            }
            return true;
          }
          _parseDisconnect() {
            let e4 = this.packet;
            if (D3("_parseDisconnect"), this.settings.protocolVersion === 5) {
              this._list.length > 0 ? (e4.reasonCode = this._parseByte(), V4.MQTT5_DISCONNECT_CODES[e4.reasonCode] || this._emitError(new Error("Invalid disconnect reason code"))) : e4.reasonCode = 0;
              let r4 = this._parseProperties();
              Object.getOwnPropertyNames(r4).length && (e4.properties = r4);
            }
            return D3("_parseDisconnect result: true"), true;
          }
          _parseAuth() {
            D3("_parseAuth");
            let e4 = this.packet;
            if (this.settings.protocolVersion !== 5)
              return this._emitError(new Error("Not supported auth packet for this version MQTT"));
            if (e4.reasonCode = this._parseByte(), !V4.MQTT5_AUTH_CODES[e4.reasonCode])
              return this._emitError(new Error("Invalid auth reason code"));
            let r4 = this._parseProperties();
            return Object.getOwnPropertyNames(r4).length && (e4.properties = r4), D3("_parseAuth: result: true"), true;
          }
          _parseMessageId() {
            let e4 = this.packet;
            return e4.messageId = this._parseNum(), e4.messageId === null ? (this._emitError(new Error("Cannot parse messageId")), false) : (D3("_parseMessageId: packet.messageId %d", e4.messageId), true);
          }
          _parseString(e4) {
            let r4 = this._parseNum(), i5 = r4 + this._pos;
            if (r4 === -1 || i5 > this._list.length || i5 > this.packet.length)
              return null;
            let n4 = this._list.toString("utf8", this._pos, i5);
            return this._pos += r4, D3("_parseString: result: %s", n4), n4;
          }
          _parseStringPair() {
            return D3("_parseStringPair"), { name: this._parseString(), value: this._parseString() };
          }
          _parseBuffer() {
            let e4 = this._parseNum(), r4 = e4 + this._pos;
            if (e4 === -1 || r4 > this._list.length || r4 > this.packet.length)
              return null;
            let i5 = this._list.slice(this._pos, r4);
            return this._pos += e4, D3("_parseBuffer: result: %o", i5), i5;
          }
          _parseNum() {
            if (this._list.length - this._pos < 2)
              return -1;
            let e4 = this._list.readUInt16BE(this._pos);
            return this._pos += 2, D3("_parseNum: result: %s", e4), e4;
          }
          _parse4ByteNum() {
            if (this._list.length - this._pos < 4)
              return -1;
            let e4 = this._list.readUInt32BE(this._pos);
            return this._pos += 4, D3("_parse4ByteNum: result: %s", e4), e4;
          }
          _parseVarByteNum(e4) {
            D3("_parseVarByteNum");
            let r4 = 4, i5 = 0, n4 = 1, o4 = 0, s4 = false, a4, u4 = this._pos ? this._pos : 0;
            for (; i5 < r4 && u4 + i5 < this._list.length; ) {
              if (a4 = this._list.readUInt8(u4 + i5++), o4 += n4 * (a4 & V4.VARBYTEINT_MASK), n4 *= 128, !(a4 & V4.VARBYTEINT_FIN_MASK)) {
                s4 = true;
                break;
              }
              if (this._list.length <= i5)
                break;
            }
            return !s4 && i5 === r4 && this._list.length >= i5 && this._emitError(new Error("Invalid variable byte integer")), u4 && (this._pos += i5), s4 ? e4 ? s4 = { bytes: i5, value: o4 } : s4 = o4 : s4 = false, D3("_parseVarByteNum: result: %o", s4), s4;
          }
          _parseByte() {
            let e4;
            return this._pos < this._list.length && (e4 = this._list.readUInt8(this._pos), this._pos++), D3("_parseByte: result: %o", e4), e4;
          }
          _parseByType(e4) {
            switch (D3("_parseByType: type: %s", e4), e4) {
              case "byte":
                return this._parseByte() !== 0;
              case "int8":
                return this._parseByte();
              case "int16":
                return this._parseNum();
              case "int32":
                return this._parse4ByteNum();
              case "var":
                return this._parseVarByteNum();
              case "string":
                return this._parseString();
              case "pair":
                return this._parseStringPair();
              case "binary":
                return this._parseBuffer();
            }
          }
          _parseProperties() {
            D3("_parseProperties");
            let e4 = this._parseVarByteNum(), i5 = this._pos + e4, n4 = {};
            for (; this._pos < i5; ) {
              let o4 = this._parseByte();
              if (!o4)
                return this._emitError(new Error("Cannot parse property code type")), false;
              let s4 = V4.propertiesCodes[o4];
              if (!s4)
                return this._emitError(new Error("Unknown property")), false;
              if (s4 === "userProperties") {
                n4[s4] || (n4[s4] = /* @__PURE__ */ Object.create(null));
                let a4 = this._parseByType(V4.propertiesTypes[s4]);
                if (n4[s4][a4.name])
                  if (Array.isArray(n4[s4][a4.name]))
                    n4[s4][a4.name].push(a4.value);
                  else {
                    let u4 = n4[s4][a4.name];
                    n4[s4][a4.name] = [u4], n4[s4][a4.name].push(a4.value);
                  }
                else
                  n4[s4][a4.name] = a4.value;
                continue;
              }
              n4[s4] ? Array.isArray(n4[s4]) ? n4[s4].push(this._parseByType(V4.propertiesTypes[s4])) : (n4[s4] = [n4[s4]], n4[s4].push(this._parseByType(V4.propertiesTypes[s4]))) : n4[s4] = this._parseByType(V4.propertiesTypes[s4]);
            }
            return n4;
          }
          _newPacket() {
            return D3("_newPacket"), this.packet && (this._list.consume(this.packet.length), D3("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), this.emit("packet", this.packet)), D3("_newPacket: new packet"), this.packet = new wd(), this._pos = 0, true;
          }
          _emitError(e4) {
            D3("_emitError", e4), this.error = e4, this.emit("error", e4);
          }
        };
        _d.exports = $o3;
      });
      Ad2 = M3((zP, Sd2) => {
        v3();
        m3();
        _3();
        var { Buffer: vi3 } = (ye5(), X3(_e5)), km2 = 65536, vd = {}, xm2 = vi3.isBuffer(vi3.from([1, 2]).subarray(0, 1));
        function Ed2(t4) {
          let e4 = vi3.allocUnsafe(2);
          return e4.writeUInt8(t4 >> 8, 0), e4.writeUInt8(t4 & 255, 0 + 1), e4;
        }
        function Mm2() {
          for (let t4 = 0; t4 < km2; t4++)
            vd[t4] = Ed2(t4);
        }
        function Lm2(t4) {
          let r4 = 0, i5 = 0, n4 = vi3.allocUnsafe(4);
          do
            r4 = t4 % 128 | 0, t4 = t4 / 128 | 0, t4 > 0 && (r4 = r4 | 128), n4.writeUInt8(r4, i5++);
          while (t4 > 0 && i5 < 4);
          return t4 > 0 && (i5 = 0), xm2 ? n4.subarray(0, i5) : n4.slice(0, i5);
        }
        function Um2(t4) {
          let e4 = vi3.allocUnsafe(4);
          return e4.writeUInt32BE(t4, 0), e4;
        }
        Sd2.exports = { cache: vd, generateCache: Mm2, generateNumber: Ed2, genBufVariableByteInt: Lm2, generate4ByteBuffer: Um2 };
      });
      Id = M3((rO, Ho3) => {
        "use strict";
        v3();
        m3();
        _3();
        typeof P3 > "u" || !P3.version || P3.version.indexOf("v0.") === 0 || P3.version.indexOf("v1.") === 0 && P3.version.indexOf("v1.8.") !== 0 ? Ho3.exports = { nextTick: Nm2 } : Ho3.exports = P3;
        function Nm2(t4, e4, r4, i5) {
          if (typeof t4 != "function")
            throw new TypeError('"callback" argument must be a function');
          var n4 = arguments.length, o4, s4;
          switch (n4) {
            case 0:
            case 1:
              return P3.nextTick(t4);
            case 2:
              return P3.nextTick(function() {
                t4.call(null, e4);
              });
            case 3:
              return P3.nextTick(function() {
                t4.call(null, e4, r4);
              });
            case 4:
              return P3.nextTick(function() {
                t4.call(null, e4, r4, i5);
              });
            default:
              for (o4 = new Array(n4 - 1), s4 = 0; s4 < o4.length; )
                o4[s4++] = arguments[s4];
              return P3.nextTick(function() {
                t4.apply(null, o4);
              });
          }
        }
      });
      Ko3 = M3((hO, xd) => {
        v3();
        m3();
        _3();
        var j4 = Wo2(), { Buffer: q4 } = (ye5(), X3(_e5)), qm2 = q4.allocUnsafe(0), Dm2 = q4.from([0]), Ei3 = Ad2(), jm2 = Id().nextTick, qe3 = ot3()("mqtt-packet:writeToStream"), Cn4 = Ei3.cache, Fm2 = Ei3.generateNumber, Wm2 = Ei3.generateCache, Vo3 = Ei3.genBufVariableByteInt, $m2 = Ei3.generate4ByteBuffer, Ie3 = zo2, Bn4 = true;
        function Od(t4, e4, r4) {
          switch (qe3("generate called"), e4.cork && (e4.cork(), jm2(Hm2, e4)), Bn4 && (Bn4 = false, Wm2()), qe3("generate: packet.cmd: %s", t4.cmd), t4.cmd) {
            case "connect":
              return Vm2(t4, e4, r4);
            case "connack":
              return zm2(t4, e4, r4);
            case "publish":
              return Km2(t4, e4, r4);
            case "puback":
            case "pubrec":
            case "pubrel":
            case "pubcomp":
              return Gm2(t4, e4, r4);
            case "subscribe":
              return Qm2(t4, e4, r4);
            case "suback":
              return Ym2(t4, e4, r4);
            case "unsubscribe":
              return Jm2(t4, e4, r4);
            case "unsuback":
              return Xm2(t4, e4, r4);
            case "pingreq":
            case "pingresp":
              return Zm2(t4, e4, r4);
            case "disconnect":
              return e1(t4, e4, r4);
            case "auth":
              return t1(t4, e4, r4);
            default:
              return e4.destroy(new Error("Unknown command")), false;
          }
        }
        Object.defineProperty(Od, "cacheNumbers", { get() {
          return Ie3 === zo2;
        }, set(t4) {
          t4 ? ((!Cn4 || Object.keys(Cn4).length === 0) && (Bn4 = true), Ie3 = zo2) : (Bn4 = false, Ie3 = r1);
        } });
        function Hm2(t4) {
          t4.uncork();
        }
        function Vm2(t4, e4, r4) {
          let i5 = t4 || {}, n4 = i5.protocolId || "MQTT", o4 = i5.protocolVersion || 4, s4 = i5.will, a4 = i5.clean, u4 = i5.keepalive || 0, c5 = i5.clientId || "", h4 = i5.username, d4 = i5.password, g4 = i5.properties;
          a4 === void 0 && (a4 = true);
          let y3 = 0;
          if (!n4 || typeof n4 != "string" && !q4.isBuffer(n4))
            return e4.destroy(new Error("Invalid protocolId")), false;
          if (y3 += n4.length + 2, o4 !== 3 && o4 !== 4 && o4 !== 5)
            return e4.destroy(new Error("Invalid protocol version")), false;
          if (y3 += 1, (typeof c5 == "string" || q4.isBuffer(c5)) && (c5 || o4 >= 4) && (c5 || a4))
            y3 += q4.byteLength(c5) + 2;
          else {
            if (o4 < 4)
              return e4.destroy(new Error("clientId must be supplied before 3.1.1")), false;
            if (a4 * 1 === 0)
              return e4.destroy(new Error("clientId must be given if cleanSession set to 0")), false;
          }
          if (typeof u4 != "number" || u4 < 0 || u4 > 65535 || u4 % 1 !== 0)
            return e4.destroy(new Error("Invalid keepalive")), false;
          y3 += 2, y3 += 1;
          let w3, E4;
          if (o4 === 5) {
            if (w3 = Wt4(e4, g4), !w3)
              return false;
            y3 += w3.length;
          }
          if (s4) {
            if (typeof s4 != "object")
              return e4.destroy(new Error("Invalid will")), false;
            if (!s4.topic || typeof s4.topic != "string")
              return e4.destroy(new Error("Invalid will topic")), false;
            if (y3 += q4.byteLength(s4.topic) + 2, y3 += 2, s4.payload)
              if (s4.payload.length >= 0)
                typeof s4.payload == "string" ? y3 += q4.byteLength(s4.payload) : y3 += s4.payload.length;
              else
                return e4.destroy(new Error("Invalid will payload")), false;
            if (E4 = {}, o4 === 5) {
              if (E4 = Wt4(e4, s4.properties), !E4)
                return false;
              y3 += E4.length;
            }
          }
          let S3 = false;
          if (h4 != null)
            if (Pd2(h4))
              S3 = true, y3 += q4.byteLength(h4) + 2;
            else
              return e4.destroy(new Error("Invalid username")), false;
          if (d4 != null) {
            if (!S3)
              return e4.destroy(new Error("Username is required to use password")), false;
            if (Pd2(d4))
              y3 += kd2(d4) + 2;
            else
              return e4.destroy(new Error("Invalid password")), false;
          }
          e4.write(j4.CONNECT_HEADER), De4(e4, y3), Gr4(e4, n4), i5.bridgeMode && (o4 += 128), e4.write(o4 === 131 ? j4.VERSION131 : o4 === 132 ? j4.VERSION132 : o4 === 4 ? j4.VERSION4 : o4 === 5 ? j4.VERSION5 : j4.VERSION3);
          let I3 = 0;
          return I3 |= h4 != null ? j4.USERNAME_MASK : 0, I3 |= d4 != null ? j4.PASSWORD_MASK : 0, I3 |= s4 && s4.retain ? j4.WILL_RETAIN_MASK : 0, I3 |= s4 && s4.qos ? s4.qos << j4.WILL_QOS_SHIFT : 0, I3 |= s4 ? j4.WILL_FLAG_MASK : 0, I3 |= a4 ? j4.CLEAN_SESSION_MASK : 0, e4.write(q4.from([I3])), Ie3(e4, u4), o4 === 5 && w3.write(), Gr4(e4, c5), s4 && (o4 === 5 && E4.write(), yr4(e4, s4.topic), Gr4(e4, s4.payload)), h4 != null && Gr4(e4, h4), d4 != null && Gr4(e4, d4), true;
        }
        function zm2(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = i5 === 5 ? n4.reasonCode : n4.returnCode, s4 = n4.properties, a4 = 2;
          if (typeof o4 != "number")
            return e4.destroy(new Error("Invalid return code")), false;
          let u4 = null;
          if (i5 === 5) {
            if (u4 = Wt4(e4, s4), !u4)
              return false;
            a4 += u4.length;
          }
          return e4.write(j4.CONNACK_HEADER), De4(e4, a4), e4.write(n4.sessionPresent ? j4.SESSIONPRESENT_HEADER : Dm2), e4.write(q4.from([o4])), u4?.write(), true;
        }
        function Km2(t4, e4, r4) {
          qe3("publish: packet: %o", t4);
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.qos || 0, s4 = n4.retain ? j4.RETAIN_MASK : 0, a4 = n4.topic, u4 = n4.payload || qm2, c5 = n4.messageId, h4 = n4.properties, d4 = 0;
          if (typeof a4 == "string")
            d4 += q4.byteLength(a4) + 2;
          else if (q4.isBuffer(a4))
            d4 += a4.length + 2;
          else
            return e4.destroy(new Error("Invalid topic")), false;
          if (q4.isBuffer(u4) ? d4 += u4.length : d4 += q4.byteLength(u4), o4 && typeof c5 != "number")
            return e4.destroy(new Error("Invalid messageId")), false;
          o4 && (d4 += 2);
          let g4 = null;
          if (i5 === 5) {
            if (g4 = Wt4(e4, h4), !g4)
              return false;
            d4 += g4.length;
          }
          return e4.write(j4.PUBLISH_HEADER[o4][n4.dup ? 1 : 0][s4 ? 1 : 0]), De4(e4, d4), Ie3(e4, kd2(a4)), e4.write(a4), o4 > 0 && Ie3(e4, c5), g4?.write(), qe3("publish: payload: %o", u4), e4.write(u4);
        }
        function Gm2(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.cmd || "puback", s4 = n4.messageId, a4 = n4.dup && o4 === "pubrel" ? j4.DUP_MASK : 0, u4 = 0, c5 = n4.reasonCode, h4 = n4.properties, d4 = i5 === 5 ? 3 : 2;
          if (o4 === "pubrel" && (u4 = 1), typeof s4 != "number")
            return e4.destroy(new Error("Invalid messageId")), false;
          let g4 = null;
          if (i5 === 5 && typeof h4 == "object") {
            if (g4 = Si3(e4, h4, r4, d4), !g4)
              return false;
            d4 += g4.length;
          }
          return e4.write(j4.ACKS[o4][u4][a4][0]), d4 === 3 && (d4 += c5 !== 0 ? 1 : -1), De4(e4, d4), Ie3(e4, s4), i5 === 5 && d4 !== 2 && e4.write(q4.from([c5])), g4 !== null ? g4.write() : d4 === 4 && e4.write(q4.from([0])), true;
        }
        function Qm2(t4, e4, r4) {
          qe3("subscribe: packet: ");
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.dup ? j4.DUP_MASK : 0, s4 = n4.messageId, a4 = n4.subscriptions, u4 = n4.properties, c5 = 0;
          if (typeof s4 != "number")
            return e4.destroy(new Error("Invalid messageId")), false;
          c5 += 2;
          let h4 = null;
          if (i5 === 5) {
            if (h4 = Wt4(e4, u4), !h4)
              return false;
            c5 += h4.length;
          }
          if (typeof a4 == "object" && a4.length)
            for (let g4 = 0; g4 < a4.length; g4 += 1) {
              let y3 = a4[g4].topic, w3 = a4[g4].qos;
              if (typeof y3 != "string")
                return e4.destroy(new Error("Invalid subscriptions - invalid topic")), false;
              if (typeof w3 != "number")
                return e4.destroy(new Error("Invalid subscriptions - invalid qos")), false;
              if (i5 === 5) {
                if (typeof (a4[g4].nl || false) != "boolean")
                  return e4.destroy(new Error("Invalid subscriptions - invalid No Local")), false;
                if (typeof (a4[g4].rap || false) != "boolean")
                  return e4.destroy(new Error("Invalid subscriptions - invalid Retain as Published")), false;
                let I3 = a4[g4].rh || 0;
                if (typeof I3 != "number" || I3 > 2)
                  return e4.destroy(new Error("Invalid subscriptions - invalid Retain Handling")), false;
              }
              c5 += q4.byteLength(y3) + 2 + 1;
            }
          else
            return e4.destroy(new Error("Invalid subscriptions")), false;
          qe3("subscribe: writing to stream: %o", j4.SUBSCRIBE_HEADER), e4.write(j4.SUBSCRIBE_HEADER[1][o4 ? 1 : 0][0]), De4(e4, c5), Ie3(e4, s4), h4 !== null && h4.write();
          let d4 = true;
          for (let g4 of a4) {
            let y3 = g4.topic, w3 = g4.qos, E4 = +g4.nl, S3 = +g4.rap, I3 = g4.rh, C3;
            yr4(e4, y3), C3 = j4.SUBSCRIBE_OPTIONS_QOS[w3], i5 === 5 && (C3 |= E4 ? j4.SUBSCRIBE_OPTIONS_NL : 0, C3 |= S3 ? j4.SUBSCRIBE_OPTIONS_RAP : 0, C3 |= I3 ? j4.SUBSCRIBE_OPTIONS_RH[I3] : 0), d4 = e4.write(q4.from([C3]));
          }
          return d4;
        }
        function Ym2(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.messageId, s4 = n4.granted, a4 = n4.properties, u4 = 0;
          if (typeof o4 != "number")
            return e4.destroy(new Error("Invalid messageId")), false;
          if (u4 += 2, typeof s4 == "object" && s4.length)
            for (let h4 = 0; h4 < s4.length; h4 += 1) {
              if (typeof s4[h4] != "number")
                return e4.destroy(new Error("Invalid qos vector")), false;
              u4 += 1;
            }
          else
            return e4.destroy(new Error("Invalid qos vector")), false;
          let c5 = null;
          if (i5 === 5) {
            if (c5 = Si3(e4, a4, r4, u4), !c5)
              return false;
            u4 += c5.length;
          }
          return e4.write(j4.SUBACK_HEADER), De4(e4, u4), Ie3(e4, o4), c5 !== null && c5.write(), e4.write(q4.from(s4));
        }
        function Jm2(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.messageId, s4 = n4.dup ? j4.DUP_MASK : 0, a4 = n4.unsubscriptions, u4 = n4.properties, c5 = 0;
          if (typeof o4 != "number")
            return e4.destroy(new Error("Invalid messageId")), false;
          if (c5 += 2, typeof a4 == "object" && a4.length)
            for (let g4 = 0; g4 < a4.length; g4 += 1) {
              if (typeof a4[g4] != "string")
                return e4.destroy(new Error("Invalid unsubscriptions")), false;
              c5 += q4.byteLength(a4[g4]) + 2;
            }
          else
            return e4.destroy(new Error("Invalid unsubscriptions")), false;
          let h4 = null;
          if (i5 === 5) {
            if (h4 = Wt4(e4, u4), !h4)
              return false;
            c5 += h4.length;
          }
          e4.write(j4.UNSUBSCRIBE_HEADER[1][s4 ? 1 : 0][0]), De4(e4, c5), Ie3(e4, o4), h4 !== null && h4.write();
          let d4 = true;
          for (let g4 = 0; g4 < a4.length; g4++)
            d4 = yr4(e4, a4[g4]);
          return d4;
        }
        function Xm2(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.messageId, s4 = n4.dup ? j4.DUP_MASK : 0, a4 = n4.granted, u4 = n4.properties, c5 = n4.cmd, h4 = 0, d4 = 2;
          if (typeof o4 != "number")
            return e4.destroy(new Error("Invalid messageId")), false;
          if (i5 === 5)
            if (typeof a4 == "object" && a4.length)
              for (let y3 = 0; y3 < a4.length; y3 += 1) {
                if (typeof a4[y3] != "number")
                  return e4.destroy(new Error("Invalid qos vector")), false;
                d4 += 1;
              }
            else
              return e4.destroy(new Error("Invalid qos vector")), false;
          let g4 = null;
          if (i5 === 5) {
            if (g4 = Si3(e4, u4, r4, d4), !g4)
              return false;
            d4 += g4.length;
          }
          return e4.write(j4.ACKS[c5][h4][s4][0]), De4(e4, d4), Ie3(e4, o4), g4 !== null && g4.write(), i5 === 5 && e4.write(q4.from(a4)), true;
        }
        function Zm2(t4, e4, r4) {
          return e4.write(j4.EMPTY[t4.cmd]);
        }
        function e1(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.reasonCode, s4 = n4.properties, a4 = i5 === 5 ? 1 : 0, u4 = null;
          if (i5 === 5) {
            if (u4 = Si3(e4, s4, r4, a4), !u4)
              return false;
            a4 += u4.length;
          }
          return e4.write(q4.from([j4.codes.disconnect << 4])), De4(e4, a4), i5 === 5 && e4.write(q4.from([o4])), u4 !== null && u4.write(), true;
        }
        function t1(t4, e4, r4) {
          let i5 = r4 ? r4.protocolVersion : 4, n4 = t4 || {}, o4 = n4.reasonCode, s4 = n4.properties, a4 = i5 === 5 ? 1 : 0;
          i5 !== 5 && e4.destroy(new Error("Invalid mqtt version for auth packet"));
          let u4 = Si3(e4, s4, r4, a4);
          return u4 ? (a4 += u4.length, e4.write(q4.from([j4.codes.auth << 4])), De4(e4, a4), e4.write(q4.from([o4])), u4 !== null && u4.write(), true) : false;
        }
        var Td2 = {};
        function De4(t4, e4) {
          if (e4 > j4.VARBYTEINT_MAX)
            return t4.destroy(new Error(`Invalid variable byte integer: ${e4}`)), false;
          let r4 = Td2[e4];
          return r4 || (r4 = Vo3(e4), e4 < 16384 && (Td2[e4] = r4)), qe3("writeVarByteInt: writing to stream: %o", r4), t4.write(r4);
        }
        function yr4(t4, e4) {
          let r4 = q4.byteLength(e4);
          return Ie3(t4, r4), qe3("writeString: %s", e4), t4.write(e4, "utf8");
        }
        function Rd(t4, e4, r4) {
          yr4(t4, e4), yr4(t4, r4);
        }
        function zo2(t4, e4) {
          return qe3("writeNumberCached: number: %d", e4), qe3("writeNumberCached: %o", Cn4[e4]), t4.write(Cn4[e4]);
        }
        function r1(t4, e4) {
          let r4 = Fm2(e4);
          return qe3("writeNumberGenerated: %o", r4), t4.write(r4);
        }
        function i1(t4, e4) {
          let r4 = $m2(e4);
          return qe3("write4ByteNumber: %o", r4), t4.write(r4);
        }
        function Gr4(t4, e4) {
          typeof e4 == "string" ? yr4(t4, e4) : e4 ? (Ie3(t4, e4.length), t4.write(e4)) : Ie3(t4, 0);
        }
        function Wt4(t4, e4) {
          if (typeof e4 != "object" || e4.length != null)
            return { length: 1, write() {
              Bd(t4, {}, 0);
            } };
          let r4 = 0;
          function i5(o4, s4) {
            let a4 = j4.propertiesTypes[o4], u4 = 0;
            switch (a4) {
              case "byte": {
                if (typeof s4 != "boolean")
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + 1;
                break;
              }
              case "int8": {
                if (typeof s4 != "number" || s4 < 0 || s4 > 255)
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + 1;
                break;
              }
              case "binary": {
                if (s4 && s4 === null)
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + q4.byteLength(s4) + 2;
                break;
              }
              case "int16": {
                if (typeof s4 != "number" || s4 < 0 || s4 > 65535)
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + 2;
                break;
              }
              case "int32": {
                if (typeof s4 != "number" || s4 < 0 || s4 > 4294967295)
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + 4;
                break;
              }
              case "var": {
                if (typeof s4 != "number" || s4 < 0 || s4 > 268435455)
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + q4.byteLength(Vo3(s4));
                break;
              }
              case "string": {
                if (typeof s4 != "string")
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += 1 + 2 + q4.byteLength(s4.toString());
                break;
              }
              case "pair": {
                if (typeof s4 != "object")
                  return t4.destroy(new Error(`Invalid ${o4}: ${s4}`)), false;
                u4 += Object.getOwnPropertyNames(s4).reduce((c5, h4) => {
                  let d4 = s4[h4];
                  return Array.isArray(d4) ? c5 += d4.reduce((g4, y3) => (g4 += 1 + 2 + q4.byteLength(h4.toString()) + 2 + q4.byteLength(y3.toString()), g4), 0) : c5 += 1 + 2 + q4.byteLength(h4.toString()) + 2 + q4.byteLength(s4[h4].toString()), c5;
                }, 0);
                break;
              }
              default:
                return t4.destroy(new Error(`Invalid property ${o4}: ${s4}`)), false;
            }
            return u4;
          }
          if (e4)
            for (let o4 in e4) {
              let s4 = 0, a4 = 0, u4 = e4[o4];
              if (Array.isArray(u4))
                for (let c5 = 0; c5 < u4.length; c5++) {
                  if (a4 = i5(o4, u4[c5]), !a4)
                    return false;
                  s4 += a4;
                }
              else {
                if (a4 = i5(o4, u4), !a4)
                  return false;
                s4 = a4;
              }
              if (!s4)
                return false;
              r4 += s4;
            }
          return { length: q4.byteLength(Vo3(r4)) + r4, write() {
            Bd(t4, e4, r4);
          } };
        }
        function Si3(t4, e4, r4, i5) {
          let n4 = ["reasonString", "userProperties"], o4 = r4 && r4.properties && r4.properties.maximumPacketSize ? r4.properties.maximumPacketSize : 0, s4 = Wt4(t4, e4);
          if (o4)
            for (; i5 + s4.length > o4; ) {
              let a4 = n4.shift();
              if (a4 && e4[a4])
                delete e4[a4], s4 = Wt4(t4, e4);
              else
                return false;
            }
          return s4;
        }
        function Cd2(t4, e4, r4) {
          switch (j4.propertiesTypes[e4]) {
            case "byte": {
              t4.write(q4.from([j4.properties[e4]])), t4.write(q4.from([+r4]));
              break;
            }
            case "int8": {
              t4.write(q4.from([j4.properties[e4]])), t4.write(q4.from([r4]));
              break;
            }
            case "binary": {
              t4.write(q4.from([j4.properties[e4]])), Gr4(t4, r4);
              break;
            }
            case "int16": {
              t4.write(q4.from([j4.properties[e4]])), Ie3(t4, r4);
              break;
            }
            case "int32": {
              t4.write(q4.from([j4.properties[e4]])), i1(t4, r4);
              break;
            }
            case "var": {
              t4.write(q4.from([j4.properties[e4]])), De4(t4, r4);
              break;
            }
            case "string": {
              t4.write(q4.from([j4.properties[e4]])), yr4(t4, r4);
              break;
            }
            case "pair": {
              Object.getOwnPropertyNames(r4).forEach((n4) => {
                let o4 = r4[n4];
                Array.isArray(o4) ? o4.forEach((s4) => {
                  t4.write(q4.from([j4.properties[e4]])), Rd(t4, n4.toString(), s4.toString());
                }) : (t4.write(q4.from([j4.properties[e4]])), Rd(t4, n4.toString(), o4.toString()));
              });
              break;
            }
            default:
              return t4.destroy(new Error(`Invalid property ${e4} value: ${r4}`)), false;
          }
        }
        function Bd(t4, e4, r4) {
          De4(t4, r4);
          for (let i5 in e4)
            if (Object.prototype.hasOwnProperty.call(e4, i5) && e4[i5] !== null) {
              let n4 = e4[i5];
              if (Array.isArray(n4))
                for (let o4 = 0; o4 < n4.length; o4++)
                  Cd2(t4, i5, n4[o4]);
              else
                Cd2(t4, i5, n4);
            }
        }
        function kd2(t4) {
          return t4 ? t4 instanceof q4 ? t4.length : q4.byteLength(t4) : 0;
        }
        function Pd2(t4) {
          return typeof t4 == "string" || t4 instanceof q4;
        }
        xd.exports = Od;
      });
      Ud = M3((EO, Ld2) => {
        v3();
        m3();
        _3();
        var n1 = Ko3(), { EventEmitter: s1 } = (ir3(), X3(rr3)), { Buffer: Md } = (ye5(), X3(_e5));
        function o1(t4, e4) {
          let r4 = new Go2();
          return n1(t4, r4, e4), r4.concat();
        }
        var Go2 = class extends s1 {
          constructor() {
            super(), this._array = new Array(20), this._i = 0;
          }
          write(e4) {
            return this._array[this._i++] = e4, true;
          }
          concat() {
            let e4 = 0, r4 = new Array(this._array.length), i5 = this._array, n4 = 0, o4;
            for (o4 = 0; o4 < i5.length && i5[o4] !== void 0; o4++)
              typeof i5[o4] != "string" ? r4[o4] = i5[o4].length : r4[o4] = Md.byteLength(i5[o4]), e4 += r4[o4];
            let s4 = Md.allocUnsafe(e4);
            for (o4 = 0; o4 < i5.length && i5[o4] !== void 0; o4++)
              typeof i5[o4] != "string" ? (i5[o4].copy(s4, n4), n4 += r4[o4]) : (s4.write(i5[o4], n4), n4 += r4[o4]);
            return s4;
          }
          destroy(e4) {
            e4 && this.emit("error", e4);
          }
        };
        Ld2.exports = o1;
      });
      Nd2 = M3((Pn3) => {
        v3();
        m3();
        _3();
        Pn3.parser = md2().parser;
        Pn3.generate = Ud();
        Pn3.writeToStream = Ko3();
      });
      Jo3 = M3((Yo3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Yo3, "__esModule", { value: true });
        var Qo3 = class {
          constructor() {
            this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
          }
          allocate() {
            let e4 = this.nextId++;
            return this.nextId === 65536 && (this.nextId = 1), e4;
          }
          getLastAllocated() {
            return this.nextId === 1 ? 65535 : this.nextId - 1;
          }
          register(e4) {
            return true;
          }
          deallocate(e4) {
          }
          clear() {
          }
        };
        Yo3.default = Qo3;
      });
      Dd2 = M3((XO, qd) => {
        "use strict";
        v3();
        m3();
        _3();
        qd.exports = a1;
        function Qr3(t4) {
          return t4 instanceof x3 ? x3.from(t4) : new t4.constructor(t4.buffer.slice(), t4.byteOffset, t4.length);
        }
        function a1(t4) {
          if (t4 = t4 || {}, t4.circles)
            return l1(t4);
          return t4.proto ? i5 : r4;
          function e4(n4, o4) {
            for (var s4 = Object.keys(n4), a4 = new Array(s4.length), u4 = 0; u4 < s4.length; u4++) {
              var c5 = s4[u4], h4 = n4[c5];
              typeof h4 != "object" || h4 === null ? a4[c5] = h4 : h4 instanceof Date ? a4[c5] = new Date(h4) : ArrayBuffer.isView(h4) ? a4[c5] = Qr3(h4) : a4[c5] = o4(h4);
            }
            return a4;
          }
          function r4(n4) {
            if (typeof n4 != "object" || n4 === null)
              return n4;
            if (n4 instanceof Date)
              return new Date(n4);
            if (Array.isArray(n4))
              return e4(n4, r4);
            if (n4 instanceof Map)
              return new Map(e4(Array.from(n4), r4));
            if (n4 instanceof Set)
              return new Set(e4(Array.from(n4), r4));
            var o4 = {};
            for (var s4 in n4)
              if (Object.hasOwnProperty.call(n4, s4) !== false) {
                var a4 = n4[s4];
                typeof a4 != "object" || a4 === null ? o4[s4] = a4 : a4 instanceof Date ? o4[s4] = new Date(a4) : a4 instanceof Map ? o4[s4] = new Map(e4(Array.from(a4), r4)) : a4 instanceof Set ? o4[s4] = new Set(e4(Array.from(a4), r4)) : ArrayBuffer.isView(a4) ? o4[s4] = Qr3(a4) : o4[s4] = r4(a4);
              }
            return o4;
          }
          function i5(n4) {
            if (typeof n4 != "object" || n4 === null)
              return n4;
            if (n4 instanceof Date)
              return new Date(n4);
            if (Array.isArray(n4))
              return e4(n4, i5);
            if (n4 instanceof Map)
              return new Map(e4(Array.from(n4), i5));
            if (n4 instanceof Set)
              return new Set(e4(Array.from(n4), i5));
            var o4 = {};
            for (var s4 in n4) {
              var a4 = n4[s4];
              typeof a4 != "object" || a4 === null ? o4[s4] = a4 : a4 instanceof Date ? o4[s4] = new Date(a4) : a4 instanceof Map ? o4[s4] = new Map(e4(Array.from(a4), i5)) : a4 instanceof Set ? o4[s4] = new Set(e4(Array.from(a4), i5)) : ArrayBuffer.isView(a4) ? o4[s4] = Qr3(a4) : o4[s4] = i5(a4);
            }
            return o4;
          }
        }
        function l1(t4) {
          var e4 = [], r4 = [];
          return t4.proto ? o4 : n4;
          function i5(s4, a4) {
            for (var u4 = Object.keys(s4), c5 = new Array(u4.length), h4 = 0; h4 < u4.length; h4++) {
              var d4 = u4[h4], g4 = s4[d4];
              if (typeof g4 != "object" || g4 === null)
                c5[d4] = g4;
              else if (g4 instanceof Date)
                c5[d4] = new Date(g4);
              else if (ArrayBuffer.isView(g4))
                c5[d4] = Qr3(g4);
              else {
                var y3 = e4.indexOf(g4);
                y3 !== -1 ? c5[d4] = r4[y3] : c5[d4] = a4(g4);
              }
            }
            return c5;
          }
          function n4(s4) {
            if (typeof s4 != "object" || s4 === null)
              return s4;
            if (s4 instanceof Date)
              return new Date(s4);
            if (Array.isArray(s4))
              return i5(s4, n4);
            if (s4 instanceof Map)
              return new Map(i5(Array.from(s4), n4));
            if (s4 instanceof Set)
              return new Set(i5(Array.from(s4), n4));
            var a4 = {};
            e4.push(s4), r4.push(a4);
            for (var u4 in s4)
              if (Object.hasOwnProperty.call(s4, u4) !== false) {
                var c5 = s4[u4];
                if (typeof c5 != "object" || c5 === null)
                  a4[u4] = c5;
                else if (c5 instanceof Date)
                  a4[u4] = new Date(c5);
                else if (c5 instanceof Map)
                  a4[u4] = new Map(i5(Array.from(c5), n4));
                else if (c5 instanceof Set)
                  a4[u4] = new Set(i5(Array.from(c5), n4));
                else if (ArrayBuffer.isView(c5))
                  a4[u4] = Qr3(c5);
                else {
                  var h4 = e4.indexOf(c5);
                  h4 !== -1 ? a4[u4] = r4[h4] : a4[u4] = n4(c5);
                }
              }
            return e4.pop(), r4.pop(), a4;
          }
          function o4(s4) {
            if (typeof s4 != "object" || s4 === null)
              return s4;
            if (s4 instanceof Date)
              return new Date(s4);
            if (Array.isArray(s4))
              return i5(s4, o4);
            if (s4 instanceof Map)
              return new Map(i5(Array.from(s4), o4));
            if (s4 instanceof Set)
              return new Set(i5(Array.from(s4), o4));
            var a4 = {};
            e4.push(s4), r4.push(a4);
            for (var u4 in s4) {
              var c5 = s4[u4];
              if (typeof c5 != "object" || c5 === null)
                a4[u4] = c5;
              else if (c5 instanceof Date)
                a4[u4] = new Date(c5);
              else if (c5 instanceof Map)
                a4[u4] = new Map(i5(Array.from(c5), o4));
              else if (c5 instanceof Set)
                a4[u4] = new Set(i5(Array.from(c5), o4));
              else if (ArrayBuffer.isView(c5))
                a4[u4] = Qr3(c5);
              else {
                var h4 = e4.indexOf(c5);
                h4 !== -1 ? a4[u4] = r4[h4] : a4[u4] = o4(c5);
              }
            }
            return e4.pop(), r4.pop(), a4;
          }
        }
      });
      Fd2 = M3((lk, jd2) => {
        "use strict";
        v3();
        m3();
        _3();
        jd2.exports = Dd2()();
      });
      $d2 = M3((Yr3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Yr3, "__esModule", { value: true });
        Yr3.validateTopics = Yr3.validateTopic = void 0;
        function Wd(t4) {
          let e4 = t4.split("/");
          for (let r4 = 0; r4 < e4.length; r4++)
            if (e4[r4] !== "+") {
              if (e4[r4] === "#")
                return r4 === e4.length - 1;
              if (e4[r4].indexOf("+") !== -1 || e4[r4].indexOf("#") !== -1)
                return false;
            }
          return true;
        }
        Yr3.validateTopic = Wd;
        function u1(t4) {
          if (t4.length === 0)
            return "empty_topic_list";
          for (let e4 = 0; e4 < t4.length; e4++)
            if (!Wd(t4[e4]))
              return t4[e4];
          return null;
        }
        Yr3.validateTopics = u1;
      });
      ea3 = M3((Zo2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Zo2, "__esModule", { value: true });
        var f1 = jt4(), c1 = { objectMode: true }, h1 = { clean: true }, Xo3 = class {
          constructor(e4) {
            this.options = e4 || {}, this.options = Object.assign(Object.assign({}, h1), e4), this._inflights = /* @__PURE__ */ new Map();
          }
          put(e4, r4) {
            return this._inflights.set(e4.messageId, e4), r4 && r4(), this;
          }
          createStream() {
            let e4 = new f1.Readable(c1), r4 = [], i5 = false, n4 = 0;
            return this._inflights.forEach((o4, s4) => {
              r4.push(o4);
            }), e4._read = () => {
              !i5 && n4 < r4.length ? e4.push(r4[n4++]) : e4.push(null);
            }, e4.destroy = (o4) => {
              if (!i5)
                return i5 = true, setTimeout(() => {
                  e4.emit("close");
                }, 0), e4;
            }, e4;
          }
          del(e4, r4) {
            let i5 = this._inflights.get(e4.messageId);
            return i5 ? (this._inflights.delete(e4.messageId), r4(null, i5)) : r4 && r4(new Error("missing packet")), this;
          }
          get(e4, r4) {
            let i5 = this._inflights.get(e4.messageId);
            return i5 ? r4(null, i5) : r4 && r4(new Error("missing packet")), this;
          }
          close(e4) {
            this.options.clean && (this._inflights = null), e4 && e4();
          }
        };
        Zo2.default = Xo3;
      });
      Vd = M3((ta3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(ta3, "__esModule", { value: true });
        var Hd = [0, 16, 128, 131, 135, 144, 145, 151, 153], d1 = (t4, e4, r4) => {
          t4.log("handlePublish: packet %o", e4), r4 = typeof r4 < "u" ? r4 : t4.noop;
          let i5 = e4.topic.toString(), n4 = e4.payload, { qos: o4 } = e4, { messageId: s4 } = e4, { options: a4 } = t4;
          if (t4.options.protocolVersion === 5) {
            let u4;
            if (e4.properties && (u4 = e4.properties.topicAlias), typeof u4 < "u")
              if (i5.length === 0)
                if (u4 > 0 && u4 <= 65535) {
                  let c5 = t4.topicAliasRecv.getTopicByAlias(u4);
                  if (c5)
                    i5 = c5, t4.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d", i5, u4);
                  else {
                    t4.log("handlePublish :: unregistered topic alias. alias: %d", u4), t4.emit("error", new Error("Received unregistered Topic Alias"));
                    return;
                  }
                } else {
                  t4.log("handlePublish :: topic alias out of range. alias: %d", u4), t4.emit("error", new Error("Received Topic Alias is out of range"));
                  return;
                }
              else if (t4.topicAliasRecv.put(i5, u4))
                t4.log("handlePublish :: registered topic: %s - alias: %d", i5, u4);
              else {
                t4.log("handlePublish :: topic alias out of range. alias: %d", u4), t4.emit("error", new Error("Received Topic Alias is out of range"));
                return;
              }
          }
          switch (t4.log("handlePublish: qos %d", o4), o4) {
            case 2: {
              a4.customHandleAcks(i5, n4, e4, (u4, c5) => {
                if (typeof u4 == "number" && (c5 = u4, u4 = null), u4)
                  return t4.emit("error", u4);
                if (Hd.indexOf(c5) === -1)
                  return t4.emit("error", new Error("Wrong reason code for pubrec"));
                c5 ? t4._sendPacket({ cmd: "pubrec", messageId: s4, reasonCode: c5 }, r4) : t4.incomingStore.put(e4, () => {
                  t4._sendPacket({ cmd: "pubrec", messageId: s4 }, r4);
                });
              });
              break;
            }
            case 1: {
              a4.customHandleAcks(i5, n4, e4, (u4, c5) => {
                if (typeof u4 == "number" && (c5 = u4, u4 = null), u4)
                  return t4.emit("error", u4);
                if (Hd.indexOf(c5) === -1)
                  return t4.emit("error", new Error("Wrong reason code for puback"));
                c5 || t4.emit("message", i5, n4, e4), t4.handleMessage(e4, (h4) => {
                  if (h4)
                    return r4 && r4(h4);
                  t4._sendPacket({ cmd: "puback", messageId: s4, reasonCode: c5 }, r4);
                });
              });
              break;
            }
            case 0:
              t4.emit("message", i5, n4, e4), t4.handleMessage(e4, r4);
              break;
            default:
              t4.log("handlePublish: unknown QoS. Doing nothing.");
              break;
          }
        };
        ta3.default = d1;
      });
      zd = M3((Gk, p1) => {
        p1.exports = { version: "5.5.3" };
      });
      Jr3 = M3((at4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(at4, "__esModule", { value: true });
        at4.MQTTJS_VERSION = at4.nextTick = at4.applyMixin = at4.ErrorWithReasonCode = void 0;
        var ra3 = class t4 extends Error {
          constructor(e4, r4) {
            super(e4), this.code = r4, Object.setPrototypeOf(this, t4.prototype), Object.getPrototypeOf(this).name = "ErrorWithReasonCode";
          }
        };
        at4.ErrorWithReasonCode = ra3;
        function g1(t4, e4, r4 = false) {
          var i5;
          let n4 = [e4];
          for (; ; ) {
            let o4 = n4[0], s4 = Object.getPrototypeOf(o4);
            if (s4?.prototype)
              n4.unshift(s4);
            else
              break;
          }
          for (let o4 of n4)
            for (let s4 of Object.getOwnPropertyNames(o4.prototype))
              (r4 || s4 !== "constructor") && Object.defineProperty(t4.prototype, s4, (i5 = Object.getOwnPropertyDescriptor(o4.prototype, s4)) !== null && i5 !== void 0 ? i5 : /* @__PURE__ */ Object.create(null));
        }
        at4.applyMixin = g1;
        at4.nextTick = typeof (P3 === null || P3 === void 0 ? void 0 : P3.nextTick) == "function" ? P3.nextTick : (t4) => {
          setTimeout(t4, 0);
        };
        at4.MQTTJS_VERSION = zd().version;
      });
      Ai3 = M3((br4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(br4, "__esModule", { value: true });
        br4.ReasonCodes = void 0;
        br4.ReasonCodes = { 0: "", 1: "Unacceptable protocol version", 2: "Identifier rejected", 3: "Server unavailable", 4: "Bad username or password", 5: "Not authorized", 16: "No matching subscribers", 17: "No subscription existed", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 132: "Unsupported Protocol Version", 133: "Client Identifier not valid", 134: "Bad User Name or Password", 135: "Not authorized", 136: "Server unavailable", 137: "Server busy", 138: "Banned", 139: "Server shutting down", 140: "Bad authentication method", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 145: "Packet identifier in use", 146: "Packet Identifier not found", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
        var y1 = (t4, e4) => {
          let { messageId: r4 } = e4, i5 = e4.cmd, n4 = null, o4 = t4.outgoing[r4] ? t4.outgoing[r4].cb : null, s4;
          if (!o4) {
            t4.log("_handleAck :: Server sent an ack in error. Ignoring.");
            return;
          }
          switch (t4.log("_handleAck :: packet type", i5), i5) {
            case "pubcomp":
            case "puback": {
              let a4 = e4.reasonCode;
              a4 && a4 > 0 && a4 !== 16 ? (s4 = new Error(`Publish error: ${br4.ReasonCodes[a4]}`), s4.code = a4, t4._removeOutgoingAndStoreMessage(r4, () => {
                o4(s4, e4);
              })) : t4._removeOutgoingAndStoreMessage(r4, o4);
              break;
            }
            case "pubrec": {
              n4 = { cmd: "pubrel", qos: 2, messageId: r4 };
              let a4 = e4.reasonCode;
              a4 && a4 > 0 && a4 !== 16 ? (s4 = new Error(`Publish error: ${br4.ReasonCodes[a4]}`), s4.code = a4, t4._removeOutgoingAndStoreMessage(r4, () => {
                o4(s4, e4);
              })) : t4._sendPacket(n4);
              break;
            }
            case "suback": {
              delete t4.outgoing[r4], t4.messageIdProvider.deallocate(r4);
              let a4 = e4.granted;
              for (let u4 = 0; u4 < a4.length; u4++)
                if (a4[u4] & 128) {
                  let c5 = t4.messageIdToTopic[r4];
                  c5 && c5.forEach((h4) => {
                    delete t4._resubscribeTopics[h4];
                  });
                }
              delete t4.messageIdToTopic[r4], t4._invokeStoreProcessingQueue(), o4(null, e4);
              break;
            }
            case "unsuback": {
              delete t4.outgoing[r4], t4.messageIdProvider.deallocate(r4), t4._invokeStoreProcessingQueue(), o4(null);
              break;
            }
            default:
              t4.emit("error", new Error("unrecognized packet type"));
          }
          t4.disconnecting && Object.keys(t4.outgoing).length === 0 && t4.emit("outgoingEmpty");
        };
        br4.default = y1;
      });
      Gd = M3((ia2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(ia2, "__esModule", { value: true });
        var Kd2 = Jr3(), b1 = Ai3(), w1 = (t4, e4) => {
          let { options: r4 } = t4, i5 = r4.protocolVersion, n4 = i5 === 5 ? e4.reasonCode : e4.returnCode;
          if (i5 !== 5) {
            let o4 = new Kd2.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${i5}`, n4);
            t4.emit("error", o4);
            return;
          }
          t4.handleAuth(e4, (o4, s4) => {
            if (o4) {
              t4.emit("error", o4);
              return;
            }
            if (n4 === 24)
              t4.reconnecting = false, t4._sendPacket(s4);
            else {
              let a4 = new Kd2.ErrorWithReasonCode(`Connection refused: ${b1.ReasonCodes[n4]}`, n4);
              t4.emit("error", a4);
            }
          });
        };
        ia2.default = w1;
      });
      Zd2 = M3((kn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(kn4, "__esModule", { value: true });
        kn4.LRUCache = void 0;
        var Ii3 = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, Yd2 = /* @__PURE__ */ new Set(), na3 = typeof P3 == "object" && P3 ? P3 : {}, Jd2 = (t4, e4, r4, i5) => {
          typeof na3.emitWarning == "function" ? na3.emitWarning(t4, e4, r4, i5) : console.error(`[${r4}] ${e4}: ${t4}`);
        }, On3 = globalThis.AbortController, Qd2 = globalThis.AbortSignal;
        if (typeof On3 > "u") {
          Qd2 = class {
            onabort;
            _onabort = [];
            reason;
            aborted = false;
            addEventListener(i5, n4) {
              this._onabort.push(n4);
            }
          }, On3 = class {
            constructor() {
              e4();
            }
            signal = new Qd2();
            abort(i5) {
              if (!this.signal.aborted) {
                this.signal.reason = i5, this.signal.aborted = true;
                for (let n4 of this.signal._onabort)
                  n4(i5);
                this.signal.onabort?.(i5);
              }
            }
          };
          let t4 = na3.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1", e4 = () => {
            t4 && (t4 = false, Jd2("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", e4));
          };
        }
        var _1 = (t4) => !Yd2.has(t4), Cx = Symbol("type"), $t3 = (t4) => t4 && t4 === Math.floor(t4) && t4 > 0 && isFinite(t4), Xd2 = (t4) => $t3(t4) ? t4 <= Math.pow(2, 8) ? Uint8Array : t4 <= Math.pow(2, 16) ? Uint16Array : t4 <= Math.pow(2, 32) ? Uint32Array : t4 <= Number.MAX_SAFE_INTEGER ? Xr3 : null : null, Xr3 = class extends Array {
          constructor(e4) {
            super(e4), this.fill(0);
          }
        }, sa3 = class t4 {
          heap;
          length;
          static #l = false;
          static create(e4) {
            let r4 = Xd2(e4);
            if (!r4)
              return [];
            t4.#l = true;
            let i5 = new t4(e4, r4);
            return t4.#l = false, i5;
          }
          constructor(e4, r4) {
            if (!t4.#l)
              throw new TypeError("instantiate Stack using Stack.create(n)");
            this.heap = new r4(e4), this.length = 0;
          }
          push(e4) {
            this.heap[this.length++] = e4;
          }
          pop() {
            return this.heap[--this.length];
          }
        }, oa3 = class t4 {
          #l;
          #c;
          #p;
          #g;
          #B;
          ttl;
          ttlResolution;
          ttlAutopurge;
          updateAgeOnGet;
          updateAgeOnHas;
          allowStale;
          noDisposeOnSet;
          noUpdateTTL;
          maxEntrySize;
          sizeCalculation;
          noDeleteOnFetchRejection;
          noDeleteOnStaleGet;
          allowStaleOnFetchAbort;
          allowStaleOnFetchRejection;
          ignoreFetchAbort;
          #i;
          #y;
          #n;
          #r;
          #e;
          #u;
          #h;
          #a;
          #s;
          #b;
          #o;
          #E;
          #S;
          #w;
          #_;
          #I;
          #f;
          static unsafeExposeInternals(e4) {
            return { starts: e4.#S, ttls: e4.#w, sizes: e4.#E, keyMap: e4.#n, keyList: e4.#r, valList: e4.#e, next: e4.#u, prev: e4.#h, get head() {
              return e4.#a;
            }, get tail() {
              return e4.#s;
            }, free: e4.#b, isBackgroundFetch: (r4) => e4.#t(r4), backgroundFetch: (r4, i5, n4, o4) => e4.#k(r4, i5, n4, o4), moveToTail: (r4) => e4.#C(r4), indexes: (r4) => e4.#m(r4), rindexes: (r4) => e4.#v(r4), isStale: (r4) => e4.#d(r4) };
          }
          get max() {
            return this.#l;
          }
          get maxSize() {
            return this.#c;
          }
          get calculatedSize() {
            return this.#y;
          }
          get size() {
            return this.#i;
          }
          get fetchMethod() {
            return this.#B;
          }
          get dispose() {
            return this.#p;
          }
          get disposeAfter() {
            return this.#g;
          }
          constructor(e4) {
            let { max: r4 = 0, ttl: i5, ttlResolution: n4 = 1, ttlAutopurge: o4, updateAgeOnGet: s4, updateAgeOnHas: a4, allowStale: u4, dispose: c5, disposeAfter: h4, noDisposeOnSet: d4, noUpdateTTL: g4, maxSize: y3 = 0, maxEntrySize: w3 = 0, sizeCalculation: E4, fetchMethod: S3, noDeleteOnFetchRejection: I3, noDeleteOnStaleGet: C3, allowStaleOnFetchRejection: R5, allowStaleOnFetchAbort: U5, ignoreFetchAbort: N4 } = e4;
            if (r4 !== 0 && !$t3(r4))
              throw new TypeError("max option must be a nonnegative integer");
            let W4 = r4 ? Xd2(r4) : Array;
            if (!W4)
              throw new Error("invalid max value: " + r4);
            if (this.#l = r4, this.#c = y3, this.maxEntrySize = w3 || this.#c, this.sizeCalculation = E4, this.sizeCalculation) {
              if (!this.#c && !this.maxEntrySize)
                throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
              if (typeof this.sizeCalculation != "function")
                throw new TypeError("sizeCalculation set to non-function");
            }
            if (S3 !== void 0 && typeof S3 != "function")
              throw new TypeError("fetchMethod must be a function if specified");
            if (this.#B = S3, this.#I = !!S3, this.#n = /* @__PURE__ */ new Map(), this.#r = new Array(r4).fill(void 0), this.#e = new Array(r4).fill(void 0), this.#u = new W4(r4), this.#h = new W4(r4), this.#a = 0, this.#s = 0, this.#b = sa3.create(r4), this.#i = 0, this.#y = 0, typeof c5 == "function" && (this.#p = c5), typeof h4 == "function" ? (this.#g = h4, this.#o = []) : (this.#g = void 0, this.#o = void 0), this.#_ = !!this.#p, this.#f = !!this.#g, this.noDisposeOnSet = !!d4, this.noUpdateTTL = !!g4, this.noDeleteOnFetchRejection = !!I3, this.allowStaleOnFetchRejection = !!R5, this.allowStaleOnFetchAbort = !!U5, this.ignoreFetchAbort = !!N4, this.maxEntrySize !== 0) {
              if (this.#c !== 0 && !$t3(this.#c))
                throw new TypeError("maxSize must be a positive integer if specified");
              if (!$t3(this.maxEntrySize))
                throw new TypeError("maxEntrySize must be a positive integer if specified");
              this.#q();
            }
            if (this.allowStale = !!u4, this.noDeleteOnStaleGet = !!C3, this.updateAgeOnGet = !!s4, this.updateAgeOnHas = !!a4, this.ttlResolution = $t3(n4) || n4 === 0 ? n4 : 1, this.ttlAutopurge = !!o4, this.ttl = i5 || 0, this.ttl) {
              if (!$t3(this.ttl))
                throw new TypeError("ttl must be a positive integer if specified");
              this.#x();
            }
            if (this.#l === 0 && this.ttl === 0 && this.#c === 0)
              throw new TypeError("At least one of max, maxSize, or ttl is required");
            if (!this.ttlAutopurge && !this.#l && !this.#c) {
              let K5 = "LRU_CACHE_UNBOUNDED";
              _1(K5) && (Yd2.add(K5), Jd2("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", K5, t4));
            }
          }
          getRemainingTTL(e4) {
            return this.#n.has(e4) ? 1 / 0 : 0;
          }
          #x() {
            let e4 = new Xr3(this.#l), r4 = new Xr3(this.#l);
            this.#w = e4, this.#S = r4, this.#M = (o4, s4, a4 = Ii3.now()) => {
              if (r4[o4] = s4 !== 0 ? a4 : 0, e4[o4] = s4, s4 !== 0 && this.ttlAutopurge) {
                let u4 = setTimeout(() => {
                  this.#d(o4) && this.delete(this.#r[o4]);
                }, s4 + 1);
                u4.unref && u4.unref();
              }
            }, this.#T = (o4) => {
              r4[o4] = e4[o4] !== 0 ? Ii3.now() : 0;
            }, this.#A = (o4, s4) => {
              if (e4[s4]) {
                let a4 = e4[s4], u4 = r4[s4];
                o4.ttl = a4, o4.start = u4, o4.now = i5 || n4();
                let c5 = o4.now - u4;
                o4.remainingTTL = a4 - c5;
              }
            };
            let i5 = 0, n4 = () => {
              let o4 = Ii3.now();
              if (this.ttlResolution > 0) {
                i5 = o4;
                let s4 = setTimeout(() => i5 = 0, this.ttlResolution);
                s4.unref && s4.unref();
              }
              return o4;
            };
            this.getRemainingTTL = (o4) => {
              let s4 = this.#n.get(o4);
              if (s4 === void 0)
                return 0;
              let a4 = e4[s4], u4 = r4[s4];
              if (a4 === 0 || u4 === 0)
                return 1 / 0;
              let c5 = (i5 || n4()) - u4;
              return a4 - c5;
            }, this.#d = (o4) => e4[o4] !== 0 && r4[o4] !== 0 && (i5 || n4()) - r4[o4] > e4[o4];
          }
          #T = () => {
          };
          #A = () => {
          };
          #M = () => {
          };
          #d = () => false;
          #q() {
            let e4 = new Xr3(this.#l);
            this.#y = 0, this.#E = e4, this.#R = (r4) => {
              this.#y -= e4[r4], e4[r4] = 0;
            }, this.#L = (r4, i5, n4, o4) => {
              if (this.#t(i5))
                return 0;
              if (!$t3(n4))
                if (o4) {
                  if (typeof o4 != "function")
                    throw new TypeError("sizeCalculation must be a function");
                  if (n4 = o4(i5, r4), !$t3(n4))
                    throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                } else
                  throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
              return n4;
            }, this.#P = (r4, i5, n4) => {
              if (e4[r4] = i5, this.#c) {
                let o4 = this.#c - e4[r4];
                for (; this.#y > o4; )
                  this.#O(true);
              }
              this.#y += e4[r4], n4 && (n4.entrySize = i5, n4.totalCalculatedSize = this.#y);
            };
          }
          #R = (e4) => {
          };
          #P = (e4, r4, i5) => {
          };
          #L = (e4, r4, i5, n4) => {
            if (i5 || n4)
              throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
            return 0;
          };
          *#m({ allowStale: e4 = this.allowStale } = {}) {
            if (this.#i)
              for (let r4 = this.#s; !(!this.#U(r4) || ((e4 || !this.#d(r4)) && (yield r4), r4 === this.#a)); )
                r4 = this.#h[r4];
          }
          *#v({ allowStale: e4 = this.allowStale } = {}) {
            if (this.#i)
              for (let r4 = this.#a; !(!this.#U(r4) || ((e4 || !this.#d(r4)) && (yield r4), r4 === this.#s)); )
                r4 = this.#u[r4];
          }
          #U(e4) {
            return e4 !== void 0 && this.#n.get(this.#r[e4]) === e4;
          }
          *entries() {
            for (let e4 of this.#m())
              this.#e[e4] !== void 0 && this.#r[e4] !== void 0 && !this.#t(this.#e[e4]) && (yield [this.#r[e4], this.#e[e4]]);
          }
          *rentries() {
            for (let e4 of this.#v())
              this.#e[e4] !== void 0 && this.#r[e4] !== void 0 && !this.#t(this.#e[e4]) && (yield [this.#r[e4], this.#e[e4]]);
          }
          *keys() {
            for (let e4 of this.#m()) {
              let r4 = this.#r[e4];
              r4 !== void 0 && !this.#t(this.#e[e4]) && (yield r4);
            }
          }
          *rkeys() {
            for (let e4 of this.#v()) {
              let r4 = this.#r[e4];
              r4 !== void 0 && !this.#t(this.#e[e4]) && (yield r4);
            }
          }
          *values() {
            for (let e4 of this.#m())
              this.#e[e4] !== void 0 && !this.#t(this.#e[e4]) && (yield this.#e[e4]);
          }
          *rvalues() {
            for (let e4 of this.#v())
              this.#e[e4] !== void 0 && !this.#t(this.#e[e4]) && (yield this.#e[e4]);
          }
          [Symbol.iterator]() {
            return this.entries();
          }
          find(e4, r4 = {}) {
            for (let i5 of this.#m()) {
              let n4 = this.#e[i5], o4 = this.#t(n4) ? n4.__staleWhileFetching : n4;
              if (o4 !== void 0 && e4(o4, this.#r[i5], this))
                return this.get(this.#r[i5], r4);
            }
          }
          forEach(e4, r4 = this) {
            for (let i5 of this.#m()) {
              let n4 = this.#e[i5], o4 = this.#t(n4) ? n4.__staleWhileFetching : n4;
              o4 !== void 0 && e4.call(r4, o4, this.#r[i5], this);
            }
          }
          rforEach(e4, r4 = this) {
            for (let i5 of this.#v()) {
              let n4 = this.#e[i5], o4 = this.#t(n4) ? n4.__staleWhileFetching : n4;
              o4 !== void 0 && e4.call(r4, o4, this.#r[i5], this);
            }
          }
          purgeStale() {
            let e4 = false;
            for (let r4 of this.#v({ allowStale: true }))
              this.#d(r4) && (this.delete(this.#r[r4]), e4 = true);
            return e4;
          }
          dump() {
            let e4 = [];
            for (let r4 of this.#m({ allowStale: true })) {
              let i5 = this.#r[r4], n4 = this.#e[r4], o4 = this.#t(n4) ? n4.__staleWhileFetching : n4;
              if (o4 === void 0 || i5 === void 0)
                continue;
              let s4 = { value: o4 };
              if (this.#w && this.#S) {
                s4.ttl = this.#w[r4];
                let a4 = Ii3.now() - this.#S[r4];
                s4.start = Math.floor(Date.now() - a4);
              }
              this.#E && (s4.size = this.#E[r4]), e4.unshift([i5, s4]);
            }
            return e4;
          }
          load(e4) {
            this.clear();
            for (let [r4, i5] of e4) {
              if (i5.start) {
                let n4 = Date.now() - i5.start;
                i5.start = Ii3.now() - n4;
              }
              this.set(r4, i5.value, i5);
            }
          }
          set(e4, r4, i5 = {}) {
            if (r4 === void 0)
              return this.delete(e4), this;
            let { ttl: n4 = this.ttl, start: o4, noDisposeOnSet: s4 = this.noDisposeOnSet, sizeCalculation: a4 = this.sizeCalculation, status: u4 } = i5, { noUpdateTTL: c5 = this.noUpdateTTL } = i5, h4 = this.#L(e4, r4, i5.size || 0, a4);
            if (this.maxEntrySize && h4 > this.maxEntrySize)
              return u4 && (u4.set = "miss", u4.maxEntrySizeExceeded = true), this.delete(e4), this;
            let d4 = this.#i === 0 ? void 0 : this.#n.get(e4);
            if (d4 === void 0)
              d4 = this.#i === 0 ? this.#s : this.#b.length !== 0 ? this.#b.pop() : this.#i === this.#l ? this.#O(false) : this.#i, this.#r[d4] = e4, this.#e[d4] = r4, this.#n.set(e4, d4), this.#u[this.#s] = d4, this.#h[d4] = this.#s, this.#s = d4, this.#i++, this.#P(d4, h4, u4), u4 && (u4.set = "add"), c5 = false;
            else {
              this.#C(d4);
              let g4 = this.#e[d4];
              if (r4 !== g4) {
                if (this.#I && this.#t(g4)) {
                  g4.__abortController.abort(new Error("replaced"));
                  let { __staleWhileFetching: y3 } = g4;
                  y3 !== void 0 && !s4 && (this.#_ && this.#p?.(y3, e4, "set"), this.#f && this.#o?.push([y3, e4, "set"]));
                } else
                  s4 || (this.#_ && this.#p?.(g4, e4, "set"), this.#f && this.#o?.push([g4, e4, "set"]));
                if (this.#R(d4), this.#P(d4, h4, u4), this.#e[d4] = r4, u4) {
                  u4.set = "replace";
                  let y3 = g4 && this.#t(g4) ? g4.__staleWhileFetching : g4;
                  y3 !== void 0 && (u4.oldValue = y3);
                }
              } else
                u4 && (u4.set = "update");
            }
            if (n4 !== 0 && !this.#w && this.#x(), this.#w && (c5 || this.#M(d4, n4, o4), u4 && this.#A(u4, d4)), !s4 && this.#f && this.#o) {
              let g4 = this.#o, y3;
              for (; y3 = g4?.shift(); )
                this.#g?.(...y3);
            }
            return this;
          }
          pop() {
            try {
              for (; this.#i; ) {
                let e4 = this.#e[this.#a];
                if (this.#O(true), this.#t(e4)) {
                  if (e4.__staleWhileFetching)
                    return e4.__staleWhileFetching;
                } else if (e4 !== void 0)
                  return e4;
              }
            } finally {
              if (this.#f && this.#o) {
                let e4 = this.#o, r4;
                for (; r4 = e4?.shift(); )
                  this.#g?.(...r4);
              }
            }
          }
          #O(e4) {
            let r4 = this.#a, i5 = this.#r[r4], n4 = this.#e[r4];
            return this.#I && this.#t(n4) ? n4.__abortController.abort(new Error("evicted")) : (this.#_ || this.#f) && (this.#_ && this.#p?.(n4, i5, "evict"), this.#f && this.#o?.push([n4, i5, "evict"])), this.#R(r4), e4 && (this.#r[r4] = void 0, this.#e[r4] = void 0, this.#b.push(r4)), this.#i === 1 ? (this.#a = this.#s = 0, this.#b.length = 0) : this.#a = this.#u[r4], this.#n.delete(i5), this.#i--, r4;
          }
          has(e4, r4 = {}) {
            let { updateAgeOnHas: i5 = this.updateAgeOnHas, status: n4 } = r4, o4 = this.#n.get(e4);
            if (o4 !== void 0) {
              let s4 = this.#e[o4];
              if (this.#t(s4) && s4.__staleWhileFetching === void 0)
                return false;
              if (this.#d(o4))
                n4 && (n4.has = "stale", this.#A(n4, o4));
              else
                return i5 && this.#T(o4), n4 && (n4.has = "hit", this.#A(n4, o4)), true;
            } else
              n4 && (n4.has = "miss");
            return false;
          }
          peek(e4, r4 = {}) {
            let { allowStale: i5 = this.allowStale } = r4, n4 = this.#n.get(e4);
            if (n4 !== void 0 && (i5 || !this.#d(n4))) {
              let o4 = this.#e[n4];
              return this.#t(o4) ? o4.__staleWhileFetching : o4;
            }
          }
          #k(e4, r4, i5, n4) {
            let o4 = r4 === void 0 ? void 0 : this.#e[r4];
            if (this.#t(o4))
              return o4;
            let s4 = new On3(), { signal: a4 } = i5;
            a4?.addEventListener("abort", () => s4.abort(a4.reason), { signal: s4.signal });
            let u4 = { signal: s4.signal, options: i5, context: n4 }, c5 = (E4, S3 = false) => {
              let { aborted: I3 } = s4.signal, C3 = i5.ignoreFetchAbort && E4 !== void 0;
              if (i5.status && (I3 && !S3 ? (i5.status.fetchAborted = true, i5.status.fetchError = s4.signal.reason, C3 && (i5.status.fetchAbortIgnored = true)) : i5.status.fetchResolved = true), I3 && !C3 && !S3)
                return d4(s4.signal.reason);
              let R5 = y3;
              return this.#e[r4] === y3 && (E4 === void 0 ? R5.__staleWhileFetching ? this.#e[r4] = R5.__staleWhileFetching : this.delete(e4) : (i5.status && (i5.status.fetchUpdated = true), this.set(e4, E4, u4.options))), E4;
            }, h4 = (E4) => (i5.status && (i5.status.fetchRejected = true, i5.status.fetchError = E4), d4(E4)), d4 = (E4) => {
              let { aborted: S3 } = s4.signal, I3 = S3 && i5.allowStaleOnFetchAbort, C3 = I3 || i5.allowStaleOnFetchRejection, R5 = C3 || i5.noDeleteOnFetchRejection, U5 = y3;
              if (this.#e[r4] === y3 && (!R5 || U5.__staleWhileFetching === void 0 ? this.delete(e4) : I3 || (this.#e[r4] = U5.__staleWhileFetching)), C3)
                return i5.status && U5.__staleWhileFetching !== void 0 && (i5.status.returnedStale = true), U5.__staleWhileFetching;
              if (U5.__returned === U5)
                throw E4;
            }, g4 = (E4, S3) => {
              let I3 = this.#B?.(e4, o4, u4);
              I3 && I3 instanceof Promise && I3.then((C3) => E4(C3 === void 0 ? void 0 : C3), S3), s4.signal.addEventListener("abort", () => {
                (!i5.ignoreFetchAbort || i5.allowStaleOnFetchAbort) && (E4(void 0), i5.allowStaleOnFetchAbort && (E4 = (C3) => c5(C3, true)));
              });
            };
            i5.status && (i5.status.fetchDispatched = true);
            let y3 = new Promise(g4).then(c5, h4), w3 = Object.assign(y3, { __abortController: s4, __staleWhileFetching: o4, __returned: void 0 });
            return r4 === void 0 ? (this.set(e4, w3, { ...u4.options, status: void 0 }), r4 = this.#n.get(e4)) : this.#e[r4] = w3, w3;
          }
          #t(e4) {
            if (!this.#I)
              return false;
            let r4 = e4;
            return !!r4 && r4 instanceof Promise && r4.hasOwnProperty("__staleWhileFetching") && r4.__abortController instanceof On3;
          }
          async fetch(e4, r4 = {}) {
            let { allowStale: i5 = this.allowStale, updateAgeOnGet: n4 = this.updateAgeOnGet, noDeleteOnStaleGet: o4 = this.noDeleteOnStaleGet, ttl: s4 = this.ttl, noDisposeOnSet: a4 = this.noDisposeOnSet, size: u4 = 0, sizeCalculation: c5 = this.sizeCalculation, noUpdateTTL: h4 = this.noUpdateTTL, noDeleteOnFetchRejection: d4 = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: g4 = this.allowStaleOnFetchRejection, ignoreFetchAbort: y3 = this.ignoreFetchAbort, allowStaleOnFetchAbort: w3 = this.allowStaleOnFetchAbort, context: E4, forceRefresh: S3 = false, status: I3, signal: C3 } = r4;
            if (!this.#I)
              return I3 && (I3.fetch = "get"), this.get(e4, { allowStale: i5, updateAgeOnGet: n4, noDeleteOnStaleGet: o4, status: I3 });
            let R5 = { allowStale: i5, updateAgeOnGet: n4, noDeleteOnStaleGet: o4, ttl: s4, noDisposeOnSet: a4, size: u4, sizeCalculation: c5, noUpdateTTL: h4, noDeleteOnFetchRejection: d4, allowStaleOnFetchRejection: g4, allowStaleOnFetchAbort: w3, ignoreFetchAbort: y3, status: I3, signal: C3 }, U5 = this.#n.get(e4);
            if (U5 === void 0) {
              I3 && (I3.fetch = "miss");
              let N4 = this.#k(e4, U5, R5, E4);
              return N4.__returned = N4;
            } else {
              let N4 = this.#e[U5];
              if (this.#t(N4)) {
                let de3 = i5 && N4.__staleWhileFetching !== void 0;
                return I3 && (I3.fetch = "inflight", de3 && (I3.returnedStale = true)), de3 ? N4.__staleWhileFetching : N4.__returned = N4;
              }
              let W4 = this.#d(U5);
              if (!S3 && !W4)
                return I3 && (I3.fetch = "hit"), this.#C(U5), n4 && this.#T(U5), I3 && this.#A(I3, U5), N4;
              let K5 = this.#k(e4, U5, R5, E4), Q3 = K5.__staleWhileFetching !== void 0 && i5;
              return I3 && (I3.fetch = W4 ? "stale" : "refresh", Q3 && W4 && (I3.returnedStale = true)), Q3 ? K5.__staleWhileFetching : K5.__returned = K5;
            }
          }
          get(e4, r4 = {}) {
            let { allowStale: i5 = this.allowStale, updateAgeOnGet: n4 = this.updateAgeOnGet, noDeleteOnStaleGet: o4 = this.noDeleteOnStaleGet, status: s4 } = r4, a4 = this.#n.get(e4);
            if (a4 !== void 0) {
              let u4 = this.#e[a4], c5 = this.#t(u4);
              return s4 && this.#A(s4, a4), this.#d(a4) ? (s4 && (s4.get = "stale"), c5 ? (s4 && i5 && u4.__staleWhileFetching !== void 0 && (s4.returnedStale = true), i5 ? u4.__staleWhileFetching : void 0) : (o4 || this.delete(e4), s4 && i5 && (s4.returnedStale = true), i5 ? u4 : void 0)) : (s4 && (s4.get = "hit"), c5 ? u4.__staleWhileFetching : (this.#C(a4), n4 && this.#T(a4), u4));
            } else
              s4 && (s4.get = "miss");
          }
          #N(e4, r4) {
            this.#h[r4] = e4, this.#u[e4] = r4;
          }
          #C(e4) {
            e4 !== this.#s && (e4 === this.#a ? this.#a = this.#u[e4] : this.#N(this.#h[e4], this.#u[e4]), this.#N(this.#s, e4), this.#s = e4);
          }
          delete(e4) {
            let r4 = false;
            if (this.#i !== 0) {
              let i5 = this.#n.get(e4);
              if (i5 !== void 0)
                if (r4 = true, this.#i === 1)
                  this.clear();
                else {
                  this.#R(i5);
                  let n4 = this.#e[i5];
                  this.#t(n4) ? n4.__abortController.abort(new Error("deleted")) : (this.#_ || this.#f) && (this.#_ && this.#p?.(n4, e4, "delete"), this.#f && this.#o?.push([n4, e4, "delete"])), this.#n.delete(e4), this.#r[i5] = void 0, this.#e[i5] = void 0, i5 === this.#s ? this.#s = this.#h[i5] : i5 === this.#a ? this.#a = this.#u[i5] : (this.#u[this.#h[i5]] = this.#u[i5], this.#h[this.#u[i5]] = this.#h[i5]), this.#i--, this.#b.push(i5);
                }
            }
            if (this.#f && this.#o?.length) {
              let i5 = this.#o, n4;
              for (; n4 = i5?.shift(); )
                this.#g?.(...n4);
            }
            return r4;
          }
          clear() {
            for (let e4 of this.#v({ allowStale: true })) {
              let r4 = this.#e[e4];
              if (this.#t(r4))
                r4.__abortController.abort(new Error("deleted"));
              else {
                let i5 = this.#r[e4];
                this.#_ && this.#p?.(r4, i5, "delete"), this.#f && this.#o?.push([r4, i5, "delete"]);
              }
            }
            if (this.#n.clear(), this.#e.fill(void 0), this.#r.fill(void 0), this.#w && this.#S && (this.#w.fill(0), this.#S.fill(0)), this.#E && this.#E.fill(0), this.#a = 0, this.#s = 0, this.#b.length = 0, this.#y = 0, this.#i = 0, this.#f && this.#o) {
              let e4 = this.#o, r4;
              for (; r4 = e4?.shift(); )
                this.#g?.(...r4);
            }
          }
        };
        kn4.LRUCache = oa3;
      });
      lt3 = M3((Ht4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Ht4, "t", { value: true });
        Ht4.ContainerIterator = Ht4.Container = Ht4.Base = void 0;
        var aa2 = class {
          constructor(e4 = 0) {
            this.iteratorType = e4;
          }
          equals(e4) {
            return this.o === e4.o;
          }
        };
        Ht4.ContainerIterator = aa2;
        var xn4 = class {
          constructor() {
            this.i = 0;
          }
          get length() {
            return this.i;
          }
          size() {
            return this.i;
          }
          empty() {
            return this.i === 0;
          }
        };
        Ht4.Base = xn4;
        var la3 = class extends xn4 {
        };
        Ht4.Container = la3;
      });
      ep2 = M3((Mn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Mn4, "t", { value: true });
        Mn4.default = void 0;
        var m1 = lt3(), ua3 = class extends m1.Base {
          constructor(e4 = []) {
            super(), this.S = [];
            let r4 = this;
            e4.forEach(function(i5) {
              r4.push(i5);
            });
          }
          clear() {
            this.i = 0, this.S = [];
          }
          push(e4) {
            return this.S.push(e4), this.i += 1, this.i;
          }
          pop() {
            if (this.i !== 0)
              return this.i -= 1, this.S.pop();
          }
          top() {
            return this.S[this.i - 1];
          }
        }, v1 = ua3;
        Mn4.default = v1;
      });
      tp2 = M3((Ln4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Ln4, "t", { value: true });
        Ln4.default = void 0;
        var E1 = lt3(), fa3 = class extends E1.Base {
          constructor(e4 = []) {
            super(), this.j = 0, this.q = [];
            let r4 = this;
            e4.forEach(function(i5) {
              r4.push(i5);
            });
          }
          clear() {
            this.q = [], this.i = this.j = 0;
          }
          push(e4) {
            let r4 = this.q.length;
            if (this.j / r4 > 0.5 && this.j + this.i >= r4 && r4 > 4096) {
              let i5 = this.i;
              for (let n4 = 0; n4 < i5; ++n4)
                this.q[n4] = this.q[this.j + n4];
              this.j = 0, this.q[this.i] = e4;
            } else
              this.q[this.j + this.i] = e4;
            return ++this.i;
          }
          pop() {
            if (this.i === 0)
              return;
            let e4 = this.q[this.j++];
            return this.i -= 1, e4;
          }
          front() {
            if (this.i !== 0)
              return this.q[this.j];
          }
        }, S1 = fa3;
        Ln4.default = S1;
      });
      rp2 = M3((Un4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Un4, "t", { value: true });
        Un4.default = void 0;
        var A1 = lt3(), ca3 = class extends A1.Base {
          constructor(e4 = [], r4 = function(n4, o4) {
            return n4 > o4 ? -1 : n4 < o4 ? 1 : 0;
          }, i5 = true) {
            if (super(), this.v = r4, Array.isArray(e4))
              this.C = i5 ? [...e4] : e4;
            else {
              this.C = [];
              let o4 = this;
              e4.forEach(function(s4) {
                o4.C.push(s4);
              });
            }
            this.i = this.C.length;
            let n4 = this.i >> 1;
            for (let o4 = this.i - 1 >> 1; o4 >= 0; --o4)
              this.k(o4, n4);
          }
          m(e4) {
            let r4 = this.C[e4];
            for (; e4 > 0; ) {
              let i5 = e4 - 1 >> 1, n4 = this.C[i5];
              if (this.v(n4, r4) <= 0)
                break;
              this.C[e4] = n4, e4 = i5;
            }
            this.C[e4] = r4;
          }
          k(e4, r4) {
            let i5 = this.C[e4];
            for (; e4 < r4; ) {
              let n4 = e4 << 1 | 1, o4 = n4 + 1, s4 = this.C[n4];
              if (o4 < this.i && this.v(s4, this.C[o4]) > 0 && (n4 = o4, s4 = this.C[o4]), this.v(s4, i5) >= 0)
                break;
              this.C[e4] = s4, e4 = n4;
            }
            this.C[e4] = i5;
          }
          clear() {
            this.i = 0, this.C.length = 0;
          }
          push(e4) {
            this.C.push(e4), this.m(this.i), this.i += 1;
          }
          pop() {
            if (this.i === 0)
              return;
            let e4 = this.C[0], r4 = this.C.pop();
            return this.i -= 1, this.i && (this.C[0] = r4, this.k(0, this.i >> 1)), e4;
          }
          top() {
            return this.C[0];
          }
          find(e4) {
            return this.C.indexOf(e4) >= 0;
          }
          remove(e4) {
            let r4 = this.C.indexOf(e4);
            return r4 < 0 ? false : (r4 === 0 ? this.pop() : r4 === this.i - 1 ? (this.C.pop(), this.i -= 1) : (this.C.splice(r4, 1, this.C.pop()), this.i -= 1, this.m(r4), this.k(r4, this.i >> 1)), true);
          }
          updateItem(e4) {
            let r4 = this.C.indexOf(e4);
            return r4 < 0 ? false : (this.m(r4), this.k(r4, this.i >> 1), true);
          }
          toArray() {
            return [...this.C];
          }
        }, I1 = ca3;
        Un4.default = I1;
      });
      qn3 = M3((Nn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Nn4, "t", { value: true });
        Nn4.default = void 0;
        var T1 = lt3(), ha3 = class extends T1.Container {
        }, R1 = ha3;
        Nn4.default = R1;
      });
      ut4 = M3((da3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(da3, "t", { value: true });
        da3.throwIteratorAccessError = C1;
        function C1() {
          throw new RangeError("Iterator access denied!");
        }
      });
      ga2 = M3((jn3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(jn3, "t", { value: true });
        jn3.RandomIterator = void 0;
        var B1 = lt3(), Dn4 = ut4(), pa3 = class extends B1.ContainerIterator {
          constructor(e4, r4) {
            super(r4), this.o = e4, this.iteratorType === 0 ? (this.pre = function() {
              return this.o === 0 && (0, Dn4.throwIteratorAccessError)(), this.o -= 1, this;
            }, this.next = function() {
              return this.o === this.container.size() && (0, Dn4.throwIteratorAccessError)(), this.o += 1, this;
            }) : (this.pre = function() {
              return this.o === this.container.size() - 1 && (0, Dn4.throwIteratorAccessError)(), this.o += 1, this;
            }, this.next = function() {
              return this.o === -1 && (0, Dn4.throwIteratorAccessError)(), this.o -= 1, this;
            });
          }
          get pointer() {
            return this.container.getElementByPos(this.o);
          }
          set pointer(e4) {
            this.container.setElementByPos(this.o, e4);
          }
        };
        jn3.RandomIterator = pa3;
      });
      ip2 = M3((Fn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Fn4, "t", { value: true });
        Fn4.default = void 0;
        var P1 = k1(qn3()), O1 = ga2();
        function k1(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var wr4 = class t4 extends O1.RandomIterator {
          constructor(e4, r4, i5) {
            super(e4, i5), this.container = r4;
          }
          copy() {
            return new t4(this.o, this.container, this.iteratorType);
          }
        }, ya2 = class extends P1.default {
          constructor(e4 = [], r4 = true) {
            if (super(), Array.isArray(e4))
              this.J = r4 ? [...e4] : e4, this.i = e4.length;
            else {
              this.J = [];
              let i5 = this;
              e4.forEach(function(n4) {
                i5.pushBack(n4);
              });
            }
          }
          clear() {
            this.i = 0, this.J.length = 0;
          }
          begin() {
            return new wr4(0, this);
          }
          end() {
            return new wr4(this.i, this);
          }
          rBegin() {
            return new wr4(this.i - 1, this, 1);
          }
          rEnd() {
            return new wr4(-1, this, 1);
          }
          front() {
            return this.J[0];
          }
          back() {
            return this.J[this.i - 1];
          }
          getElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            return this.J[e4];
          }
          eraseElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            return this.J.splice(e4, 1), this.i -= 1, this.i;
          }
          eraseElementByValue(e4) {
            let r4 = 0;
            for (let i5 = 0; i5 < this.i; ++i5)
              this.J[i5] !== e4 && (this.J[r4++] = this.J[i5]);
            return this.i = this.J.length = r4, this.i;
          }
          eraseElementByIterator(e4) {
            let r4 = e4.o;
            return e4 = e4.next(), this.eraseElementByPos(r4), e4;
          }
          pushBack(e4) {
            return this.J.push(e4), this.i += 1, this.i;
          }
          popBack() {
            if (this.i !== 0)
              return this.i -= 1, this.J.pop();
          }
          setElementByPos(e4, r4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            this.J[e4] = r4;
          }
          insert(e4, r4, i5 = 1) {
            if (e4 < 0 || e4 > this.i)
              throw new RangeError();
            return this.J.splice(e4, 0, ...new Array(i5).fill(r4)), this.i += i5, this.i;
          }
          find(e4) {
            for (let r4 = 0; r4 < this.i; ++r4)
              if (this.J[r4] === e4)
                return new wr4(r4, this);
            return this.end();
          }
          reverse() {
            this.J.reverse();
          }
          unique() {
            let e4 = 1;
            for (let r4 = 1; r4 < this.i; ++r4)
              this.J[r4] !== this.J[r4 - 1] && (this.J[e4++] = this.J[r4]);
            return this.i = this.J.length = e4, this.i;
          }
          sort(e4) {
            this.J.sort(e4);
          }
          forEach(e4) {
            for (let r4 = 0; r4 < this.i; ++r4)
              e4(this.J[r4], r4, this);
          }
          [Symbol.iterator]() {
            return function* () {
              yield* this.J;
            }.bind(this)();
          }
        }, x1 = ya2;
        Fn4.default = x1;
      });
      np2 = M3((Wn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Wn4, "t", { value: true });
        Wn4.default = void 0;
        var M1 = U1(qn3()), L1 = lt3(), _r4 = ut4();
        function U1(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var mr4 = class t4 extends L1.ContainerIterator {
          constructor(e4, r4, i5, n4) {
            super(n4), this.o = e4, this.h = r4, this.container = i5, this.iteratorType === 0 ? (this.pre = function() {
              return this.o.L === this.h && (0, _r4.throwIteratorAccessError)(), this.o = this.o.L, this;
            }, this.next = function() {
              return this.o === this.h && (0, _r4.throwIteratorAccessError)(), this.o = this.o.B, this;
            }) : (this.pre = function() {
              return this.o.B === this.h && (0, _r4.throwIteratorAccessError)(), this.o = this.o.B, this;
            }, this.next = function() {
              return this.o === this.h && (0, _r4.throwIteratorAccessError)(), this.o = this.o.L, this;
            });
          }
          get pointer() {
            return this.o === this.h && (0, _r4.throwIteratorAccessError)(), this.o.l;
          }
          set pointer(e4) {
            this.o === this.h && (0, _r4.throwIteratorAccessError)(), this.o.l = e4;
          }
          copy() {
            return new t4(this.o, this.h, this.container, this.iteratorType);
          }
        }, ba3 = class extends M1.default {
          constructor(e4 = []) {
            super(), this.h = {}, this.p = this._ = this.h.L = this.h.B = this.h;
            let r4 = this;
            e4.forEach(function(i5) {
              r4.pushBack(i5);
            });
          }
          V(e4) {
            let { L: r4, B: i5 } = e4;
            r4.B = i5, i5.L = r4, e4 === this.p && (this.p = i5), e4 === this._ && (this._ = r4), this.i -= 1;
          }
          G(e4, r4) {
            let i5 = r4.B, n4 = { l: e4, L: r4, B: i5 };
            r4.B = n4, i5.L = n4, r4 === this.h && (this.p = n4), i5 === this.h && (this._ = n4), this.i += 1;
          }
          clear() {
            this.i = 0, this.p = this._ = this.h.L = this.h.B = this.h;
          }
          begin() {
            return new mr4(this.p, this.h, this);
          }
          end() {
            return new mr4(this.h, this.h, this);
          }
          rBegin() {
            return new mr4(this._, this.h, this, 1);
          }
          rEnd() {
            return new mr4(this.h, this.h, this, 1);
          }
          front() {
            return this.p.l;
          }
          back() {
            return this._.l;
          }
          getElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4 = this.p;
            for (; e4--; )
              r4 = r4.B;
            return r4.l;
          }
          eraseElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4 = this.p;
            for (; e4--; )
              r4 = r4.B;
            return this.V(r4), this.i;
          }
          eraseElementByValue(e4) {
            let r4 = this.p;
            for (; r4 !== this.h; )
              r4.l === e4 && this.V(r4), r4 = r4.B;
            return this.i;
          }
          eraseElementByIterator(e4) {
            let r4 = e4.o;
            return r4 === this.h && (0, _r4.throwIteratorAccessError)(), e4 = e4.next(), this.V(r4), e4;
          }
          pushBack(e4) {
            return this.G(e4, this._), this.i;
          }
          popBack() {
            if (this.i === 0)
              return;
            let e4 = this._.l;
            return this.V(this._), e4;
          }
          pushFront(e4) {
            return this.G(e4, this.h), this.i;
          }
          popFront() {
            if (this.i === 0)
              return;
            let e4 = this.p.l;
            return this.V(this.p), e4;
          }
          setElementByPos(e4, r4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let i5 = this.p;
            for (; e4--; )
              i5 = i5.B;
            i5.l = r4;
          }
          insert(e4, r4, i5 = 1) {
            if (e4 < 0 || e4 > this.i)
              throw new RangeError();
            if (i5 <= 0)
              return this.i;
            if (e4 === 0)
              for (; i5--; )
                this.pushFront(r4);
            else if (e4 === this.i)
              for (; i5--; )
                this.pushBack(r4);
            else {
              let n4 = this.p;
              for (let s4 = 1; s4 < e4; ++s4)
                n4 = n4.B;
              let o4 = n4.B;
              for (this.i += i5; i5--; )
                n4.B = { l: r4, L: n4 }, n4.B.L = n4, n4 = n4.B;
              n4.B = o4, o4.L = n4;
            }
            return this.i;
          }
          find(e4) {
            let r4 = this.p;
            for (; r4 !== this.h; ) {
              if (r4.l === e4)
                return new mr4(r4, this.h, this);
              r4 = r4.B;
            }
            return this.end();
          }
          reverse() {
            if (this.i <= 1)
              return;
            let e4 = this.p, r4 = this._, i5 = 0;
            for (; i5 << 1 < this.i; ) {
              let n4 = e4.l;
              e4.l = r4.l, r4.l = n4, e4 = e4.B, r4 = r4.L, i5 += 1;
            }
          }
          unique() {
            if (this.i <= 1)
              return this.i;
            let e4 = this.p;
            for (; e4 !== this.h; ) {
              let r4 = e4;
              for (; r4.B !== this.h && r4.l === r4.B.l; )
                r4 = r4.B, this.i -= 1;
              e4.B = r4.B, e4.B.L = e4, e4 = e4.B;
            }
            return this.i;
          }
          sort(e4) {
            if (this.i <= 1)
              return;
            let r4 = [];
            this.forEach(function(n4) {
              r4.push(n4);
            }), r4.sort(e4);
            let i5 = this.p;
            r4.forEach(function(n4) {
              i5.l = n4, i5 = i5.B;
            });
          }
          merge(e4) {
            let r4 = this;
            if (this.i === 0)
              e4.forEach(function(i5) {
                r4.pushBack(i5);
              });
            else {
              let i5 = this.p;
              e4.forEach(function(n4) {
                for (; i5 !== r4.h && i5.l <= n4; )
                  i5 = i5.B;
                r4.G(n4, i5.L);
              });
            }
            return this.i;
          }
          forEach(e4) {
            let r4 = this.p, i5 = 0;
            for (; r4 !== this.h; )
              e4(r4.l, i5++, this), r4 = r4.B;
          }
          [Symbol.iterator]() {
            return function* () {
              if (this.i === 0)
                return;
              let e4 = this.p;
              for (; e4 !== this.h; )
                yield e4.l, e4 = e4.B;
            }.bind(this)();
          }
        }, N1 = ba3;
        Wn4.default = N1;
      });
      sp2 = M3(($n4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty($n4, "t", { value: true });
        $n4.default = void 0;
        var q1 = j1(qn3()), D1 = ga2();
        function j1(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var vr4 = class t4 extends D1.RandomIterator {
          constructor(e4, r4, i5) {
            super(e4, i5), this.container = r4;
          }
          copy() {
            return new t4(this.o, this.container, this.iteratorType);
          }
        }, wa2 = class extends q1.default {
          constructor(e4 = [], r4 = 4096) {
            super(), this.j = 0, this.D = 0, this.R = 0, this.N = 0, this.P = 0, this.A = [];
            let i5 = (() => {
              if (typeof e4.length == "number")
                return e4.length;
              if (typeof e4.size == "number")
                return e4.size;
              if (typeof e4.size == "function")
                return e4.size();
              throw new TypeError("Cannot get the length or size of the container");
            })();
            this.F = r4, this.P = Math.max(Math.ceil(i5 / this.F), 1);
            for (let s4 = 0; s4 < this.P; ++s4)
              this.A.push(new Array(this.F));
            let n4 = Math.ceil(i5 / this.F);
            this.j = this.R = (this.P >> 1) - (n4 >> 1), this.D = this.N = this.F - i5 % this.F >> 1;
            let o4 = this;
            e4.forEach(function(s4) {
              o4.pushBack(s4);
            });
          }
          T() {
            let e4 = [], r4 = Math.max(this.P >> 1, 1);
            for (let i5 = 0; i5 < r4; ++i5)
              e4[i5] = new Array(this.F);
            for (let i5 = this.j; i5 < this.P; ++i5)
              e4[e4.length] = this.A[i5];
            for (let i5 = 0; i5 < this.R; ++i5)
              e4[e4.length] = this.A[i5];
            e4[e4.length] = [...this.A[this.R]], this.j = r4, this.R = e4.length - 1;
            for (let i5 = 0; i5 < r4; ++i5)
              e4[e4.length] = new Array(this.F);
            this.A = e4, this.P = e4.length;
          }
          O(e4) {
            let r4 = this.D + e4 + 1, i5 = r4 % this.F, n4 = i5 - 1, o4 = this.j + (r4 - i5) / this.F;
            return i5 === 0 && (o4 -= 1), o4 %= this.P, n4 < 0 && (n4 += this.F), { curNodeBucketIndex: o4, curNodePointerIndex: n4 };
          }
          clear() {
            this.A = [new Array(this.F)], this.P = 1, this.j = this.R = this.i = 0, this.D = this.N = this.F >> 1;
          }
          begin() {
            return new vr4(0, this);
          }
          end() {
            return new vr4(this.i, this);
          }
          rBegin() {
            return new vr4(this.i - 1, this, 1);
          }
          rEnd() {
            return new vr4(-1, this, 1);
          }
          front() {
            if (this.i !== 0)
              return this.A[this.j][this.D];
          }
          back() {
            if (this.i !== 0)
              return this.A[this.R][this.N];
          }
          pushBack(e4) {
            return this.i && (this.N < this.F - 1 ? this.N += 1 : this.R < this.P - 1 ? (this.R += 1, this.N = 0) : (this.R = 0, this.N = 0), this.R === this.j && this.N === this.D && this.T()), this.i += 1, this.A[this.R][this.N] = e4, this.i;
          }
          popBack() {
            if (this.i === 0)
              return;
            let e4 = this.A[this.R][this.N];
            return this.i !== 1 && (this.N > 0 ? this.N -= 1 : this.R > 0 ? (this.R -= 1, this.N = this.F - 1) : (this.R = this.P - 1, this.N = this.F - 1)), this.i -= 1, e4;
          }
          pushFront(e4) {
            return this.i && (this.D > 0 ? this.D -= 1 : this.j > 0 ? (this.j -= 1, this.D = this.F - 1) : (this.j = this.P - 1, this.D = this.F - 1), this.j === this.R && this.D === this.N && this.T()), this.i += 1, this.A[this.j][this.D] = e4, this.i;
          }
          popFront() {
            if (this.i === 0)
              return;
            let e4 = this.A[this.j][this.D];
            return this.i !== 1 && (this.D < this.F - 1 ? this.D += 1 : this.j < this.P - 1 ? (this.j += 1, this.D = 0) : (this.j = 0, this.D = 0)), this.i -= 1, e4;
          }
          getElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let { curNodeBucketIndex: r4, curNodePointerIndex: i5 } = this.O(e4);
            return this.A[r4][i5];
          }
          setElementByPos(e4, r4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let { curNodeBucketIndex: i5, curNodePointerIndex: n4 } = this.O(e4);
            this.A[i5][n4] = r4;
          }
          insert(e4, r4, i5 = 1) {
            if (e4 < 0 || e4 > this.i)
              throw new RangeError();
            if (e4 === 0)
              for (; i5--; )
                this.pushFront(r4);
            else if (e4 === this.i)
              for (; i5--; )
                this.pushBack(r4);
            else {
              let n4 = [];
              for (let o4 = e4; o4 < this.i; ++o4)
                n4.push(this.getElementByPos(o4));
              this.cut(e4 - 1);
              for (let o4 = 0; o4 < i5; ++o4)
                this.pushBack(r4);
              for (let o4 = 0; o4 < n4.length; ++o4)
                this.pushBack(n4[o4]);
            }
            return this.i;
          }
          cut(e4) {
            if (e4 < 0)
              return this.clear(), 0;
            let { curNodeBucketIndex: r4, curNodePointerIndex: i5 } = this.O(e4);
            return this.R = r4, this.N = i5, this.i = e4 + 1, this.i;
          }
          eraseElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            if (e4 === 0)
              this.popFront();
            else if (e4 === this.i - 1)
              this.popBack();
            else {
              let r4 = [];
              for (let n4 = e4 + 1; n4 < this.i; ++n4)
                r4.push(this.getElementByPos(n4));
              this.cut(e4), this.popBack();
              let i5 = this;
              r4.forEach(function(n4) {
                i5.pushBack(n4);
              });
            }
            return this.i;
          }
          eraseElementByValue(e4) {
            if (this.i === 0)
              return 0;
            let r4 = [];
            for (let n4 = 0; n4 < this.i; ++n4) {
              let o4 = this.getElementByPos(n4);
              o4 !== e4 && r4.push(o4);
            }
            let i5 = r4.length;
            for (let n4 = 0; n4 < i5; ++n4)
              this.setElementByPos(n4, r4[n4]);
            return this.cut(i5 - 1);
          }
          eraseElementByIterator(e4) {
            let r4 = e4.o;
            return this.eraseElementByPos(r4), e4 = e4.next(), e4;
          }
          find(e4) {
            for (let r4 = 0; r4 < this.i; ++r4)
              if (this.getElementByPos(r4) === e4)
                return new vr4(r4, this);
            return this.end();
          }
          reverse() {
            let e4 = 0, r4 = this.i - 1;
            for (; e4 < r4; ) {
              let i5 = this.getElementByPos(e4);
              this.setElementByPos(e4, this.getElementByPos(r4)), this.setElementByPos(r4, i5), e4 += 1, r4 -= 1;
            }
          }
          unique() {
            if (this.i <= 1)
              return this.i;
            let e4 = 1, r4 = this.getElementByPos(0);
            for (let i5 = 1; i5 < this.i; ++i5) {
              let n4 = this.getElementByPos(i5);
              n4 !== r4 && (r4 = n4, this.setElementByPos(e4++, n4));
            }
            for (; this.i > e4; )
              this.popBack();
            return this.i;
          }
          sort(e4) {
            let r4 = [];
            for (let i5 = 0; i5 < this.i; ++i5)
              r4.push(this.getElementByPos(i5));
            r4.sort(e4);
            for (let i5 = 0; i5 < this.i; ++i5)
              this.setElementByPos(i5, r4[i5]);
          }
          shrinkToFit() {
            if (this.i === 0)
              return;
            let e4 = [];
            this.forEach(function(r4) {
              e4.push(r4);
            }), this.P = Math.max(Math.ceil(this.i / this.F), 1), this.i = this.j = this.R = this.D = this.N = 0, this.A = [];
            for (let r4 = 0; r4 < this.P; ++r4)
              this.A.push(new Array(this.F));
            for (let r4 = 0; r4 < e4.length; ++r4)
              this.pushBack(e4[r4]);
          }
          forEach(e4) {
            for (let r4 = 0; r4 < this.i; ++r4)
              e4(this.getElementByPos(r4), r4, this);
          }
          [Symbol.iterator]() {
            return function* () {
              for (let e4 = 0; e4 < this.i; ++e4)
                yield this.getElementByPos(e4);
            }.bind(this)();
          }
        }, F1 = wa2;
        $n4.default = F1;
      });
      op2 = M3((Zr3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Zr3, "t", { value: true });
        Zr3.TreeNodeEnableIndex = Zr3.TreeNode = void 0;
        var Hn3 = class {
          constructor(e4, r4) {
            this.ee = 1, this.u = void 0, this.l = void 0, this.U = void 0, this.W = void 0, this.tt = void 0, this.u = e4, this.l = r4;
          }
          L() {
            let e4 = this;
            if (e4.ee === 1 && e4.tt.tt === e4)
              e4 = e4.W;
            else if (e4.U)
              for (e4 = e4.U; e4.W; )
                e4 = e4.W;
            else {
              let r4 = e4.tt;
              for (; r4.U === e4; )
                e4 = r4, r4 = e4.tt;
              e4 = r4;
            }
            return e4;
          }
          B() {
            let e4 = this;
            if (e4.W) {
              for (e4 = e4.W; e4.U; )
                e4 = e4.U;
              return e4;
            } else {
              let r4 = e4.tt;
              for (; r4.W === e4; )
                e4 = r4, r4 = e4.tt;
              return e4.W !== r4 ? r4 : e4;
            }
          }
          te() {
            let e4 = this.tt, r4 = this.W, i5 = r4.U;
            return e4.tt === this ? e4.tt = r4 : e4.U === this ? e4.U = r4 : e4.W = r4, r4.tt = e4, r4.U = this, this.tt = r4, this.W = i5, i5 && (i5.tt = this), r4;
          }
          se() {
            let e4 = this.tt, r4 = this.U, i5 = r4.W;
            return e4.tt === this ? e4.tt = r4 : e4.U === this ? e4.U = r4 : e4.W = r4, r4.tt = e4, r4.W = this, this.tt = r4, this.U = i5, i5 && (i5.tt = this), r4;
          }
        };
        Zr3.TreeNode = Hn3;
        var _a3 = class extends Hn3 {
          constructor() {
            super(...arguments), this.rt = 1;
          }
          te() {
            let e4 = super.te();
            return this.ie(), e4.ie(), e4;
          }
          se() {
            let e4 = super.se();
            return this.ie(), e4.ie(), e4;
          }
          ie() {
            this.rt = 1, this.U && (this.rt += this.U.rt), this.W && (this.rt += this.W.rt);
          }
        };
        Zr3.TreeNodeEnableIndex = _a3;
      });
      va2 = M3((Vn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Vn4, "t", { value: true });
        Vn4.default = void 0;
        var ap2 = op2(), W1 = lt3(), lp2 = ut4(), ma3 = class extends W1.Container {
          constructor(e4 = function(i5, n4) {
            return i5 < n4 ? -1 : i5 > n4 ? 1 : 0;
          }, r4 = false) {
            super(), this.Y = void 0, this.v = e4, r4 ? (this.re = ap2.TreeNodeEnableIndex, this.M = function(i5, n4, o4) {
              let s4 = this.ne(i5, n4, o4);
              if (s4) {
                let a4 = s4.tt;
                for (; a4 !== this.h; )
                  a4.rt += 1, a4 = a4.tt;
                let u4 = this.he(s4);
                if (u4) {
                  let { parentNode: c5, grandParent: h4, curNode: d4 } = u4;
                  c5.ie(), h4.ie(), d4.ie();
                }
              }
              return this.i;
            }, this.V = function(i5) {
              let n4 = this.fe(i5);
              for (; n4 !== this.h; )
                n4.rt -= 1, n4 = n4.tt;
            }) : (this.re = ap2.TreeNode, this.M = function(i5, n4, o4) {
              let s4 = this.ne(i5, n4, o4);
              return s4 && this.he(s4), this.i;
            }, this.V = this.fe), this.h = new this.re();
          }
          X(e4, r4) {
            let i5 = this.h;
            for (; e4; ) {
              let n4 = this.v(e4.u, r4);
              if (n4 < 0)
                e4 = e4.W;
              else if (n4 > 0)
                i5 = e4, e4 = e4.U;
              else
                return e4;
            }
            return i5;
          }
          Z(e4, r4) {
            let i5 = this.h;
            for (; e4; )
              this.v(e4.u, r4) <= 0 ? e4 = e4.W : (i5 = e4, e4 = e4.U);
            return i5;
          }
          $(e4, r4) {
            let i5 = this.h;
            for (; e4; ) {
              let n4 = this.v(e4.u, r4);
              if (n4 < 0)
                i5 = e4, e4 = e4.W;
              else if (n4 > 0)
                e4 = e4.U;
              else
                return e4;
            }
            return i5;
          }
          rr(e4, r4) {
            let i5 = this.h;
            for (; e4; )
              this.v(e4.u, r4) < 0 ? (i5 = e4, e4 = e4.W) : e4 = e4.U;
            return i5;
          }
          ue(e4) {
            for (; ; ) {
              let r4 = e4.tt;
              if (r4 === this.h)
                return;
              if (e4.ee === 1) {
                e4.ee = 0;
                return;
              }
              if (e4 === r4.U) {
                let i5 = r4.W;
                if (i5.ee === 1)
                  i5.ee = 0, r4.ee = 1, r4 === this.Y ? this.Y = r4.te() : r4.te();
                else if (i5.W && i5.W.ee === 1) {
                  i5.ee = r4.ee, r4.ee = 0, i5.W.ee = 0, r4 === this.Y ? this.Y = r4.te() : r4.te();
                  return;
                } else
                  i5.U && i5.U.ee === 1 ? (i5.ee = 1, i5.U.ee = 0, i5.se()) : (i5.ee = 1, e4 = r4);
              } else {
                let i5 = r4.U;
                if (i5.ee === 1)
                  i5.ee = 0, r4.ee = 1, r4 === this.Y ? this.Y = r4.se() : r4.se();
                else if (i5.U && i5.U.ee === 1) {
                  i5.ee = r4.ee, r4.ee = 0, i5.U.ee = 0, r4 === this.Y ? this.Y = r4.se() : r4.se();
                  return;
                } else
                  i5.W && i5.W.ee === 1 ? (i5.ee = 1, i5.W.ee = 0, i5.te()) : (i5.ee = 1, e4 = r4);
              }
            }
          }
          fe(e4) {
            if (this.i === 1)
              return this.clear(), this.h;
            let r4 = e4;
            for (; r4.U || r4.W; ) {
              if (r4.W)
                for (r4 = r4.W; r4.U; )
                  r4 = r4.U;
              else
                r4 = r4.U;
              [e4.u, r4.u] = [r4.u, e4.u], [e4.l, r4.l] = [r4.l, e4.l], e4 = r4;
            }
            this.h.U === r4 ? this.h.U = r4.tt : this.h.W === r4 && (this.h.W = r4.tt), this.ue(r4);
            let i5 = r4.tt;
            return r4 === i5.U ? i5.U = void 0 : i5.W = void 0, this.i -= 1, this.Y.ee = 0, i5;
          }
          oe(e4, r4) {
            return e4 === void 0 ? false : this.oe(e4.U, r4) || r4(e4) ? true : this.oe(e4.W, r4);
          }
          he(e4) {
            for (; ; ) {
              let r4 = e4.tt;
              if (r4.ee === 0)
                return;
              let i5 = r4.tt;
              if (r4 === i5.U) {
                let n4 = i5.W;
                if (n4 && n4.ee === 1) {
                  if (n4.ee = r4.ee = 0, i5 === this.Y)
                    return;
                  i5.ee = 1, e4 = i5;
                  continue;
                } else if (e4 === r4.W) {
                  if (e4.ee = 0, e4.U && (e4.U.tt = r4), e4.W && (e4.W.tt = i5), r4.W = e4.U, i5.U = e4.W, e4.U = r4, e4.W = i5, i5 === this.Y)
                    this.Y = e4, this.h.tt = e4;
                  else {
                    let o4 = i5.tt;
                    o4.U === i5 ? o4.U = e4 : o4.W = e4;
                  }
                  return e4.tt = i5.tt, r4.tt = e4, i5.tt = e4, i5.ee = 1, { parentNode: r4, grandParent: i5, curNode: e4 };
                } else
                  r4.ee = 0, i5 === this.Y ? this.Y = i5.se() : i5.se(), i5.ee = 1;
              } else {
                let n4 = i5.U;
                if (n4 && n4.ee === 1) {
                  if (n4.ee = r4.ee = 0, i5 === this.Y)
                    return;
                  i5.ee = 1, e4 = i5;
                  continue;
                } else if (e4 === r4.U) {
                  if (e4.ee = 0, e4.U && (e4.U.tt = i5), e4.W && (e4.W.tt = r4), i5.W = e4.U, r4.U = e4.W, e4.U = i5, e4.W = r4, i5 === this.Y)
                    this.Y = e4, this.h.tt = e4;
                  else {
                    let o4 = i5.tt;
                    o4.U === i5 ? o4.U = e4 : o4.W = e4;
                  }
                  return e4.tt = i5.tt, r4.tt = e4, i5.tt = e4, i5.ee = 1, { parentNode: r4, grandParent: i5, curNode: e4 };
                } else
                  r4.ee = 0, i5 === this.Y ? this.Y = i5.te() : i5.te(), i5.ee = 1;
              }
              return;
            }
          }
          ne(e4, r4, i5) {
            if (this.Y === void 0) {
              this.i += 1, this.Y = new this.re(e4, r4), this.Y.ee = 0, this.Y.tt = this.h, this.h.tt = this.Y, this.h.U = this.Y, this.h.W = this.Y;
              return;
            }
            let n4, o4 = this.h.U, s4 = this.v(o4.u, e4);
            if (s4 === 0) {
              o4.l = r4;
              return;
            } else if (s4 > 0)
              o4.U = new this.re(e4, r4), o4.U.tt = o4, n4 = o4.U, this.h.U = n4;
            else {
              let a4 = this.h.W, u4 = this.v(a4.u, e4);
              if (u4 === 0) {
                a4.l = r4;
                return;
              } else if (u4 < 0)
                a4.W = new this.re(e4, r4), a4.W.tt = a4, n4 = a4.W, this.h.W = n4;
              else {
                if (i5 !== void 0) {
                  let c5 = i5.o;
                  if (c5 !== this.h) {
                    let h4 = this.v(c5.u, e4);
                    if (h4 === 0) {
                      c5.l = r4;
                      return;
                    } else if (h4 > 0) {
                      let d4 = c5.L(), g4 = this.v(d4.u, e4);
                      if (g4 === 0) {
                        d4.l = r4;
                        return;
                      } else
                        g4 < 0 && (n4 = new this.re(e4, r4), d4.W === void 0 ? (d4.W = n4, n4.tt = d4) : (c5.U = n4, n4.tt = c5));
                    }
                  }
                }
                if (n4 === void 0)
                  for (n4 = this.Y; ; ) {
                    let c5 = this.v(n4.u, e4);
                    if (c5 > 0) {
                      if (n4.U === void 0) {
                        n4.U = new this.re(e4, r4), n4.U.tt = n4, n4 = n4.U;
                        break;
                      }
                      n4 = n4.U;
                    } else if (c5 < 0) {
                      if (n4.W === void 0) {
                        n4.W = new this.re(e4, r4), n4.W.tt = n4, n4 = n4.W;
                        break;
                      }
                      n4 = n4.W;
                    } else {
                      n4.l = r4;
                      return;
                    }
                  }
              }
            }
            return this.i += 1, n4;
          }
          I(e4, r4) {
            for (; e4; ) {
              let i5 = this.v(e4.u, r4);
              if (i5 < 0)
                e4 = e4.W;
              else if (i5 > 0)
                e4 = e4.U;
              else
                return e4;
            }
            return e4 || this.h;
          }
          clear() {
            this.i = 0, this.Y = void 0, this.h.tt = void 0, this.h.U = this.h.W = void 0;
          }
          updateKeyByIterator(e4, r4) {
            let i5 = e4.o;
            if (i5 === this.h && (0, lp2.throwIteratorAccessError)(), this.i === 1)
              return i5.u = r4, true;
            if (i5 === this.h.U)
              return this.v(i5.B().u, r4) > 0 ? (i5.u = r4, true) : false;
            if (i5 === this.h.W)
              return this.v(i5.L().u, r4) < 0 ? (i5.u = r4, true) : false;
            let n4 = i5.L().u;
            if (this.v(n4, r4) >= 0)
              return false;
            let o4 = i5.B().u;
            return this.v(o4, r4) <= 0 ? false : (i5.u = r4, true);
          }
          eraseElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4 = 0, i5 = this;
            return this.oe(this.Y, function(n4) {
              return e4 === r4 ? (i5.V(n4), true) : (r4 += 1, false);
            }), this.i;
          }
          eraseElementByKey(e4) {
            if (this.i === 0)
              return false;
            let r4 = this.I(this.Y, e4);
            return r4 === this.h ? false : (this.V(r4), true);
          }
          eraseElementByIterator(e4) {
            let r4 = e4.o;
            r4 === this.h && (0, lp2.throwIteratorAccessError)();
            let i5 = r4.W === void 0;
            return e4.iteratorType === 0 ? i5 && e4.next() : (!i5 || r4.U === void 0) && e4.next(), this.V(r4), e4;
          }
          forEach(e4) {
            let r4 = 0;
            for (let i5 of this)
              e4(i5, r4++, this);
          }
          getElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4, i5 = 0;
            for (let n4 of this) {
              if (i5 === e4) {
                r4 = n4;
                break;
              }
              i5 += 1;
            }
            return r4;
          }
          getHeight() {
            if (this.i === 0)
              return 0;
            let e4 = function(r4) {
              return r4 ? Math.max(e4(r4.U), e4(r4.W)) + 1 : 0;
            };
            return e4(this.Y);
          }
        }, $1 = ma3;
        Vn4.default = $1;
      });
      Sa2 = M3((Kn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Kn4, "t", { value: true });
        Kn4.default = void 0;
        var H1 = lt3(), zn4 = ut4(), Ea2 = class extends H1.ContainerIterator {
          constructor(e4, r4, i5) {
            super(i5), this.o = e4, this.h = r4, this.iteratorType === 0 ? (this.pre = function() {
              return this.o === this.h.U && (0, zn4.throwIteratorAccessError)(), this.o = this.o.L(), this;
            }, this.next = function() {
              return this.o === this.h && (0, zn4.throwIteratorAccessError)(), this.o = this.o.B(), this;
            }) : (this.pre = function() {
              return this.o === this.h.W && (0, zn4.throwIteratorAccessError)(), this.o = this.o.B(), this;
            }, this.next = function() {
              return this.o === this.h && (0, zn4.throwIteratorAccessError)(), this.o = this.o.L(), this;
            });
          }
          get index() {
            let e4 = this.o, r4 = this.h.tt;
            if (e4 === this.h)
              return r4 ? r4.rt - 1 : 0;
            let i5 = 0;
            for (e4.U && (i5 += e4.U.rt); e4 !== r4; ) {
              let n4 = e4.tt;
              e4 === n4.W && (i5 += 1, n4.U && (i5 += n4.U.rt)), e4 = n4;
            }
            return i5;
          }
        }, V1 = Ea2;
        Kn4.default = V1;
      });
      fp2 = M3((Gn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Gn4, "t", { value: true });
        Gn4.default = void 0;
        var z1 = up2(va2()), K1 = up2(Sa2()), G1 = ut4();
        function up2(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var Ke4 = class t4 extends K1.default {
          constructor(e4, r4, i5, n4) {
            super(e4, r4, n4), this.container = i5;
          }
          get pointer() {
            return this.o === this.h && (0, G1.throwIteratorAccessError)(), this.o.u;
          }
          copy() {
            return new t4(this.o, this.h, this.container, this.iteratorType);
          }
        }, Aa2 = class extends z1.default {
          constructor(e4 = [], r4, i5) {
            super(r4, i5);
            let n4 = this;
            e4.forEach(function(o4) {
              n4.insert(o4);
            });
          }
          *K(e4) {
            e4 !== void 0 && (yield* this.K(e4.U), yield e4.u, yield* this.K(e4.W));
          }
          begin() {
            return new Ke4(this.h.U || this.h, this.h, this);
          }
          end() {
            return new Ke4(this.h, this.h, this);
          }
          rBegin() {
            return new Ke4(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new Ke4(this.h, this.h, this, 1);
          }
          front() {
            return this.h.U ? this.h.U.u : void 0;
          }
          back() {
            return this.h.W ? this.h.W.u : void 0;
          }
          insert(e4, r4) {
            return this.M(e4, void 0, r4);
          }
          find(e4) {
            let r4 = this.I(this.Y, e4);
            return new Ke4(r4, this.h, this);
          }
          lowerBound(e4) {
            let r4 = this.X(this.Y, e4);
            return new Ke4(r4, this.h, this);
          }
          upperBound(e4) {
            let r4 = this.Z(this.Y, e4);
            return new Ke4(r4, this.h, this);
          }
          reverseLowerBound(e4) {
            let r4 = this.$(this.Y, e4);
            return new Ke4(r4, this.h, this);
          }
          reverseUpperBound(e4) {
            let r4 = this.rr(this.Y, e4);
            return new Ke4(r4, this.h, this);
          }
          union(e4) {
            let r4 = this;
            return e4.forEach(function(i5) {
              r4.insert(i5);
            }), this.i;
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        }, Q1 = Aa2;
        Gn4.default = Q1;
      });
      hp2 = M3((Qn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Qn4, "t", { value: true });
        Qn4.default = void 0;
        var Y1 = cp2(va2()), J1 = cp2(Sa2()), X1 = ut4();
        function cp2(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var Ge4 = class t4 extends J1.default {
          constructor(e4, r4, i5, n4) {
            super(e4, r4, n4), this.container = i5;
          }
          get pointer() {
            this.o === this.h && (0, X1.throwIteratorAccessError)();
            let e4 = this;
            return new Proxy([], { get(r4, i5) {
              if (i5 === "0")
                return e4.o.u;
              if (i5 === "1")
                return e4.o.l;
            }, set(r4, i5, n4) {
              if (i5 !== "1")
                throw new TypeError("props must be 1");
              return e4.o.l = n4, true;
            } });
          }
          copy() {
            return new t4(this.o, this.h, this.container, this.iteratorType);
          }
        }, Ia2 = class extends Y1.default {
          constructor(e4 = [], r4, i5) {
            super(r4, i5);
            let n4 = this;
            e4.forEach(function(o4) {
              n4.setElement(o4[0], o4[1]);
            });
          }
          *K(e4) {
            e4 !== void 0 && (yield* this.K(e4.U), yield [e4.u, e4.l], yield* this.K(e4.W));
          }
          begin() {
            return new Ge4(this.h.U || this.h, this.h, this);
          }
          end() {
            return new Ge4(this.h, this.h, this);
          }
          rBegin() {
            return new Ge4(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new Ge4(this.h, this.h, this, 1);
          }
          front() {
            if (this.i === 0)
              return;
            let e4 = this.h.U;
            return [e4.u, e4.l];
          }
          back() {
            if (this.i === 0)
              return;
            let e4 = this.h.W;
            return [e4.u, e4.l];
          }
          lowerBound(e4) {
            let r4 = this.X(this.Y, e4);
            return new Ge4(r4, this.h, this);
          }
          upperBound(e4) {
            let r4 = this.Z(this.Y, e4);
            return new Ge4(r4, this.h, this);
          }
          reverseLowerBound(e4) {
            let r4 = this.$(this.Y, e4);
            return new Ge4(r4, this.h, this);
          }
          reverseUpperBound(e4) {
            let r4 = this.rr(this.Y, e4);
            return new Ge4(r4, this.h, this);
          }
          setElement(e4, r4, i5) {
            return this.M(e4, r4, i5);
          }
          find(e4) {
            let r4 = this.I(this.Y, e4);
            return new Ge4(r4, this.h, this);
          }
          getElementByKey(e4) {
            return this.I(this.Y, e4).l;
          }
          union(e4) {
            let r4 = this;
            return e4.forEach(function(i5) {
              r4.setElement(i5[0], i5[1]);
            }), this.i;
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        }, Z1 = Ia2;
        Qn4.default = Z1;
      });
      Ra2 = M3((Ta2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Ta2, "t", { value: true });
        Ta2.default = ev;
        function ev(t4) {
          let e4 = typeof t4;
          return e4 === "object" && t4 !== null || e4 === "function";
        }
      });
      Oa2 = M3((ei3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(ei3, "t", { value: true });
        ei3.HashContainerIterator = ei3.HashContainer = void 0;
        var dp2 = lt3(), Ca2 = tv(Ra2()), Ti3 = ut4();
        function tv(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var Ba2 = class extends dp2.ContainerIterator {
          constructor(e4, r4, i5) {
            super(i5), this.o = e4, this.h = r4, this.iteratorType === 0 ? (this.pre = function() {
              return this.o.L === this.h && (0, Ti3.throwIteratorAccessError)(), this.o = this.o.L, this;
            }, this.next = function() {
              return this.o === this.h && (0, Ti3.throwIteratorAccessError)(), this.o = this.o.B, this;
            }) : (this.pre = function() {
              return this.o.B === this.h && (0, Ti3.throwIteratorAccessError)(), this.o = this.o.B, this;
            }, this.next = function() {
              return this.o === this.h && (0, Ti3.throwIteratorAccessError)(), this.o = this.o.L, this;
            });
          }
        };
        ei3.HashContainerIterator = Ba2;
        var Pa2 = class extends dp2.Container {
          constructor() {
            super(), this.H = [], this.g = {}, this.HASH_TAG = Symbol("@@HASH_TAG"), Object.setPrototypeOf(this.g, null), this.h = {}, this.h.L = this.h.B = this.p = this._ = this.h;
          }
          V(e4) {
            let { L: r4, B: i5 } = e4;
            r4.B = i5, i5.L = r4, e4 === this.p && (this.p = i5), e4 === this._ && (this._ = r4), this.i -= 1;
          }
          M(e4, r4, i5) {
            i5 === void 0 && (i5 = (0, Ca2.default)(e4));
            let n4;
            if (i5) {
              let o4 = e4[this.HASH_TAG];
              if (o4 !== void 0)
                return this.H[o4].l = r4, this.i;
              Object.defineProperty(e4, this.HASH_TAG, { value: this.H.length, configurable: true }), n4 = { u: e4, l: r4, L: this._, B: this.h }, this.H.push(n4);
            } else {
              let o4 = this.g[e4];
              if (o4)
                return o4.l = r4, this.i;
              n4 = { u: e4, l: r4, L: this._, B: this.h }, this.g[e4] = n4;
            }
            return this.i === 0 ? (this.p = n4, this.h.B = n4) : this._.B = n4, this._ = n4, this.h.L = n4, ++this.i;
          }
          I(e4, r4) {
            if (r4 === void 0 && (r4 = (0, Ca2.default)(e4)), r4) {
              let i5 = e4[this.HASH_TAG];
              return i5 === void 0 ? this.h : this.H[i5];
            } else
              return this.g[e4] || this.h;
          }
          clear() {
            let e4 = this.HASH_TAG;
            this.H.forEach(function(r4) {
              delete r4.u[e4];
            }), this.H = [], this.g = {}, Object.setPrototypeOf(this.g, null), this.i = 0, this.p = this._ = this.h.L = this.h.B = this.h;
          }
          eraseElementByKey(e4, r4) {
            let i5;
            if (r4 === void 0 && (r4 = (0, Ca2.default)(e4)), r4) {
              let n4 = e4[this.HASH_TAG];
              if (n4 === void 0)
                return false;
              delete e4[this.HASH_TAG], i5 = this.H[n4], delete this.H[n4];
            } else {
              if (i5 = this.g[e4], i5 === void 0)
                return false;
              delete this.g[e4];
            }
            return this.V(i5), true;
          }
          eraseElementByIterator(e4) {
            let r4 = e4.o;
            return r4 === this.h && (0, Ti3.throwIteratorAccessError)(), this.V(r4), e4.next();
          }
          eraseElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4 = this.p;
            for (; e4--; )
              r4 = r4.B;
            return this.V(r4), this.i;
          }
        };
        ei3.HashContainer = Pa2;
      });
      gp2 = M3((Yn3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Yn3, "t", { value: true });
        Yn3.default = void 0;
        var pp2 = Oa2(), rv = ut4(), Er3 = class t4 extends pp2.HashContainerIterator {
          constructor(e4, r4, i5, n4) {
            super(e4, r4, n4), this.container = i5;
          }
          get pointer() {
            return this.o === this.h && (0, rv.throwIteratorAccessError)(), this.o.u;
          }
          copy() {
            return new t4(this.o, this.h, this.container, this.iteratorType);
          }
        }, ka2 = class extends pp2.HashContainer {
          constructor(e4 = []) {
            super();
            let r4 = this;
            e4.forEach(function(i5) {
              r4.insert(i5);
            });
          }
          begin() {
            return new Er3(this.p, this.h, this);
          }
          end() {
            return new Er3(this.h, this.h, this);
          }
          rBegin() {
            return new Er3(this._, this.h, this, 1);
          }
          rEnd() {
            return new Er3(this.h, this.h, this, 1);
          }
          front() {
            return this.p.u;
          }
          back() {
            return this._.u;
          }
          insert(e4, r4) {
            return this.M(e4, void 0, r4);
          }
          getElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4 = this.p;
            for (; e4--; )
              r4 = r4.B;
            return r4.u;
          }
          find(e4, r4) {
            let i5 = this.I(e4, r4);
            return new Er3(i5, this.h, this);
          }
          forEach(e4) {
            let r4 = 0, i5 = this.p;
            for (; i5 !== this.h; )
              e4(i5.u, r4++, this), i5 = i5.B;
          }
          [Symbol.iterator]() {
            return function* () {
              let e4 = this.p;
              for (; e4 !== this.h; )
                yield e4.u, e4 = e4.B;
            }.bind(this)();
          }
        }, iv = ka2;
        Yn3.default = iv;
      });
      bp2 = M3((Jn4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Jn4, "t", { value: true });
        Jn4.default = void 0;
        var yp2 = Oa2(), nv = ov(Ra2()), sv = ut4();
        function ov(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
        var Sr3 = class t4 extends yp2.HashContainerIterator {
          constructor(e4, r4, i5, n4) {
            super(e4, r4, n4), this.container = i5;
          }
          get pointer() {
            this.o === this.h && (0, sv.throwIteratorAccessError)();
            let e4 = this;
            return new Proxy([], { get(r4, i5) {
              if (i5 === "0")
                return e4.o.u;
              if (i5 === "1")
                return e4.o.l;
            }, set(r4, i5, n4) {
              if (i5 !== "1")
                throw new TypeError("props must be 1");
              return e4.o.l = n4, true;
            } });
          }
          copy() {
            return new t4(this.o, this.h, this.container, this.iteratorType);
          }
        }, xa2 = class extends yp2.HashContainer {
          constructor(e4 = []) {
            super();
            let r4 = this;
            e4.forEach(function(i5) {
              r4.setElement(i5[0], i5[1]);
            });
          }
          begin() {
            return new Sr3(this.p, this.h, this);
          }
          end() {
            return new Sr3(this.h, this.h, this);
          }
          rBegin() {
            return new Sr3(this._, this.h, this, 1);
          }
          rEnd() {
            return new Sr3(this.h, this.h, this, 1);
          }
          front() {
            if (this.i !== 0)
              return [this.p.u, this.p.l];
          }
          back() {
            if (this.i !== 0)
              return [this._.u, this._.l];
          }
          setElement(e4, r4, i5) {
            return this.M(e4, r4, i5);
          }
          getElementByKey(e4, r4) {
            if (r4 === void 0 && (r4 = (0, nv.default)(e4)), r4) {
              let n4 = e4[this.HASH_TAG];
              return n4 !== void 0 ? this.H[n4].l : void 0;
            }
            let i5 = this.g[e4];
            return i5 ? i5.l : void 0;
          }
          getElementByPos(e4) {
            if (e4 < 0 || e4 > this.i - 1)
              throw new RangeError();
            let r4 = this.p;
            for (; e4--; )
              r4 = r4.B;
            return [r4.u, r4.l];
          }
          find(e4, r4) {
            let i5 = this.I(e4, r4);
            return new Sr3(i5, this.h, this);
          }
          forEach(e4) {
            let r4 = 0, i5 = this.p;
            for (; i5 !== this.h; )
              e4([i5.u, i5.l], r4++, this), i5 = i5.B;
          }
          [Symbol.iterator]() {
            return function* () {
              let e4 = this.p;
              for (; e4 !== this.h; )
                yield [e4.u, e4.l], e4 = e4.B;
            }.bind(this)();
          }
        }, av = xa2;
        Jn4.default = av;
      });
      wp2 = M3((je4) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(je4, "t", { value: true });
        Object.defineProperty(je4, "Deque", { enumerable: true, get: function() {
          return dv.default;
        } });
        Object.defineProperty(je4, "HashMap", { enumerable: true, get: function() {
          return bv.default;
        } });
        Object.defineProperty(je4, "HashSet", { enumerable: true, get: function() {
          return yv.default;
        } });
        Object.defineProperty(je4, "LinkList", { enumerable: true, get: function() {
          return hv.default;
        } });
        Object.defineProperty(je4, "OrderedMap", { enumerable: true, get: function() {
          return gv.default;
        } });
        Object.defineProperty(je4, "OrderedSet", { enumerable: true, get: function() {
          return pv.default;
        } });
        Object.defineProperty(je4, "PriorityQueue", { enumerable: true, get: function() {
          return fv.default;
        } });
        Object.defineProperty(je4, "Queue", { enumerable: true, get: function() {
          return uv.default;
        } });
        Object.defineProperty(je4, "Stack", { enumerable: true, get: function() {
          return lv.default;
        } });
        Object.defineProperty(je4, "Vector", { enumerable: true, get: function() {
          return cv.default;
        } });
        var lv = ft4(ep2()), uv = ft4(tp2()), fv = ft4(rp2()), cv = ft4(ip2()), hv = ft4(np2()), dv = ft4(sp2()), pv = ft4(fp2()), gv = ft4(hp2()), yv = ft4(gp2()), bv = ft4(bp2());
        function ft4(t4) {
          return t4 && t4.t ? t4 : { default: t4 };
        }
      });
      mp2 = M3((SN, _p2) => {
        "use strict";
        v3();
        m3();
        _3();
        var wv = wp2().OrderedSet, ct4 = ot3()("number-allocator:trace"), _v = ot3()("number-allocator:error");
        function Te4(t4, e4) {
          this.low = t4, this.high = e4;
        }
        Te4.prototype.equals = function(t4) {
          return this.low === t4.low && this.high === t4.high;
        };
        Te4.prototype.compare = function(t4) {
          return this.low < t4.low && this.high < t4.low ? -1 : t4.low < this.low && t4.high < this.low ? 1 : 0;
        };
        function ht4(t4, e4) {
          if (!(this instanceof ht4))
            return new ht4(t4, e4);
          this.min = t4, this.max = e4, this.ss = new wv([], (r4, i5) => r4.compare(i5)), ct4("Create"), this.clear();
        }
        ht4.prototype.firstVacant = function() {
          return this.ss.size() === 0 ? null : this.ss.front().low;
        };
        ht4.prototype.alloc = function() {
          if (this.ss.size() === 0)
            return ct4("alloc():empty"), null;
          let t4 = this.ss.begin(), e4 = t4.pointer.low, r4 = t4.pointer.high, i5 = e4;
          return i5 + 1 <= r4 ? this.ss.updateKeyByIterator(t4, new Te4(e4 + 1, r4)) : this.ss.eraseElementByPos(0), ct4("alloc():" + i5), i5;
        };
        ht4.prototype.use = function(t4) {
          let e4 = new Te4(t4, t4), r4 = this.ss.lowerBound(e4);
          if (!r4.equals(this.ss.end())) {
            let i5 = r4.pointer.low, n4 = r4.pointer.high;
            return r4.pointer.equals(e4) ? (this.ss.eraseElementByIterator(r4), ct4("use():" + t4), true) : i5 > t4 ? false : i5 === t4 ? (this.ss.updateKeyByIterator(r4, new Te4(i5 + 1, n4)), ct4("use():" + t4), true) : n4 === t4 ? (this.ss.updateKeyByIterator(r4, new Te4(i5, n4 - 1)), ct4("use():" + t4), true) : (this.ss.updateKeyByIterator(r4, new Te4(t4 + 1, n4)), this.ss.insert(new Te4(i5, t4 - 1)), ct4("use():" + t4), true);
          }
          return ct4("use():failed"), false;
        };
        ht4.prototype.free = function(t4) {
          if (t4 < this.min || t4 > this.max) {
            _v("free():" + t4 + " is out of range");
            return;
          }
          let e4 = new Te4(t4, t4), r4 = this.ss.upperBound(e4);
          if (r4.equals(this.ss.end())) {
            if (r4.equals(this.ss.begin())) {
              this.ss.insert(e4);
              return;
            }
            r4.pre();
            let i5 = r4.pointer.high;
            r4.pointer.high + 1 === t4 ? this.ss.updateKeyByIterator(r4, new Te4(i5, t4)) : this.ss.insert(e4);
          } else if (r4.equals(this.ss.begin()))
            if (t4 + 1 === r4.pointer.low) {
              let i5 = r4.pointer.high;
              this.ss.updateKeyByIterator(r4, new Te4(t4, i5));
            } else
              this.ss.insert(e4);
          else {
            let i5 = r4.pointer.low, n4 = r4.pointer.high;
            r4.pre();
            let o4 = r4.pointer.low;
            r4.pointer.high + 1 === t4 ? t4 + 1 === i5 ? (this.ss.eraseElementByIterator(r4), this.ss.updateKeyByIterator(r4, new Te4(o4, n4))) : this.ss.updateKeyByIterator(r4, new Te4(o4, t4)) : t4 + 1 === i5 ? (this.ss.eraseElementByIterator(r4.next()), this.ss.insert(new Te4(t4, n4))) : this.ss.insert(e4);
          }
          ct4("free():" + t4);
        };
        ht4.prototype.clear = function() {
          ct4("clear()"), this.ss.clear(), this.ss.insert(new Te4(this.min, this.max));
        };
        ht4.prototype.intervalCount = function() {
          return this.ss.size();
        };
        ht4.prototype.dump = function() {
          console.log("length:" + this.ss.size());
          for (let t4 of this.ss)
            console.log(t4);
        };
        _p2.exports = ht4;
      });
      Ma2 = M3((xN, vp2) => {
        v3();
        m3();
        _3();
        var mv = mp2();
        vp2.exports.NumberAllocator = mv;
      });
      Ep2 = M3((Ua2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Ua2, "__esModule", { value: true });
        var vv = Zd2(), Ev = Ma2(), La2 = class {
          constructor(e4) {
            e4 > 0 && (this.aliasToTopic = new vv.LRUCache({ max: e4 }), this.topicToAlias = {}, this.numberAllocator = new Ev.NumberAllocator(1, e4), this.max = e4, this.length = 0);
          }
          put(e4, r4) {
            if (r4 === 0 || r4 > this.max)
              return false;
            let i5 = this.aliasToTopic.get(r4);
            return i5 && delete this.topicToAlias[i5], this.aliasToTopic.set(r4, e4), this.topicToAlias[e4] = r4, this.numberAllocator.use(r4), this.length = this.aliasToTopic.size, true;
          }
          getTopicByAlias(e4) {
            return this.aliasToTopic.get(e4);
          }
          getAliasByTopic(e4) {
            let r4 = this.topicToAlias[e4];
            return typeof r4 < "u" && this.aliasToTopic.get(r4), r4;
          }
          clear() {
            this.aliasToTopic.clear(), this.topicToAlias = {}, this.numberAllocator.clear(), this.length = 0;
          }
          getLruAlias() {
            let e4 = this.numberAllocator.firstVacant();
            return e4 || [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
          }
        };
        Ua2.default = La2;
      });
      Sp2 = M3((Ri3) => {
        "use strict";
        v3();
        m3();
        _3();
        var Sv = Ri3 && Ri3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Ri3, "__esModule", { value: true });
        var Av = Ai3(), Iv = Sv(Ep2()), Tv = Jr3(), Rv = (t4, e4) => {
          t4.log("_handleConnack");
          let { options: r4 } = t4, n4 = r4.protocolVersion === 5 ? e4.reasonCode : e4.returnCode;
          if (clearTimeout(t4.connackTimer), delete t4.topicAliasSend, e4.properties) {
            if (e4.properties.topicAliasMaximum) {
              if (e4.properties.topicAliasMaximum > 65535) {
                t4.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                return;
              }
              e4.properties.topicAliasMaximum > 0 && (t4.topicAliasSend = new Iv.default(e4.properties.topicAliasMaximum));
            }
            e4.properties.serverKeepAlive && r4.keepalive && (r4.keepalive = e4.properties.serverKeepAlive, t4._shiftPingInterval()), e4.properties.maximumPacketSize && (r4.properties || (r4.properties = {}), r4.properties.maximumPacketSize = e4.properties.maximumPacketSize);
          }
          if (n4 === 0)
            t4.reconnecting = false, t4._onConnect(e4);
          else if (n4 > 0) {
            let o4 = new Tv.ErrorWithReasonCode(`Connection refused: ${Av.ReasonCodes[n4]}`, n4);
            t4.emit("error", o4);
          }
        };
        Ri3.default = Rv;
      });
      Ap2 = M3((Na2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Na2, "__esModule", { value: true });
        var Cv = (t4, e4, r4) => {
          t4.log("handling pubrel packet");
          let i5 = typeof r4 < "u" ? r4 : t4.noop, { messageId: n4 } = e4, o4 = { cmd: "pubcomp", messageId: n4 };
          t4.incomingStore.get(e4, (s4, a4) => {
            s4 ? t4._sendPacket(o4, i5) : (t4.emit("message", a4.topic, a4.payload, a4), t4.handleMessage(a4, (u4) => {
              if (u4)
                return i5(u4);
              t4.incomingStore.del(a4, t4.noop), t4._sendPacket(o4, i5);
            }));
          });
        };
        Na2.default = Cv;
      });
      Ip2 = M3((Ci3) => {
        "use strict";
        v3();
        m3();
        _3();
        var Bi3 = Ci3 && Ci3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Ci3, "__esModule", { value: true });
        var Bv = Bi3(Vd()), Pv = Bi3(Gd()), Ov = Bi3(Sp2()), kv = Bi3(Ai3()), xv = Bi3(Ap2()), Mv = (t4, e4, r4) => {
          let { options: i5 } = t4;
          if (i5.protocolVersion === 5 && i5.properties && i5.properties.maximumPacketSize && i5.properties.maximumPacketSize < e4.length)
            return t4.emit("error", new Error(`exceeding packets size ${e4.cmd}`)), t4.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } }), t4;
          switch (t4.log("_handlePacket :: emitting packetreceive"), t4.emit("packetreceive", e4), e4.cmd) {
            case "publish":
              (0, Bv.default)(t4, e4, r4);
              break;
            case "puback":
            case "pubrec":
            case "pubcomp":
            case "suback":
            case "unsuback":
              (0, kv.default)(t4, e4), r4();
              break;
            case "pubrel":
              (0, xv.default)(t4, e4, r4);
              break;
            case "connack":
              (0, Ov.default)(t4, e4), r4();
              break;
            case "auth":
              (0, Pv.default)(t4, e4), r4();
              break;
            case "pingresp":
              t4.pingResp = true, r4();
              break;
            case "disconnect":
              t4.emit("disconnect", e4), r4();
              break;
            default:
              t4.log("_handlePacket :: unknown command"), r4();
              break;
          }
        };
        Ci3.default = Mv;
      });
      Tp2 = M3((ti3) => {
        "use strict";
        v3();
        m3();
        _3();
        var Lv = ti3 && ti3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(ti3, "__esModule", { value: true });
        ti3.TypedEventEmitter = void 0;
        var Uv = Lv((ir3(), X3(rr3))), Nv = Jr3(), Xn4 = class {
        };
        ti3.TypedEventEmitter = Xn4;
        (0, Nv.applyMixin)(Xn4, Uv.default);
      });
      Pi3 = M3((Ar3) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Ar3, "__esModule", { value: true });
        Ar3.isReactNativeBrowser = Ar3.isWebWorker = void 0;
        var qv = () => typeof window < "u" && typeof window.document < "u", Rp = () => {
          var t4, e4;
          return !!(typeof self == "object" && (!((e4 = (t4 = self?.constructor) === null || t4 === void 0 ? void 0 : t4.name) === null || e4 === void 0) && e4.includes("WorkerGlobalScope")));
        }, Cp2 = () => typeof B4 < "u" && B4.product === "ReactNative", Dv = qv() || Rp() || Cp2();
        Ar3.isWebWorker = Rp();
        Ar3.isReactNativeBrowser = Cp2();
        Ar3.default = Dv;
      });
      Pp2 = M3((Zn4, Bp2) => {
        v3();
        m3();
        _3();
        (function(t4, e4) {
          typeof Zn4 == "object" && typeof Bp2 < "u" ? e4(Zn4) : typeof define == "function" && define.amd ? define(["exports"], e4) : (t4 = typeof globalThis < "u" ? globalThis : t4 || self, e4(t4.fastUniqueNumbers = {}));
        })(Zn4, function(t4) {
          "use strict";
          var e4 = function(g4) {
            return function(y3) {
              var w3 = g4(y3);
              return y3.add(w3), w3;
            };
          }, r4 = function(g4) {
            return function(y3, w3) {
              return g4.set(y3, w3), w3;
            };
          }, i5 = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER, n4 = 536870912, o4 = n4 * 2, s4 = function(g4, y3) {
            return function(w3) {
              var E4 = y3.get(w3), S3 = E4 === void 0 ? w3.size : E4 < o4 ? E4 + 1 : 0;
              if (!w3.has(S3))
                return g4(w3, S3);
              if (w3.size < n4) {
                for (; w3.has(S3); )
                  S3 = Math.floor(Math.random() * o4);
                return g4(w3, S3);
              }
              if (w3.size > i5)
                throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
              for (; w3.has(S3); )
                S3 = Math.floor(Math.random() * i5);
              return g4(w3, S3);
            };
          }, a4 = /* @__PURE__ */ new WeakMap(), u4 = r4(a4), c5 = s4(u4, a4), h4 = e4(c5);
          t4.addUniqueNumber = h4, t4.generateUniqueNumber = c5;
        });
      });
      kp2 = M3((es3, Op2) => {
        v3();
        m3();
        _3();
        (function(t4, e4) {
          typeof es3 == "object" && typeof Op2 < "u" ? e4(es3, Pp2()) : typeof define == "function" && define.amd ? define(["exports", "fast-unique-numbers"], e4) : (t4 = typeof globalThis < "u" ? globalThis : t4 || self, e4(t4.workerTimersBroker = {}, t4.fastUniqueNumbers));
        })(es3, function(t4, e4) {
          "use strict";
          var r4 = function(s4) {
            return s4.method !== void 0 && s4.method === "call";
          }, i5 = function(s4) {
            return s4.error === null && typeof s4.id == "number";
          }, n4 = function(s4) {
            var a4 = /* @__PURE__ */ new Map([[0, function() {
            }]]), u4 = /* @__PURE__ */ new Map([[0, function() {
            }]]), c5 = /* @__PURE__ */ new Map(), h4 = new Worker(s4);
            h4.addEventListener("message", function(E4) {
              var S3 = E4.data;
              if (r4(S3)) {
                var I3 = S3.params, C3 = I3.timerId, R5 = I3.timerType;
                if (R5 === "interval") {
                  var U5 = a4.get(C3);
                  if (typeof U5 == "number") {
                    var N4 = c5.get(U5);
                    if (N4 === void 0 || N4.timerId !== C3 || N4.timerType !== R5)
                      throw new Error("The timer is in an undefined state.");
                  } else if (typeof U5 < "u")
                    U5();
                  else
                    throw new Error("The timer is in an undefined state.");
                } else if (R5 === "timeout") {
                  var W4 = u4.get(C3);
                  if (typeof W4 == "number") {
                    var K5 = c5.get(W4);
                    if (K5 === void 0 || K5.timerId !== C3 || K5.timerType !== R5)
                      throw new Error("The timer is in an undefined state.");
                  } else if (typeof W4 < "u")
                    W4(), u4.delete(C3);
                  else
                    throw new Error("The timer is in an undefined state.");
                }
              } else if (i5(S3)) {
                var z4 = S3.id, Q3 = c5.get(z4);
                if (Q3 === void 0)
                  throw new Error("The timer is in an undefined state.");
                var de3 = Q3.timerId, Gt3 = Q3.timerType;
                c5.delete(z4), Gt3 === "interval" ? a4.delete(de3) : u4.delete(de3);
              } else {
                var pe3 = S3.error.message;
                throw new Error(pe3);
              }
            });
            var d4 = function(S3) {
              var I3 = e4.generateUniqueNumber(c5);
              c5.set(I3, { timerId: S3, timerType: "interval" }), a4.set(S3, I3), h4.postMessage({ id: I3, method: "clear", params: { timerId: S3, timerType: "interval" } });
            }, g4 = function(S3) {
              var I3 = e4.generateUniqueNumber(c5);
              c5.set(I3, { timerId: S3, timerType: "timeout" }), u4.set(S3, I3), h4.postMessage({ id: I3, method: "clear", params: { timerId: S3, timerType: "timeout" } });
            }, y3 = function(S3) {
              var I3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, C3 = e4.generateUniqueNumber(a4);
              return a4.set(C3, function() {
                S3(), typeof a4.get(C3) == "function" && h4.postMessage({ id: null, method: "set", params: { delay: I3, now: performance.now(), timerId: C3, timerType: "interval" } });
              }), h4.postMessage({ id: null, method: "set", params: { delay: I3, now: performance.now(), timerId: C3, timerType: "interval" } }), C3;
            }, w3 = function(S3) {
              var I3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, C3 = e4.generateUniqueNumber(u4);
              return u4.set(C3, S3), h4.postMessage({ id: null, method: "set", params: { delay: I3, now: performance.now(), timerId: C3, timerType: "timeout" } }), C3;
            };
            return { clearInterval: d4, clearTimeout: g4, setInterval: y3, setTimeout: w3 };
          };
          t4.load = n4;
        });
      });
      Mp2 = M3((ts3, xp2) => {
        v3();
        m3();
        _3();
        (function(t4, e4) {
          typeof ts3 == "object" && typeof xp2 < "u" ? e4(ts3, kp2()) : typeof define == "function" && define.amd ? define(["exports", "worker-timers-broker"], e4) : (t4 = typeof globalThis < "u" ? globalThis : t4 || self, e4(t4.workerTimers = {}, t4.workerTimersBroker));
        })(ts3, function(t4, e4) {
          "use strict";
          var r4 = function(h4, d4) {
            var g4 = null;
            return function() {
              if (g4 !== null)
                return g4;
              var y3 = new Blob([d4], { type: "application/javascript; charset=utf-8" }), w3 = URL.createObjectURL(y3);
              return g4 = h4(w3), setTimeout(function() {
                return URL.revokeObjectURL(w3);
              }), g4;
            };
          }, i5 = `(()=>{var e={472:(e,t,r)=>{var o,i;void 0===(i="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:"call",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,"interval"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if("interval"===c)r(d),postMessage({error:null,id:i});else{if("timeout"!==c)throw new Error('The given type "'.concat(c,'" is not supported'));o(d),postMessage({error:null,id:i})}}else{if("set"!==t.method)throw new Error('The given method "'.concat(t.method,'" is not supported'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if("interval"===v)a(l,m,p);else{if("timeout"!==v)throw new Error('The given type "'.concat(v,'" is not supported'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();`, n4 = r4(e4.load, i5), o4 = function(h4) {
            return n4().clearInterval(h4);
          }, s4 = function(h4) {
            return n4().clearTimeout(h4);
          }, a4 = function() {
            var h4;
            return (h4 = n4()).setInterval.apply(h4, arguments);
          }, u4 = function() {
            var h4;
            return (h4 = n4()).setTimeout.apply(h4, arguments);
          };
          t4.clearInterval = o4, t4.clearTimeout = s4, t4.setInterval = a4, t4.setTimeout = u4;
        });
      });
      qp2 = M3((Ct3) => {
        "use strict";
        v3();
        m3();
        _3();
        var jv = Ct3 && Ct3.__createBinding || (Object.create ? function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4);
          var n4 = Object.getOwnPropertyDescriptor(e4, r4);
          (!n4 || ("get" in n4 ? !e4.__esModule : n4.writable || n4.configurable)) && (n4 = { enumerable: true, get: function() {
            return e4[r4];
          } }), Object.defineProperty(t4, i5, n4);
        } : function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4), t4[i5] = e4[r4];
        }), Fv = Ct3 && Ct3.__setModuleDefault || (Object.create ? function(t4, e4) {
          Object.defineProperty(t4, "default", { enumerable: true, value: e4 });
        } : function(t4, e4) {
          t4.default = e4;
        }), Wv = Ct3 && Ct3.__importStar || function(t4) {
          if (t4 && t4.__esModule)
            return t4;
          var e4 = {};
          if (t4 != null)
            for (var r4 in t4)
              r4 !== "default" && Object.prototype.hasOwnProperty.call(t4, r4) && jv(e4, t4, r4);
          return Fv(e4, t4), e4;
        };
        Object.defineProperty(Ct3, "__esModule", { value: true });
        var qa3 = Wv(Pi3()), Lp = Mp2(), Up2 = { set: Lp.setTimeout, clear: Lp.clearTimeout }, Np = { set: (t4, e4) => setTimeout(t4, e4), clear: (t4) => clearTimeout(t4) }, $v = (t4) => {
          switch (t4) {
            case "native":
              return Np;
            case "worker":
              return Up2;
            case "auto":
            default:
              return qa3.default && !qa3.isWebWorker && !qa3.isReactNativeBrowser ? Up2 : Np;
          }
        };
        Ct3.default = $v;
      });
      ja3 = M3((Oi3) => {
        "use strict";
        v3();
        m3();
        _3();
        var Hv = Oi3 && Oi3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Oi3, "__esModule", { value: true });
        var Vv = Hv(qp2()), Da2 = class {
          constructor(e4, r4, i5) {
            this.destroyed = false, this.keepalive = e4 * 1e3, this.checkPing = r4, this.timer = (0, Vv.default)(i5), this.reschedule();
          }
          clear() {
            this.timerId && (this.timer.clear(this.timerId), this.timerId = null);
          }
          destroy() {
            this.clear(), this.destroyed = true;
          }
          reschedule() {
            this.destroyed || (this.clear(), this.timerId = this.timer.set(() => {
              this.destroyed || (this.checkPing(), this.reschedule());
            }, this.keepalive));
          }
        };
        Oi3.default = Da2;
      });
      ss3 = M3((Qe3) => {
        "use strict";
        v3();
        m3();
        _3();
        var zv = Qe3 && Qe3.__createBinding || (Object.create ? function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4);
          var n4 = Object.getOwnPropertyDescriptor(e4, r4);
          (!n4 || ("get" in n4 ? !e4.__esModule : n4.writable || n4.configurable)) && (n4 = { enumerable: true, get: function() {
            return e4[r4];
          } }), Object.defineProperty(t4, i5, n4);
        } : function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4), t4[i5] = e4[r4];
        }), Kv = Qe3 && Qe3.__setModuleDefault || (Object.create ? function(t4, e4) {
          Object.defineProperty(t4, "default", { enumerable: true, value: e4 });
        } : function(t4, e4) {
          t4.default = e4;
        }), $p2 = Qe3 && Qe3.__importStar || function(t4) {
          if (t4 && t4.__esModule)
            return t4;
          var e4 = {};
          if (t4 != null)
            for (var r4 in t4)
              r4 !== "default" && Object.prototype.hasOwnProperty.call(t4, r4) && zv(e4, t4, r4);
          return Kv(e4, t4), e4;
        }, Vt4 = Qe3 && Qe3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Qe3, "__esModule", { value: true });
        var Gv = Vt4(Gu2()), Fa2 = Vt4(Nd2()), Qv = Vt4(Jo3()), Yv = jt4(), Dp = Vt4(Fd2()), jp2 = $p2($d2()), Jv = Vt4(ot3()), rs3 = Vt4(ea3()), Xv = Vt4(Ip2()), is3 = Jr3(), Zv = Tp2(), eE = Vt4(ja3()), Fp2 = $p2(Pi3()), Wa2 = globalThis.setImmediate || ((...t4) => {
          let e4 = t4.shift();
          (0, is3.nextTick)(() => {
            e4(...t4);
          });
        }), Wp2 = { keepalive: 60, reschedulePings: true, protocolId: "MQTT", protocolVersion: 4, reconnectPeriod: 1e3, connectTimeout: 30 * 1e3, clean: true, resubscribe: true, writeCache: true, timerVariant: "auto" }, ns3 = class t4 extends Zv.TypedEventEmitter {
          static defaultId() {
            return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
          }
          constructor(e4, r4) {
            super(), this.options = r4 || {};
            for (let i5 in Wp2)
              typeof this.options[i5] > "u" ? this.options[i5] = Wp2[i5] : this.options[i5] = r4[i5];
            this.log = this.options.log || (0, Jv.default)("mqttjs:client"), this.noop = this._noop.bind(this), this.log("MqttClient :: version:", t4.VERSION), Fp2.isWebWorker ? this.log("MqttClient :: environment", "webworker") : this.log("MqttClient :: environment", Fp2.default ? "browser" : "node"), this.log("MqttClient :: options.protocol", r4.protocol), this.log("MqttClient :: options.protocolVersion", r4.protocolVersion), this.log("MqttClient :: options.username", r4.username), this.log("MqttClient :: options.keepalive", r4.keepalive), this.log("MqttClient :: options.reconnectPeriod", r4.reconnectPeriod), this.log("MqttClient :: options.rejectUnauthorized", r4.rejectUnauthorized), this.log("MqttClient :: options.properties.topicAliasMaximum", r4.properties ? r4.properties.topicAliasMaximum : void 0), this.options.clientId = typeof r4.clientId == "string" ? r4.clientId : t4.defaultId(), this.log("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = r4.protocolVersion === 5 && r4.customHandleAcks ? r4.customHandleAcks : (...i5) => {
              i5[3](null, 0);
            }, this.options.writeCache || (Fa2.default.writeToStream.cacheNumbers = false), this.streamBuilder = e4, this.messageIdProvider = typeof this.options.messageIdProvider > "u" ? new Qv.default() : this.options.messageIdProvider, this.outgoingStore = r4.outgoingStore || new rs3.default(), this.incomingStore = r4.incomingStore || new rs3.default(), this.queueQoSZero = r4.queueQoSZero === void 0 ? true : r4.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = false, this.disconnecting = false, this.reconnecting = false, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this._storeProcessing = false, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], this.outgoing = {}, this._firstConnection = true, r4.properties && r4.properties.topicAliasMaximum > 0 && (r4.properties.topicAliasMaximum > 65535 ? this.log("MqttClient :: options.properties.topicAliasMaximum is out of range") : this.topicAliasRecv = new Gv.default(r4.properties.topicAliasMaximum)), this.on("connect", () => {
              let { queue: i5 } = this, n4 = () => {
                let o4 = i5.shift();
                this.log("deliver :: entry %o", o4);
                let s4 = null;
                if (!o4) {
                  this._resubscribe();
                  return;
                }
                s4 = o4.packet, this.log("deliver :: call _sendPacket for %o", s4);
                let a4 = true;
                s4.messageId && s4.messageId !== 0 && (this.messageIdProvider.register(s4.messageId) || (a4 = false)), a4 ? this._sendPacket(s4, (u4) => {
                  o4.cb && o4.cb(u4), n4();
                }) : (this.log("messageId: %d has already used. The message is skipped and removed.", s4.messageId), n4());
              };
              this.log("connect :: sending queued packets"), n4();
            }), this.on("close", () => {
              this.log("close :: connected set to `false`"), this.connected = false, this.log("close :: clearing connackTimer"), clearTimeout(this.connackTimer), this.log("close :: destroy ping timer"), this.pingTimer && (this.pingTimer.destroy(), this.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), this.log("close :: calling _setupReconnect"), this._setupReconnect();
            }), this.options.manualConnect || (this.log("MqttClient :: setting up stream"), this.connect());
          }
          handleAuth(e4, r4) {
            r4();
          }
          handleMessage(e4, r4) {
            r4();
          }
          _nextId() {
            return this.messageIdProvider.allocate();
          }
          getLastMessageId() {
            return this.messageIdProvider.getLastAllocated();
          }
          connect() {
            var e4;
            let r4 = new Yv.Writable(), i5 = Fa2.default.parser(this.options), n4 = null, o4 = [];
            this.log("connect :: calling method to clear reconnect"), this._clearReconnect(), this.log("connect :: using streamBuilder provided to client to create stream"), this.stream = this.streamBuilder(this), i5.on("packet", (h4) => {
              this.log("parser :: on packet push to packets array."), o4.push(h4);
            });
            let s4 = () => {
              this.log("work :: getting next packet in queue");
              let h4 = o4.shift();
              if (h4)
                this.log("work :: packet pulled from queue"), (0, Xv.default)(this, h4, a4);
              else {
                this.log("work :: no packets in queue");
                let d4 = n4;
                n4 = null, this.log("work :: done flag is %s", !!d4), d4 && d4();
              }
            }, a4 = () => {
              if (o4.length)
                (0, is3.nextTick)(s4);
              else {
                let h4 = n4;
                n4 = null, h4();
              }
            };
            r4._write = (h4, d4, g4) => {
              n4 = g4, this.log("writable stream :: parsing buffer"), i5.parse(h4), s4();
            };
            let u4 = (h4) => {
              this.log("streamErrorHandler :: error", h4.message), h4.code ? (this.log("streamErrorHandler :: emitting error"), this.emit("error", h4)) : this.noop(h4);
            };
            this.log("connect :: pipe stream to writable stream"), this.stream.pipe(r4), this.stream.on("error", u4), this.stream.on("close", () => {
              this.log("(%s)stream :: on close", this.options.clientId), this._flushVolatile(), this.log("stream: emit close to MqttClient"), this.emit("close");
            }), this.log("connect: sending packet `connect`");
            let c5 = { cmd: "connect", protocolId: this.options.protocolId, protocolVersion: this.options.protocolVersion, clean: this.options.clean, clientId: this.options.clientId, keepalive: this.options.keepalive, username: this.options.username, password: this.options.password, properties: this.options.properties };
            if (this.options.will && (c5.will = Object.assign(Object.assign({}, this.options.will), { payload: (e4 = this.options.will) === null || e4 === void 0 ? void 0 : e4.payload })), this.topicAliasRecv && (c5.properties || (c5.properties = {}), this.topicAliasRecv && (c5.properties.topicAliasMaximum = this.topicAliasRecv.max)), this._writePacket(c5), i5.on("error", this.emit.bind(this, "error")), this.options.properties) {
              if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData)
                return this.end(() => this.emit("error", new Error("Packet has no Authentication Method"))), this;
              if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket == "object") {
                let h4 = Object.assign({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
                this._writePacket(h4);
              }
            }
            return this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(() => {
              this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`"), this.emit("error", new Error("connack timeout")), this._cleanUp(true);
            }, this.options.connectTimeout), this;
          }
          publish(e4, r4, i5, n4) {
            this.log("publish :: message `%s` to topic `%s`", r4, e4);
            let { options: o4 } = this;
            typeof i5 == "function" && (n4 = i5, i5 = null), i5 = i5 || {}, i5 = Object.assign(Object.assign({}, { qos: 0, retain: false, dup: false }), i5);
            let { qos: a4, retain: u4, dup: c5, properties: h4, cbStorePut: d4 } = i5;
            if (this._checkDisconnecting(n4))
              return this;
            let g4 = () => {
              let y3 = 0;
              if ((a4 === 1 || a4 === 2) && (y3 = this._nextId(), y3 === null))
                return this.log("No messageId left"), false;
              let w3 = { cmd: "publish", topic: e4, payload: r4, qos: a4, retain: u4, messageId: y3, dup: c5 };
              switch (o4.protocolVersion === 5 && (w3.properties = h4), this.log("publish :: qos", a4), a4) {
                case 1:
                case 2:
                  this.outgoing[w3.messageId] = { volatile: false, cb: n4 || this.noop }, this.log("MqttClient:publish: packet cmd: %s", w3.cmd), this._sendPacket(w3, void 0, d4);
                  break;
                default:
                  this.log("MqttClient:publish: packet cmd: %s", w3.cmd), this._sendPacket(w3, n4, d4);
                  break;
              }
              return true;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !g4()) && this._storeProcessingQueue.push({ invoke: g4, cbStorePut: i5.cbStorePut, callback: n4 }), this;
          }
          publishAsync(e4, r4, i5) {
            return new Promise((n4, o4) => {
              this.publish(e4, r4, i5, (s4, a4) => {
                s4 ? o4(s4) : n4(a4);
              });
            });
          }
          subscribe(e4, r4, i5) {
            let n4 = this.options.protocolVersion;
            typeof r4 == "function" && (i5 = r4), i5 = i5 || this.noop;
            let o4 = false, s4 = [];
            typeof e4 == "string" ? (e4 = [e4], s4 = e4) : Array.isArray(e4) ? s4 = e4 : typeof e4 == "object" && (o4 = e4.resubscribe, delete e4.resubscribe, s4 = Object.keys(e4));
            let a4 = jp2.validateTopics(s4);
            if (a4 !== null)
              return Wa2(i5, new Error(`Invalid topic ${a4}`)), this;
            if (this._checkDisconnecting(i5))
              return this.log("subscribe: discconecting true"), this;
            let u4 = { qos: 0 };
            n4 === 5 && (u4.nl = false, u4.rap = false, u4.rh = 0), r4 = Object.assign(Object.assign({}, u4), r4);
            let c5 = r4.properties, h4 = [], d4 = (y3, w3) => {
              if (w3 = w3 || r4, !Object.prototype.hasOwnProperty.call(this._resubscribeTopics, y3) || this._resubscribeTopics[y3].qos < w3.qos || o4) {
                let E4 = { topic: y3, qos: w3.qos };
                n4 === 5 && (E4.nl = w3.nl, E4.rap = w3.rap, E4.rh = w3.rh, E4.properties = c5), this.log("subscribe: pushing topic `%s` and qos `%s` to subs list", E4.topic, E4.qos), h4.push(E4);
              }
            };
            if (Array.isArray(e4) ? e4.forEach((y3) => {
              this.log("subscribe: array topic %s", y3), d4(y3);
            }) : Object.keys(e4).forEach((y3) => {
              this.log("subscribe: object topic %s, %o", y3, e4[y3]), d4(y3, e4[y3]);
            }), !h4.length)
              return i5(null, []), this;
            let g4 = () => {
              let y3 = this._nextId();
              if (y3 === null)
                return this.log("No messageId left"), false;
              let w3 = { cmd: "subscribe", subscriptions: h4, messageId: y3 };
              if (c5 && (w3.properties = c5), this.options.resubscribe) {
                this.log("subscribe :: resubscribe true");
                let E4 = [];
                h4.forEach((S3) => {
                  if (this.options.reconnectPeriod > 0) {
                    let I3 = { qos: S3.qos };
                    n4 === 5 && (I3.nl = S3.nl || false, I3.rap = S3.rap || false, I3.rh = S3.rh || 0, I3.properties = S3.properties), this._resubscribeTopics[S3.topic] = I3, E4.push(S3.topic);
                  }
                }), this.messageIdToTopic[w3.messageId] = E4;
              }
              return this.outgoing[w3.messageId] = { volatile: true, cb(E4, S3) {
                if (!E4) {
                  let { granted: I3 } = S3;
                  for (let C3 = 0; C3 < I3.length; C3 += 1)
                    h4[C3].qos = I3[C3];
                }
                i5(E4, h4);
              } }, this.log("subscribe :: call _sendPacket"), this._sendPacket(w3), true;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !g4()) && this._storeProcessingQueue.push({ invoke: g4, callback: i5 }), this;
          }
          subscribeAsync(e4, r4) {
            return new Promise((i5, n4) => {
              this.subscribe(e4, r4, (o4, s4) => {
                o4 ? n4(o4) : i5(s4);
              });
            });
          }
          unsubscribe(e4, r4, i5) {
            typeof e4 == "string" && (e4 = [e4]), typeof r4 == "function" && (i5 = r4), i5 = i5 || this.noop;
            let n4 = jp2.validateTopics(e4);
            if (n4 !== null)
              return Wa2(i5, new Error(`Invalid topic ${n4}`)), this;
            if (this._checkDisconnecting(i5))
              return this;
            let o4 = () => {
              let s4 = this._nextId();
              if (s4 === null)
                return this.log("No messageId left"), false;
              let a4 = { cmd: "unsubscribe", messageId: s4, unsubscriptions: [] };
              return typeof e4 == "string" ? a4.unsubscriptions = [e4] : Array.isArray(e4) && (a4.unsubscriptions = e4), this.options.resubscribe && a4.unsubscriptions.forEach((u4) => {
                delete this._resubscribeTopics[u4];
              }), typeof r4 == "object" && r4.properties && (a4.properties = r4.properties), this.outgoing[a4.messageId] = { volatile: true, cb: i5 }, this.log("unsubscribe: call _sendPacket"), this._sendPacket(a4), true;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !o4()) && this._storeProcessingQueue.push({ invoke: o4, callback: i5 }), this;
          }
          unsubscribeAsync(e4, r4) {
            return new Promise((i5, n4) => {
              this.unsubscribe(e4, r4, (o4, s4) => {
                o4 ? n4(o4) : i5(s4);
              });
            });
          }
          end(e4, r4, i5) {
            this.log("end :: (%s)", this.options.clientId), (e4 == null || typeof e4 != "boolean") && (i5 = i5 || r4, r4 = e4, e4 = false), typeof r4 != "object" && (i5 = i5 || r4, r4 = null), this.log("end :: cb? %s", !!i5), (!i5 || typeof i5 != "function") && (i5 = this.noop);
            let n4 = () => {
              this.log("end :: closeStores: closing incoming and outgoing stores"), this.disconnected = true, this.incomingStore.close((s4) => {
                this.outgoingStore.close((a4) => {
                  if (this.log("end :: closeStores: emitting end"), this.emit("end"), i5) {
                    let u4 = s4 || a4;
                    this.log("end :: closeStores: invoking callback with args"), i5(u4);
                  }
                });
              }), this._deferredReconnect && this._deferredReconnect();
            }, o4 = () => {
              this.log("end :: (%s) :: finish :: calling _cleanUp with force %s", this.options.clientId, e4), this._cleanUp(e4, () => {
                this.log("end :: finish :: calling process.nextTick on closeStores"), (0, is3.nextTick)(n4);
              }, r4);
            };
            return this.disconnecting ? (i5(), this) : (this._clearReconnect(), this.disconnecting = true, !e4 && Object.keys(this.outgoing).length > 0 ? (this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty", this.options.clientId), this.once("outgoingEmpty", setTimeout.bind(null, o4, 10))) : (this.log("end :: (%s) :: immediately calling finish", this.options.clientId), o4()), this);
          }
          endAsync(e4, r4) {
            return new Promise((i5, n4) => {
              this.end(e4, r4, (o4) => {
                o4 ? n4(o4) : i5();
              });
            });
          }
          removeOutgoingMessage(e4) {
            if (this.outgoing[e4]) {
              let { cb: r4 } = this.outgoing[e4];
              this._removeOutgoingAndStoreMessage(e4, () => {
                r4(new Error("Message removed"));
              });
            }
            return this;
          }
          reconnect(e4) {
            this.log("client reconnect");
            let r4 = () => {
              e4 ? (this.options.incomingStore = e4.incomingStore, this.options.outgoingStore = e4.outgoingStore) : (this.options.incomingStore = null, this.options.outgoingStore = null), this.incomingStore = this.options.incomingStore || new rs3.default(), this.outgoingStore = this.options.outgoingStore || new rs3.default(), this.disconnecting = false, this.disconnected = false, this._deferredReconnect = null, this._reconnect();
            };
            return this.disconnecting && !this.disconnected ? this._deferredReconnect = r4 : r4(), this;
          }
          _flushVolatile() {
            this.outgoing && (this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), Object.keys(this.outgoing).forEach((e4) => {
              this.outgoing[e4].volatile && typeof this.outgoing[e4].cb == "function" && (this.outgoing[e4].cb(new Error("Connection closed")), delete this.outgoing[e4]);
            }));
          }
          _flush() {
            this.outgoing && (this.log("_flush: queue exists? %b", !!this.outgoing), Object.keys(this.outgoing).forEach((e4) => {
              typeof this.outgoing[e4].cb == "function" && (this.outgoing[e4].cb(new Error("Connection closed")), delete this.outgoing[e4]);
            }));
          }
          _removeTopicAliasAndRecoverTopicName(e4) {
            let r4;
            e4.properties && (r4 = e4.properties.topicAlias);
            let i5 = e4.topic.toString();
            if (this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o", r4, i5), i5.length === 0) {
              if (typeof r4 > "u")
                return new Error("Unregistered Topic Alias");
              if (i5 = this.topicAliasSend.getTopicByAlias(r4), typeof i5 > "u")
                return new Error("Unregistered Topic Alias");
              e4.topic = i5;
            }
            r4 && delete e4.properties.topicAlias;
          }
          _checkDisconnecting(e4) {
            return this.disconnecting && (e4 && e4 !== this.noop ? e4(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting;
          }
          _reconnect() {
            this.log("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end(() => {
              this.connect();
            }), this.log("client already connected. disconnecting first.")) : (this.log("_reconnect: calling connect"), this.connect());
          }
          _setupReconnect() {
            !this.disconnecting && !this.reconnectTimer && this.options.reconnectPeriod > 0 ? (this.reconnecting || (this.log("_setupReconnect :: emit `offline` state"), this.emit("offline"), this.log("_setupReconnect :: set `reconnecting` to `true`"), this.reconnecting = true), this.log("_setupReconnect :: setting reconnectTimer for %d ms", this.options.reconnectPeriod), this.reconnectTimer = setInterval(() => {
              this.log("reconnectTimer :: reconnect triggered!"), this._reconnect();
            }, this.options.reconnectPeriod)) : this.log("_setupReconnect :: doing nothing...");
          }
          _clearReconnect() {
            this.log("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null);
          }
          _cleanUp(e4, r4, i5 = {}) {
            if (r4 && (this.log("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", r4)), this.log("_cleanUp :: forced? %s", e4), e4)
              this.options.reconnectPeriod === 0 && this.options.clean && this._flush(), this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy();
            else {
              let n4 = Object.assign({ cmd: "disconnect" }, i5);
              this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), this._sendPacket(n4, () => {
                this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId), Wa2(() => {
                  this.stream.end(() => {
                    this.log("_cleanUp :: (%s) :: stream destroyed", this.options.clientId);
                  });
                });
              });
            }
            !this.disconnecting && !this.reconnecting && (this.log("_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect."), this._clearReconnect(), this._setupReconnect()), this.pingTimer && (this.log("_cleanUp :: destroy pingTimer"), this.pingTimer.destroy(), this.pingTimer = null), r4 && !this.connected && (this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), this.stream.removeListener("close", r4), r4());
          }
          _storeAndSend(e4, r4, i5) {
            this.log("storeAndSend :: store packet with cmd %s to outgoingStore", e4.cmd);
            let n4 = e4, o4;
            if (n4.cmd === "publish" && (n4 = (0, Dp.default)(e4), o4 = this._removeTopicAliasAndRecoverTopicName(n4), o4))
              return r4 && r4(o4);
            this.outgoingStore.put(n4, (s4) => {
              if (s4)
                return r4 && r4(s4);
              i5(), this._writePacket(e4, r4);
            });
          }
          _applyTopicAlias(e4) {
            if (this.options.protocolVersion === 5 && e4.cmd === "publish") {
              let r4;
              e4.properties && (r4 = e4.properties.topicAlias);
              let i5 = e4.topic.toString();
              if (this.topicAliasSend)
                if (r4) {
                  if (i5.length !== 0 && (this.log("applyTopicAlias :: register topic: %s - alias: %d", i5, r4), !this.topicAliasSend.put(i5, r4)))
                    return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", i5, r4), new Error("Sending Topic Alias out of range");
                } else
                  i5.length !== 0 && (this.options.autoAssignTopicAlias ? (r4 = this.topicAliasSend.getAliasByTopic(i5), r4 ? (e4.topic = "", e4.properties = Object.assign(Object.assign({}, e4.properties), { topicAlias: r4 }), this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", i5, r4)) : (r4 = this.topicAliasSend.getLruAlias(), this.topicAliasSend.put(i5, r4), e4.properties = Object.assign(Object.assign({}, e4.properties), { topicAlias: r4 }), this.log("applyTopicAlias :: auto assign topic: %s - alias: %d", i5, r4))) : this.options.autoUseTopicAlias && (r4 = this.topicAliasSend.getAliasByTopic(i5), r4 && (e4.topic = "", e4.properties = Object.assign(Object.assign({}, e4.properties), { topicAlias: r4 }), this.log("applyTopicAlias :: auto use topic: %s - alias: %d", i5, r4))));
              else if (r4)
                return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", i5, r4), new Error("Sending Topic Alias out of range");
            }
          }
          _noop(e4) {
            this.log("noop ::", e4);
          }
          _writePacket(e4, r4) {
            this.log("_writePacket :: packet: %O", e4), this.log("_writePacket :: emitting `packetsend`"), this.emit("packetsend", e4), this._shiftPingInterval(), this.log("_writePacket :: writing to stream");
            let i5 = Fa2.default.writeToStream(e4, this.stream, this.options);
            this.log("_writePacket :: writeToStream result %s", i5), !i5 && r4 && r4 !== this.noop ? (this.log("_writePacket :: handle events on `drain` once through callback."), this.stream.once("drain", r4)) : r4 && (this.log("_writePacket :: invoking cb"), r4());
          }
          _sendPacket(e4, r4, i5, n4) {
            this.log("_sendPacket :: (%s) ::  start", this.options.clientId), i5 = i5 || this.noop, r4 = r4 || this.noop;
            let o4 = this._applyTopicAlias(e4);
            if (o4) {
              r4(o4);
              return;
            }
            if (!this.connected) {
              if (e4.cmd === "auth") {
                this._writePacket(e4, r4);
                return;
              }
              this.log("_sendPacket :: client not connected. Storing packet offline."), this._storePacket(e4, r4, i5);
              return;
            }
            if (n4) {
              this._writePacket(e4, r4);
              return;
            }
            switch (e4.cmd) {
              case "publish":
                break;
              case "pubrel":
                this._storeAndSend(e4, r4, i5);
                return;
              default:
                this._writePacket(e4, r4);
                return;
            }
            switch (e4.qos) {
              case 2:
              case 1:
                this._storeAndSend(e4, r4, i5);
                break;
              case 0:
              default:
                this._writePacket(e4, r4);
                break;
            }
            this.log("_sendPacket :: (%s) ::  end", this.options.clientId);
          }
          _storePacket(e4, r4, i5) {
            this.log("_storePacket :: packet: %o", e4), this.log("_storePacket :: cb? %s", !!r4), i5 = i5 || this.noop;
            let n4 = e4;
            if (n4.cmd === "publish") {
              n4 = (0, Dp.default)(e4);
              let s4 = this._removeTopicAliasAndRecoverTopicName(n4);
              if (s4)
                return r4 && r4(s4);
            }
            let o4 = n4.qos || 0;
            o4 === 0 && this.queueQoSZero || n4.cmd !== "publish" ? this.queue.push({ packet: n4, cb: r4 }) : o4 > 0 ? (r4 = this.outgoing[n4.messageId] ? this.outgoing[n4.messageId].cb : null, this.outgoingStore.put(n4, (s4) => {
              if (s4)
                return r4 && r4(s4);
              i5();
            })) : r4 && r4(new Error("No connection to broker"));
          }
          _setupPingTimer() {
            this.log("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive), !this.pingTimer && this.options.keepalive && (this.pingResp = true, this.pingTimer = new eE.default(this.options.keepalive, () => {
              this._checkPing();
            }, this.options.timerVariant));
          }
          _shiftPingInterval() {
            this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule();
          }
          _checkPing() {
            this.log("_checkPing :: checking ping..."), this.pingResp ? (this.log("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), this.pingResp = false, this._sendPacket({ cmd: "pingreq" })) : (this.emit("error", new Error("Keepalive timeout")), this.log("_checkPing :: calling _cleanUp with force true"), this._cleanUp(true));
          }
          _resubscribe() {
            this.log("_resubscribe");
            let e4 = Object.keys(this._resubscribeTopics);
            if (!this._firstConnection && (this.options.clean || this.options.protocolVersion >= 4 && !this.connackPacket.sessionPresent) && e4.length > 0)
              if (this.options.resubscribe)
                if (this.options.protocolVersion === 5) {
                  this.log("_resubscribe: protocolVersion 5");
                  for (let r4 = 0; r4 < e4.length; r4++) {
                    let i5 = {};
                    i5[e4[r4]] = this._resubscribeTopics[e4[r4]], i5.resubscribe = true, this.subscribe(i5, { properties: i5[e4[r4]].properties });
                  }
                } else
                  this._resubscribeTopics.resubscribe = true, this.subscribe(this._resubscribeTopics);
              else
                this._resubscribeTopics = {};
            this._firstConnection = false;
          }
          _onConnect(e4) {
            if (this.disconnected) {
              this.emit("connect", e4);
              return;
            }
            this.connackPacket = e4, this.messageIdProvider.clear(), this._setupPingTimer(), this.connected = true;
            let r4 = () => {
              let i5 = this.outgoingStore.createStream(), n4 = () => {
                i5.destroy(), i5 = null, this._flushStoreProcessingQueue(), o4();
              }, o4 = () => {
                this._storeProcessing = false, this._packetIdsDuringStoreProcessing = {};
              };
              this.once("close", n4), i5.on("error", (a4) => {
                o4(), this._flushStoreProcessingQueue(), this.removeListener("close", n4), this.emit("error", a4);
              });
              let s4 = () => {
                if (!i5)
                  return;
                let a4 = i5.read(1), u4;
                if (!a4) {
                  i5.once("readable", s4);
                  return;
                }
                if (this._storeProcessing = true, this._packetIdsDuringStoreProcessing[a4.messageId]) {
                  s4();
                  return;
                }
                !this.disconnecting && !this.reconnectTimer ? (u4 = this.outgoing[a4.messageId] ? this.outgoing[a4.messageId].cb : null, this.outgoing[a4.messageId] = { volatile: false, cb(c5, h4) {
                  u4 && u4(c5, h4), s4();
                } }, this._packetIdsDuringStoreProcessing[a4.messageId] = true, this.messageIdProvider.register(a4.messageId) ? this._sendPacket(a4, void 0, void 0, true) : this.log("messageId: %d has already used.", a4.messageId)) : i5.destroy && i5.destroy();
              };
              i5.on("end", () => {
                let a4 = true;
                for (let u4 in this._packetIdsDuringStoreProcessing)
                  if (!this._packetIdsDuringStoreProcessing[u4]) {
                    a4 = false;
                    break;
                  }
                this.removeListener("close", n4), a4 ? (o4(), this._invokeAllStoreProcessingQueue(), this.emit("connect", e4)) : r4();
              }), s4();
            };
            r4();
          }
          _invokeStoreProcessingQueue() {
            if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
              let e4 = this._storeProcessingQueue[0];
              if (e4 && e4.invoke())
                return this._storeProcessingQueue.shift(), true;
            }
            return false;
          }
          _invokeAllStoreProcessingQueue() {
            for (; this._invokeStoreProcessingQueue(); )
              ;
          }
          _flushStoreProcessingQueue() {
            for (let e4 of this._storeProcessingQueue)
              e4.cbStorePut && e4.cbStorePut(new Error("Connection closed")), e4.callback && e4.callback(new Error("Connection closed"));
            this._storeProcessingQueue.splice(0);
          }
          _removeOutgoingAndStoreMessage(e4, r4) {
            delete this.outgoing[e4], this.outgoingStore.del({ messageId: e4 }, (i5, n4) => {
              r4(i5, n4), this.messageIdProvider.deallocate(e4), this._invokeStoreProcessingQueue();
            });
          }
        };
        ns3.VERSION = is3.MQTTJS_VERSION;
        Qe3.default = ns3;
      });
      Hp2 = M3((Ha2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(Ha2, "__esModule", { value: true });
        var tE = Ma2(), $a2 = class {
          constructor() {
            this.numberAllocator = new tE.NumberAllocator(1, 65535);
          }
          allocate() {
            return this.lastId = this.numberAllocator.alloc(), this.lastId;
          }
          getLastAllocated() {
            return this.lastId;
          }
          register(e4) {
            return this.numberAllocator.use(e4);
          }
          deallocate(e4) {
            this.numberAllocator.free(e4);
          }
          clear() {
            this.numberAllocator.clear();
          }
        };
        Ha2.default = $a2;
      });
      Jp2 = we4(() => {
        v3();
        m3();
        _3();
        rE = /^xn--/, iE = /[^\0-\x7E]/, nE = /[\x2E\u3002\uFF0E\uFF61]/g, sE = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, dt4 = Math.floor, Va2 = String.fromCharCode;
        zp2 = function(t4, e4) {
          return t4 + 22 + 75 * (t4 < 26) - ((e4 != 0) << 5);
        }, Yp2 = function(t4, e4, r4) {
          let i5 = 0;
          for (t4 = r4 ? dt4(t4 / 700) : t4 >> 1, t4 += dt4(t4 / e4); t4 > 455; i5 += 36)
            t4 = dt4(t4 / 35);
          return dt4(i5 + 36 * t4 / (t4 + 38));
        }, Kp2 = function(t4) {
          let e4 = [], r4 = t4.length, i5 = 0, n4 = 128, o4 = 72, s4 = t4.lastIndexOf("-");
          s4 < 0 && (s4 = 0);
          for (let u4 = 0; u4 < s4; ++u4)
            t4.charCodeAt(u4) >= 128 && Ir3("not-basic"), e4.push(t4.charCodeAt(u4));
          for (let u4 = s4 > 0 ? s4 + 1 : 0; u4 < r4; ) {
            let c5 = i5;
            for (let d4 = 1, g4 = 36; ; g4 += 36) {
              u4 >= r4 && Ir3("invalid-input");
              let y3 = (a4 = t4.charCodeAt(u4++)) - 48 < 10 ? a4 - 22 : a4 - 65 < 26 ? a4 - 65 : a4 - 97 < 26 ? a4 - 97 : 36;
              (y3 >= 36 || y3 > dt4((2147483647 - i5) / d4)) && Ir3("overflow"), i5 += y3 * d4;
              let w3 = g4 <= o4 ? 1 : g4 >= o4 + 26 ? 26 : g4 - o4;
              if (y3 < w3)
                break;
              let E4 = 36 - w3;
              d4 > dt4(2147483647 / E4) && Ir3("overflow"), d4 *= E4;
            }
            let h4 = e4.length + 1;
            o4 = Yp2(i5 - c5, h4, c5 == 0), dt4(i5 / h4) > 2147483647 - n4 && Ir3("overflow"), n4 += dt4(i5 / h4), i5 %= h4, e4.splice(i5++, 0, n4);
          }
          var a4;
          return String.fromCodePoint(...e4);
        }, Gp2 = function(t4) {
          let e4 = [], r4 = (t4 = Qp2(t4)).length, i5 = 128, n4 = 0, o4 = 72;
          for (let u4 of t4)
            u4 < 128 && e4.push(Va2(u4));
          let s4 = e4.length, a4 = s4;
          for (s4 && e4.push("-"); a4 < r4; ) {
            let u4 = 2147483647;
            for (let h4 of t4)
              h4 >= i5 && h4 < u4 && (u4 = h4);
            let c5 = a4 + 1;
            u4 - i5 > dt4((2147483647 - n4) / c5) && Ir3("overflow"), n4 += (u4 - i5) * c5, i5 = u4;
            for (let h4 of t4)
              if (h4 < i5 && ++n4 > 2147483647 && Ir3("overflow"), h4 == i5) {
                let d4 = n4;
                for (let g4 = 36; ; g4 += 36) {
                  let y3 = g4 <= o4 ? 1 : g4 >= o4 + 26 ? 26 : g4 - o4;
                  if (d4 < y3)
                    break;
                  let w3 = d4 - y3, E4 = 36 - y3;
                  e4.push(Va2(zp2(y3 + w3 % E4, 0))), d4 = dt4(w3 / E4);
                }
                e4.push(Va2(zp2(d4, 0))), o4 = Yp2(n4, c5, a4 == s4), n4 = 0, ++a4;
              }
            ++n4, ++i5;
          }
          return e4.join("");
        }, zt3 = { version: "2.1.0", ucs2: { decode: Qp2, encode: (t4) => String.fromCodePoint(...t4) }, decode: Kp2, encode: Gp2, toASCII: function(t4) {
          return Vp2(t4, function(e4) {
            return iE.test(e4) ? "xn--" + Gp2(e4) : e4;
          });
        }, toUnicode: function(t4) {
          return Vp2(t4, function(e4) {
            return rE.test(e4) ? Kp2(e4.slice(4).toLowerCase()) : e4;
          });
        } };
        zt3.decode;
        zt3.encode;
        zt3.toASCII;
        zt3.toUnicode;
        zt3.ucs2;
        zt3.version;
      });
      Xp2 = we4(() => {
        v3();
        m3();
        _3();
        aE = function(t4, e4, r4, i5) {
          e4 = e4 || "&", r4 = r4 || "=";
          var n4 = {};
          if (typeof t4 != "string" || t4.length === 0)
            return n4;
          var o4 = /\+/g;
          t4 = t4.split(e4);
          var s4 = 1e3;
          i5 && typeof i5.maxKeys == "number" && (s4 = i5.maxKeys);
          var a4 = t4.length;
          s4 > 0 && a4 > s4 && (a4 = s4);
          for (var u4 = 0; u4 < a4; ++u4) {
            var c5, h4, d4, g4, y3 = t4[u4].replace(o4, "%20"), w3 = y3.indexOf(r4);
            w3 >= 0 ? (c5 = y3.substr(0, w3), h4 = y3.substr(w3 + 1)) : (c5 = y3, h4 = ""), d4 = decodeURIComponent(c5), g4 = decodeURIComponent(h4), oE(n4, d4) ? Array.isArray(n4[d4]) ? n4[d4].push(g4) : n4[d4] = [n4[d4], g4] : n4[d4] = g4;
          }
          return n4;
        }, ki3 = function(t4) {
          switch (typeof t4) {
            case "string":
              return t4;
            case "boolean":
              return t4 ? "true" : "false";
            case "number":
              return isFinite(t4) ? t4 : "";
            default:
              return "";
          }
        }, lE = function(t4, e4, r4, i5) {
          return e4 = e4 || "&", r4 = r4 || "=", t4 === null && (t4 = void 0), typeof t4 == "object" ? Object.keys(t4).map(function(n4) {
            var o4 = encodeURIComponent(ki3(n4)) + r4;
            return Array.isArray(t4[n4]) ? t4[n4].map(function(s4) {
              return o4 + encodeURIComponent(ki3(s4));
            }).join(e4) : o4 + encodeURIComponent(ki3(t4[n4]));
          }).join(e4) : i5 ? encodeURIComponent(ki3(i5)) + r4 + encodeURIComponent(ki3(t4)) : "";
        }, pt4 = {};
        pt4.decode = pt4.parse = aE, pt4.encode = pt4.stringify = lE;
        pt4.decode;
        pt4.encode;
        pt4.parse;
        pt4.stringify;
      });
      ig2 = we4(() => {
        v3();
        m3();
        _3();
        ii2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, fe4 = eg2 = {};
        (function() {
          try {
            Pt3 = typeof setTimeout == "function" ? setTimeout : za2;
          } catch {
            Pt3 = za2;
          }
          try {
            Ot4 = typeof clearTimeout == "function" ? clearTimeout : Ka3;
          } catch {
            Ot4 = Ka3;
          }
        })();
        kt4 = [], ri2 = false, os3 = -1;
        fe4.nextTick = function(t4) {
          var e4 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r4 = 1; r4 < arguments.length; r4++)
              e4[r4 - 1] = arguments[r4];
          kt4.push(new Zp2(t4, e4)), kt4.length !== 1 || ri2 || tg2(rg);
        }, Zp2.prototype.run = function() {
          (this || ii2).fun.apply(null, (this || ii2).array);
        }, fe4.title = "browser", fe4.browser = true, fe4.env = {}, fe4.argv = [], fe4.version = "", fe4.versions = {}, fe4.on = Bt4, fe4.addListener = Bt4, fe4.once = Bt4, fe4.off = Bt4, fe4.removeListener = Bt4, fe4.removeAllListeners = Bt4, fe4.emit = Bt4, fe4.prependListener = Bt4, fe4.prependOnceListener = Bt4, fe4.listeners = function(t4) {
          return [];
        }, fe4.binding = function(t4) {
          throw new Error("process.binding is not supported");
        }, fe4.cwd = function() {
          return "/";
        }, fe4.chdir = function(t4) {
          throw new Error("process.chdir is not supported");
        }, fe4.umask = function() {
          return 0;
        };
        ne3 = eg2;
        ne3.addListener;
        ne3.argv;
        ne3.binding;
        ne3.browser;
        ne3.chdir;
        ne3.cwd;
        ne3.emit;
        ne3.env;
        ne3.listeners;
        ne3.nextTick;
        ne3.off;
        ne3.on;
        ne3.once;
        ne3.prependListener;
        ne3.prependOnceListener;
        ne3.removeAllListeners;
        ne3.removeListener;
        ne3.title;
        ne3.umask;
        ne3.version;
        ne3.versions;
      });
      Qa3 = we4(() => {
        v3();
        m3();
        _3();
        Ga2 = {}, ng2 = false, ni2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
        re4 = fE();
        re4.platform = "browser";
        re4.addListener;
        re4.argv;
        re4.binding;
        re4.browser;
        re4.chdir;
        re4.cwd;
        re4.emit;
        re4.env;
        re4.listeners;
        re4.nextTick;
        re4.off;
        re4.on;
        re4.once;
        re4.prependListener;
        re4.prependOnceListener;
        re4.removeAllListeners;
        re4.removeListener;
        re4.title;
        re4.umask;
        re4.version;
        re4.versions;
      });
      og2 = we4(() => {
        v3();
        m3();
        _3();
        Qa3();
        Ya3 = {}, sg2 = false;
        Ja3 = cE();
      });
      pg2 = {};
      Qt3(pg2, { URL: () => FE, Url: () => UE, default: () => Z4, fileURLToPath: () => hg2, format: () => NE, parse: () => jE, pathToFileURL: () => dg2, resolve: () => qE, resolveObject: () => DE });
      gg2 = we4(() => {
        v3();
        m3();
        _3();
        Jp2();
        Xp2();
        ig2();
        og2();
        Qa3();
        Z4 = {}, hE = zt3, gt3 = { isString: function(t4) {
          return typeof t4 == "string";
        }, isObject: function(t4) {
          return typeof t4 == "object" && t4 !== null;
        }, isNull: function(t4) {
          return t4 === null;
        }, isNullOrUndefined: function(t4) {
          return t4 == null;
        } };
        Z4.parse = xi3, Z4.resolve = function(t4, e4) {
          return xi3(t4, false, true).resolve(e4);
        }, Z4.resolveObject = function(t4, e4) {
          return t4 ? xi3(t4, false, true).resolveObject(e4) : e4;
        }, Z4.format = function(t4) {
          return gt3.isString(t4) && (t4 = xi3(t4)), t4 instanceof Fe4 ? t4.format() : Fe4.prototype.format.call(t4);
        }, Z4.Url = Fe4;
        dE = /^([a-z0-9.+-]+:)/i, pE = /:[0-9]*$/, gE = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, yE = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), tl2 = ["'"].concat(yE), ag2 = ["%", "/", "?", ";", "#"].concat(tl2), lg2 = ["/", "?", "#"], ug = /^[+a-z0-9A-Z_-]{0,63}$/, bE = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, wE = { javascript: true, "javascript:": true }, Xa3 = { javascript: true, "javascript:": true }, si2 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, Za3 = pt4;
        Fe4.prototype.parse = function(t4, e4, r4) {
          if (!gt3.isString(t4))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof t4);
          var i5 = t4.indexOf("?"), n4 = i5 !== -1 && i5 < t4.indexOf("#") ? "?" : "#", o4 = t4.split(n4);
          o4[0] = o4[0].replace(/\\/g, "/");
          var s4 = t4 = o4.join(n4);
          if (s4 = s4.trim(), !r4 && t4.split("#").length === 1) {
            var a4 = gE.exec(s4);
            if (a4)
              return this.path = s4, this.href = s4, this.pathname = a4[1], a4[2] ? (this.search = a4[2], this.query = e4 ? Za3.parse(this.search.substr(1)) : this.search.substr(1)) : e4 && (this.search = "", this.query = {}), this;
          }
          var u4 = dE.exec(s4);
          if (u4) {
            var c5 = (u4 = u4[0]).toLowerCase();
            this.protocol = c5, s4 = s4.substr(u4.length);
          }
          if (r4 || u4 || s4.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var h4 = s4.substr(0, 2) === "//";
            !h4 || u4 && Xa3[u4] || (s4 = s4.substr(2), this.slashes = true);
          }
          if (!Xa3[u4] && (h4 || u4 && !si2[u4])) {
            for (var d4, g4, y3 = -1, w3 = 0; w3 < lg2.length; w3++)
              (E4 = s4.indexOf(lg2[w3])) !== -1 && (y3 === -1 || E4 < y3) && (y3 = E4);
            for ((g4 = y3 === -1 ? s4.lastIndexOf("@") : s4.lastIndexOf("@", y3)) !== -1 && (d4 = s4.slice(0, g4), s4 = s4.slice(g4 + 1), this.auth = decodeURIComponent(d4)), y3 = -1, w3 = 0; w3 < ag2.length; w3++) {
              var E4;
              (E4 = s4.indexOf(ag2[w3])) !== -1 && (y3 === -1 || E4 < y3) && (y3 = E4);
            }
            y3 === -1 && (y3 = s4.length), this.host = s4.slice(0, y3), s4 = s4.slice(y3), this.parseHost(), this.hostname = this.hostname || "";
            var S3 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!S3)
              for (var I3 = this.hostname.split(/\./), C3 = (w3 = 0, I3.length); w3 < C3; w3++) {
                var R5 = I3[w3];
                if (R5 && !R5.match(ug)) {
                  for (var U5 = "", N4 = 0, W4 = R5.length; N4 < W4; N4++)
                    R5.charCodeAt(N4) > 127 ? U5 += "x" : U5 += R5[N4];
                  if (!U5.match(ug)) {
                    var K5 = I3.slice(0, w3), z4 = I3.slice(w3 + 1), Q3 = R5.match(bE);
                    Q3 && (K5.push(Q3[1]), z4.unshift(Q3[2])), z4.length && (s4 = "/" + z4.join(".") + s4), this.hostname = K5.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), S3 || (this.hostname = hE.toASCII(this.hostname));
            var de3 = this.port ? ":" + this.port : "", Gt3 = this.hostname || "";
            this.host = Gt3 + de3, this.href += this.host, S3 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s4[0] !== "/" && (s4 = "/" + s4));
          }
          if (!wE[c5])
            for (w3 = 0, C3 = tl2.length; w3 < C3; w3++) {
              var pe3 = tl2[w3];
              if (s4.indexOf(pe3) !== -1) {
                var Cr3 = encodeURIComponent(pe3);
                Cr3 === pe3 && (Cr3 = escape(pe3)), s4 = s4.split(pe3).join(Cr3);
              }
            }
          var Br4 = s4.indexOf("#");
          Br4 !== -1 && (this.hash = s4.substr(Br4), s4 = s4.slice(0, Br4));
          var Pr3 = s4.indexOf("?");
          if (Pr3 !== -1 ? (this.search = s4.substr(Pr3), this.query = s4.substr(Pr3 + 1), e4 && (this.query = Za3.parse(this.query)), s4 = s4.slice(0, Pr3)) : e4 && (this.search = "", this.query = {}), s4 && (this.pathname = s4), si2[c5] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            de3 = this.pathname || "";
            var fs3 = this.search || "";
            this.path = de3 + fs3;
          }
          return this.href = this.format(), this;
        }, Fe4.prototype.format = function() {
          var t4 = this.auth || "";
          t4 && (t4 = (t4 = encodeURIComponent(t4)).replace(/%3A/i, ":"), t4 += "@");
          var e4 = this.protocol || "", r4 = this.pathname || "", i5 = this.hash || "", n4 = false, o4 = "";
          this.host ? n4 = t4 + this.host : this.hostname && (n4 = t4 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n4 += ":" + this.port)), this.query && gt3.isObject(this.query) && Object.keys(this.query).length && (o4 = Za3.stringify(this.query));
          var s4 = this.search || o4 && "?" + o4 || "";
          return e4 && e4.substr(-1) !== ":" && (e4 += ":"), this.slashes || (!e4 || si2[e4]) && n4 !== false ? (n4 = "//" + (n4 || ""), r4 && r4.charAt(0) !== "/" && (r4 = "/" + r4)) : n4 || (n4 = ""), i5 && i5.charAt(0) !== "#" && (i5 = "#" + i5), s4 && s4.charAt(0) !== "?" && (s4 = "?" + s4), e4 + n4 + (r4 = r4.replace(/[?#]/g, function(a4) {
            return encodeURIComponent(a4);
          })) + (s4 = s4.replace("#", "%23")) + i5;
        }, Fe4.prototype.resolve = function(t4) {
          return this.resolveObject(xi3(t4, false, true)).format();
        }, Fe4.prototype.resolveObject = function(t4) {
          if (gt3.isString(t4)) {
            var e4 = new Fe4();
            e4.parse(t4, false, true), t4 = e4;
          }
          for (var r4 = new Fe4(), i5 = Object.keys(this), n4 = 0; n4 < i5.length; n4++) {
            var o4 = i5[n4];
            r4[o4] = this[o4];
          }
          if (r4.hash = t4.hash, t4.href === "")
            return r4.href = r4.format(), r4;
          if (t4.slashes && !t4.protocol) {
            for (var s4 = Object.keys(t4), a4 = 0; a4 < s4.length; a4++) {
              var u4 = s4[a4];
              u4 !== "protocol" && (r4[u4] = t4[u4]);
            }
            return si2[r4.protocol] && r4.hostname && !r4.pathname && (r4.path = r4.pathname = "/"), r4.href = r4.format(), r4;
          }
          if (t4.protocol && t4.protocol !== r4.protocol) {
            if (!si2[t4.protocol]) {
              for (var c5 = Object.keys(t4), h4 = 0; h4 < c5.length; h4++) {
                var d4 = c5[h4];
                r4[d4] = t4[d4];
              }
              return r4.href = r4.format(), r4;
            }
            if (r4.protocol = t4.protocol, t4.host || Xa3[t4.protocol])
              r4.pathname = t4.pathname;
            else {
              for (var g4 = (t4.pathname || "").split("/"); g4.length && !(t4.host = g4.shift()); )
                ;
              t4.host || (t4.host = ""), t4.hostname || (t4.hostname = ""), g4[0] !== "" && g4.unshift(""), g4.length < 2 && g4.unshift(""), r4.pathname = g4.join("/");
            }
            if (r4.search = t4.search, r4.query = t4.query, r4.host = t4.host || "", r4.auth = t4.auth, r4.hostname = t4.hostname || t4.host, r4.port = t4.port, r4.pathname || r4.search) {
              var y3 = r4.pathname || "", w3 = r4.search || "";
              r4.path = y3 + w3;
            }
            return r4.slashes = r4.slashes || t4.slashes, r4.href = r4.format(), r4;
          }
          var E4 = r4.pathname && r4.pathname.charAt(0) === "/", S3 = t4.host || t4.pathname && t4.pathname.charAt(0) === "/", I3 = S3 || E4 || r4.host && t4.pathname, C3 = I3, R5 = r4.pathname && r4.pathname.split("/") || [], U5 = (g4 = t4.pathname && t4.pathname.split("/") || [], r4.protocol && !si2[r4.protocol]);
          if (U5 && (r4.hostname = "", r4.port = null, r4.host && (R5[0] === "" ? R5[0] = r4.host : R5.unshift(r4.host)), r4.host = "", t4.protocol && (t4.hostname = null, t4.port = null, t4.host && (g4[0] === "" ? g4[0] = t4.host : g4.unshift(t4.host)), t4.host = null), I3 = I3 && (g4[0] === "" || R5[0] === "")), S3)
            r4.host = t4.host || t4.host === "" ? t4.host : r4.host, r4.hostname = t4.hostname || t4.hostname === "" ? t4.hostname : r4.hostname, r4.search = t4.search, r4.query = t4.query, R5 = g4;
          else if (g4.length)
            R5 || (R5 = []), R5.pop(), R5 = R5.concat(g4), r4.search = t4.search, r4.query = t4.query;
          else if (!gt3.isNullOrUndefined(t4.search))
            return U5 && (r4.hostname = r4.host = R5.shift(), (Q3 = !!(r4.host && r4.host.indexOf("@") > 0) && r4.host.split("@")) && (r4.auth = Q3.shift(), r4.host = r4.hostname = Q3.shift())), r4.search = t4.search, r4.query = t4.query, gt3.isNull(r4.pathname) && gt3.isNull(r4.search) || (r4.path = (r4.pathname ? r4.pathname : "") + (r4.search ? r4.search : "")), r4.href = r4.format(), r4;
          if (!R5.length)
            return r4.pathname = null, r4.search ? r4.path = "/" + r4.search : r4.path = null, r4.href = r4.format(), r4;
          for (var N4 = R5.slice(-1)[0], W4 = (r4.host || t4.host || R5.length > 1) && (N4 === "." || N4 === "..") || N4 === "", K5 = 0, z4 = R5.length; z4 >= 0; z4--)
            (N4 = R5[z4]) === "." ? R5.splice(z4, 1) : N4 === ".." ? (R5.splice(z4, 1), K5++) : K5 && (R5.splice(z4, 1), K5--);
          if (!I3 && !C3)
            for (; K5--; K5)
              R5.unshift("..");
          !I3 || R5[0] === "" || R5[0] && R5[0].charAt(0) === "/" || R5.unshift(""), W4 && R5.join("/").substr(-1) !== "/" && R5.push("");
          var Q3, de3 = R5[0] === "" || R5[0] && R5[0].charAt(0) === "/";
          return U5 && (r4.hostname = r4.host = de3 ? "" : R5.length ? R5.shift() : "", (Q3 = !!(r4.host && r4.host.indexOf("@") > 0) && r4.host.split("@")) && (r4.auth = Q3.shift(), r4.host = r4.hostname = Q3.shift())), (I3 = I3 || r4.host && R5.length) && !de3 && R5.unshift(""), R5.length ? r4.pathname = R5.join("/") : (r4.pathname = null, r4.path = null), gt3.isNull(r4.pathname) && gt3.isNull(r4.search) || (r4.path = (r4.pathname ? r4.pathname : "") + (r4.search ? r4.search : "")), r4.auth = t4.auth || r4.auth, r4.slashes = r4.slashes || t4.slashes, r4.href = r4.format(), r4;
        }, Fe4.prototype.parseHost = function() {
          var t4 = this.host, e4 = pE.exec(t4);
          e4 && ((e4 = e4[0]) !== ":" && (this.port = e4.substr(1)), t4 = t4.substr(0, t4.length - e4.length)), t4 && (this.hostname = t4);
        };
        Z4.Url;
        Z4.format;
        Z4.resolve;
        Z4.resolveObject;
        el2 = {}, fg2 = false;
        cg2 = _E(), mE = typeof Deno < "u" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
        Z4.URL = typeof URL < "u" ? URL : null;
        Z4.pathToFileURL = ME;
        Z4.fileURLToPath = OE;
        Z4.Url;
        Z4.format;
        Z4.resolve;
        Z4.resolveObject;
        Z4.URL;
        vE = 92, EE = 47, SE = 97, AE = 122, rl2 = mE === "win32", IE = /\//g, TE = /%/g, RE = /\\/g, CE = /\n/g, BE = /\r/g, PE = /\t/g;
        LE = typeof Deno < "u" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
        Z4.URL = typeof URL < "u" ? URL : null;
        Z4.pathToFileURL = dg2;
        Z4.fileURLToPath = hg2;
        UE = Z4.Url, NE = Z4.format, qE = Z4.resolve, DE = Z4.resolveObject, jE = Z4.parse, FE = Z4.URL, WE = 92, $E = 47, HE = 97, VE = 122, il2 = LE === "win32", zE = /\//g, KE = /%/g, GE = /\\/g, QE = /\n/g, YE = /\r/g, JE = /\t/g;
      });
      nl = {};
      Qt3(nl, { Server: () => Me3, Socket: () => Me3, Stream: () => Me3, _createServerHandle: () => Me3, _normalizeArgs: () => Me3, _setSimultaneousAccepts: () => Me3, connect: () => Me3, createConnection: () => Me3, createServer: () => Me3, default: () => eS, isIP: () => Me3, isIPv4: () => Me3, isIPv6: () => Me3 });
      sl2 = we4(() => {
        v3();
        m3();
        _3();
        eS = { _createServerHandle: Me3, _normalizeArgs: Me3, _setSimultaneousAccepts: Me3, connect: Me3, createConnection: Me3, createServer: Me3, isIP: Me3, isIPv4: Me3, isIPv6: Me3, Server: Me3, Socket: Me3, Stream: Me3 };
      });
      ol2 = M3((Mi3) => {
        "use strict";
        v3();
        m3();
        _3();
        var yg2 = Mi3 && Mi3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Mi3, "__esModule", { value: true });
        var tS = yg2((sl2(), X3(nl))), rS = yg2(ot3()), iS = (0, rS.default)("mqttjs:tcp"), nS = (t4, e4) => {
          e4.port = e4.port || 1883, e4.hostname = e4.hostname || e4.host || "localhost";
          let { port: r4 } = e4, i5 = e4.hostname;
          return iS("port %d and host %s", r4, i5), tS.default.createConnection(r4, i5);
        };
        Mi3.default = nS;
      });
      bg2 = {};
      Qt3(bg2, { default: () => sS });
      wg2 = we4(() => {
        v3();
        m3();
        _3();
        sS = {};
      });
      ll2 = M3((Li3) => {
        "use strict";
        v3();
        m3();
        _3();
        var al2 = Li3 && Li3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Li3, "__esModule", { value: true });
        var oS = al2((wg2(), X3(bg2))), aS = al2((sl2(), X3(nl))), lS = al2(ot3()), uS = (0, lS.default)("mqttjs:tls"), fS = (t4, e4) => {
          e4.port = e4.port || 8883, e4.host = e4.hostname || e4.host || "localhost", aS.default.isIP(e4.host) === 0 && (e4.servername = e4.host), e4.rejectUnauthorized = e4.rejectUnauthorized !== false, delete e4.path, uS("port %d host %s rejectUnauthorized %b", e4.port, e4.host, e4.rejectUnauthorized);
          let r4 = oS.default.connect(e4);
          r4.on("secureConnect", () => {
            e4.rejectUnauthorized && !r4.authorized ? r4.emit("error", new Error("TLS not authorized")) : r4.removeListener("error", i5);
          });
          function i5(n4) {
            e4.rejectUnauthorized && t4.emit("error", n4), r4.end();
          }
          return r4.on("error", i5), r4;
        };
        Li3.default = fS;
      });
      as3 = M3((oi2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(oi2, "__esModule", { value: true });
        oi2.BufferedDuplex = oi2.writev = void 0;
        var cS = jt4(), _g2 = (ye5(), X3(_e5));
        function mg2(t4, e4) {
          let r4 = new Array(t4.length);
          for (let i5 = 0; i5 < t4.length; i5++)
            typeof t4[i5].chunk == "string" ? r4[i5] = _g2.Buffer.from(t4[i5].chunk, "utf8") : r4[i5] = t4[i5].chunk;
          this._write(_g2.Buffer.concat(r4), "binary", e4);
        }
        oi2.writev = mg2;
        var ul2 = class extends cS.Duplex {
          constructor(e4, r4, i5) {
            super({ objectMode: true }), this.proxy = r4, this.socket = i5, this.writeQueue = [], e4.objectMode || (this._writev = mg2.bind(this)), this.isSocketOpen = false, this.proxy.on("data", (n4) => {
              this.push(n4);
            });
          }
          _read(e4) {
            this.proxy.read(e4);
          }
          _write(e4, r4, i5) {
            this.isSocketOpen ? this.writeToProxy(e4, r4, i5) : this.writeQueue.push({ chunk: e4, encoding: r4, cb: i5 });
          }
          _final(e4) {
            this.writeQueue = [], this.proxy.end(e4);
          }
          _destroy(e4, r4) {
            this.writeQueue = [], this.proxy.destroy(), r4(e4);
          }
          socketReady() {
            this.emit("connect"), this.isSocketOpen = true, this.processWriteQueue();
          }
          writeToProxy(e4, r4, i5) {
            this.proxy.write(e4, r4) === false ? this.proxy.once("drain", i5) : i5();
          }
          processWriteQueue() {
            for (; this.writeQueue.length > 0; ) {
              let { chunk: e4, encoding: r4, cb: i5 } = this.writeQueue.shift();
              this.writeToProxy(e4, r4, i5);
            }
          }
        };
        oi2.BufferedDuplex = ul2;
      });
      hl2 = M3((cl2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(cl2, "__esModule", { value: true });
        var vg2 = (ye5(), X3(_e5)), hS = jt4(), dS = as3(), yt3, fl3, Le5;
        function pS() {
          let t4 = new hS.Transform();
          return t4._write = (e4, r4, i5) => {
            yt3.send({ data: e4.buffer, success() {
              i5();
            }, fail(n4) {
              i5(new Error(n4));
            } });
          }, t4._flush = (e4) => {
            yt3.close({ success() {
              e4();
            } });
          }, t4;
        }
        function gS(t4) {
          t4.hostname || (t4.hostname = "localhost"), t4.path || (t4.path = "/"), t4.wsOptions || (t4.wsOptions = {});
        }
        function yS(t4, e4) {
          let r4 = t4.protocol === "wxs" ? "wss" : "ws", i5 = `${r4}://${t4.hostname}${t4.path}`;
          return t4.port && t4.port !== 80 && t4.port !== 443 && (i5 = `${r4}://${t4.hostname}:${t4.port}${t4.path}`), typeof t4.transformWsUrl == "function" && (i5 = t4.transformWsUrl(i5, t4, e4)), i5;
        }
        function bS() {
          yt3.onOpen(() => {
            Le5.socketReady();
          }), yt3.onMessage((t4) => {
            let { data: e4 } = t4;
            e4 instanceof ArrayBuffer ? e4 = vg2.Buffer.from(e4) : e4 = vg2.Buffer.from(e4, "utf8"), fl3.push(e4);
          }), yt3.onClose(() => {
            Le5.emit("close"), Le5.end(), Le5.destroy();
          }), yt3.onError((t4) => {
            let e4 = new Error(t4.errMsg);
            Le5.destroy(e4);
          });
        }
        var wS = (t4, e4) => {
          if (e4.hostname = e4.hostname || e4.host, !e4.hostname)
            throw new Error("Could not determine host. Specify host manually.");
          let r4 = e4.protocolId === "MQIsdp" && e4.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          gS(e4);
          let i5 = yS(e4, t4);
          yt3 = wx.connectSocket({ url: i5, protocols: [r4] }), fl3 = pS(), Le5 = new dS.BufferedDuplex(e4, fl3, yt3), Le5._destroy = (o4, s4) => {
            yt3.close({ success() {
              s4 && s4(o4);
            } });
          };
          let n4 = Le5.destroy;
          return Le5.destroy = (o4, s4) => (Le5.destroy = n4, setTimeout(() => {
            yt3.close({ fail() {
              Le5._destroy(o4, s4);
            } });
          }, 0), Le5), bS(), Le5;
        };
        cl2.default = wS;
      });
      gl2 = M3((pl2) => {
        "use strict";
        v3();
        m3();
        _3();
        Object.defineProperty(pl2, "__esModule", { value: true });
        var dl2 = (ye5(), X3(_e5)), _S = jt4(), mS = as3(), xt4, ls3, ai2, Eg = false;
        function vS() {
          let t4 = new _S.Transform();
          return t4._write = (e4, r4, i5) => {
            xt4.sendSocketMessage({ data: e4.buffer, success() {
              i5();
            }, fail() {
              i5(new Error());
            } });
          }, t4._flush = (e4) => {
            xt4.closeSocket({ success() {
              e4();
            } });
          }, t4;
        }
        function ES(t4) {
          t4.hostname || (t4.hostname = "localhost"), t4.path || (t4.path = "/"), t4.wsOptions || (t4.wsOptions = {});
        }
        function SS(t4, e4) {
          let r4 = t4.protocol === "alis" ? "wss" : "ws", i5 = `${r4}://${t4.hostname}${t4.path}`;
          return t4.port && t4.port !== 80 && t4.port !== 443 && (i5 = `${r4}://${t4.hostname}:${t4.port}${t4.path}`), typeof t4.transformWsUrl == "function" && (i5 = t4.transformWsUrl(i5, t4, e4)), i5;
        }
        function AS() {
          Eg || (Eg = true, xt4.onSocketOpen(() => {
            ai2.socketReady();
          }), xt4.onSocketMessage((t4) => {
            if (typeof t4.data == "string") {
              let e4 = dl2.Buffer.from(t4.data, "base64");
              ls3.push(e4);
            } else {
              let e4 = new FileReader();
              e4.addEventListener("load", () => {
                let r4 = e4.result;
                r4 instanceof ArrayBuffer ? r4 = dl2.Buffer.from(r4) : r4 = dl2.Buffer.from(r4, "utf8"), ls3.push(r4);
              }), e4.readAsArrayBuffer(t4.data);
            }
          }), xt4.onSocketClose(() => {
            ai2.end(), ai2.destroy();
          }), xt4.onSocketError((t4) => {
            ai2.destroy(t4);
          }));
        }
        var IS = (t4, e4) => {
          if (e4.hostname = e4.hostname || e4.host, !e4.hostname)
            throw new Error("Could not determine host. Specify host manually.");
          let r4 = e4.protocolId === "MQIsdp" && e4.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          ES(e4);
          let i5 = SS(e4, t4);
          return xt4 = e4.my, xt4.connectSocket({ url: i5, protocols: r4 }), ls3 = vS(), ai2 = new mS.BufferedDuplex(e4, ls3, xt4), AS(), ai2;
        };
        pl2.default = IS;
      });
      Ag = M3((xD, Sg2) => {
        "use strict";
        v3();
        m3();
        _3();
        Sg2.exports = function() {
          throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
        };
      });
      _l2 = M3((Ui3) => {
        "use strict";
        v3();
        m3();
        _3();
        var wl2 = Ui3 && Ui3.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Ui3, "__esModule", { value: true });
        var yl2 = (ye5(), X3(_e5)), Ig2 = wl2(Ag()), TS = wl2(ot3()), RS = jt4(), Tg = wl2(Pi3()), bl2 = as3(), Kt4 = (0, TS.default)("mqttjs:ws"), CS = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"];
        function Rg(t4, e4) {
          let r4 = `${t4.protocol}://${t4.hostname}:${t4.port}${t4.path}`;
          return typeof t4.transformWsUrl == "function" && (r4 = t4.transformWsUrl(r4, t4, e4)), r4;
        }
        function Cg(t4) {
          let e4 = t4;
          return t4.hostname || (e4.hostname = "localhost"), t4.port || (t4.protocol === "wss" ? e4.port = 443 : e4.port = 80), t4.path || (e4.path = "/"), t4.wsOptions || (e4.wsOptions = {}), !Tg.default && t4.protocol === "wss" && CS.forEach((r4) => {
            Object.prototype.hasOwnProperty.call(t4, r4) && !Object.prototype.hasOwnProperty.call(t4.wsOptions, r4) && (e4.wsOptions[r4] = t4[r4]);
          }), e4;
        }
        function BS(t4) {
          let e4 = Cg(t4);
          if (e4.hostname || (e4.hostname = e4.host), !e4.hostname) {
            if (typeof document > "u")
              throw new Error("Could not determine host. Specify host manually.");
            let r4 = new URL(document.URL);
            e4.hostname = r4.hostname, e4.port || (e4.port = Number(r4.port));
          }
          return e4.objectMode === void 0 && (e4.objectMode = !(e4.binary === true || e4.binary === void 0)), e4;
        }
        function PS(t4, e4, r4) {
          Kt4("createWebSocket"), Kt4(`protocol: ${r4.protocolId} ${r4.protocolVersion}`);
          let i5 = r4.protocolId === "MQIsdp" && r4.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          Kt4(`creating new Websocket for url: ${e4} and protocol: ${i5}`);
          let n4;
          return r4.createWebsocket ? n4 = r4.createWebsocket(e4, [i5], r4) : n4 = new Ig2.default(e4, [i5], r4.wsOptions), n4;
        }
        function OS(t4, e4) {
          let r4 = e4.protocolId === "MQIsdp" && e4.protocolVersion === 3 ? "mqttv3.1" : "mqtt", i5 = Rg(e4, t4), n4;
          return e4.createWebsocket ? n4 = e4.createWebsocket(i5, [r4], e4) : n4 = new WebSocket(i5, [r4]), n4.binaryType = "arraybuffer", n4;
        }
        var kS = (t4, e4) => {
          Kt4("streamBuilder");
          let r4 = Cg(e4), i5 = Rg(r4, t4), n4 = PS(t4, i5, r4), o4 = Ig2.default.createWebSocketStream(n4, r4.wsOptions);
          return o4.url = i5, n4.on("close", () => {
            o4.destroy();
          }), o4;
        }, xS = (t4, e4) => {
          Kt4("browserStreamBuilder");
          let r4, n4 = BS(e4).browserBufferSize || 1024 * 512, o4 = e4.browserBufferTimeout || 1e3, s4 = !e4.objectMode, a4 = OS(t4, e4), u4 = h4(e4, E4, S3);
          e4.objectMode || (u4._writev = bl2.writev.bind(u4)), u4.on("close", () => {
            a4.close();
          });
          let c5 = typeof a4.addEventListener < "u";
          a4.readyState === a4.OPEN ? (r4 = u4, r4.socket = a4) : (r4 = new bl2.BufferedDuplex(e4, u4, a4), c5 ? a4.addEventListener("open", d4) : a4.onopen = d4), c5 ? (a4.addEventListener("close", g4), a4.addEventListener("error", y3), a4.addEventListener("message", w3)) : (a4.onclose = g4, a4.onerror = y3, a4.onmessage = w3);
          function h4(I3, C3, R5) {
            let U5 = new RS.Transform({ objectMode: I3.objectMode });
            return U5._write = C3, U5._flush = R5, U5;
          }
          function d4() {
            Kt4("WebSocket onOpen"), r4 instanceof bl2.BufferedDuplex && r4.socketReady();
          }
          function g4(I3) {
            Kt4("WebSocket onClose", I3), r4.end(), r4.destroy();
          }
          function y3(I3) {
            Kt4("WebSocket onError", I3);
            let C3 = new Error("WebSocket error");
            C3.event = I3, r4.destroy(C3);
          }
          function w3(I3) {
            let { data: C3 } = I3;
            C3 instanceof ArrayBuffer ? C3 = yl2.Buffer.from(C3) : C3 = yl2.Buffer.from(C3, "utf8"), u4.push(C3);
          }
          function E4(I3, C3, R5) {
            if (a4.bufferedAmount > n4) {
              setTimeout(E4, o4, I3, C3, R5);
              return;
            }
            s4 && typeof I3 == "string" && (I3 = yl2.Buffer.from(I3, "utf8"));
            try {
              a4.send(I3);
            } catch (U5) {
              return R5(U5);
            }
            R5();
          }
          function S3(I3) {
            a4.close(), I3();
          }
          return r4;
        };
        Ui3.default = Tg.default ? xS : kS;
      });
      Og2 = M3((Rr4) => {
        "use strict";
        v3();
        m3();
        _3();
        var us3 = Rr4 && Rr4.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(Rr4, "__esModule", { value: true });
        Rr4.connectAsync = void 0;
        var MS = us3(ot3()), LS = us3((gg2(), X3(pg2))), US = us3(ss3()), NS = us3(Pi3()), Bg = (0, MS.default)("mqttjs"), Re4 = {};
        NS.default ? (Re4.wx = hl2().default, Re4.wxs = hl2().default, Re4.ali = gl2().default, Re4.alis = gl2().default) : (Re4.mqtt = ol2().default, Re4.tcp = ol2().default, Re4.ssl = ll2().default, Re4.tls = Re4.ssl, Re4.mqtts = ll2().default);
        Re4.ws = _l2().default;
        Re4.wss = _l2().default;
        function qS(t4) {
          let e4;
          t4.auth && (e4 = t4.auth.match(/^(.+):(.+)$/), e4 ? (t4.username = e4[1], t4.password = e4[2]) : t4.username = t4.auth);
        }
        function Pg(t4, e4) {
          if (Bg("connecting to an MQTT broker..."), typeof t4 == "object" && !e4 && (e4 = t4, t4 = ""), e4 = e4 || {}, t4 && typeof t4 == "string") {
            let n4 = LS.default.parse(t4, true);
            if (n4.port != null && (n4.port = Number(n4.port)), e4 = Object.assign(Object.assign({}, n4), e4), e4.protocol === null)
              throw new Error("Missing protocol");
            e4.protocol = e4.protocol.replace(/:$/, "");
          }
          if (qS(e4), e4.query && typeof e4.query.clientId == "string" && (e4.clientId = e4.query.clientId), e4.cert && e4.key)
            if (e4.protocol) {
              if (["mqtts", "wss", "wxs", "alis"].indexOf(e4.protocol) === -1)
                switch (e4.protocol) {
                  case "mqtt":
                    e4.protocol = "mqtts";
                    break;
                  case "ws":
                    e4.protocol = "wss";
                    break;
                  case "wx":
                    e4.protocol = "wxs";
                    break;
                  case "ali":
                    e4.protocol = "alis";
                    break;
                  default:
                    throw new Error(`Unknown protocol for secure connection: "${e4.protocol}"!`);
                }
            } else
              throw new Error("Missing secure protocol key");
          if (!Re4[e4.protocol]) {
            let n4 = ["mqtts", "wss"].indexOf(e4.protocol) !== -1;
            e4.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis"].filter((o4, s4) => n4 && s4 % 2 === 0 ? false : typeof Re4[o4] == "function")[0];
          }
          if (e4.clean === false && !e4.clientId)
            throw new Error("Missing clientId for unclean clients");
          e4.protocol && (e4.defaultProtocol = e4.protocol);
          function r4(n4) {
            return e4.servers && ((!n4._reconnectCount || n4._reconnectCount === e4.servers.length) && (n4._reconnectCount = 0), e4.host = e4.servers[n4._reconnectCount].host, e4.port = e4.servers[n4._reconnectCount].port, e4.protocol = e4.servers[n4._reconnectCount].protocol ? e4.servers[n4._reconnectCount].protocol : e4.defaultProtocol, e4.hostname = e4.host, n4._reconnectCount++), Bg("calling streambuilder for", e4.protocol), Re4[e4.protocol](n4, e4);
          }
          let i5 = new US.default(r4, e4);
          return i5.on("error", () => {
          }), i5;
        }
        function DS(t4, e4, r4 = true) {
          return new Promise((i5, n4) => {
            let o4 = Pg(t4, e4), s4 = { connect: (u4) => {
              a4(), i5(o4);
            }, end: () => {
              a4(), i5(o4);
            }, error: (u4) => {
              a4(), o4.end(), n4(u4);
            } };
            r4 === false && (s4.close = () => {
              s4.error(new Error("Couldn't connect to server"));
            });
            function a4() {
              Object.keys(s4).forEach((u4) => {
                o4.off(u4, s4[u4]);
              });
            }
            Object.keys(s4).forEach((u4) => {
              o4.on(u4, s4[u4]);
            });
          });
        }
        Rr4.connectAsync = DS;
        Rr4.default = Pg;
      });
      ml2 = M3((G4) => {
        "use strict";
        v3();
        m3();
        _3();
        var kg = G4 && G4.__createBinding || (Object.create ? function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4);
          var n4 = Object.getOwnPropertyDescriptor(e4, r4);
          (!n4 || ("get" in n4 ? !e4.__esModule : n4.writable || n4.configurable)) && (n4 = { enumerable: true, get: function() {
            return e4[r4];
          } }), Object.defineProperty(t4, i5, n4);
        } : function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4), t4[i5] = e4[r4];
        }), jS = G4 && G4.__setModuleDefault || (Object.create ? function(t4, e4) {
          Object.defineProperty(t4, "default", { enumerable: true, value: e4 });
        } : function(t4, e4) {
          t4.default = e4;
        }), FS = G4 && G4.__importStar || function(t4) {
          if (t4 && t4.__esModule)
            return t4;
          var e4 = {};
          if (t4 != null)
            for (var r4 in t4)
              r4 !== "default" && Object.prototype.hasOwnProperty.call(t4, r4) && kg(e4, t4, r4);
          return jS(e4, t4), e4;
        }, xg = G4 && G4.__exportStar || function(t4, e4) {
          for (var r4 in t4)
            r4 !== "default" && !Object.prototype.hasOwnProperty.call(e4, r4) && kg(e4, t4, r4);
        }, Ni3 = G4 && G4.__importDefault || function(t4) {
          return t4 && t4.__esModule ? t4 : { default: t4 };
        };
        Object.defineProperty(G4, "__esModule", { value: true });
        G4.ReasonCodes = G4.PingTimer = G4.UniqueMessageIdProvider = G4.DefaultMessageIdProvider = G4.Store = G4.MqttClient = G4.connectAsync = G4.connect = G4.Client = void 0;
        var Mg = Ni3(ss3());
        G4.MqttClient = Mg.default;
        var WS = Ni3(Jo3());
        G4.DefaultMessageIdProvider = WS.default;
        var $S = Ni3(Hp2());
        G4.UniqueMessageIdProvider = $S.default;
        var HS = Ni3(ea3());
        G4.Store = HS.default;
        var Lg = FS(Og2());
        G4.connect = Lg.default;
        Object.defineProperty(G4, "connectAsync", { enumerable: true, get: function() {
          return Lg.connectAsync;
        } });
        var VS = Ni3(ja3());
        G4.PingTimer = VS.default;
        G4.Client = Mg.default;
        xg(ss3(), G4);
        xg(Jr3(), G4);
        var zS = Ai3();
        Object.defineProperty(G4, "ReasonCodes", { enumerable: true, get: function() {
          return zS.ReasonCodes;
        } });
      });
      JS = M3((We3) => {
        v3();
        m3();
        _3();
        var Ug = We3 && We3.__createBinding || (Object.create ? function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4);
          var n4 = Object.getOwnPropertyDescriptor(e4, r4);
          (!n4 || ("get" in n4 ? !e4.__esModule : n4.writable || n4.configurable)) && (n4 = { enumerable: true, get: function() {
            return e4[r4];
          } }), Object.defineProperty(t4, i5, n4);
        } : function(t4, e4, r4, i5) {
          i5 === void 0 && (i5 = r4), t4[i5] = e4[r4];
        }), KS = We3 && We3.__setModuleDefault || (Object.create ? function(t4, e4) {
          Object.defineProperty(t4, "default", { enumerable: true, value: e4 });
        } : function(t4, e4) {
          t4.default = e4;
        }), GS = We3 && We3.__importStar || function(t4) {
          if (t4 && t4.__esModule)
            return t4;
          var e4 = {};
          if (t4 != null)
            for (var r4 in t4)
              r4 !== "default" && Object.prototype.hasOwnProperty.call(t4, r4) && Ug(e4, t4, r4);
          return KS(e4, t4), e4;
        }, QS = We3 && We3.__exportStar || function(t4, e4) {
          for (var r4 in t4)
            r4 !== "default" && !Object.prototype.hasOwnProperty.call(e4, r4) && Ug(e4, t4, r4);
        };
        Object.defineProperty(We3, "__esModule", { value: true });
        var YS = GS(ml2());
        We3.default = YS;
        QS(ml2(), We3);
      });
      mqtt_esm_default = JS();
    }
  });

  // node_modules/@sermas/toolkit/mqtt-client.js
  var MqttClient;
  var init_mqtt_client = __esm({
    "node_modules/@sermas/toolkit/mqtt-client.js"() {
      init_mqtt_esm();
      init_esm_browser();
      init_events();
      init_logger();
      MqttClient = class {
        constructor(options) {
          this.options = options;
          this.events = {
            pub: [],
            sub: []
          };
          this.topics = [];
          this.appId = this.options.appId;
          this.moduleId = this.options.moduleId;
          this.logger = new Logger(`broker <${this.moduleId}>`);
        }
        addACLEvent(type, ev) {
          if (this.events[type].includes(ev))
            return;
          this.logger.debug(`EVT ${type} ${ev}`);
          this.events[type].push(ev);
        }
        getACLEvents() {
          return this.events;
        }
        setTopics(topics) {
          this.unsubscribeTopics();
          this.topics = topics;
          this.subscribeTopics();
        }
        setUserId(userId) {
          if (this.userId !== userId) {
            this.userId = userId;
            this.resubscribe();
          }
        }
        setAppId(appId) {
          if (this.appId !== appId) {
            this.appId = appId;
            this.resubscribe();
          }
        }
        setSessionId(sessionId) {
          if (this.sessionId !== sessionId) {
            this.sessionId = sessionId;
            this.resubscribe();
          }
        }
        resubscribe() {
          this.setTopics(this.topics);
        }
        subscribeTopics() {
          this.mapTopics(this.topics).map((topic) => this.subscribe(topic));
        }
        unsubscribeTopics() {
          this.mapTopics(this.topics).forEach((t4) => this.unsubscribe(t4));
        }
        unsubscribe(topic) {
          if (!this.isConnected()) {
            this.logger.debug(`Cannot unsubsribe, not connected`);
            return;
          }
          this.mqttClient?.unsubscribe(topic);
        }
        isConnected() {
          if (!this.mqttClient)
            return false;
          return this.mqttClient.connected;
        }
        disconnect() {
          if (!this.mqttClient)
            return;
          this.unsubscribeTopics();
          this.mqttClient.disconnected;
          this.mqttClient = void 0;
        }
        getClient() {
          return this.mqttClient;
        }
        subscribe(topics) {
          if (!this.isConnected()) {
            this.logger.debug(`MQTT not connected, cannot subscribe to ${JSON.stringify(topics)}`);
            return;
          }
          this.mqttClient?.subscribe(topics, (e4) => {
            if (e4) {
              this.logger.warn(`failed subscription to ${JSON.stringify(topics)}: ${e4.stack}`);
            }
          });
        }
        publish(topic, data, json = true) {
          if (!this.mqttClient) {
            this.logger.error("Mqtt client not initialized");
            return;
          }
          if (this.userId && data.userId === void 0)
            data.userId = this.userId;
          if (this.sessionId && data.sessionId === void 0)
            data.sessionId = this.sessionId;
          data.appId = this.appId;
          data.source = this.options.moduleId;
          try {
            if (!this.isConnected()) {
              this.logger.debug(`Cannot send, not connected`);
              return;
            }
            const [resource, scope] = topic.split("/");
            this.addACLEvent("pub", `${resource}.${scope}`);
            this.mqttClient.publish(`app/${this.options.appId}/${topic}`, json ? JSON.stringify(data) : data, { qos: 2, retain: false });
          } catch (e4) {
            this.logger.warn(`Failed to send: ${e4.message}`);
          }
        }
        mapTopics(topics) {
          return topics.map((topicTemplate) => {
            let topic = topicTemplate;
            if (this.appId)
              topic = topic.replace(":appId", this.appId);
            if (this.sessionId)
              topic = topic.replace(":sessionId", this.sessionId);
            if (this.userId)
              topic = topic.replace(":userId", this.userId);
            if ([":sessionId", ":appId"].filter((param) => topic.indexOf(param) > -1).length) {
              this.logger.debug(`SUB Skip topic=${topic} with unmapped param`);
              return "";
            } else {
              topic = topic.replace(/(:.+)$/g, "+");
            }
            return topic;
          }).filter((topic) => topic !== "");
        }
        onClientConnected() {
          if (!this.mqttClient)
            return;
          this.subscribeTopics();
        }
        onMessage(topic, payload, packet) {
          this.logger.debug(`MSG ${topic}`);
          try {
            let decoded = payload;
            try {
              try {
                decoded = decoded.toString();
              } catch (e4) {
                this.logger.error("Failed decoding payload", e4);
              }
              if (decoded && decoded.match(/^[{|[]/))
                decoded = JSON.parse(decoded);
            } catch (e4) {
              this.logger.debug(`Failed to parse message for topic ${topic}: ${e4.stack}`);
            }
            const [, appId, resource, scope, ...context] = topic.split("/");
            const ev = {
              topic,
              message: packet,
              payload: decoded,
              appId,
              resource,
              scope,
              context
            };
            (() => emitter.emit(`${resource}.${scope}`, ev.payload, ev))();
            this.addACLEvent("sub", `${resource}.${scope}`);
          } catch (e4) {
            this.logger.warn(`failed to handle mqtt message: ${e4.message}`);
            this.logger.warn(e4);
          }
        }
        async connect(token, retries = 0) {
          if (this.mqttClient)
            return;
          const prefix = "/mqtt";
          const brokerUrl = new URL(this.options.url);
          const useSSL = brokerUrl.protocol === "https:";
          const mqttPort = brokerUrl.port && brokerUrl.port !== "" ? +brokerUrl.port : useSSL ? 443 : 80;
          const mqttUrl = `ws${useSSL ? "s" : ""}://${brokerUrl.hostname}:${mqttPort}${prefix}`;
          this.logger.debug(`mqtt connecting to: ${mqttUrl} retries=${retries}`);
          const mqttClient = mqtt_esm_default.connect(mqttUrl, {
            reconnectPeriod: 2e3,
            username: token,
            password: "mqtt",
            protocol: useSSL ? "wss" : "ws",
            clientId: v4_default(),
            protocolVersion: 5,
            rejectUnauthorized: false,
            clean: true
          });
          this.mqttClient = mqttClient;
          mqttClient.on("message", (topic, payload, packet) => {
            this.onMessage(topic, payload, packet);
          });
          mqttClient.on("connect", () => {
            this.logger.debug("connected");
            this.onClientConnected();
          });
          mqttClient.on("reconnect", () => {
            this.logger.warn(`mqtt client reconnect`);
          });
          mqttClient.on("disconnect", () => {
            this.logger.warn("disconnected");
          });
          mqttClient.on("close", () => {
            this.logger.warn("close");
          });
          mqttClient.on("error", (e4) => {
            this.logger.error(`mqtt client connection error: ${e4.stack}`);
          });
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/settings.js
  var Settings;
  var init_settings = __esm({
    "node_modules/@sermas/toolkit/settings.js"() {
      init_events();
      init_constants2();
      init_logger();
      Settings = class {
        constructor() {
          this.defaults = {
            login: false,
            avatar: "default",
            background: "backgrounds/default",
            llm: "openai",
            language: DEFAULT_AVATAR_LANGUAGE,
            // developerMode
            testFace: "",
            enableTestFaces: false,
            enableAvatar: true,
            enableMic: true,
            enableAudio: true,
            showVideo: false,
            animation: "",
            enableAnimation: true,
            enableMirrorMode: false,
            animationList: [],
            devMode: false,
            rpmUrl: "",
            rpmGender: "",
            enableVideoDetection: true,
            detectorHuman: true,
            detectorFaceLandmarker: false,
            qrcode: true,
            interactionStart: "on-load"
          };
          this.settings = this.getDefaults();
        }
        export() {
          const appSettingsDto = {
            login: this.settings.login,
            avatar: this.settings.avatar,
            background: this.settings.background,
            language: this.settings.language,
            llm: this.settings.llm
          };
          return appSettingsDto;
        }
        getDefaults() {
          return {
            ...this.defaults
          };
        }
        saveLocalStorage(settings) {
          if (typeof localStorage === "undefined")
            return;
          const cfg = {
            enableAudio: settings.enableAudio,
            enableMic: settings.enableMic,
            devMode: settings.devMode === true ? true : false,
            interactionStart: settings.interactionStart
          };
          localStorage.setItem(`sermas.settings`, JSON.stringify(cfg));
        }
        loadLocalStorage() {
          if (typeof localStorage === "undefined")
            return void 0;
          try {
            const raw = localStorage.getItem(`sermas.settings`);
            if (!raw)
              return false;
            return JSON.parse(raw);
          } catch (e4) {
            logger.error(`Failed loading local storage: ${e4.message}`);
            return false;
          }
        }
        init() {
          const storage = this.loadLocalStorage();
          if (storage === false) {
            this.saveLocalStorage(this.settings);
          } else {
            this.settings = { ...this.settings, ...storage || {} };
          }
        }
        destroy() {
        }
        get() {
          return this.settings;
        }
        async save(cfg) {
          cfg = cfg || {};
          this.settings = { ...this.settings, ...cfg };
          this.saveLocalStorage(this.settings);
          emitter.emit("settings", this.settings);
          return this.settings;
        }
        async load() {
          const saved = this.loadLocalStorage();
          this.settings = {
            ...this.settings,
            ...saved || {}
          };
          return this.settings;
        }
      };
    }
  });

  // node_modules/@sermas/toolkit/user-auth.js
  var LOCAL_STORAGE_KEY, UserAuth;
  var init_user_auth = __esm({
    "node_modules/@sermas/toolkit/user-auth.js"() {
      init_auth();
      LOCAL_STORAGE_KEY = "sermas.current-user";
      UserAuth = class {
        constructor(toolkit) {
          this.toolkit = toolkit;
        }
        getCurrentUser() {
          return this.currentUser?.user;
        }
        getToken() {
          return this.currentUser?.token?.access_token;
        }
        setUser(user) {
          if (typeof localStorage === "undefined")
            return;
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(user));
        }
        removeUser() {
          if (typeof localStorage === "undefined")
            return;
          localStorage.removeItem(LOCAL_STORAGE_KEY);
        }
        getUser() {
          if (typeof localStorage === "undefined")
            return;
          const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (!raw)
            return;
          try {
            const user = JSON.parse(raw);
            if (!user)
              return;
            return user;
          } catch {
          }
        }
        async isLoginRequired() {
          const appRequiresLogin = await this.appRequiresLogin();
          if (!appRequiresLogin)
            return false;
          const user = await this.loadUser();
          if (!user)
            return true;
          return false;
        }
        async appRequiresLogin() {
          const app = await this.toolkit.getApp();
          if (!app)
            return false;
          if (!app?.settings?.login)
            return false;
          return true;
        }
        async loadUser() {
          const currentUser = await this.getUser();
          if (!currentUser)
            return void 0;
          const tokenExp = currentUser.user?.exp;
          const now3 = Math.floor(Date.now() / 1e3);
          if (tokenExp < now3) {
            await this.logout();
            return void 0;
          }
          this.currentUser = currentUser;
          this.toolkit.setUserId(this.currentUser.user.sub);
          return currentUser;
        }
        async logout() {
          this.currentUser = void 0;
          this.toolkit.setUserId(void 0);
          await this.removeUser();
        }
        async login(params) {
          const token = await this.toolkit.getApi().login({
            ...params,
            appId: params.appId || this.toolkit.getAppId()
          });
          if (token === null)
            return null;
          const user = parseJWT(token.access_token);
          if (!user)
            return null;
          this.currentUser = {
            token,
            user
          };
          await this.setUser(this.currentUser);
          this.toolkit.setUserId(this.currentUser.user.sub);
          return this.currentUser;
        }
      };
    }
  });

  // node_modules/jwt-decode/build/esm/index.js
  var InvalidTokenError;
  var init_esm = __esm({
    "node_modules/jwt-decode/build/esm/index.js"() {
      InvalidTokenError = class extends Error {
      };
      InvalidTokenError.prototype.name = "InvalidTokenError";
    }
  });

  // node_modules/@sermas/api-client/index.js
  var Y4, Z5, i4, c4, re5;
  var init_api_client = __esm({
    "node_modules/@sermas/api-client/index.js"() {
      init_esm();
      init_mqtt_esm();
      Y4 = Object.defineProperty;
      Z5 = (o4, e4, t4) => e4 in o4 ? Y4(o4, e4, { enumerable: true, configurable: true, writable: true, value: t4 }) : o4[e4] = t4;
      i4 = (o4, e4, t4) => (Z5(o4, typeof e4 != "symbol" ? e4 + "" : e4, t4), t4);
      c4 = class {
        constructor() {
          i4(this, "_fns");
          this._fns = [];
        }
        eject(e4) {
          let t4 = this._fns.indexOf(e4);
          t4 !== -1 && (this._fns = [...this._fns.slice(0, t4), ...this._fns.slice(t4 + 1)]);
        }
        use(e4) {
          this._fns = [...this._fns, e4];
        }
      };
      re5 = { BASE: "", CREDENTIALS: "include", ENCODE_PATH: void 0, HEADERS: void 0, PASSWORD: void 0, RESULT: "body", TOKEN: void 0, USERNAME: void 0, VERSION: "1.0", WITH_CREDENTIALS: false, interceptors: { request: new c4(), response: new c4() } };
    }
  });

  // node_modules/@sermas/toolkit/index.js
  var defaultEnv, getEnv, getUrl, SermasToolkit;
  var init_toolkit = __esm({
    "node_modules/@sermas/toolkit/index.js"() {
      init_esm_browser();
      init_api();
      init_auth();
      init_avatar();
      init_constants2();
      init_detection();
      init_detection_dto();
      init_errors_dto();
      init_events();
      init_fps();
      init_logger();
      init_mqtt_client();
      init_settings();
      init_user_auth();
      init_api_client();
      init_constants2();
      init_api_client();
      init_constants2();
      defaultEnv = "prod";
      getEnv = () => {
        if (typeof document === "undefined")
          return defaultEnv;
        if (!document.location.hostname)
          return defaultEnv;
        if (document.location.hostname === "localhost")
          return "local";
        const parts = document.location.hostname.split(".");
        if (!parts.length)
          return defaultEnv;
        if (parts[0] === "local")
          return "local";
        if (parts[0] === "dev")
          return "dev";
        if (parts[0] === "staging")
          return "staging";
        if (parts[0] === "prod")
          return "prod";
        return defaultEnv;
      };
      getUrl = () => {
        if (typeof document === "undefined")
          return void 0;
        const { hostname, protocol, port } = document.location;
        return `${protocol}//${hostname}${port ? ":" + port : ""}`;
      };
      SermasToolkit = class {
        constructor(options) {
          this.options = options;
          this.logger = new Logger("toolkit");
          this.settings = new Settings();
          this.emitter = emitter;
          this.listeners = new EventListenerTracker(emitter);
          this.fpsMonitor = new FpsMonitor(this.emitter);
          const env = getEnv();
          const baseUrl = this.options.url || getUrl();
          if (!baseUrl)
            throw new Error(`Failed to detect baseUrl. Please provide the 'url' option in config.`);
          this.logger.debug(`baseUrl=${baseUrl}`);
          this.baseUrl = baseUrl;
          const appId = this.options.appId;
          const moduleId = this.options.moduleId;
          const authUrl = this.options.auth.url;
          const authClientId = this.options.auth.clientId || "sermas";
          const authRealm = this.options.auth.realm || `sermas-${env}`;
          const apiUrl = `${baseUrl}/api`;
          this.settings.init();
          this.api = new ApiClient({
            url: apiUrl,
            appId
          });
          this.auth = new AuthClient({
            authUrl,
            authClientId,
            authRealm,
            refreshToken: () => {
              return this.api.refreshToken();
            }
          });
          this.broker = new MqttClient({
            url: baseUrl,
            appId,
            moduleId
          });
          this.userAuth = new UserAuth(this);
        }
        async createWebAvatar(avatarConfig) {
          avatarConfig = avatarConfig || await this.getAvatarConfig();
          this.avatar = await createWebAvatar(avatarConfig, this);
          return this.avatar;
        }
        getAudioDetection() {
          if (!this.audioDetection)
            this.audioDetection = new AudioDetection(this);
          return this.audioDetection;
        }
        getVideoDetection() {
          if (!this.videoDetection)
            this.videoDetection = new VideoDetection(this);
          return this.videoDetection;
        }
        getCurrentUser() {
          return this.userAuth.getCurrentUser();
        }
        getUserAuth() {
          return this.userAuth;
        }
        getSettings() {
          return this.settings;
        }
        getBaseUrl() {
          return this.baseUrl;
        }
        async setAppId(appId) {
          this.options.appId = appId;
          this.loadApp();
        }
        getAppId() {
          return this.options.appId;
        }
        getSessionId() {
          return this.sessionId;
        }
        setSessionId(sessionId) {
          this.emit("session", sessionId);
          this.sessionId = sessionId;
        }
        createSessionId() {
          const sessionId = v4_default();
          this.setSessionId(sessionId);
          this.logger.debug(`Created new session sessionId=${this.sessionId}`);
          return sessionId;
        }
        getUserId() {
          return this.userId;
        }
        setUserId(userId) {
          this.userId = userId;
          this.emit("user.changed", userId);
        }
        async loadApp(appId) {
          const app = await this.api.getApp(appId || this.options.appId);
          this.app = app || void 0;
          this.emitter.emit("app", app);
        }
        async getApp() {
          if (!this.app)
            await this.loadApp();
          return this.app;
        }
        getApi() {
          return this.api;
        }
        getBroker() {
          return this.broker;
        }
        getToken() {
          return this.token;
        }
        onSession(sessionId) {
          this.api.setSessionId(sessionId);
          this.broker.setSessionId(sessionId);
        }
        onApp(app) {
          if (app === null) {
            this.emit("failure", {
              reason: ErrorReason.MISSING_APP
            });
            return;
          }
          this.api.setAppId(app?.appId);
          this.broker.setAppId(app?.appId);
          this.settings.save(app.settings || {});
        }
        onAvatarSpeechStop() {
          this.logger.log(`Stop avatar generation`);
          this.getApi().sendForceStop();
        }
        onSessionChanged(ev) {
          this.logger.debug(`session event ${ev.operation} sessionId=${ev.record.sessionId}`);
          if (ev.operation === "updated") {
            if (ev.record.closedAt) {
              this.logger.log(`Session closed, creating new session id`);
              this.createSessionId();
            }
          }
        }
        onUiButtonSession(ev) {
          const interactionType = ev.status === "started" ? InteractionType.start : InteractionType.stop;
          this.getApi().interactionIntention(ev.source, ev.trigger, interactionType, this.sessionId);
        }
        async onUserChanged(userId) {
          this.logger.debug(`userId=${userId}`);
          this.api.setUserId(userId);
          this.broker.setUserId(userId);
          if (userId && this.getSessionId()) {
            const session = await this.api.getSession(this.getSessionId());
            if (session && !session.userId) {
              session.userId = this.userId;
              await this.api.updateSession(session);
            }
          }
        }
        async destroy() {
          await this.fpsMonitor.destroy();
          this.off("session", this.onSession);
          this.off("app", this.onApp);
          this.off("ui.button.session", this.onUiButtonSession);
          this.off("avatar.speech.stop", this.onAvatarSpeechStop);
          this.off("session.session", this.onSessionChanged);
          this.off("user.changed", this.onUserChanged);
          this.off("detection.interaction", this.onInteractionDetection);
          this.listeners.clear();
          this.userId = void 0;
          this.sessionId = void 0;
          if (this.avatar) {
            this.removeAllListeners("avatar.status");
            await this.avatar?.destroy();
          }
          if (this.heartbitInterval)
            clearInterval(this.heartbitInterval);
        }
        async init(token) {
          this.token = token;
          this.onApp = this.onApp.bind(this);
          this.onSession = this.onSession.bind(this);
          this.onUiButtonSession = this.onUiButtonSession.bind(this);
          this.onAvatarSpeechStop = this.onAvatarSpeechStop.bind(this);
          this.onSessionChanged = this.onSessionChanged.bind(this);
          this.onUserChanged = this.onUserChanged.bind(this);
          this.onInteractionDetection = this.onInteractionDetection.bind(this);
          this.on("session", this.onSession);
          this.on("app", this.onApp);
          this.on("ui.button.session", this.onUiButtonSession);
          this.on("avatar.speech.stop", this.onAvatarSpeechStop);
          this.on("session.session", this.onSessionChanged);
          this.on("user.changed", this.onUserChanged);
          this.on("detection.interaction", this.onInteractionDetection);
          this.logger.debug(`appId=${this.options.appId}`);
          if (token) {
            this.logger.debug("Using provided token");
            this.auth.setToken(token);
            this.api.setToken(token);
          }
          await this.loadApp(this.options.appId);
          const appRequiresLogin = await this.userAuth.appRequiresLogin();
          if (appRequiresLogin) {
            this.logger.debug(`Login requred for app ${this.getAppId()}`);
            const currentUser = await this.userAuth.loadUser();
            if (currentUser) {
              const session = await this.api.getUserSession(this.getAppId(), this.userAuth.getToken());
              if (session) {
                this.logger.debug(`loaded existing session sessionId=${session.sessionId}`);
                this.setSessionId(session.sessionId);
              }
            }
          }
          if (token) {
            const topics = await this.api.listTopics(this.options.moduleId);
            if (topics) {
              this.broker.setTopics(topics);
            } else {
              this.logger.warn(`Failed to fetch topics`);
            }
            await this.broker.connect(token);
          }
          await this.fpsMonitor.init();
          this.on("avatar.status", async (status) => {
            if (status !== "ready")
              return;
            if (this.settings?.get().interactionStart == "on-load") {
              this.createSessionId();
              await this.sendHeartBit();
            }
          });
          this.emit("ready", this);
        }
        async triggerInteractionStart(source) {
          this.onInteractionDetection({
            source,
            appId: this.getAppId(),
            sessionId: "",
            moduleId: "detection",
            interactionType: "start",
            probability: 1
          });
        }
        async onInteractionDetection(ev) {
          if (this.getSessionId())
            return;
          if (ev.source == "ui" && this.settings?.get().interactionStart != "touch")
            return;
          if (ev.source == "microphone" && this.settings?.get().interactionStart != "speak")
            return;
          if (ev.source == "camera" && this.settings?.get().interactionStart != "intent-detection")
            return;
          this.logger.log(`Starting interaction on event from source ${ev.source}`);
          this.createSessionId();
          await this.sendHeartBit();
        }
        async sendHeartBit() {
          await this.api.sendAgentHeartBeat({
            appId: this.options.appId,
            moduleId: this.options.moduleId,
            status: "ready",
            sessionId: this.sessionId,
            userId: this.userId
          });
          this.logger.debug(`Sent heartbit sessionId=${this.sessionId}`);
        }
        emit(event, ...args) {
          this.emitter.emit.apply(this.emitter, [event, ...args]);
        }
        on(event, callback) {
          this.listeners.add(event, callback);
          this.emitter.on(event, callback);
        }
        off(event, callback) {
          this.listeners.remove(event, callback);
          this.emitter.off(event, callback);
        }
        removeAllListeners(event) {
          this.listeners.remove(event);
          this.emitter.removeAllListeners(event);
        }
        async configureLoader(type, id2, loader, useDefaults = true) {
          let config = await this.getAssetConfig(type, id2);
          if (!config) {
            this.logger.warn(`Asset config ${type} ${id2} not found`);
            if (!useDefaults)
              return void 0;
            this.logger.debug(`using default asset for ${type} loader`);
            const repositoryDefaults = await this.getRepositoryDefaults();
            const repo = repositoryDefaults ? repositoryDefaults[type] : void 0;
            if (!repo || !repo.length)
              return void 0;
            config = repo[0];
          }
          if (config.path.startsWith("http"))
            return config.path;
          loader.setWithCredentials(true);
          loader.setRequestHeader({ Authorization: `Bearer ${this.token}` });
          return `${this.baseUrl}/api/ui/asset/${this.getAppId()}/${config.type}/${config.id}`;
        }
        async getAvatarBackgroundPath(path) {
          if (path?.startsWith("http"))
            return path;
          const app = await this.getApp();
          if (!app)
            return DefaultBackground.path;
          path = path || app?.settings?.background;
          const filtered = app.repository?.backgrounds?.filter((b3) => b3.id === path || b3.path === path);
          return filtered?.length ? filtered[0].path : DefaultBackground.path;
        }
        async getAvatarGender(avatarName) {
          const avatar = await this.getAvatarConfig(avatarName);
          if (!avatar)
            return void 0;
          return avatar.gender;
        }
        async getAvatarConfig(avatarId) {
          const app = await this.getApp();
          avatarId = avatarId || this.settings.get().avatar || app?.settings?.avatar;
          if (!avatarId)
            return void 0;
          return await this.getAssetConfig("avatars", avatarId);
        }
        async getAssetConfig(type, id2, defaultValue) {
          const app = await this.getApp();
          if (!id2 || !app || !app.repository)
            return defaultValue;
          const repo = app?.repository[type];
          if (!repo)
            return defaultValue;
          const filtered = repo?.filter((a4) => a4.id === id2);
          return filtered && filtered.length ? filtered[0] : defaultValue;
        }
        getAppLanguage() {
          return this.settings.get().language || DEFAULT_AVATAR_LANGUAGE;
        }
        async getRepositoryDefaults() {
          if (!this.repositoryDefaults) {
            const repositoryDefaults = await this.api.getRepositoryDefaults();
            this.repositoryDefaults = repositoryDefaults || void 0;
          }
          return this.repositoryDefaults;
        }
      };
    }
  });

  // src/app.ts
  var require_app = __commonJS({
    "src/app.ts"() {
      init_toolkit();
      var main = async () => {
        const toolkit = new SermasToolkit({
          url: "http://localhost:8080",
          moduleId: "kiosk",
          appId: "",
          auth: {
            url: "http://localhost:8080",
            clientId: "platform",
            realm: "sermas-local"
          }
        });
        await toolkit.init();
        console.log(toolkit);
      };
      main().catch((e4) => console.error(e4.stack));
    }
  });
  require_app();
})();
/*! Bundled license information:

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

three/examples/jsm/libs/fflate.module.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.6.9
  *)

three/examples/jsm/libs/lil-gui.module.min.js:
  (**
   * lil-gui
   * https://lil-gui.georgealways.com
   * @version 0.17.0
   * @author George Michael Brower
   * @license MIT
   *)

cardboard-vr-display/dist/cardboard-vr-display.js:
  (**
   * @license
   * cardboard-vr-display
   * Copyright (c) 2015-2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * gl-preserve-state
   * Copyright (c) 2016, Brandon Jones.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
  (**
   * @license
   * webvr-polyfill-dpdb
   * Copyright (c) 2015-2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * nosleep.js
   * Copyright (c) 2017, Rich Tibbett
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

holoplay-core/dist/holoplaycore.module.js:
  (**
   * This files defines the HoloPlayClient class and Message class.
   *
   * Copyright (c) [2019] [Looking Glass Factory]
   *
   * @link    https://lookingglassfactory.com/
   * @file    This files defines the HoloPlayClient class and Message class.
   * @author  Looking Glass Factory.
   * @version 0.0.8
   * @license SEE LICENSE IN LICENSE.md
   *)

onnxruntime-web/dist/cjs/ort.min.js:
  (*!
   * ONNX Runtime Web v1.17.3
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)
  (*! Bundled license information:
  
  long/index.js:
    (**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     *)
  *)

mqtt/dist/mqtt.esm.js:
  (*! Bundled license information:
  
  @jspm/core/nodelibs/browser/buffer.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  *)
*/
